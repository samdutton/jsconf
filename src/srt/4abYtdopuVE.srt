1
00:00:00,550 --> 00:00:10,459

ah

2
00:00:10,469 --> 00:00:13,500
I'm going to talk about node

3
00:00:13,500 --> 00:00:15,400
unfortunately I'm not going to give so

4
00:00:15,400 --> 00:00:17,919
much of an introduction to it because I

5
00:00:17,919 --> 00:00:19,990
kind of give a rather long one a while

6
00:00:19,990 --> 00:00:21,310
ago and there's this video on the

7
00:00:21,310 --> 00:00:23,860
internet so I kind of figured like if

8
00:00:23,860 --> 00:00:25,360
you want to know about it you could you

9
00:00:25,360 --> 00:00:27,070
could watch that that video and I don't

10
00:00:27,070 --> 00:00:29,759
really want to waste your time so much

11
00:00:29,759 --> 00:00:34,450
so here's my introduction slide node is

12
00:00:34,450 --> 00:00:38,020
a server-side JavaScript platform it's

13
00:00:38,020 --> 00:00:42,610
built on v8 and it's really good at

14
00:00:42,610 --> 00:00:46,060
handling lots of i/o at the same time

15
00:00:46,060 --> 00:00:48,670
and not necessarily like lots of server

16
00:00:48,670 --> 00:00:51,760
connections it does that fine but also

17
00:00:51,760 --> 00:00:54,540
lots of different types of i/o like

18
00:00:54,540 --> 00:00:58,840
standard input and standard output and a

19
00:00:58,840 --> 00:01:01,750
UNIX socket and the TCP socket and vials

20
00:01:01,750 --> 00:01:03,160
and just kind of all of this different

21
00:01:03,160 --> 00:01:08,189
IO all at the same time and it does this

22
00:01:08,189 --> 00:01:12,670
in a way that's not at all new it's what

23
00:01:12,670 --> 00:01:16,420
twisted and what event machine do which

24
00:01:16,420 --> 00:01:20,350
is making the network i/o non-blocking

25
00:01:20,350 --> 00:01:24,939
and using an event loop yeah and the

26
00:01:24,939 --> 00:01:28,990
file i/o is is asynchronous which is a

27
00:01:28,990 --> 00:01:30,759
little bit new so it has a built in

28
00:01:30,759 --> 00:01:33,189
thread pool so that whenever you call

29
00:01:33,189 --> 00:01:37,119
like some blocking system call on on

30
00:01:37,119 --> 00:01:39,670
some file which system calls usually are

31
00:01:39,670 --> 00:01:42,490
on actual hard drive files it actually

32
00:01:42,490 --> 00:01:45,069
goes to a thread pool so you you kind of

33
00:01:45,069 --> 00:01:46,600
get this complete non blocking

34
00:01:46,600 --> 00:01:52,869
environment and so just a very simple

35
00:01:52,869 --> 00:01:57,399
demonstration this is a little program

36
00:01:57,399 --> 00:02:00,099
that listens starts a web server and

37
00:02:00,099 --> 00:02:02,590
starts a TCP server at the same time and

38
00:02:02,590 --> 00:02:05,439
the web server is listening on port 8000

39
00:02:05,439 --> 00:02:07,929
and the the TCP server is listening on

40
00:02:07,929 --> 00:02:13,000
port 8000 and 1 and when you connect to

41
00:02:13,000 --> 00:02:14,739
the web server you get hello world and

42
00:02:14,739 --> 00:02:17,200
when you connect to the TCP server it

43
00:02:17,200 --> 00:02:18,849
tells you how many people have connected

44
00:02:18,849 --> 00:02:20,230
to the web server

45
00:02:20,230 --> 00:02:24,410
just just an example that you can throw

46
00:02:24,410 --> 00:02:28,280
multiple lots of different types of io

47
00:02:28,280 --> 00:02:34,860
into the same program rather easily

48
00:02:34,870 --> 00:02:38,660
right so here's a here's a reference to

49
00:02:38,660 --> 00:02:42,230
a the other video so I want to talk

50
00:02:42,230 --> 00:02:45,500
about speed actually in node because

51
00:02:45,500 --> 00:02:48,070
it's it's pretty important like

52
00:02:48,070 --> 00:02:50,390
everything is speed actually if the

53
00:02:50,390 --> 00:02:52,100
program is not fast then it's it's

54
00:02:52,100 --> 00:02:57,710
basically worthless and I think it's

55
00:02:57,710 --> 00:03:02,450
important to make an environment like

56
00:03:02,450 --> 00:03:05,480
this that is supposed to be for writing

57
00:03:05,480 --> 00:03:07,610
servers and stuff as fast as it possibly

58
00:03:07,610 --> 00:03:14,330
can be so what I want to do is is try to

59
00:03:14,330 --> 00:03:17,830
describe to you how node is fast and

60
00:03:17,830 --> 00:03:20,570
maybe some things that are not fast

61
00:03:20,570 --> 00:03:23,150
about it just kind of put a realistic

62
00:03:23,150 --> 00:03:25,640
perspective on you know what is this

63
00:03:25,640 --> 00:03:28,760
there's no thing and really how fast is

64
00:03:28,760 --> 00:03:33,110
it and so to do that I'll give some a

65
00:03:33,110 --> 00:03:36,410
couple of benchmarks and I'll benchmark

66
00:03:36,410 --> 00:03:41,810
against engine X which is a web server

67
00:03:41,810 --> 00:03:46,940
written in C and is really really quite

68
00:03:46,940 --> 00:03:53,570
fast and maybe there's the possibility

69
00:03:53,570 --> 00:03:57,050
of a faster web server but I think we

70
00:03:57,050 --> 00:03:59,180
can take engine X as kind of like the

71
00:03:59,180 --> 00:04:02,360
baseline this is what is possible and

72
00:04:02,360 --> 00:04:04,340
you probably can't get much better than

73
00:04:04,340 --> 00:04:07,640
that and then we'll we'll benchmark node

74
00:04:07,640 --> 00:04:12,560
and then we'll benchmark to web servers

75
00:04:12,560 --> 00:04:16,480
for dynamic languages which is tornado

76
00:04:16,480 --> 00:04:22,730
and then tornados Python thing and thin

77
00:04:22,730 --> 00:04:26,660
is a ruby thing and I just did it on

78
00:04:26,660 --> 00:04:29,840
this on this laptop these these

79
00:04:29,840 --> 00:04:32,020
benchmarks aren't really meant to be

80
00:04:32,020 --> 00:04:33,930
real necessary

81
00:04:33,930 --> 00:04:35,580
it's not just trying to simulate like

82
00:04:35,580 --> 00:04:39,830
actual what would happen on a website

83
00:04:39,830 --> 00:04:41,880
because basically we're going to hit it

84
00:04:41,880 --> 00:04:46,410
with more load than is achievable on a

85
00:04:46,410 --> 00:04:51,240
single like Network device all four of

86
00:04:51,240 --> 00:04:53,460
these web servers can saturate your

87
00:04:53,460 --> 00:04:55,800
bandwidth right there they're all quite

88
00:04:55,800 --> 00:04:59,009
fast what we're interested in is is more

89
00:04:59,009 --> 00:05:02,310
about how they perform under very high

90
00:05:02,310 --> 00:05:05,370
load levels and just see if we can bring

91
00:05:05,370 --> 00:05:12,150
out any problems with with them so let's

92
00:05:12,150 --> 00:05:13,830
let's just start with the standard like

93
00:05:13,830 --> 00:05:18,300
hello world web server and what we'll do

94
00:05:18,300 --> 00:05:20,340
is is we'll just hit it we'll hit each

95
00:05:20,340 --> 00:05:23,460
of these with Apache bench and look at

96
00:05:23,460 --> 00:05:25,800
how they differ with different amounts

97
00:05:25,800 --> 00:05:29,580
of concurrency so hopefully you can see

98
00:05:29,580 --> 00:05:31,889
this I'm not sure if it okay looks

99
00:05:31,889 --> 00:05:36,199
visible um so so here's here's the the

100
00:05:36,199 --> 00:05:39,479
the three control servers right nginx is

101
00:05:39,479 --> 00:05:41,250
on the bottom okay wait so so

102
00:05:41,250 --> 00:05:43,800
concurrency is is the horizontal axis

103
00:05:43,800 --> 00:05:46,139
that's how many people are connecting at

104
00:05:46,139 --> 00:05:48,750
the same time and the vertical axis is

105
00:05:48,750 --> 00:05:52,229
response time so you want to be fast you

106
00:05:52,229 --> 00:05:53,880
want to be lower down on the graph so

107
00:05:53,880 --> 00:05:56,970
smaller is better so so engine X looks

108
00:05:56,970 --> 00:05:58,849
really good it's at the bottom as

109
00:05:58,849 --> 00:06:01,710
expected since somewhere in the middle

110
00:06:01,710 --> 00:06:05,880
and and tornadoes a bit slower again the

111
00:06:05,880 --> 00:06:08,820
actual numbers here aren't really so

112
00:06:08,820 --> 00:06:12,050
important because they're probably not

113
00:06:12,050 --> 00:06:14,729
you probably can't achieve this sort of

114
00:06:14,729 --> 00:06:19,050
load actually in real life but the point

115
00:06:19,050 --> 00:06:22,680
is engine X is quite a bit faster than

116
00:06:22,680 --> 00:06:24,960
than the other ones by a factor of two

117
00:06:24,960 --> 00:06:25,460
or three

118
00:06:25,460 --> 00:06:28,830
so if we add note into there then it

119
00:06:28,830 --> 00:06:32,699
looks like this which is good I would

120
00:06:32,699 --> 00:06:36,389
say it's not really comparable to engine

121
00:06:36,389 --> 00:06:39,750
X but it's it's looking good when

122
00:06:39,750 --> 00:06:46,260
compared to thin yep

123
00:06:46,270 --> 00:06:49,970
so now let's let's let's do another

124
00:06:49,970 --> 00:06:53,000
benchmark and instead of just sending a

125
00:06:53,000 --> 00:06:55,610
hello world response what we can do is

126
00:06:55,610 --> 00:06:59,630
is fix our concurrency and and vary the

127
00:06:59,630 --> 00:07:04,790
response size so you know send a five

128
00:07:04,790 --> 00:07:06,950
kilobyte response send a ten kilobyte

129
00:07:06,950 --> 00:07:09,250
response and see how the web servers

130
00:07:09,250 --> 00:07:12,380
deal with with these different amounts

131
00:07:12,380 --> 00:07:20,510
of throughput basically and so so well

132
00:07:20,510 --> 00:07:22,370
ignore that bottom line here's oh wait

133
00:07:22,370 --> 00:07:25,460
okay yeah so so basically this is this

134
00:07:25,460 --> 00:07:28,250
is what the node webserver would do this

135
00:07:28,250 --> 00:07:30,500
is for 16 kilobytes so you you just

136
00:07:30,500 --> 00:07:33,770
generate some some string of data and

137
00:07:33,770 --> 00:07:36,230
then you you when somebody connects you

138
00:07:36,230 --> 00:07:37,760
write that string to the socket so this

139
00:07:37,760 --> 00:07:39,770
would be 4 for 16 kilobytes but we're

140
00:07:39,770 --> 00:07:42,140
going to vary the amount of response

141
00:07:42,140 --> 00:07:46,640
size okay so so again here's the control

142
00:07:46,640 --> 00:07:52,580
servers and again response time is on

143
00:07:52,580 --> 00:07:55,760
the vertical axis and nginx looks really

144
00:07:55,760 --> 00:07:58,130
good and it's it's approximately the

145
00:07:58,130 --> 00:08:01,400
same as what we saw before you know thin

146
00:08:01,400 --> 00:08:03,530
is in the middle tornadoes a little bit

147
00:08:03,530 --> 00:08:08,170
slower and engine X is at the bottom so

148
00:08:08,170 --> 00:08:11,800
let's let's add node into this picture

149
00:08:11,800 --> 00:08:14,990
remember here this is 2 to the 18 so

150
00:08:14,990 --> 00:08:18,230
that's like 256 kilobytes or something

151
00:08:18,230 --> 00:08:21,560
like that and this is you know your

152
00:08:21,560 --> 00:08:24,950
basic hello world program so you know

153
00:08:24,950 --> 00:08:29,210
they slow down as you as you as they

154
00:08:29,210 --> 00:08:32,419
send larger responses so let's let's add

155
00:08:32,419 --> 00:08:38,630
note into this picture and I'll let you

156
00:08:38,630 --> 00:08:43,970
grasp this for a second this is not good

157
00:08:43,970 --> 00:08:46,100
that's a bad spike that's not a good

158
00:08:46,100 --> 00:08:51,980
spike down here they look okay we can't

159
00:08:51,980 --> 00:08:54,710
really see but it's pretty similar but

160
00:08:54,710 --> 00:08:56,840
as we start getting into large response

161
00:08:56,840 --> 00:09:06,060
sizes note sucks right node really sucks

162
00:09:06,070 --> 00:09:10,520
your your that was like three seconds

163
00:09:10,520 --> 00:09:13,670
well over three seconds four for a 256

164
00:09:13,670 --> 00:09:16,610
kilobyte response that it's terrible

165
00:09:16,610 --> 00:09:22,120
it's not rails terrible right I mean

166
00:09:22,120 --> 00:09:26,210
this this is at 300 concurrent users at

167
00:09:26,210 --> 00:09:28,340
the same time okay rails would be off

168
00:09:28,340 --> 00:09:31,520
the map here but it's not it's it's a

169
00:09:31,520 --> 00:09:33,830
different order of magnitude than these

170
00:09:33,830 --> 00:09:36,470
other servers they're doing something

171
00:09:36,470 --> 00:09:40,280
right and nodes doing something wrong so

172
00:09:40,280 --> 00:09:42,650
so what's what's actually happening here

173
00:09:42,650 --> 00:09:47,120
well v8 the the the virtual machine that

174
00:09:47,120 --> 00:09:50,180
node runs on has this is very

175
00:09:50,180 --> 00:09:52,910
complicated and has this generational

176
00:09:52,910 --> 00:09:56,150
garbage collector so it moves data

177
00:09:56,150 --> 00:10:00,920
around inside of its own heap and so v8

178
00:10:00,920 --> 00:10:04,040
won't actually give you a pointer to the

179
00:10:04,040 --> 00:10:06,590
data like the actual data of a string

180
00:10:06,590 --> 00:10:09,980
you have to copy the data out of v8 into

181
00:10:09,980 --> 00:10:12,680
your own heap outside of the vehicle and

182
00:10:12,680 --> 00:10:15,320
then you can write it to socket so every

183
00:10:15,320 --> 00:10:17,540
time node writes something to to a

184
00:10:17,540 --> 00:10:20,210
socket it copies it out of v8 and then

185
00:10:20,210 --> 00:10:25,280
copies it to the socket so I think in

186
00:10:25,280 --> 00:10:31,280
the other web servers they can take

187
00:10:31,280 --> 00:10:33,230
strings and write them directly to the

188
00:10:33,230 --> 00:10:40,640
socket so to address this problem I've

189
00:10:40,640 --> 00:10:45,280
added a buffer object to node which is

190
00:10:45,280 --> 00:10:49,130
very simple it's just it's a chunk of

191
00:10:49,130 --> 00:10:50,870
memory it's a chunk of memory that's

192
00:10:50,870 --> 00:10:55,040
outside of v8s heap that you can modify

193
00:10:55,040 --> 00:10:57,560
and write directly to the socket

194
00:10:57,560 --> 00:11:00,980
and so this is what what the example

195
00:11:00,980 --> 00:11:02,840
would look like with a with a buffer you

196
00:11:02,840 --> 00:11:07,550
know it's it's binary data so it doesn't

197
00:11:07,550 --> 00:11:09,320
look very string like but you can fill

198
00:11:09,320 --> 00:11:12,350
it with data so so here where we create

199
00:11:12,350 --> 00:11:15,080
a 16 kilobyte buffer and then we write

200
00:11:15,080 --> 00:11:19,940
it to the socket so let's look at the

201
00:11:19,940 --> 00:11:22,970
benchmark with the buffer now things

202
00:11:22,970 --> 00:11:27,190
look ok actually things look really ok

203
00:11:27,190 --> 00:11:31,130
over here with with the buffer note is

204
00:11:31,130 --> 00:11:35,090
basically matching engine x4 speed which

205
00:11:35,090 --> 00:11:36,380
is which is pretty impressive

206
00:11:36,380 --> 00:11:38,690
considering that you know engine X is

207
00:11:38,690 --> 00:11:42,710
this highly optimized C program and node

208
00:11:42,710 --> 00:11:45,560
is this completely dynamic you know

209
00:11:45,560 --> 00:11:47,860
things sitting written and java script

210
00:11:47,860 --> 00:11:50,720
written sitting on top of this virtual

211
00:11:50,720 --> 00:12:01,310
machine so so that's good yeah so so so

212
00:12:01,310 --> 00:12:04,910
these buffers are pretty fast like node

213
00:12:04,910 --> 00:12:07,580
can push these these buffers directly to

214
00:12:07,580 --> 00:12:10,310
the socket and and it can it can do it

215
00:12:10,310 --> 00:12:13,250
very well so if we just go back here and

216
00:12:13,250 --> 00:12:15,800
we just took like a cross-section right

217
00:12:15,800 --> 00:12:18,620
here at like the 256 kilobyte case and

218
00:12:18,620 --> 00:12:21,260
and just looked at a histogram of of

219
00:12:21,260 --> 00:12:25,430
these response times here just to get an

220
00:12:25,430 --> 00:12:30,980
idea of how this looks now response time

221
00:12:30,980 --> 00:12:32,750
it's a histogram so the response time is

222
00:12:32,750 --> 00:12:35,300
on the on the horizontal axis here so

223
00:12:35,300 --> 00:12:37,730
you want to be over there that's fast

224
00:12:37,730 --> 00:12:41,750
this is slow and Engine X has this this

225
00:12:41,750 --> 00:12:45,970
great spike here meaning it's fast and

226
00:12:45,970 --> 00:12:50,180
node has a larger variance which is not

227
00:12:50,180 --> 00:12:52,640
so good but it's it's getting in very

228
00:12:52,640 --> 00:12:54,980
fast responses it's also getting in some

229
00:12:54,980 --> 00:12:59,050
slow responses to the slow end is is

230
00:12:59,050 --> 00:13:02,830
equivalent to the fast end of thin and

231
00:13:02,830 --> 00:13:09,960
tornadoes kind of out there

232
00:13:09,970 --> 00:13:13,640
so but the fact remains I mean if you

233
00:13:13,640 --> 00:13:16,880
just took the hello world program that's

234
00:13:16,880 --> 00:13:22,220
on the node website and and you you know

235
00:13:22,220 --> 00:13:24,770
adapted that to write out a large string

236
00:13:24,770 --> 00:13:27,170
to the socket it's going to be slow in

237
00:13:27,170 --> 00:13:30,950
and it's kind of unacceptably slow

238
00:13:30,950 --> 00:13:34,220
so hopefully this this can be fixed in

239
00:13:34,220 --> 00:13:38,060
the future you know what what might have

240
00:13:38,060 --> 00:13:41,180
to happen is is we might have to modify

241
00:13:41,180 --> 00:13:45,080
v8 so that you know if v8 doesn't want

242
00:13:45,080 --> 00:13:48,530
to give us a pointer to the data inside

243
00:13:48,530 --> 00:13:49,970
their heap which is completely

244
00:13:49,970 --> 00:13:51,320
reasonable since they're moving around

245
00:13:51,320 --> 00:13:52,970
at all that they're moving around these

246
00:13:52,970 --> 00:13:55,820
objects you know maybe we can give the

247
00:13:55,820 --> 00:13:58,820
right system call to v8 and say hey v8

248
00:13:58,820 --> 00:14:01,700
here's this file descriptor can you

249
00:14:01,700 --> 00:14:03,440
write that string to the socket and just

250
00:14:03,440 --> 00:14:05,960
let it deal with with its own memory

251
00:14:05,960 --> 00:14:07,570
issues so that that might be a way to

252
00:14:07,570 --> 00:14:13,130
solve the problem anyway so the this

253
00:14:13,130 --> 00:14:16,940
buffer it's pretty simple and it's one

254
00:14:16,940 --> 00:14:20,300
of the new features in node it's what

255
00:14:20,300 --> 00:14:22,070
you would expect it's just a very simple

256
00:14:22,070 --> 00:14:25,460
C buffer you can you can allocate it and

257
00:14:25,460 --> 00:14:28,270
you can adjust the values and you can

258
00:14:28,270 --> 00:14:31,340
encode strings into it and then decode

259
00:14:31,340 --> 00:14:32,780
strings out of it so if you actually

260
00:14:32,780 --> 00:14:34,520
have like a big file that you want to

261
00:14:34,520 --> 00:14:36,410
write to the socket it's probably good

262
00:14:36,410 --> 00:14:38,690
to allocate a buffer for it write the

263
00:14:38,690 --> 00:14:42,380
file into the buffer using this and then

264
00:14:42,380 --> 00:14:44,300
write that buffer to the socket many

265
00:14:44,300 --> 00:14:46,310
many times so like for a static file

266
00:14:46,310 --> 00:14:47,840
server that would definitely be the way

267
00:14:47,840 --> 00:14:53,030
to go importantly you can't resize

268
00:14:53,030 --> 00:14:54,980
buffers though so they're not completely

269
00:14:54,980 --> 00:14:56,720
string like you can't just kind of

270
00:14:56,720 --> 00:15:01,730
append values to them yeah Chris chris

271
00:15:01,730 --> 00:15:03,590
has been talking about having some like

272
00:15:03,590 --> 00:15:05,450
higher abstraction on top of buffers

273
00:15:05,450 --> 00:15:06,950
which would be totally possible where

274
00:15:06,950 --> 00:15:08,810
you could you know just depends strings

275
00:15:08,810 --> 00:15:11,390
and stuff but under the underneath it

276
00:15:11,390 --> 00:15:13,400
would be it would be buffers that would

277
00:15:13,400 --> 00:15:17,980
be possible we'll see how it turns out

278
00:15:17,990 --> 00:15:23,780
right and so since since the 1.90

279
00:15:23,780 --> 00:15:26,240
release of node which was a couple weeks

280
00:15:26,240 --> 00:15:29,510
ago note is is mostly written in

281
00:15:29,510 --> 00:15:33,200
JavaScript now it used to be back when I

282
00:15:33,200 --> 00:15:35,030
when I gave the talk last November that

283
00:15:35,030 --> 00:15:37,520
that most of node was was kind of C and

284
00:15:37,520 --> 00:15:39,500
it just kind of had this this thin

285
00:15:39,500 --> 00:15:43,600
binding layer and so most of the

286
00:15:43,600 --> 00:15:47,720
algorithms that node used to push data

287
00:15:47,720 --> 00:15:49,820
to the socket and and all of the stuff

288
00:15:49,820 --> 00:15:52,370
that I was doing was basically opaque

289
00:15:52,370 --> 00:15:55,190
because it was kind of inside this the C

290
00:15:55,190 --> 00:15:56,720
realm that people don't really want to

291
00:15:56,720 --> 00:15:59,660
touch and it's it's hard to modify I

292
00:15:59,660 --> 00:16:02,750
mean C's sees a hard language to just

293
00:16:02,750 --> 00:16:07,340
manipulate and so now now most the the

294
00:16:07,340 --> 00:16:09,230
the binding level is much lower

295
00:16:09,230 --> 00:16:12,050
it's basically at the POSIX layer where

296
00:16:12,050 --> 00:16:15,080
you just kind of bind certain calls and

297
00:16:15,080 --> 00:16:16,400
then the rest is written in JavaScript

298
00:16:16,400 --> 00:16:21,440
and this is working out really well so

299
00:16:21,440 --> 00:16:23,330
so part of the rewrite was was to get

300
00:16:23,330 --> 00:16:24,920
this buffer thing that we needed because

301
00:16:24,920 --> 00:16:28,240
getting strings out of v8 was so slow

302
00:16:28,240 --> 00:16:31,730
and also just because you know strings

303
00:16:31,730 --> 00:16:33,500
aren't really an appropriate data type

304
00:16:33,500 --> 00:16:36,260
in JavaScript for binary data I mean you

305
00:16:36,260 --> 00:16:39,040
can pack arbitrary binary data into

306
00:16:39,040 --> 00:16:42,680
strings but it's just somehow it's it's

307
00:16:42,680 --> 00:16:46,970
not right for that but the other part of

308
00:16:46,970 --> 00:16:49,310
the rewrite in addition to just kind of

309
00:16:49,310 --> 00:16:52,300
making things more JavaScript friendly

310
00:16:52,300 --> 00:16:56,440
was was to unify this concept of

311
00:16:56,440 --> 00:16:59,900
strength streams so node had all these

312
00:16:59,900 --> 00:17:02,180
all these different objects which which

313
00:17:02,180 --> 00:17:05,540
would stream data but they they they had

314
00:17:05,540 --> 00:17:07,370
different interfaces so like you had a

315
00:17:07,370 --> 00:17:09,860
HTTP request object and it emitted this

316
00:17:09,860 --> 00:17:11,630
body event you know if somebody's

317
00:17:11,630 --> 00:17:13,130
uploading a movie to you it's a body

318
00:17:13,130 --> 00:17:17,089
body body and you'd get various chunks

319
00:17:17,089 --> 00:17:20,089
of the body and for HTTP response object

320
00:17:20,089 --> 00:17:21,740
you would have this send body function

321
00:17:21,740 --> 00:17:24,500
so you could you could send stream data

322
00:17:24,500 --> 00:17:28,730
back to the to the user and a TCP socket

323
00:17:28,730 --> 00:17:31,160
had a receive method so when you got

324
00:17:31,160 --> 00:17:31,880
when

325
00:17:31,880 --> 00:17:34,070
you got data on the TCP sockets they

326
00:17:34,070 --> 00:17:36,980
receive receive receipt and then it had

327
00:17:36,980 --> 00:17:39,350
a send method to send data you know it's

328
00:17:39,350 --> 00:17:42,500
like the POSIX calls that made sense at

329
00:17:42,500 --> 00:17:43,040
the time

330
00:17:43,040 --> 00:17:46,280
and and standard i/o had like this data

331
00:17:46,280 --> 00:17:48,830
event when you read stuff from from

332
00:17:48,830 --> 00:17:50,600
standard in and it had this this write

333
00:17:50,600 --> 00:17:54,890
event to write to standard out and you

334
00:17:54,890 --> 00:17:58,670
know kind of very slowly in my very like

335
00:17:58,670 --> 00:17:59,530
sloth-like

336
00:17:59,530 --> 00:18:02,960
mental capacity like I came to realize

337
00:18:02,960 --> 00:18:05,810
like huh maybe maybe I should like not

338
00:18:05,810 --> 00:18:07,820
be making up new names for all of these

339
00:18:07,820 --> 00:18:11,180
different things every time we came up

340
00:18:11,180 --> 00:18:17,900
with a new stream and the more I thought

341
00:18:17,900 --> 00:18:22,190
about it again very slowly that like

342
00:18:22,190 --> 00:18:23,900
unifying these streams would be very

343
00:18:23,900 --> 00:18:26,930
cool because if we did that we could we

344
00:18:26,930 --> 00:18:29,600
could actually do polymorphism like we

345
00:18:29,600 --> 00:18:31,700
could we could write general-purpose

346
00:18:31,700 --> 00:18:33,560
functions that dealt with streams that

347
00:18:33,560 --> 00:18:36,170
could like do things in particular we

348
00:18:36,170 --> 00:18:38,230
could write like a general-purpose

349
00:18:38,230 --> 00:18:40,730
pumping function that would take data

350
00:18:40,730 --> 00:18:42,440
from one stream and pump it into the

351
00:18:42,440 --> 00:18:44,720
other one and we could actually do this

352
00:18:44,720 --> 00:18:46,550
in a really good way with all the proper

353
00:18:46,550 --> 00:18:48,890
throttling and stuff and it could be all

354
00:18:48,890 --> 00:18:51,320
on one event loop and we could just get

355
00:18:51,320 --> 00:18:53,780
a callback when we're done with it so

356
00:18:53,780 --> 00:18:55,670
maybe you somebody's uploading a file

357
00:18:55,670 --> 00:18:57,470
and you just pump it to the standardout

358
00:18:57,470 --> 00:19:00,140
if you want to see what it is or you

359
00:19:00,140 --> 00:19:03,770
pump it to a file or you pump a file

360
00:19:03,770 --> 00:19:07,220
into a into a response pumping data

361
00:19:07,220 --> 00:19:09,680
throughout a process is a very common

362
00:19:09,680 --> 00:19:11,030
thing and it would be nice if we could

363
00:19:11,030 --> 00:19:14,030
just put it into a single function

364
00:19:14,030 --> 00:19:22,250
basically so the the stream interface

365
00:19:22,250 --> 00:19:24,590
which I will describe to you is split

366
00:19:24,590 --> 00:19:27,800
into two parts it's readable and

367
00:19:27,800 --> 00:19:32,360
writeable streams some streams are both

368
00:19:32,360 --> 00:19:34,670
readable and writeable they're duplex so

369
00:19:34,670 --> 00:19:37,940
like a like a TCP socket so the readable

370
00:19:37,940 --> 00:19:41,690
stream looks like this it has a data

371
00:19:41,690 --> 00:19:44,060
event you receive data and it says data

372
00:19:44,060 --> 00:19:45,680
data every time it's

373
00:19:45,680 --> 00:19:47,750
it's continually pulling in data and

374
00:19:47,750 --> 00:19:50,900
when you get an EO F or a fin packet on

375
00:19:50,900 --> 00:19:55,760
TCP or whatever if maybe it's a fake

376
00:19:55,760 --> 00:19:58,070
stream maybe it's maybe it's an HTTP

377
00:19:58,070 --> 00:20:01,490
request in pipelines HTTP connections so

378
00:20:01,490 --> 00:20:03,170
it's not actually the end of something

379
00:20:03,170 --> 00:20:06,050
but maybe you have an end event when

380
00:20:06,050 --> 00:20:08,900
this data terminates and then you have

381
00:20:08,900 --> 00:20:10,550
you have some things for throttling so

382
00:20:10,550 --> 00:20:12,920
you can pause that you know stop I can't

383
00:20:12,920 --> 00:20:15,530
deal with more data right now I have to

384
00:20:15,530 --> 00:20:17,840
do some other stuff and resume and then

385
00:20:17,840 --> 00:20:20,630
a destroy method which would just kind

386
00:20:20,630 --> 00:20:22,100
of terminate everything it would close

387
00:20:22,100 --> 00:20:23,960
the underlying socket it would say okay

388
00:20:23,960 --> 00:20:25,580
I can't I don't want any more events

389
00:20:25,580 --> 00:20:28,550
right now and they're the writable

390
00:20:28,550 --> 00:20:33,950
stream has a right method basically it

391
00:20:33,950 --> 00:20:35,930
has a right method and an end method so

392
00:20:35,930 --> 00:20:38,740
you write data and then you end it and

393
00:20:38,740 --> 00:20:44,840
then for for the purposes of of you know

394
00:20:44,840 --> 00:20:47,060
the the the kernel right buffer might

395
00:20:47,060 --> 00:20:49,220
fill up and at that point the right

396
00:20:49,220 --> 00:20:51,380
method is supposed to return false and

397
00:20:51,380 --> 00:20:53,480
then you would listen for a drain event

398
00:20:53,480 --> 00:20:55,550
so you write all this data it all fills

399
00:20:55,550 --> 00:20:57,920
up and you say you know I can't the

400
00:20:57,920 --> 00:20:59,600
kernel can't handle pushing out more

401
00:20:59,600 --> 00:21:02,570
data to the interface right now and so

402
00:21:02,570 --> 00:21:04,310
you just wait for that to drain down and

403
00:21:04,310 --> 00:21:05,900
then you get this drain event and then

404
00:21:05,900 --> 00:21:12,800
you can fill up the the buffer again so

405
00:21:12,800 --> 00:21:15,020
I mean with with with this drain and

406
00:21:15,020 --> 00:21:18,980
this read this pause in this resume you

407
00:21:18,980 --> 00:21:21,190
can actually you know take data from

408
00:21:21,190 --> 00:21:24,380
here and pump it into there and then

409
00:21:24,380 --> 00:21:26,710
when this one returns false from right

410
00:21:26,710 --> 00:21:30,230
no because the the the buffer is filled

411
00:21:30,230 --> 00:21:33,290
up then you say pause okay I can't

412
00:21:33,290 --> 00:21:36,110
handle any more over here and you know

413
00:21:36,110 --> 00:21:38,210
wait till wait till this data flows out

414
00:21:38,210 --> 00:21:39,260
here you know if you're pumping

415
00:21:39,260 --> 00:21:40,940
something from a very fast connection

416
00:21:40,940 --> 00:21:43,040
into a very slow connection this is

417
00:21:43,040 --> 00:21:46,580
likely that will happen so you need to

418
00:21:46,580 --> 00:21:49,000
be able to handle the these sort of

419
00:21:49,000 --> 00:21:54,110
throttling issues mm-hmm yeah so just as

420
00:21:54,110 --> 00:21:56,750
an example there's lots of these streams

421
00:21:56,750 --> 00:21:59,030
inside notes so like standard input

422
00:21:59,030 --> 00:21:59,360
would

423
00:21:59,360 --> 00:22:02,630
readable stream and a server request

424
00:22:02,630 --> 00:22:03,980
would be a readable stream like

425
00:22:03,980 --> 00:22:05,690
somebody's uploading a movie to you that

426
00:22:05,690 --> 00:22:08,750
would be something readable and and if

427
00:22:08,750 --> 00:22:10,940
you launch a child process the pipe into

428
00:22:10,940 --> 00:22:13,730
that child process to the child

429
00:22:13,730 --> 00:22:16,460
processes standard out that would be a

430
00:22:16,460 --> 00:22:18,890
readable stream right because the child

431
00:22:18,890 --> 00:22:24,290
processes writing stuff and and then the

432
00:22:24,290 --> 00:22:31,730
opposite for the writable streams yeah

433
00:22:31,730 --> 00:22:34,190
the stream interface I mean it I think

434
00:22:34,190 --> 00:22:36,130
it needs to grow a bit organically

435
00:22:36,130 --> 00:22:38,690
there's probably more that needs to be

436
00:22:38,690 --> 00:22:41,360
added so for example there probably

437
00:22:41,360 --> 00:22:42,980
needs to be some sort of low watermark

438
00:22:42,980 --> 00:22:47,450
for for writable streams to to say when

439
00:22:47,450 --> 00:22:48,800
when they should when they should

440
00:22:48,800 --> 00:22:51,860
actually drain so that so that they

441
00:22:51,860 --> 00:22:54,050
don't push that it out to the socket

442
00:22:54,050 --> 00:22:58,580
immediately okay so what else is

443
00:22:58,580 --> 00:23:01,910
happening so for rather technical

444
00:23:01,910 --> 00:23:05,720
reasons node had this you DNS library

445
00:23:05,720 --> 00:23:08,000
that used to do asynchronous DNS lookups

446
00:23:08,000 --> 00:23:10,430
DNS is extremely complicated like

447
00:23:10,430 --> 00:23:12,740
there's no way I could possibly write my

448
00:23:12,740 --> 00:23:15,470
own DNS library I I would like to but

449
00:23:15,470 --> 00:23:20,270
it's it's infeasible so I was using this

450
00:23:20,270 --> 00:23:24,620
you DNS and that's been replaced with

451
00:23:24,620 --> 00:23:27,940
with a similar library called see Aires

452
00:23:27,940 --> 00:23:31,700
and when we did this rewrite of these

453
00:23:31,700 --> 00:23:34,220
streaming interfaces we used to use new

454
00:23:34,220 --> 00:23:38,120
TLS for the for the in the C code but

455
00:23:38,120 --> 00:23:39,920
but now we're going to switch it out

456
00:23:39,920 --> 00:23:42,950
with open SSL which is a bit more

457
00:23:42,950 --> 00:23:47,120
available and you know usually you have

458
00:23:47,120 --> 00:23:48,650
open SSL installed on your computer

459
00:23:48,650 --> 00:23:54,060
whereas you don't usually have new TLS

460
00:23:54,070 --> 00:23:56,990
but the side effect is that these to

461
00:23:56,990 --> 00:24:02,930
these new TLS and you DNS I've rent they

462
00:24:02,930 --> 00:24:08,090
they were both LGPL libraries and with

463
00:24:08,090 --> 00:24:11,560
this replacement

464
00:24:11,570 --> 00:24:13,580
all of the libraries that know'd uses

465
00:24:13,580 --> 00:24:16,910
and note itself is is rather simply

466
00:24:16,910 --> 00:24:18,500
licensed this last sentence isn't

467
00:24:18,500 --> 00:24:22,760
correct 100% MIT BSD I mean open SSL has

468
00:24:22,760 --> 00:24:24,770
this Apache sort of license but it's

469
00:24:24,770 --> 00:24:29,000
it's rather ok and open SSL is kind of

470
00:24:29,000 --> 00:24:32,450
this big understood library so this is

471
00:24:32,450 --> 00:24:34,940
only good if you're like some company

472
00:24:34,940 --> 00:24:37,990
and you like can't touch GPL code at all

473
00:24:37,990 --> 00:24:43,750
well now note is pretty free from that

474
00:24:43,750 --> 00:24:46,610
another thing that that was done

475
00:24:46,610 --> 00:24:51,440
recently was was a repo library which we

476
00:24:51,440 --> 00:24:54,290
had already but you could only do it on

477
00:24:54,290 --> 00:24:56,630
standard i/o now you can do the repo

478
00:24:56,630 --> 00:24:59,390
library on arbitrary sockets so you

479
00:24:59,390 --> 00:25:02,180
could start a TCP server and put the

480
00:25:02,180 --> 00:25:04,220
repo on the TCP server so you could tell

481
00:25:04,220 --> 00:25:07,370
that into your process and examine

482
00:25:07,370 --> 00:25:09,290
what's doing but that's a bit dangerous

483
00:25:09,290 --> 00:25:12,380
you probably rather want to open a UNIX

484
00:25:12,380 --> 00:25:18,130
socket and telnet into that UNIX socket

485
00:25:18,130 --> 00:25:20,480
but this is cool right you can have a

486
00:25:20,480 --> 00:25:22,310
running web server and you can tell that

487
00:25:22,310 --> 00:25:24,320
into it and inspect variables while it's

488
00:25:24,320 --> 00:25:27,140
running and it can completely demonize

489
00:25:27,140 --> 00:25:29,480
and everything and and be detached from

490
00:25:29,480 --> 00:25:32,870
a TTY so yeah here's here's an example

491
00:25:32,870 --> 00:25:39,260
of of starting the repo on a on a UNIX

492
00:25:39,260 --> 00:25:42,890
socket it's pretty trivial just copy

493
00:25:42,890 --> 00:25:44,180
those three lines of code into your

494
00:25:44,180 --> 00:25:50,270
program and then there was this other

495
00:25:50,270 --> 00:25:53,420
thing this promise dot wait so node had

496
00:25:53,420 --> 00:25:55,310
this thing where when you did like a

497
00:25:55,310 --> 00:25:57,680
file operation you it returned a promise

498
00:25:57,680 --> 00:25:59,540
and then I had this this weird thing

499
00:25:59,540 --> 00:26:01,430
where you could wait on that and it

500
00:26:01,430 --> 00:26:05,480
would make the the the it would make the

501
00:26:05,480 --> 00:26:07,190
operation seem synchronous in that

502
00:26:07,190 --> 00:26:09,590
instead of having to do a callback after

503
00:26:09,590 --> 00:26:11,030
that file operation because it was

504
00:26:11,030 --> 00:26:14,000
asynchronous you could wait on it and we

505
00:26:14,000 --> 00:26:15,470
just return the value and then right

506
00:26:15,470 --> 00:26:17,000
under that you could do the next line of

507
00:26:17,000 --> 00:26:19,820
code as if nothing had happened but it

508
00:26:19,820 --> 00:26:22,190
wasn't really synchronous it was just

509
00:26:22,190 --> 00:26:23,960
kind of faking it it was switching to a

510
00:26:23,960 --> 00:26:25,010
different exit

511
00:26:25,010 --> 00:26:26,720
you should stack and calling other

512
00:26:26,720 --> 00:26:28,310
events and then when it was done it

513
00:26:28,310 --> 00:26:29,150
would switch back to the original

514
00:26:29,150 --> 00:26:35,620
execution stack this was a terrible idea

515
00:26:35,620 --> 00:26:40,550
kuru teens suck like don't listen to

516
00:26:40,550 --> 00:26:48,260
Brian Mitchell there they're terrible we

517
00:26:48,260 --> 00:26:49,760
don't have these in the web browser

518
00:26:49,760 --> 00:26:53,030
right you don't you don't have multiple

519
00:26:53,030 --> 00:26:54,980
execution stacks in the web browser you

520
00:26:54,980 --> 00:26:57,890
get events you call functions and then

521
00:26:57,890 --> 00:27:00,260
you return to the event loop and then

522
00:27:00,260 --> 00:27:02,660
another event happens it would be

523
00:27:02,660 --> 00:27:04,580
terrible if you were in your web browser

524
00:27:04,580 --> 00:27:06,410
environment and you called all these

525
00:27:06,410 --> 00:27:08,120
functions and then kind of like in the

526
00:27:08,120 --> 00:27:10,610
middle of your call to jQuery somebody

527
00:27:10,610 --> 00:27:12,170
else called the button clicked a button

528
00:27:12,170 --> 00:27:15,050
and then that event started while your

529
00:27:15,050 --> 00:27:17,780
other stuff was like being paused and

530
00:27:17,780 --> 00:27:20,150
then that other button event you know

531
00:27:20,150 --> 00:27:22,610
screwed up all the state of of what was

532
00:27:22,610 --> 00:27:25,220
happening in the original function call

533
00:27:25,220 --> 00:27:27,350
in the original event and then when you

534
00:27:27,350 --> 00:27:29,090
returned back to this original function

535
00:27:29,090 --> 00:27:30,770
can you follow me at all probably not

536
00:27:30,770 --> 00:27:34,760
enslaving my hands the state is all

537
00:27:34,760 --> 00:27:37,250
messed up there you have to thinking

538
00:27:37,250 --> 00:27:39,170
about co-routines

539
00:27:39,170 --> 00:27:42,740
is hard because you at any function call

540
00:27:42,740 --> 00:27:44,330
you have to be prepared for the fact

541
00:27:44,330 --> 00:27:47,090
that IO can like somehow happen somebody

542
00:27:47,090 --> 00:27:48,500
you know I'm gonna call this function

543
00:27:48,500 --> 00:27:50,290
and then in some library down the line

544
00:27:50,290 --> 00:27:52,400
somebody's gonna call wait and it's

545
00:27:52,400 --> 00:27:54,290
going to jump to the event loop and then

546
00:27:54,290 --> 00:27:56,060
IO is going to happen so if I just have

547
00:27:56,060 --> 00:27:57,890
a parser and I'm like parsing a socket

548
00:27:57,890 --> 00:27:59,690
happily and then I call a function and

549
00:27:59,690 --> 00:28:03,680
then suddenly like you know now more

550
00:28:03,680 --> 00:28:06,350
data comes in on the socket and and my

551
00:28:06,350 --> 00:28:08,120
parser starts on that data and then when

552
00:28:08,120 --> 00:28:09,860
I return to my original function like

553
00:28:09,860 --> 00:28:12,020
the state of my parser is completely

554
00:28:12,020 --> 00:28:14,120
different what would have to happen if

555
00:28:14,120 --> 00:28:16,280
we had co-routines is we would have to

556
00:28:16,280 --> 00:28:18,800
have locks around the parser we would

557
00:28:18,800 --> 00:28:21,560
have to be really careful about what the

558
00:28:21,560 --> 00:28:23,960
state of where of what we were doing and

559
00:28:23,960 --> 00:28:27,830
we had to make sure that when you call

560
00:28:27,830 --> 00:28:29,510
the function that you were aware that

561
00:28:29,510 --> 00:28:32,510
there was a possibility that anything is

562
00:28:32,510 --> 00:28:34,640
going to happen at that point it's not

563
00:28:34,640 --> 00:28:37,610
as hard as as thread safety co-routine

564
00:28:37,610 --> 00:28:38,630
safety is easier

565
00:28:38,630 --> 00:28:40,580
and thread safety you have to worry

566
00:28:40,580 --> 00:28:42,830
about these atomic issues I mean in

567
00:28:42,830 --> 00:28:45,260
co-routine safety you can you can copy

568
00:28:45,260 --> 00:28:48,140
an array to some place and it's not

569
00:28:48,140 --> 00:28:50,480
going to cut right in the middle of that

570
00:28:50,480 --> 00:28:54,080
array copy copying but it's still

571
00:28:54,080 --> 00:28:56,660
difficult let's just make life easy okay

572
00:28:56,660 --> 00:28:58,850
it's it's hard enough

573
00:28:58,850 --> 00:29:03,169
no co-routines let's just have events

574
00:29:03,169 --> 00:29:04,910
we'll call some functions and then it

575
00:29:04,910 --> 00:29:07,220
will be done the co-routines don't add

576
00:29:07,220 --> 00:29:08,990
anything if anything they make our

577
00:29:08,990 --> 00:29:11,450
program perform worse the only thing

578
00:29:11,450 --> 00:29:14,090
that they do is give you this kind of

579
00:29:14,090 --> 00:29:18,350
you know pleasure of having like these

580
00:29:18,350 --> 00:29:20,690
calls one after another which I agree is

581
00:29:20,690 --> 00:29:23,059
is kind of nice but it's just not worth

582
00:29:23,059 --> 00:29:28,190
the mental anguish so cooperative

583
00:29:28,190 --> 00:29:32,330
threading of any sort is a terrible idea

584
00:29:32,330 --> 00:29:34,940
the other thing that's going on is yeah

585
00:29:34,940 --> 00:29:37,250
the project is growing and now we have a

586
00:29:37,250 --> 00:29:39,500
build bot which does continuous builds

587
00:29:39,500 --> 00:29:42,740
and and runs all the tests and it even

588
00:29:42,740 --> 00:29:44,929
like does performance test just like in

589
00:29:44,929 --> 00:29:47,780
the Chrome project so on every commit it

590
00:29:47,780 --> 00:29:51,140
runs a set of benchmarks and displays it

591
00:29:51,140 --> 00:29:54,620
on a website and so we can see if we

592
00:29:54,620 --> 00:29:57,770
commit something if suddenly that makes

593
00:29:57,770 --> 00:30:00,830
the rest of the project slow and we can

594
00:30:00,830 --> 00:30:07,190
revert that commit yeah

595
00:30:07,190 --> 00:30:13,159
so so yeah the project's growing there's

596
00:30:13,159 --> 00:30:15,260
been a lot of interest in it there's

597
00:30:15,260 --> 00:30:18,409
been 42 releases and there's 63

598
00:30:18,409 --> 00:30:20,120
contributors

599
00:30:20,120 --> 00:30:22,400
it hasn't grown that much in code size

600
00:30:22,400 --> 00:30:26,240
mostly because of this wrote rewrite but

601
00:30:26,240 --> 00:30:27,650
we've got over a thousand people on the

602
00:30:27,650 --> 00:30:30,440
mailing list and thousand people on

603
00:30:30,440 --> 00:30:33,230
github that are watching it so so it's

604
00:30:33,230 --> 00:30:39,730
it's nice yeah are there any questions

605
00:30:39,730 --> 00:30:42,130
was the threshold for the drain event

606
00:30:42,130 --> 00:30:48,380
right now

607
00:30:48,390 --> 00:30:51,010
if any it rights to the socket

608
00:30:51,010 --> 00:30:55,120
immediately so so you're going to - as

609
00:30:55,120 --> 00:30:56,919
soon as you you write something to a

610
00:30:56,919 --> 00:30:58,900
socket it flushes it it tries to flush

611
00:30:58,900 --> 00:31:11,230
it yes reloading dynamically reloading

612
00:31:11,230 --> 00:31:13,179
modules like hot reloading of modules

613
00:31:13,179 --> 00:31:15,220
like you know when you're in Ruby on

614
00:31:15,220 --> 00:31:16,780
Rails and you update some code and then

615
00:31:16,780 --> 00:31:18,580
you know you go back to the website and

616
00:31:18,580 --> 00:31:21,520
it's changed this is hard this is really

617
00:31:21,520 --> 00:31:23,260
hard to do like I thought this would be

618
00:31:23,260 --> 00:31:25,950
fairly simple but it's not

619
00:31:25,950 --> 00:31:28,960
and the problem is you you're just kind

620
00:31:28,960 --> 00:31:29,980
of carrying around these JavaScript

621
00:31:29,980 --> 00:31:31,809
references and just can't you can't

622
00:31:31,809 --> 00:31:33,190
really switch out the implementation

623
00:31:33,190 --> 00:31:37,570
from underneath them there's been

624
00:31:37,570 --> 00:31:41,159
several attempts none of them are very

625
00:31:41,159 --> 00:31:45,309
satisfactory to me there's some new

626
00:31:45,309 --> 00:31:48,659
development going on in v8 which does

627
00:31:48,659 --> 00:31:53,169
live editing kind of at a very low level

628
00:31:53,169 --> 00:31:56,080
which i think is the proper way to go

629
00:31:56,080 --> 00:31:58,330
for for doing this sort of thing so I'm

630
00:31:58,330 --> 00:32:04,190
I'm waiting for v8 to figure it out

631
00:32:04,200 --> 00:32:12,700
right so so I want to stabilize the API

632
00:32:12,700 --> 00:32:16,630
very soon now I want to do this at a

633
00:32:16,630 --> 00:32:19,030
zero point to release I mean I can't

634
00:32:19,030 --> 00:32:20,830
completely like say I'll never change it

635
00:32:20,830 --> 00:32:23,200
again but I want to like not change it

636
00:32:23,200 --> 00:32:24,340
every day okay

637
00:32:24,340 --> 00:32:30,110
and I want to like thank you

638
00:32:30,120 --> 00:32:33,789
so so there's there's been a lot that

639
00:32:33,789 --> 00:32:35,409
needs to be done that's why I change it

640
00:32:35,409 --> 00:32:38,710
all the time I hope that that when I

641
00:32:38,710 --> 00:32:43,390
reach this 0.2 which should be in a

642
00:32:43,390 --> 00:32:44,679
couple weeks I've been saying that for

643
00:32:44,679 --> 00:32:46,870
weeks and months but it will be in a

644
00:32:46,870 --> 00:32:48,610
couple I wanted to have it done for for

645
00:32:48,610 --> 00:32:52,150
this conference but it's not I hope that

646
00:32:52,150 --> 00:32:54,370
people will start building modules on

647
00:32:54,370 --> 00:32:59,140
top of note at that point huh more

648
00:32:59,140 --> 00:33:01,929
modules please yes there are some of

