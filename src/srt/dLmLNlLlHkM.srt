1
00:00:02,480 --> 00:00:05,970

hello everyone thank you all for coming

2
00:00:05,970 --> 00:00:09,030
I'm so excited to be here Budapest is a

3
00:00:09,030 --> 00:00:12,150
beautiful city I'm from San Francisco my

4
00:00:12,150 --> 00:00:14,099
name is Ahmad le - I'm software engineer

5
00:00:14,099 --> 00:00:15,870
and web / experienced team at Pinterest

6
00:00:15,870 --> 00:00:18,060
and one of the projects that I've been

7
00:00:18,060 --> 00:00:20,580
working on last year is react migration

8
00:00:20,580 --> 00:00:23,310
and today I'm going to tell you a story

9
00:00:23,310 --> 00:00:25,890
about our journey to react we'll take a

10
00:00:25,890 --> 00:00:27,630
look into challenges we faced and

11
00:00:27,630 --> 00:00:29,160
techniques we used while migrating

12
00:00:29,160 --> 00:00:31,650
pinterest profiles to react if you have

13
00:00:31,650 --> 00:00:33,390
any questions please make a note and

14
00:00:33,390 --> 00:00:35,690
i'll be happy to answer them in the end

15
00:00:35,690 --> 00:00:38,370
so today's presentation is broke into

16
00:00:38,370 --> 00:00:41,280
four major parts and the first one is

17
00:00:41,280 --> 00:00:43,890
about how we why we decided to migrate

18
00:00:43,890 --> 00:00:45,870
to react at all and not any other

19
00:00:45,870 --> 00:00:49,559
library the second part is about how we

20
00:00:49,559 --> 00:00:51,420
had to prepare on our infrastructure

21
00:00:51,420 --> 00:00:53,760
first before we were able to build

22
00:00:53,760 --> 00:00:56,640
something in reality the third part is

23
00:00:56,640 --> 00:01:00,840
about measuring the impact and this

24
00:01:00,840 --> 00:01:02,640
pretty important part because during

25
00:01:02,640 --> 00:01:04,500
migrations like that you may introduce

26
00:01:04,500 --> 00:01:06,689
bugs or break something and you'll never

27
00:01:06,689 --> 00:01:08,820
know if you're not measuring the things

28
00:01:08,820 --> 00:01:11,340
that you're building and the last part I

29
00:01:11,340 --> 00:01:13,770
will share you the details how our life

30
00:01:13,770 --> 00:01:16,439
and engineering life has changed after

31
00:01:16,439 --> 00:01:22,680
adoption of react so first of all why we

32
00:01:22,680 --> 00:01:25,049
had to move away from the existing

33
00:01:25,049 --> 00:01:27,240
framework at all and the existing

34
00:01:27,240 --> 00:01:29,689
framework Denzel which was built into

35
00:01:29,689 --> 00:01:32,610
2013 served us well until a certain

36
00:01:32,610 --> 00:01:35,040
period of time but nowadays it's

37
00:01:35,040 --> 00:01:37,560
outdated it's very common to many other

38
00:01:37,560 --> 00:01:39,360
frameworks that were introduced during

39
00:01:39,360 --> 00:01:42,090
the time three four five years ago and

40
00:01:42,090 --> 00:01:45,240
it's based on object-oriented JavaScript

41
00:01:45,240 --> 00:01:47,490
paradigm and it uses components based

42
00:01:47,490 --> 00:01:53,430
here are key so one of the most common

43
00:01:53,430 --> 00:01:55,890
questions is why we decided to move to

44
00:01:55,890 --> 00:01:58,740
react and not to angular ember or meteor

45
00:01:58,740 --> 00:02:01,950
or anything else and on this slide you

46
00:02:01,950 --> 00:02:03,780
can see a list of requirements that we

47
00:02:03,780 --> 00:02:07,259
head to our new framework and we want to

48
00:02:07,259 --> 00:02:09,330
have a framework with a large developer

49
00:02:09,330 --> 00:02:11,970
community and react has a huge developer

50
00:02:11,970 --> 00:02:13,170
community and

51
00:02:13,170 --> 00:02:14,640
to take advantage of these developer

52
00:02:14,640 --> 00:02:18,300
community another requirement is design

53
00:02:18,300 --> 00:02:21,239
patterns and react is very compatible

54
00:02:21,239 --> 00:02:24,930
with our legacy stack and it makes the

55
00:02:24,930 --> 00:02:27,180
emigration to many other frameworks much

56
00:02:27,180 --> 00:02:31,770
easier the third requirement is solution

57
00:02:31,770 --> 00:02:33,959
for isomorphism or so-called Universal

58
00:02:33,959 --> 00:02:36,450
rendering and now we'll tell you later

59
00:02:36,450 --> 00:02:39,900
why this is so important for us and in

60
00:02:39,900 --> 00:02:42,150
that requirement is performance and

61
00:02:42,150 --> 00:02:43,980
react is well known for its performance

62
00:02:43,980 --> 00:02:45,660
benefits you probably heard about

63
00:02:45,660 --> 00:02:48,180
virtual Dom and reconciliation algorithm

64
00:02:48,180 --> 00:02:51,540
and so and so forth and the last thing

65
00:02:51,540 --> 00:02:55,410
is developer experience and this is our

66
00:02:55,410 --> 00:02:58,260
old legacy stack and you might have

67
00:02:58,260 --> 00:03:00,090
something similar in your project we

68
00:03:00,090 --> 00:03:02,760
have Python junga web server ginger

69
00:03:02,760 --> 00:03:04,860
renderer on the back end nine checks on

70
00:03:04,860 --> 00:03:07,790
the client and it's old as well but

71
00:03:07,790 --> 00:03:11,489
being on board with all of these like

72
00:03:11,489 --> 00:03:13,319
mojo bundler Redux

73
00:03:13,319 --> 00:03:16,410
just unit tests and many other tools and

74
00:03:16,410 --> 00:03:18,930
features has completely changed the way

75
00:03:18,930 --> 00:03:23,220
we develop our modern web apps so just

76
00:03:23,220 --> 00:03:25,079
to give you an idea of scale that we

77
00:03:25,079 --> 00:03:28,260
operated we have 200 200 millions of

78
00:03:28,260 --> 00:03:31,530
monthly active users which is more than

79
00:03:31,530 --> 00:03:33,420
population of the biggest country in the

80
00:03:33,420 --> 00:03:38,340
world Russia we serve more than 150,000

81
00:03:38,340 --> 00:03:43,890
requests per second and since we

82
00:03:43,890 --> 00:03:46,560
constantly ship new features we run

83
00:03:46,560 --> 00:03:48,900
hundreds of experiments we can't just

84
00:03:48,900 --> 00:03:51,630
simply freeze our product development in

85
00:03:51,630 --> 00:03:53,489
order to rebuild the new web app from

86
00:03:53,489 --> 00:03:55,500
scratch and react and while it's

87
00:03:55,500 --> 00:03:57,510
relatively easy to build a new web app

88
00:03:57,510 --> 00:04:00,810
in react changing a service immigrating

89
00:04:00,810 --> 00:04:02,670
service that is constantly changing is

90
00:04:02,670 --> 00:04:04,769
like changing engines of an airplane

91
00:04:04,769 --> 00:04:07,930
while mid-flight

92
00:04:07,940 --> 00:04:12,209
so how how many of you have tried to

93
00:04:12,209 --> 00:04:15,180
rewrite your web app from from scratch

94
00:04:15,180 --> 00:04:19,320
in any other framework again we see a

95
00:04:19,320 --> 00:04:22,320
lot of hands and I try to do this before

96
00:04:22,320 --> 00:04:25,169
and ended up in situation when I had old

97
00:04:25,169 --> 00:04:27,270
web app which is still in production

98
00:04:27,270 --> 00:04:29,819
and many almost hundreds of engineers

99
00:04:29,819 --> 00:04:32,009
were completely changing it adding new

100
00:04:32,009 --> 00:04:34,560
features and had me new one which is

101
00:04:34,560 --> 00:04:36,479
still under development and I had to

102
00:04:36,479 --> 00:04:38,520
port all these features back to the to

103
00:04:38,520 --> 00:04:40,680
the new one and it's like the constant

104
00:04:40,680 --> 00:04:42,569
race condition not the best situation to

105
00:04:42,569 --> 00:04:43,819
be in

106
00:04:43,819 --> 00:04:47,009
so now how can we avoid this and the

107
00:04:47,009 --> 00:04:49,110
only way to avoid this is to rewrite our

108
00:04:49,110 --> 00:04:52,050
web app part by part while there the

109
00:04:52,050 --> 00:04:54,090
rest is still run by the old framework

110
00:04:54,090 --> 00:04:57,900
and now we're coming to this idea of

111
00:04:57,900 --> 00:05:01,440
so-called hybrid app it's an app where

112
00:05:01,440 --> 00:05:03,419
we have two frameworks and they plug

113
00:05:03,419 --> 00:05:05,580
this together together for the time of

114
00:05:05,580 --> 00:05:08,310
the migration and thus our engineers

115
00:05:08,310 --> 00:05:10,710
will not have to write everything at

116
00:05:10,710 --> 00:05:12,599
once they will be able to migrate it

117
00:05:12,599 --> 00:05:16,169
piece by piece so now we want to ask

118
00:05:16,169 --> 00:05:18,750
question how can we make a hybrid app

119
00:05:18,750 --> 00:05:21,180
and the very first thought maybe it's

120
00:05:21,180 --> 00:05:23,310
not that complicated but let's take a

121
00:05:23,310 --> 00:05:25,379
look at the list of the all possible

122
00:05:25,379 --> 00:05:29,310
challenges and the very first challenge

123
00:05:29,310 --> 00:05:32,340
is that react is obviously JavaScript

124
00:05:32,340 --> 00:05:34,919
framework and how many of you have

125
00:05:34,919 --> 00:05:39,509
JavaScript on the server side I can see

126
00:05:39,509 --> 00:05:41,669
a little bit of hands but obviously not

127
00:05:41,669 --> 00:05:44,310
everyone and having JavaScript on the

128
00:05:44,310 --> 00:05:45,900
server side is not a very common thing

129
00:05:45,900 --> 00:05:48,360
but having javascript in Python PHP or

130
00:05:48,360 --> 00:05:51,060
Java or many other server-side languages

131
00:05:51,060 --> 00:05:54,840
is very rare it's obviously not a common

132
00:05:54,840 --> 00:05:58,039
at all so in order to enable our

133
00:05:58,039 --> 00:06:00,060
JavaScript rendering on the server side

134
00:06:00,060 --> 00:06:02,039
we had to prepare infrastructure first

135
00:06:02,039 --> 00:06:04,740
and some of you may ask the question why

136
00:06:04,740 --> 00:06:06,779
do I actually need so-called Universal

137
00:06:06,779 --> 00:06:09,870
or isomorphic rendering and there is two

138
00:06:09,870 --> 00:06:10,590
reasons for that

139
00:06:10,590 --> 00:06:12,900
first of all our engineers they will not

140
00:06:12,900 --> 00:06:15,060
have to write their templates twice so

141
00:06:15,060 --> 00:06:17,460
we're saving their work in time and the

142
00:06:17,460 --> 00:06:18,719
other reason is yes here

143
00:06:18,719 --> 00:06:21,990
and even though nowadays search engines

144
00:06:21,990 --> 00:06:25,080
they can execute JavaScript and parse

145
00:06:25,080 --> 00:06:27,330
page that is rendered on the client-side

146
00:06:27,330 --> 00:06:29,940
we run a bunch of experiments it's still

147
00:06:29,940 --> 00:06:32,069
better to serve the initial markup as a

148
00:06:32,069 --> 00:06:37,020
string as an HTML string so the second

149
00:06:37,020 --> 00:06:39,779
challenge is rendering react components

150
00:06:39,779 --> 00:06:41,400
inside of the old

151
00:06:41,400 --> 00:06:44,400
and while react is pretty flexible in

152
00:06:44,400 --> 00:06:46,199
terms of rendering as long as you can

153
00:06:46,199 --> 00:06:48,930
provide it a container Dom element there

154
00:06:48,930 --> 00:06:51,300
still might be some challenges and for

155
00:06:51,300 --> 00:06:53,280
example what if your template files are

156
00:06:53,280 --> 00:06:55,620
stored your what if your templates are

157
00:06:55,620 --> 00:06:58,020
started in separate files or what if

158
00:06:58,020 --> 00:07:00,090
your templates using a custom made

159
00:07:00,090 --> 00:07:02,219
template language and such example is

160
00:07:02,219 --> 00:07:04,620
ginger templates in Python and non Dex

161
00:07:04,620 --> 00:07:08,580
in JavaScript so the third challenge is

162
00:07:08,580 --> 00:07:11,520
dealing with the old resources and more

163
00:07:11,520 --> 00:07:14,669
likely in your your your project you

164
00:07:14,669 --> 00:07:17,219
have a resource layer which does all the

165
00:07:17,219 --> 00:07:19,860
communication with the API and probably

166
00:07:19,860 --> 00:07:21,389
you want to reuse it at least for the

167
00:07:21,389 --> 00:07:23,279
first period of time unless you want to

168
00:07:23,279 --> 00:07:26,099
really rebuild everything from scratch

169
00:07:26,099 --> 00:07:28,680
in react and you have to Web Apps as we

170
00:07:28,680 --> 00:07:31,110
discussed before so dealing with the old

171
00:07:31,110 --> 00:07:34,560
resources is another challenge and the

172
00:07:34,560 --> 00:07:37,379
last challenge is how can we make sure

173
00:07:37,379 --> 00:07:39,960
that newly created UI and components

174
00:07:39,960 --> 00:07:41,400
they're actually performing better than

175
00:07:41,400 --> 00:07:44,009
the old ones what if we introduced a bar

176
00:07:44,009 --> 00:07:46,529
for performance issues and something is

177
00:07:46,529 --> 00:07:49,800
going wrong with the users so here we

178
00:07:49,800 --> 00:07:51,779
outline our four main challenges and now

179
00:07:51,779 --> 00:07:54,259
let's dive deeper into each of those and

180
00:07:54,259 --> 00:07:56,879
before let me give you a high-level

181
00:07:56,879 --> 00:08:03,839
overview of our web app architecture as

182
00:08:03,839 --> 00:08:06,240
you can see on this slide there is

183
00:08:06,240 --> 00:08:09,180
nothing crazy we have a client-side web

184
00:08:09,180 --> 00:08:13,199
app Python junga web server and we have

185
00:08:13,199 --> 00:08:16,680
pack an API and when a user agent sends

186
00:08:16,680 --> 00:08:19,250
a request to the to the server the

187
00:08:19,250 --> 00:08:22,770
server renders HTML with ginger render

188
00:08:22,770 --> 00:08:25,259
in Python and sends back all this HTML

189
00:08:25,259 --> 00:08:27,960
to the client which spawns a bunch of

190
00:08:27,960 --> 00:08:31,169
requests for CSS images in JavaScript

191
00:08:31,169 --> 00:08:33,810
and many other assets it initializes the

192
00:08:33,810 --> 00:08:37,079
app and after that our subsequent

193
00:08:37,079 --> 00:08:39,539
requests are handled only only for

194
00:08:39,539 --> 00:08:41,760
retrieving the additional data so there

195
00:08:41,760 --> 00:08:43,860
is no more subsequent renders on the on

196
00:08:43,860 --> 00:08:46,110
the server side all the renders are

197
00:08:46,110 --> 00:08:48,540
happening on the client side and because

198
00:08:48,540 --> 00:08:50,699
of that we had so-called isomorphic

199
00:08:50,699 --> 00:08:54,300
rendering so now let me give you a

200
00:08:54,300 --> 00:08:54,690
little bit

201
00:08:54,690 --> 00:08:57,330
contacts about ginger rendering engine

202
00:08:57,330 --> 00:09:00,720
and Python and nunchucks in JavaScript

203
00:09:00,720 --> 00:09:03,420
and these templating languages are very

204
00:09:03,420 --> 00:09:06,480
similar almost identical and because of

205
00:09:06,480 --> 00:09:08,730
that we had so-called isomorphic

206
00:09:08,730 --> 00:09:11,220
rendering and the only one caveat in

207
00:09:11,220 --> 00:09:13,320
this approach was that we had to have

208
00:09:13,320 --> 00:09:15,120
two sets of utils you can see there is

209
00:09:15,120 --> 00:09:17,820
one set youtubes in libraries for python

210
00:09:17,820 --> 00:09:19,590
and another one for nunchucks in

211
00:09:19,590 --> 00:09:22,590
javascript not the best approach because

212
00:09:22,590 --> 00:09:24,960
you have to run tests and do all these

213
00:09:24,960 --> 00:09:28,560
things that are not the best how many of

214
00:09:28,560 --> 00:09:30,720
you are familiar with nunchucks or

215
00:09:30,720 --> 00:09:35,730
ginger at all not that many people but

216
00:09:35,730 --> 00:09:38,940
that's fine because I'm gonna go into a

217
00:09:38,940 --> 00:09:40,800
high-level overview of this templating

218
00:09:40,800 --> 00:09:43,770
language and it's pretty common similar

219
00:09:43,770 --> 00:09:46,470
to many other languages on this slide

220
00:09:46,470 --> 00:09:48,060
you can see small code snippet we are

221
00:09:48,060 --> 00:09:51,420
initializing three variables very common

222
00:09:51,420 --> 00:09:54,390
to many template templating languages on

223
00:09:54,390 --> 00:09:56,940
this line you can see that we are

224
00:09:56,940 --> 00:10:01,710
executing our template and if creating a

225
00:10:01,710 --> 00:10:04,770
name is empty the render hello guest

226
00:10:04,770 --> 00:10:09,990
welcome to Pinterest and finally on this

227
00:10:09,990 --> 00:10:12,750
slide we are rendering a module called

228
00:10:12,750 --> 00:10:16,380
home feed and module is a function call

229
00:10:16,380 --> 00:10:18,450
in Java C it will be converted to

230
00:10:18,450 --> 00:10:20,220
function call in JavaScript which will

231
00:10:20,220 --> 00:10:22,830
file home feed module and it will render

232
00:10:22,830 --> 00:10:25,500
for us passing all the options as a

233
00:10:25,500 --> 00:10:29,490
properties does it look familiar for you

234
00:10:29,490 --> 00:10:37,230
know any react people so it seems like

235
00:10:37,230 --> 00:10:39,270
this architecture fits very well into

236
00:10:39,270 --> 00:10:42,360
each other this is a react code snippet

237
00:10:42,360 --> 00:10:45,690
and we reading properties with calling

238
00:10:45,690 --> 00:10:48,330
home feed module we passing all the

239
00:10:48,330 --> 00:10:50,040
options of the properties as well and

240
00:10:50,040 --> 00:10:51,990
home field is not is another function

241
00:10:51,990 --> 00:10:56,700
call in react so this looks very it

242
00:10:56,700 --> 00:10:58,380
seems like these architectures fits very

243
00:10:58,380 --> 00:10:59,490
well into each other

244
00:10:59,490 --> 00:11:01,310
but the only one issue is that

245
00:11:01,310 --> 00:11:04,170
JavaScript and Python is not commenting

246
00:11:04,170 --> 00:11:06,740
at all or any other server-side language

247
00:11:06,740 --> 00:11:10,880
because of that is a very first step we

248
00:11:10,880 --> 00:11:13,100
enabled non Jax rendering on a

249
00:11:13,100 --> 00:11:16,670
standalone node.js server that enables

250
00:11:16,670 --> 00:11:18,140
JavaScript rendering on the on the

251
00:11:18,140 --> 00:11:21,770
server side this will unblock nunchuks

252
00:11:21,770 --> 00:11:23,840
rendering and our engineers would have

253
00:11:23,840 --> 00:11:27,020
to rebuild the whole thing at once

254
00:11:27,020 --> 00:11:28,940
but they will be able to migrate

255
00:11:28,940 --> 00:11:31,070
incrementally rewriting our web app

256
00:11:31,070 --> 00:11:36,470
piece by piece as a bonus we can reuse

257
00:11:36,470 --> 00:11:38,690
the same youtubes and libraries so there

258
00:11:38,690 --> 00:11:40,790
is no more duplicating libraries only in

259
00:11:40,790 --> 00:11:45,050
JavaScript no more in Python so now we

260
00:11:45,050 --> 00:11:47,930
have a plan for our migration at first

261
00:11:47,930 --> 00:11:50,840
will migrate from Gingin Python and X on

262
00:11:50,840 --> 00:11:53,390
the client tune and X on the on the

263
00:11:53,390 --> 00:11:57,530
server and on the client and now let's

264
00:11:57,530 --> 00:11:59,330
take a look how our rendering used to

265
00:11:59,330 --> 00:12:01,460
work before we introduced node.js

266
00:12:01,460 --> 00:12:04,850
sidebar as I mentioned before our

267
00:12:04,850 --> 00:12:07,250
templates are structured as a trees a

268
00:12:07,250 --> 00:12:10,010
root module can have children module and

269
00:12:10,010 --> 00:12:11,510
children modules can have more children

270
00:12:11,510 --> 00:12:14,720
modules and a renderer pass traverses

271
00:12:14,720 --> 00:12:17,090
the tree rendering each of these node

272
00:12:17,090 --> 00:12:20,440
and combining them into resulting HTML

273
00:12:20,440 --> 00:12:23,920
so a user agent sends a request to the

274
00:12:23,920 --> 00:12:28,550
to the Python jungle web server then we

275
00:12:28,550 --> 00:12:30,380
send a request to the backend API in

276
00:12:30,380 --> 00:12:31,940
order to retrieve the initial data for

277
00:12:31,940 --> 00:12:35,330
the template and we start rendering our

278
00:12:35,330 --> 00:12:38,000
templating tree so we render it as far

279
00:12:38,000 --> 00:12:40,190
as we can go until additional data is

280
00:12:40,190 --> 00:12:45,230
needed at this point worst to mention

281
00:12:45,230 --> 00:12:47,660
that this process is CPU blocking so

282
00:12:47,660 --> 00:12:49,190
nothing else can be rendered in this

283
00:12:49,190 --> 00:12:52,970
process and this happens serially at

284
00:12:52,970 --> 00:12:54,890
this point we'll request additional data

285
00:12:54,890 --> 00:12:58,520
from the back in API and we continue our

286
00:12:58,520 --> 00:13:01,490
rendering as far as we can go until

287
00:13:01,490 --> 00:13:02,870
additional data needed and we're

288
00:13:02,870 --> 00:13:05,600
requesting additional data and in the

289
00:13:05,600 --> 00:13:08,300
end after the whole template is rendered

290
00:13:08,300 --> 00:13:12,170
with sending the resulting HTML now

291
00:13:12,170 --> 00:13:14,510
let's take a look what happened after we

292
00:13:14,510 --> 00:13:17,540
introduced a node.js sidecar as you can

293
00:13:17,540 --> 00:13:19,900
see the Harket texture is

294
00:13:19,900 --> 00:13:22,330
similar to what we had before but now we

295
00:13:22,330 --> 00:13:24,820
have injects proxy layer for load

296
00:13:24,820 --> 00:13:28,330
balancing and we have a set of node.js

297
00:13:28,330 --> 00:13:34,090
workers as it was before we're sending a

298
00:13:34,090 --> 00:13:38,950
request from the user agent and we're

299
00:13:38,950 --> 00:13:40,540
requesting the additional data from the

300
00:13:40,540 --> 00:13:45,610
API after that we're sending a request

301
00:13:45,610 --> 00:13:48,400
over network to our node.js server in

302
00:13:48,400 --> 00:13:51,580
order to render our nunchuks template so

303
00:13:51,580 --> 00:13:53,800
here where it becomes different we're

304
00:13:53,800 --> 00:13:55,690
starting rendering with node.js server

305
00:13:55,690 --> 00:13:58,840
over network and that's we were able to

306
00:13:58,840 --> 00:14:01,360
enable JavaScript rendering on the

307
00:14:01,360 --> 00:14:04,840
server side is it first before it

308
00:14:04,840 --> 00:14:06,850
renders the template as far as it is it

309
00:14:06,850 --> 00:14:10,420
can go until additional data is needed

310
00:14:10,420 --> 00:14:12,490
and at this point it returns back

311
00:14:12,490 --> 00:14:14,020
partially rendered template as a

312
00:14:14,020 --> 00:14:17,680
response and our Python Django web

313
00:14:17,680 --> 00:14:19,390
server requests more data from the

314
00:14:19,390 --> 00:14:24,360
backend API so now we repeat the process

315
00:14:24,360 --> 00:14:27,580
but the only difference is now we can

316
00:14:27,580 --> 00:14:30,610
send multiple requests one for each sub

317
00:14:30,610 --> 00:14:33,550
tree in order to paralyze rendering

318
00:14:33,550 --> 00:14:37,390
process and we rendered it as far as we

319
00:14:37,390 --> 00:14:41,890
can go again and this process is not CPU

320
00:14:41,890 --> 00:14:48,580
blocking anymore so after a both sub

321
00:14:48,580 --> 00:14:50,680
trees are rendered in parallel we send

322
00:14:50,680 --> 00:14:53,440
back independent responses to the to the

323
00:14:53,440 --> 00:14:55,900
passenger junga web server and we

324
00:14:55,900 --> 00:14:58,320
continue process again and again

325
00:14:58,320 --> 00:15:00,460
requesting additional data if it's

326
00:15:00,460 --> 00:15:05,500
needed we send multiple requests and we

327
00:15:05,500 --> 00:15:06,970
continue rendering until the tree is

328
00:15:06,970 --> 00:15:10,090
fully rendered and at this point we send

329
00:15:10,090 --> 00:15:14,890
the resulting HTML to the user agent so

330
00:15:14,890 --> 00:15:16,630
if you can see the approach is very

331
00:15:16,630 --> 00:15:18,520
similar to what we had before but now

332
00:15:18,520 --> 00:15:20,800
we're rendering JavaScript templates on

333
00:15:20,800 --> 00:15:24,090
a standalone node.js servers server and

334
00:15:24,090 --> 00:15:26,830
you can use this approach in many

335
00:15:26,830 --> 00:15:29,260
different languages we use it in iPhone

336
00:15:29,260 --> 00:15:32,680
but if you are in Java or PHP or you

337
00:15:32,680 --> 00:15:35,529
something else even like cold fusion

338
00:15:35,529 --> 00:15:39,220
someone is using it still then you can

339
00:15:39,220 --> 00:15:43,450
use the same approach so now at this

340
00:15:43,450 --> 00:15:45,190
point we were able to solve our first

341
00:15:45,190 --> 00:15:49,630
challenge and we can render nunchucks

342
00:15:49,630 --> 00:15:51,040
templates on the client and on the

343
00:15:51,040 --> 00:15:53,680
server and now we can go ahead and solve

344
00:15:53,680 --> 00:16:05,470
our second challenge let me provide a

345
00:16:05,470 --> 00:16:07,060
little bit of context about the old

346
00:16:07,060 --> 00:16:11,320
framework Denzel Denzel is very very

347
00:16:11,320 --> 00:16:12,790
similar to many other frameworks that

348
00:16:12,790 --> 00:16:14,830
were introduced three four or five years

349
00:16:14,830 --> 00:16:18,820
ago its component based framework and

350
00:16:18,820 --> 00:16:21,399
uses object-oriented inheritance

351
00:16:21,399 --> 00:16:24,060
approach and on this slide you can see

352
00:16:24,060 --> 00:16:28,930
two nunchuks statements and one of them

353
00:16:28,930 --> 00:16:32,080
is old denzel module code and another

354
00:16:32,080 --> 00:16:35,980
one is new react component code and as I

355
00:16:35,980 --> 00:16:38,500
mentioned before module is a function

356
00:16:38,500 --> 00:16:41,650
call it basically converts to JavaScript

357
00:16:41,650 --> 00:16:43,930
call which will render for us Oh Denzel

358
00:16:43,930 --> 00:16:46,930
component since it the same applies to

359
00:16:46,930 --> 00:16:49,180
the component called component calls

360
00:16:49,180 --> 00:16:50,980
another function call but it falls back

361
00:16:50,980 --> 00:16:53,950
to react rendering so in order to

362
00:16:53,950 --> 00:16:56,020
empower our engineers to migrate our

363
00:16:56,020 --> 00:16:58,839
service incrementally with tweak than

364
00:16:58,839 --> 00:17:01,570
Jax code and we introduced a new keyword

365
00:17:01,570 --> 00:17:04,030
component which represents the bridge

366
00:17:04,030 --> 00:17:06,900
between Denzel and react

367
00:17:06,900 --> 00:17:11,319
so once nunchuks rendering its component

368
00:17:11,319 --> 00:17:13,030
keyword it will render it Denzel react

369
00:17:13,030 --> 00:17:15,730
bridge instead and on the slide you can

370
00:17:15,730 --> 00:17:18,880
see a simplified version of Denzel reg

371
00:17:18,880 --> 00:17:21,610
bridge which is a Denzel module which

372
00:17:21,610 --> 00:17:26,530
will render for us react component let's

373
00:17:26,530 --> 00:17:27,550
take a look how it works

374
00:17:27,550 --> 00:17:32,260
so once the component is added to the

375
00:17:32,260 --> 00:17:35,890
Dom it will read its own options and it

376
00:17:35,890 --> 00:17:37,660
will figure out the name of the react

377
00:17:37,660 --> 00:17:42,070
component that they want to render and

378
00:17:42,070 --> 00:17:44,050
it will render this component passing

379
00:17:44,050 --> 00:17:46,100
all the options to the properties

380
00:17:46,100 --> 00:17:48,140
the rendering will happen in its own

381
00:17:48,140 --> 00:17:52,970
container Dom element so this is pretty

382
00:17:52,970 --> 00:17:55,520
simple but pretty powerful technique and

383
00:17:55,520 --> 00:17:57,860
you can use it in many other JavaScript

384
00:17:57,860 --> 00:17:59,570
libraries if you want to migrate from

385
00:17:59,570 --> 00:18:02,030
one library to react and you want to use

386
00:18:02,030 --> 00:18:04,850
the same libraries together during

387
00:18:04,850 --> 00:18:09,440
period of migration some of you may ask

388
00:18:09,440 --> 00:18:12,200
a really good question how react will

389
00:18:12,200 --> 00:18:14,870
reuse the services rendered markup on

390
00:18:14,870 --> 00:18:18,050
the client-side and this is a really

391
00:18:18,050 --> 00:18:21,140
cool feature of react because once the

392
00:18:21,140 --> 00:18:23,180
HTML is rendered on the server-side

393
00:18:23,180 --> 00:18:26,330
react to automatically add a checksum to

394
00:18:26,330 --> 00:18:30,470
it and after the web app is initialized

395
00:18:30,470 --> 00:18:33,950
react to render the HTML in its own

396
00:18:33,950 --> 00:18:37,040
virtual Dom not a real dumb but virtual

397
00:18:37,040 --> 00:18:39,500
Dom and will generate another checksum

398
00:18:39,500 --> 00:18:41,780
and if this checks I'm sorry the same

399
00:18:41,780 --> 00:18:43,700
that means that we can reuse the

400
00:18:43,700 --> 00:18:45,740
existing HTML and will not have to

401
00:18:45,740 --> 00:18:48,380
change the Dom elements at all this is

402
00:18:48,380 --> 00:18:50,330
pretty important for many performance

403
00:18:50,330 --> 00:18:53,840
optimizations and also it reduces UI

404
00:18:53,840 --> 00:18:56,450
flickering that you might see when Dom

405
00:18:56,450 --> 00:18:58,970
has changed after javascript is

406
00:18:58,970 --> 00:19:01,520
initialized think it's one of the really

407
00:19:01,520 --> 00:19:07,460
cool features of react so now since we

408
00:19:07,460 --> 00:19:09,140
can render react components inside of

409
00:19:09,140 --> 00:19:11,390
the old framework we can deal with the

410
00:19:11,390 --> 00:19:14,600
old resource later and more likely in

411
00:19:14,600 --> 00:19:18,530
your project you have ajax library or

412
00:19:18,530 --> 00:19:21,290
library that is building on top of ajax

413
00:19:21,290 --> 00:19:23,540
request that does all the communication

414
00:19:23,540 --> 00:19:25,730
to the api for you and certain serves

415
00:19:25,730 --> 00:19:28,250
all the data from the server to to the

416
00:19:28,250 --> 00:19:30,200
client and probably at least for the

417
00:19:30,200 --> 00:19:31,880
first period of time of migration you

418
00:19:31,880 --> 00:19:34,460
really want to reuse this library and

419
00:19:34,460 --> 00:19:36,800
for that purpose we use powder

420
00:19:36,800 --> 00:19:40,250
components as adaptors if you don't know

421
00:19:40,250 --> 00:19:42,110
how the component is a very powerful

422
00:19:42,110 --> 00:19:44,630
technique that helps you to reuse

423
00:19:44,630 --> 00:19:46,280
components logic while remaining

424
00:19:46,280 --> 00:19:49,400
components composable it's a function

425
00:19:49,400 --> 00:19:51,110
that takes a component and returns

426
00:19:51,110 --> 00:19:53,450
another component I know it may sound a

427
00:19:53,450 --> 00:19:55,130
little bit confusing but let's take a

428
00:19:55,130 --> 00:19:56,900
look to the example and I think

429
00:19:56,900 --> 00:19:58,750
everything will be clear

430
00:19:58,750 --> 00:20:01,580
so on this slide you can see on the left

431
00:20:01,580 --> 00:20:05,600
side it's a hoc with the resource that

432
00:20:05,600 --> 00:20:09,110
helps us to communicate with the API and

433
00:20:09,110 --> 00:20:11,809
with the older resource layer and on the

434
00:20:11,809 --> 00:20:13,549
right side you can see the example of

435
00:20:13,549 --> 00:20:17,990
usage of hoc with resource so what

436
00:20:17,990 --> 00:20:24,679
happens on component it mount when the

437
00:20:24,679 --> 00:20:27,080
component is already in the Dom it will

438
00:20:27,080 --> 00:20:30,909
send a request to the resource layer and

439
00:20:30,909 --> 00:20:34,669
once the data comes back it will change

440
00:20:34,669 --> 00:20:37,700
its own state thus it will render its

441
00:20:37,700 --> 00:20:41,870
own components and no trigger rendering

442
00:20:41,870 --> 00:20:45,590
of the of the child this is pretty

443
00:20:45,590 --> 00:20:47,539
simple but pretty powerful technique

444
00:20:47,539 --> 00:20:50,330
that helps a lot in migrations like that

445
00:20:50,330 --> 00:20:52,340
and you can use it for many other things

446
00:20:52,340 --> 00:20:54,620
not only for dealing with resources but

447
00:20:54,620 --> 00:20:56,870
this one is the main one for example if

448
00:20:56,870 --> 00:21:00,070
you have some experiments layer or

449
00:21:00,070 --> 00:21:03,049
something else you can always make sure

450
00:21:03,049 --> 00:21:06,110
that the newly created reaction ponents

451
00:21:06,110 --> 00:21:08,120
and architecture are always in sync with

452
00:21:08,120 --> 00:21:13,639
the with the with this layer so now we

453
00:21:13,639 --> 00:21:16,850
can render nunchuks on the server we can

454
00:21:16,850 --> 00:21:19,190
render react on the server on the client

455
00:21:19,190 --> 00:21:22,070
and now we can move forward and solve

456
00:21:22,070 --> 00:21:32,090
our last and fourth challenge so now

457
00:21:32,090 --> 00:21:34,309
we're talking about UI experiments and

458
00:21:34,309 --> 00:21:37,029
this is the most exciting part for me

459
00:21:37,029 --> 00:21:40,639
with more than 200 200 millions of

460
00:21:40,639 --> 00:21:42,889
monthly active users we have to roll out

461
00:21:42,889 --> 00:21:44,870
things very carefully because we have to

462
00:21:44,870 --> 00:21:47,539
make sure that our newly created UI is

463
00:21:47,539 --> 00:21:49,039
actually performing better than the old

464
00:21:49,039 --> 00:21:51,850
one and for that purpose we use

465
00:21:51,850 --> 00:21:54,679
gatekeeper a be testing framework and if

466
00:21:54,679 --> 00:21:55,789
you have something similar in your

467
00:21:55,789 --> 00:21:59,750
project it's super handy normally maybe

468
00:21:59,750 --> 00:22:01,610
testing frameworks are used to compare

469
00:22:01,610 --> 00:22:03,620
different UIs and see how they behave

470
00:22:03,620 --> 00:22:04,669
and measure

471
00:22:04,669 --> 00:22:07,519
the data and impact but you can use

472
00:22:07,519 --> 00:22:11,090
these frameworks as well for for

473
00:22:11,090 --> 00:22:14,419
migrations or factoring like that so on

474
00:22:14,419 --> 00:22:17,629
this slide you can see there is a very

475
00:22:17,629 --> 00:22:20,149
simplified version of forking logic

476
00:22:20,149 --> 00:22:22,669
based off on experiment check and if

477
00:22:22,669 --> 00:22:25,369
user is in the react experiment then we

478
00:22:25,369 --> 00:22:27,679
render newly created react component and

479
00:22:27,679 --> 00:22:29,950
otherwise we'll fall back to the old

480
00:22:29,950 --> 00:22:34,659
Denzel module now let's take a look

481
00:22:34,659 --> 00:22:37,519
deeper at the experiment setup you can

482
00:22:37,519 --> 00:22:40,129
see component tree or module tree on the

483
00:22:40,129 --> 00:22:45,320
right side and this component tree at

484
00:22:45,320 --> 00:22:47,690
some node something zell node you can

485
00:22:47,690 --> 00:22:49,369
see that we are forking our experiment

486
00:22:49,369 --> 00:22:52,519
logic and the whole right subtree is

487
00:22:52,519 --> 00:22:55,070
still rendered in in denzel but the left

488
00:22:55,070 --> 00:22:59,149
one is in react so worse to mention that

489
00:22:59,149 --> 00:23:03,230
once a node is converted to component

490
00:23:03,230 --> 00:23:05,840
call old children and descendants are

491
00:23:05,840 --> 00:23:08,840
necessarily in reality basically there

492
00:23:08,840 --> 00:23:11,359
is call of react inside of Denzel but

493
00:23:11,359 --> 00:23:13,129
there is no call of the ins on one side

494
00:23:13,129 --> 00:23:15,799
of react and this is done on purpose

495
00:23:15,799 --> 00:23:18,320
because it helps you to move faster and

496
00:23:18,320 --> 00:23:21,019
also it will be total mess if you start

497
00:23:21,019 --> 00:23:23,480
calling react inside of themselves and

498
00:23:23,480 --> 00:23:25,399
then downside of react and vice-versa

499
00:23:25,399 --> 00:23:27,139
you don't want to you really don't want

500
00:23:27,139 --> 00:23:33,619
to do this because of that we had to

501
00:23:33,619 --> 00:23:36,320
convert our components from the very

502
00:23:36,320 --> 00:23:39,019
leaves moving to the very top and we

503
00:23:39,019 --> 00:23:43,399
call it bottom-up approach also it's

504
00:23:43,399 --> 00:23:45,950
worse to mention that you probably want

505
00:23:45,950 --> 00:23:48,289
to run your experiments at maximum per

506
00:23:48,289 --> 00:23:50,480
page level and you don't want to compare

507
00:23:50,480 --> 00:23:53,179
your old web up to the new one otherwise

508
00:23:53,179 --> 00:23:55,340
you have too many factors affecting your

509
00:23:55,340 --> 00:23:57,590
data and you'll never be able to figure

510
00:23:57,590 --> 00:24:00,379
out why you have metrics drops or why I

511
00:24:00,379 --> 00:24:04,429
have maybe metric improvements also it's

512
00:24:04,429 --> 00:24:06,049
forced to mention that you really want

513
00:24:06,049 --> 00:24:08,950
to run your experiments exclusively and

514
00:24:08,950 --> 00:24:10,850
otherwise you'll have the same issue

515
00:24:10,850 --> 00:24:12,559
because different experiments will

516
00:24:12,559 --> 00:24:21,830
affect the same metrics

517
00:24:21,840 --> 00:24:25,660
later on you can login into your

518
00:24:25,660 --> 00:24:28,720
experiments dashboard and see different

519
00:24:28,720 --> 00:24:31,179
metrics so while we were running

520
00:24:31,179 --> 00:24:33,160
immigration like that we were comparing

521
00:24:33,160 --> 00:24:35,350
reacting Denzel to many different

522
00:24:35,350 --> 00:24:37,809
metrics like engagement metrics or error

523
00:24:37,809 --> 00:24:40,179
rate performance metrics and so on and

524
00:24:40,179 --> 00:24:42,250
so forth on this slide you can see a

525
00:24:42,250 --> 00:24:45,429
screenshot of the dashboard and you can

526
00:24:45,429 --> 00:24:46,870
see there is a bunch of metrics on the

527
00:24:46,870 --> 00:24:48,850
left side and there is a bunch of

528
00:24:48,850 --> 00:24:51,280
squares on the right side the ones that

529
00:24:51,280 --> 00:24:53,230
without color they actually gray and

530
00:24:53,230 --> 00:24:56,380
means that there is no not enough data

531
00:24:56,380 --> 00:24:59,049
to calculate the numbers so they will be

532
00:24:59,049 --> 00:25:00,700
statistically significant

533
00:25:00,700 --> 00:25:03,929
the red ones means there is a drop and

534
00:25:03,929 --> 00:25:06,130
the blue ones means there is improvement

535
00:25:06,130 --> 00:25:09,730
if there is a job you probably really

536
00:25:09,730 --> 00:25:11,169
want to investigate it and figure out

537
00:25:11,169 --> 00:25:13,030
maybe you introduced a bug or maybe

538
00:25:13,030 --> 00:25:14,650
there is a performance issues that

539
00:25:14,650 --> 00:25:18,370
affecting your user it's important to

540
00:25:18,370 --> 00:25:21,309
say that during migrations like that you

541
00:25:21,309 --> 00:25:23,470
may have a bunch of outta task unit

542
00:25:23,470 --> 00:25:25,840
tests manual testing and things like

543
00:25:25,840 --> 00:25:28,450
that but unlikely they will cover all

544
00:25:28,450 --> 00:25:31,830
the edge cases for example what if your

545
00:25:31,830 --> 00:25:34,120
well what if in your web app there is

546
00:25:34,120 --> 00:25:36,580
something going on wrong in in different

547
00:25:36,580 --> 00:25:39,429
language or what if people with poor

548
00:25:39,429 --> 00:25:42,250
internet connection they having some

549
00:25:42,250 --> 00:25:44,200
issues and it's really hard to catch

550
00:25:44,200 --> 00:25:47,140
things like that using unit tests or out

551
00:25:47,140 --> 00:25:49,660
a test or anything else but maybe

552
00:25:49,660 --> 00:25:51,340
testing frameworks and measuring that

553
00:25:51,340 --> 00:25:53,440
your data will always give you a signal

554
00:25:53,440 --> 00:25:54,790
that something is going wrong and you

555
00:25:54,790 --> 00:26:01,240
can start investigating so interest

556
00:26:01,240 --> 00:26:03,970
profiles were the first user heavy page

557
00:26:03,970 --> 00:26:05,919
that was successful immigrated to

558
00:26:05,919 --> 00:26:09,130
reality and during react migration we've

559
00:26:09,130 --> 00:26:10,870
seen consistent performance and

560
00:26:10,870 --> 00:26:13,179
engagement improvements for example

561
00:26:13,179 --> 00:26:15,760
metrics like Dom interactive or board

562
00:26:15,760 --> 00:26:19,480
page views were up to 20% and we got

563
00:26:19,480 --> 00:26:22,090
this 20% just from changing the gears

564
00:26:22,090 --> 00:26:24,220
and infrastructure without actually

565
00:26:24,220 --> 00:26:27,250
changing UI adult I think this is pretty

566
00:26:27,250 --> 00:26:30,250
cool getting 20% from without changing

567
00:26:30,250 --> 00:26:31,500
the

568
00:26:31,500 --> 00:26:34,570
during migration our engineers our

569
00:26:34,570 --> 00:26:36,340
product engineers they were able to

570
00:26:36,340 --> 00:26:39,040
continue changing the service and they

571
00:26:39,040 --> 00:26:41,290
were able to ship different features and

572
00:26:41,290 --> 00:26:43,570
run different experiments in the rest of

573
00:26:43,570 --> 00:26:49,960
the website and finally all these leads

574
00:26:49,960 --> 00:26:52,559
to completely new developer experience

575
00:26:52,559 --> 00:26:57,010
now we don't have duplicating nunchucks

576
00:26:57,010 --> 00:27:00,549
and ginger libraries there is no need to

577
00:27:00,549 --> 00:27:03,160
learn nunchucks at all that makes the

578
00:27:03,160 --> 00:27:06,370
onboarding process much easier there is

579
00:27:06,370 --> 00:27:08,140
single language on the client and on the

580
00:27:08,140 --> 00:27:10,150
server side which makes life of our

581
00:27:10,150 --> 00:27:14,080
engineers even more easier and finally

582
00:27:14,080 --> 00:27:15,880
we are part of the large developer

583
00:27:15,880 --> 00:27:18,040
community and there is no need in wiki

584
00:27:18,040 --> 00:27:19,990
pages there is a lot of well-crafted

585
00:27:19,990 --> 00:27:23,440
examples and documentation online it's

586
00:27:23,440 --> 00:27:25,450
been a long journey but we're excited to

587
00:27:25,450 --> 00:27:29,470
be part of react community thank you and

588
00:27:29,470 --> 00:27:31,240
if you have any questions feel free to

589
00:27:31,240 --> 00:27:41,110
find me in

