1
00:00:07,490 --> 00:00:10,800

all right um yeah thank you for coming

2
00:00:10,800 --> 00:00:13,740
and listening my talk is titled 13 oseco

3
00:00:13,740 --> 00:00:15,839
how simple as your database it's

4
00:00:15,839 --> 00:00:17,160
basically about writing your own

5
00:00:17,160 --> 00:00:19,949
database in noches and why it's maybe a

6
00:00:19,949 --> 00:00:21,750
really stupid idea but maybe some parts

7
00:00:21,750 --> 00:00:24,779
of it or not and yeah just a little bit

8
00:00:24,779 --> 00:00:27,539
about myself I'm an OTS contributor I

9
00:00:27,539 --> 00:00:29,250
picked it up right wins mailing lists

10
00:00:29,250 --> 00:00:31,949
were still pretty small 30 people I have

11
00:00:31,949 --> 00:00:33,630
to start up with imma cofrin edit

12
00:00:33,630 --> 00:00:36,000
transload it we do a video uploading and

13
00:00:36,000 --> 00:00:39,149
encoding as a service one of my bigger

14
00:00:39,149 --> 00:00:41,070
open source projects with node is a

15
00:00:41,070 --> 00:00:43,980
driver for my sequel which is pretty

16
00:00:43,980 --> 00:00:47,960
crazy talking to the binary protocol and

17
00:00:47,960 --> 00:00:51,210
other people are binding the native seat

18
00:00:51,210 --> 00:00:52,559
driver for node but this one is

19
00:00:52,559 --> 00:00:53,850
completely built in notes that

20
00:00:53,850 --> 00:00:55,170
everything is non blocking it's not

21
00:00:55,170 --> 00:00:56,699
using any Z code you don't have to

22
00:00:56,699 --> 00:00:58,559
compile it and I hope I can get some

23
00:00:58,559 --> 00:01:00,359
performance pretty close to whatever she

24
00:01:00,359 --> 00:01:03,660
can deliver and I'm also a source of one

25
00:01:03,660 --> 00:01:05,760
of the libraries so you can use a note

26
00:01:05,760 --> 00:01:09,420
to talk to couch TV and so I have a

27
00:01:09,420 --> 00:01:11,340
little bit of experience with working

28
00:01:11,340 --> 00:01:13,560
with databases as a user as a also of

29
00:01:13,560 --> 00:01:15,420
client libraries but I'm not necessarily

30
00:01:15,420 --> 00:01:17,549
an expert writing databases so if at any

31
00:01:17,549 --> 00:01:19,080
point you think something is completely

32
00:01:19,080 --> 00:01:21,060
crazy and stupid please let me know so

33
00:01:21,060 --> 00:01:22,350
we can filt out it's a good stuff from

34
00:01:22,350 --> 00:01:25,770
the bad stuff all right ya SE on that

35
00:01:25,770 --> 00:01:28,229
I'm really happy to be here so volcanoes

36
00:01:28,229 --> 00:01:30,000
this time get defeated places channel by

37
00:01:30,000 --> 00:01:32,250
channel men here and I hope it's not

38
00:01:32,250 --> 00:01:35,640
showing up again first of all i'd be

39
00:01:35,640 --> 00:01:37,079
interested in what everybody's using

40
00:01:37,079 --> 00:01:38,369
these days I mean we hear a lot about

41
00:01:38,369 --> 00:01:40,710
people using no sequel but what about

42
00:01:40,710 --> 00:01:43,350
this room who's using a no sequel

43
00:01:43,350 --> 00:01:47,070
database in general that's about half of

44
00:01:47,070 --> 00:01:49,770
the people with no sequel database

45
00:01:49,770 --> 00:01:53,280
couchdb that's a bunch of people are

46
00:01:53,280 --> 00:01:58,159
Redis a bunch of people's well Mongo

47
00:01:58,159 --> 00:02:01,439
anybody crazier Reich or other stuff i

48
00:02:01,439 --> 00:02:04,530
haven't mentioned Reich okay anything

49
00:02:04,530 --> 00:02:08,069
else totally out of the ordinary okay so

50
00:02:08,069 --> 00:02:09,420
Cassandra apparently it's not

51
00:02:09,420 --> 00:02:12,060
represented and goose using

52
00:02:12,060 --> 00:02:15,870
a sequel based database that still be

53
00:02:15,870 --> 00:02:19,950
most of the people with my tickle or my

54
00:02:19,950 --> 00:02:25,140
sequel that's a bunch post crew the same

55
00:02:25,140 --> 00:02:26,730
people also i think some people

56
00:02:26,730 --> 00:02:32,459
restaurant choice yeah anyway but good

57
00:02:32,459 --> 00:02:35,190
to know but i think there's still a lot

58
00:02:35,190 --> 00:02:36,900
of people using sequel and a lot of

59
00:02:36,900 --> 00:02:39,269
people using no sequel my general

60
00:02:39,269 --> 00:02:41,069
opinion about it is just because no

61
00:02:41,069 --> 00:02:42,780
sequels all the cool hype and stuff

62
00:02:42,780 --> 00:02:44,430
today i think most of the applications

63
00:02:44,430 --> 00:02:47,819
people build these days until they get

64
00:02:47,819 --> 00:02:49,650
hit so hard that it becomes a scaling

65
00:02:49,650 --> 00:02:51,180
problem what database technology you

66
00:02:51,180 --> 00:02:52,470
choose you should really look at your

67
00:02:52,470 --> 00:02:54,150
data it's a relational or not and if

68
00:02:54,150 --> 00:02:55,890
it's relational I mean Facebook's it

69
00:02:55,890 --> 00:02:58,830
scales my sequel it's possible so but

70
00:02:58,830 --> 00:03:00,120
nevertheless I like to play with the

71
00:03:00,120 --> 00:03:02,489
cool stuff as well and he comes

72
00:03:02,489 --> 00:03:05,580
presentation on dirty basically as idea

73
00:03:05,580 --> 00:03:08,130
behind dirty is said I really like

74
00:03:08,130 --> 00:03:09,840
couchdb when I first played with it i

75
00:03:09,840 --> 00:03:12,720
really liked writing my query code in

76
00:03:12,720 --> 00:03:14,760
JavaScript having JavaScript views I saw

77
00:03:14,760 --> 00:03:16,739
that was really neat and more

78
00:03:16,739 --> 00:03:18,269
interesting way to get at your data sand

79
00:03:18,269 --> 00:03:20,880
queries and at the same time I haven't

80
00:03:20,880 --> 00:03:22,500
really used it much but I looked a lot

81
00:03:22,500 --> 00:03:24,299
at it and learned a lot from it it's

82
00:03:24,299 --> 00:03:27,420
Redis which is also very interesting key

83
00:03:27,420 --> 00:03:28,890
value store trying to solve a different

84
00:03:28,890 --> 00:03:31,170
class of problems but it's basically one

85
00:03:31,170 --> 00:03:32,670
of the fastest ones out there it's

86
00:03:32,670 --> 00:03:34,530
basically you can imagine it as

87
00:03:34,530 --> 00:03:38,130
memcached but with this back end so when

88
00:03:38,130 --> 00:03:39,630
you restart your cache server it's not

89
00:03:39,630 --> 00:03:41,370
going to be all gone but as some people

90
00:03:41,370 --> 00:03:42,450
are also starting to use it as a

91
00:03:42,450 --> 00:03:47,040
full-blown database um so let's talk

92
00:03:47,040 --> 00:03:48,630
about a little bit of the design choices

93
00:03:48,630 --> 00:03:51,120
in this library so now I'm working on

94
00:03:51,120 --> 00:03:53,400
the biggest one of course is set its

95
00:03:53,400 --> 00:03:55,799
build on noches having is an unlocking I

96
00:03:55,799 --> 00:03:58,709
also wicked fast v8 JavaScript engine or

97
00:03:58,709 --> 00:04:00,660
big wins for anybody trying to write a

98
00:04:00,660 --> 00:04:04,260
simple database how big is the win you

99
00:04:04,260 --> 00:04:06,480
can see here it's 150 lines of code

100
00:04:06,480 --> 00:04:08,700
compared to a couch TV or read us which

101
00:04:08,700 --> 00:04:11,819
each way in it about 16,000 15,000 lines

102
00:04:11,819 --> 00:04:14,190
of code my sequel by comparison has a

103
00:04:14,190 --> 00:04:16,769
code base of 1 million lines of code but

104
00:04:16,769 --> 00:04:17,850
it's really hard to tell from the

105
00:04:17,850 --> 00:04:18,859
reproach

106
00:04:18,859 --> 00:04:20,479
it's really hard to tell from the

107
00:04:20,479 --> 00:04:22,129
repository how much if it is a bunch of

108
00:04:22,129 --> 00:04:24,080
crap that's not even executed when you

109
00:04:24,080 --> 00:04:25,550
run a database and how much it's

110
00:04:25,550 --> 00:04:27,289
actually used so I'm not going to put

111
00:04:27,289 --> 00:04:29,900
that up but yeah basically 150 lines of

112
00:04:29,900 --> 00:04:31,699
code for me it's a design choice because

113
00:04:31,699 --> 00:04:33,020
I'm going to talk about it further but

114
00:04:33,020 --> 00:04:35,060
this library is meant to only solve a

115
00:04:35,060 --> 00:04:37,189
very specific class of problems and then

116
00:04:37,189 --> 00:04:39,139
show solutions to other classes of

117
00:04:39,139 --> 00:04:41,840
problems by taking yeah tricks and stuff

118
00:04:41,840 --> 00:04:43,909
that I learned writing it but it is

119
00:04:43,909 --> 00:04:45,469
minimal on purpose but I think it's

120
00:04:45,469 --> 00:04:48,169
useful even with the minimal way it's

121
00:04:48,169 --> 00:04:53,060
structured so another design choice is a

122
00:04:53,060 --> 00:04:55,969
really simple of file format the file

123
00:04:55,969 --> 00:04:57,949
format is actually new line appended

124
00:04:57,949 --> 00:04:59,960
chasing so whenever there's a record

125
00:04:59,960 --> 00:05:02,419
written to disk it stores one chase and

126
00:05:02,419 --> 00:05:05,180
entry it has two keys the first one is

127
00:05:05,180 --> 00:05:07,129
named key and holds the value of the key

128
00:05:07,129 --> 00:05:08,990
and the second one is Val which also

129
00:05:08,990 --> 00:05:11,210
value so the value can be anything can

130
00:05:11,210 --> 00:05:12,680
be string and object anything is that's

131
00:05:12,680 --> 00:05:15,289
chasing zero realizable and saying goes

132
00:05:15,289 --> 00:05:19,009
actually for the key um so what's good

133
00:05:19,009 --> 00:05:20,629
what's bad about this status you can

134
00:05:20,629 --> 00:05:21,800
already guess it's not going to scale

135
00:05:21,800 --> 00:05:23,509
forever that's going to you're going to

136
00:05:23,509 --> 00:05:24,379
hit the point we're loading your

137
00:05:24,379 --> 00:05:25,719
database is going to take forever

138
00:05:25,719 --> 00:05:27,889
because and you cannot really seek to a

139
00:05:27,889 --> 00:05:30,500
specific point so that already limits

140
00:05:30,500 --> 00:05:32,210
the scope of this project drastically

141
00:05:32,210 --> 00:05:34,520
but at the same time if you're starting

142
00:05:34,520 --> 00:05:36,409
out using in technology like this can

143
00:05:36,409 --> 00:05:38,330
you imagine a sweeter database format

144
00:05:38,330 --> 00:05:40,460
for eventually migrating to something

145
00:05:40,460 --> 00:05:42,139
else I think it's really easy you could

146
00:05:42,139 --> 00:05:44,389
probably do it in a bash script so that

147
00:05:44,389 --> 00:05:46,669
that's a design choice and I'm pretty

148
00:05:46,669 --> 00:05:47,960
happy with it because I think it works

149
00:05:47,960 --> 00:05:49,969
well for what I'm trying to do with it

150
00:05:49,969 --> 00:05:52,039
and also works well for bigger systems

151
00:05:52,039 --> 00:05:53,990
with bigger goals like gratis they're

152
00:05:53,990 --> 00:05:55,250
doing the same thing they have a more

153
00:05:55,250 --> 00:05:57,830
optimized data format but also in depend

154
00:05:57,830 --> 00:06:00,199
only luck with no indexing whatsoever as

155
00:06:00,199 --> 00:06:03,500
far as far as I know and this was

156
00:06:03,500 --> 00:06:04,819
probably the most interesting choice

157
00:06:04,819 --> 00:06:06,439
there's no networking this is an

158
00:06:06,439 --> 00:06:09,139
embedded database which has downsides

159
00:06:09,139 --> 00:06:11,270
but it also has a lot of upsides as you

160
00:06:11,270 --> 00:06:12,589
can see it's really easy to get started

161
00:06:12,589 --> 00:06:15,439
you basically install the code you get

162
00:06:15,439 --> 00:06:17,029
this little module called dirty which

163
00:06:17,029 --> 00:06:19,219
you can require and it returns a

164
00:06:19,219 --> 00:06:21,379
function which actually basically some

165
00:06:21,379 --> 00:06:22,879
functions that runs the constructor of

166
00:06:22,879 --> 00:06:24,830
it and so the first parameter pests

167
00:06:24,830 --> 00:06:28,069
entered is the name of the database file

168
00:06:28,069 --> 00:06:30,889
so do you want to access and there you

169
00:06:30,889 --> 00:06:32,689
go you have the database object you

170
00:06:32,689 --> 00:06:34,189
can start setting he's on it getting

171
00:06:34,189 --> 00:06:36,499
keys on it and a lot of pewter wizard

172
00:06:36,499 --> 00:06:38,389
first of all you don't need to write a

173
00:06:38,389 --> 00:06:40,369
client library every new database that

174
00:06:40,369 --> 00:06:42,139
comes out basically requires people to

175
00:06:42,139 --> 00:06:43,459
go out and write new client libraries

176
00:06:43,459 --> 00:06:45,409
would be it read as couchdb which is

177
00:06:45,409 --> 00:06:48,469
smart they're using HTTP or mongols they

178
00:06:48,469 --> 00:06:50,089
all need native clients that's a lot of

179
00:06:50,089 --> 00:06:51,709
code that needs to be written on the

180
00:06:51,709 --> 00:06:54,049
server side to support the clients

181
00:06:54,049 --> 00:06:56,209
asking questions and delivering those

182
00:06:56,209 --> 00:06:57,860
results but it's also a lot of work on

183
00:06:57,860 --> 00:06:59,719
the client side and every other language

184
00:06:59,719 --> 00:07:01,369
that you want to use it in it's not

185
00:07:01,369 --> 00:07:03,439
going to work so i had to benefit

186
00:07:03,439 --> 00:07:07,159
there's no delay on setting and getting

187
00:07:07,159 --> 00:07:10,729
keys and there's also no issues with

188
00:07:10,729 --> 00:07:12,259
networking in general no connection

189
00:07:12,259 --> 00:07:14,479
issues you don't need to also indicate

190
00:07:14,479 --> 00:07:16,129
because your file system issue

191
00:07:16,129 --> 00:07:17,719
permission system you build on top of

192
00:07:17,719 --> 00:07:22,489
that um yeah here's another example that

193
00:07:22,489 --> 00:07:24,379
shows how easy it is to use you

194
00:07:24,379 --> 00:07:27,289
basically set a key give it a value and

195
00:07:27,289 --> 00:07:28,909
then once you have a bunch of keys in

196
00:07:28,909 --> 00:07:31,459
your database you can use DB for each to

197
00:07:31,459 --> 00:07:32,929
iterate over them and that's basically

198
00:07:32,929 --> 00:07:34,639
how you queried there's no filter

199
00:07:34,639 --> 00:07:36,889
function per se but you could create an

200
00:07:36,889 --> 00:07:39,619
array above so for each line which

201
00:07:39,619 --> 00:07:41,149
basically captures all the data that you

202
00:07:41,149 --> 00:07:43,519
hit a right over and that makes it

203
00:07:43,519 --> 00:07:45,409
really minimal you've already seen most

204
00:07:45,409 --> 00:07:47,659
of the API on this project that because

205
00:07:47,659 --> 00:07:48,769
i can type them in and change them

206
00:07:48,769 --> 00:07:50,809
however i want them and a lot of people

207
00:07:50,809 --> 00:07:52,819
doing benchmarks do that but what's

208
00:07:52,819 --> 00:07:54,499
actually even worse as they try to

209
00:07:54,499 --> 00:07:56,509
publish benchmarks of benchmarking

210
00:07:56,509 --> 00:07:58,999
against other databases and it is really

211
00:07:58,999 --> 00:08:00,699
difficult to get this right i think yan

212
00:08:00,699 --> 00:08:02,929
who's not here has a really nice i'll

213
00:08:02,929 --> 00:08:05,179
take around it most of these benchmarks

214
00:08:05,179 --> 00:08:06,619
that you see will compare apples to

215
00:08:06,619 --> 00:08:08,659
oranges one database might just a whole

216
00:08:08,659 --> 00:08:10,159
lot more an incident has it has a whole

217
00:08:10,159 --> 00:08:11,869
lot more guarantees and what's happening

218
00:08:11,869 --> 00:08:14,149
is in another so benchmarks are really

219
00:08:14,149 --> 00:08:15,769
tricky and unless what you want to spend

220
00:08:15,769 --> 00:08:17,389
as much time as writing your project

221
00:08:17,389 --> 00:08:18,949
takes and doing the benchmarks properly

222
00:08:18,949 --> 00:08:20,149
and also getting to know all your

223
00:08:20,149 --> 00:08:23,269
competing databases you shouldn't do the

224
00:08:23,269 --> 00:08:24,800
comparisons and draw conclusions from it

225
00:08:24,800 --> 00:08:27,529
you should if anything look at the

226
00:08:27,529 --> 00:08:28,879
underlying algorithms and see if they're

227
00:08:28,879 --> 00:08:31,809
suitable for your problem but anyway

228
00:08:31,809 --> 00:08:34,399
standalone it has a pretty good

229
00:08:34,399 --> 00:08:36,050
performance if you call a get operation

230
00:08:36,050 --> 00:08:39,259
you get 50 megahertz which is 50 million

231
00:08:39,259 --> 00:08:42,490
get operations per second out of it I

232
00:08:42,490 --> 00:08:44,689
don't know why you would need that but

233
00:08:44,689 --> 00:08:45,720
where this interests

234
00:08:45,720 --> 00:08:47,720
since its v8 primitives underlying

235
00:08:47,720 --> 00:08:50,610
object types in the v8 engine are fast

236
00:08:50,610 --> 00:08:52,079
enough to pull that kind of stuff off I

237
00:08:52,079 --> 00:08:54,209
mean I have to be v8 number at the

238
00:08:54,209 --> 00:08:57,839
bottom it's like 160 to 170 megahertz to

239
00:08:57,839 --> 00:09:00,540
get keys from an object and I think that

240
00:09:00,540 --> 00:09:02,790
makes it really fast engine and maybe

241
00:09:02,790 --> 00:09:04,410
fast enough to write bigger systems and

242
00:09:04,410 --> 00:09:07,740
this one is because once you start doing

243
00:09:07,740 --> 00:09:09,540
more algorithms more iterating over data

244
00:09:09,540 --> 00:09:12,509
in more complex database that's going to

245
00:09:12,509 --> 00:09:13,920
be a bottleneck if you're really crazy

246
00:09:13,920 --> 00:09:15,620
enough to write a database in JavaScript

247
00:09:15,620 --> 00:09:19,709
if you write an season well you almost

248
00:09:19,709 --> 00:09:22,850
writing native processor comments

249
00:09:22,850 --> 00:09:24,839
there's not a whole lot you need to

250
00:09:24,839 --> 00:09:26,310
optimize anymore but here you need to be

251
00:09:26,310 --> 00:09:27,810
careful that your bottom like is not the

252
00:09:27,810 --> 00:09:32,889
language and it may very well might be

253
00:09:32,899 --> 00:09:36,120
then the set operations also very fast

254
00:09:36,120 --> 00:09:38,040
not quite as fast that it can run at

255
00:09:38,040 --> 00:09:43,949
five megahertz v8 that's 12 megahertz

256
00:09:43,949 --> 00:09:45,899
the performance is pretty much lost

257
00:09:45,899 --> 00:09:47,360
because I need to do two operations

258
00:09:47,360 --> 00:09:49,529
when's that is called I need to set the

259
00:09:49,529 --> 00:09:51,389
object key of the key value pairs that

260
00:09:51,389 --> 00:09:53,339
I'm writing on the object and then I

261
00:09:53,339 --> 00:09:55,199
also have an array which is basically a

262
00:09:55,199 --> 00:09:57,180
queue of all the keys that still need to

263
00:09:57,180 --> 00:09:59,189
be written to disk so I push into that

264
00:09:59,189 --> 00:10:01,290
array and I sat on this object so these

265
00:10:01,290 --> 00:10:02,850
two operation is what cuts the

266
00:10:02,850 --> 00:10:06,180
performance in half but then again find

267
00:10:06,180 --> 00:10:07,649
me this that can do five million inserts

268
00:10:07,649 --> 00:10:10,410
a second I it looks pretty hopeful that

269
00:10:10,410 --> 00:10:12,660
the language primitive here is not the

270
00:10:12,660 --> 00:10:19,829
bottleneck for pulling this off now

271
00:10:19,829 --> 00:10:22,170
maybe more realistic or interesting way

272
00:10:22,170 --> 00:10:23,339
to look at it when you're actually

273
00:10:23,339 --> 00:10:25,769
flushing to disk because obviously the

274
00:10:25,769 --> 00:10:27,389
numbers before I'm not flashing to this

275
00:10:27,389 --> 00:10:29,430
was basically putting stuff in as fast

276
00:10:29,430 --> 00:10:32,009
as possible and then well secure for the

277
00:10:32,009 --> 00:10:34,259
disk right would flash eventually but

278
00:10:34,259 --> 00:10:36,269
these are actually numbers for flushing

279
00:10:36,269 --> 00:10:38,850
items to disk and if you're using pure

280
00:10:38,850 --> 00:10:41,790
numbers as a key in value pairs you can

281
00:10:41,790 --> 00:10:44,850
do about 200,000 these chasing records

282
00:10:44,850 --> 00:10:48,600
the second I think in my set up by

283
00:10:48,600 --> 00:10:50,370
benchmarks this machine though your

284
00:10:50,370 --> 00:10:53,639
numbers may vary a few times but

285
00:10:53,639 --> 00:10:55,790
probably not an order of magnitude

286
00:10:55,790 --> 00:10:58,739
the main bottleneck is serializing to

287
00:10:58,739 --> 00:11:00,839
chase me and well on the other way also

288
00:11:00,839 --> 00:11:04,980
deserialising from it another number

289
00:11:04,980 --> 00:11:07,110
next to it is if instead of writing

290
00:11:07,110 --> 00:11:09,119
Tristan number as the key value pair but

291
00:11:09,119 --> 00:11:13,129
you use a 256 byte string you get around

292
00:11:13,129 --> 00:11:18,779
70,000 records per second so what I

293
00:11:18,779 --> 00:11:20,249
really like about these numbers is that

294
00:11:20,249 --> 00:11:22,799
it really looks comparable to what other

295
00:11:22,799 --> 00:11:25,259
systems that are performing similar

296
00:11:25,259 --> 00:11:29,069
operations can do like read us basically

297
00:11:29,069 --> 00:11:30,779
when you go through the network they

298
00:11:30,779 --> 00:11:33,029
have benchmarks of being able to set and

299
00:11:33,029 --> 00:11:34,709
get around a hundred thousand keys a

300
00:11:34,709 --> 00:11:37,949
second and so you can tell that memory

301
00:11:37,949 --> 00:11:40,290
access is so so much faster network is

302
00:11:40,290 --> 00:11:41,999
actually slowing red ass down while red

303
00:11:41,999 --> 00:11:43,529
is a setting and getting keys it's

304
00:11:43,529 --> 00:11:46,459
basically idled processor time it cannot

305
00:11:46,459 --> 00:11:48,869
the network is not fast enough to fill

306
00:11:48,869 --> 00:11:51,389
out your cpu speed which i guess you

307
00:11:51,389 --> 00:11:52,739
should know but that's really

308
00:11:52,739 --> 00:11:53,639
interesting thing to know about

309
00:11:53,639 --> 00:11:55,829
databases like some of the stuff is just

310
00:11:55,829 --> 00:11:58,259
loss of physics I mean your light is

311
00:11:58,259 --> 00:12:00,720
only going to go to so far or so fast

312
00:12:00,720 --> 00:12:03,149
and your electricity and there's nothing

313
00:12:03,149 --> 00:12:04,860
else you can do beyond set so actually

314
00:12:04,860 --> 00:12:06,600
the design choice of embedding a

315
00:12:06,600 --> 00:12:08,730
database into your process where you can

316
00:12:08,730 --> 00:12:10,110
share memory no inter process

317
00:12:10,110 --> 00:12:12,149
communication your networking might be

318
00:12:12,149 --> 00:12:17,829
an interesting one for certain stuff oh

319
00:12:17,839 --> 00:12:22,079
I had one number I forget basically when

320
00:12:22,079 --> 00:12:24,360
I runs the same operations without

321
00:12:24,360 --> 00:12:27,059
chasing serialization the numbers change

322
00:12:27,059 --> 00:12:31,679
from left to 2500 hurts and to 400 two

323
00:12:31,679 --> 00:12:34,079
kilohertz sorry not hurts kilohertz on

324
00:12:34,079 --> 00:12:35,879
the other side so its adjacency

325
00:12:35,879 --> 00:12:38,579
realizing is holding it up quite a bit

326
00:12:38,579 --> 00:12:42,569
like 10 times and that's a for each loop

327
00:12:42,569 --> 00:12:45,629
this basically is used to iterate or

328
00:12:45,629 --> 00:12:47,790
reserve all the keys and all the values

329
00:12:47,790 --> 00:12:50,100
in the database that's probably the

330
00:12:50,100 --> 00:12:51,749
biggest bottleneck right now it could be

331
00:12:51,749 --> 00:12:55,559
much faster busy what it does it's doing

332
00:12:55,559 --> 00:12:57,179
a four bar in and then calling a

333
00:12:57,179 --> 00:12:59,189
function on every object that it meets

334
00:12:59,189 --> 00:13:02,459
and that is sub-optimal because first of

335
00:13:02,459 --> 00:13:04,919
all it's blocking so while you're eating

336
00:13:04,919 --> 00:13:06,360
over your data set you're not doing

337
00:13:06,360 --> 00:13:08,309
anything else and second of all you

338
00:13:08,309 --> 00:13:09,030
can't stop in

339
00:13:09,030 --> 00:13:11,160
between for war in is basically

340
00:13:11,160 --> 00:13:13,200
everything or nothing so one of the

341
00:13:13,200 --> 00:13:14,850
things I'm probably still going to do is

342
00:13:14,850 --> 00:13:17,910
whenever a key is being set and I'm

343
00:13:17,910 --> 00:13:19,530
going to maintain an additional area

344
00:13:19,530 --> 00:13:22,230
which lists all the keys and then I can

345
00:13:22,230 --> 00:13:25,020
iterate over all the keys much faster

346
00:13:25,020 --> 00:13:26,790
and I can also choose to only partially

347
00:13:26,790 --> 00:13:29,250
iterate over the keys that i have that

348
00:13:29,250 --> 00:13:30,720
will make the set performance a little

349
00:13:30,720 --> 00:13:34,770
bit slower probably cut it in half again

350
00:13:34,770 --> 00:13:37,260
but at the same time for each can become

351
00:13:37,260 --> 00:13:39,150
non blocking and can become much faster

352
00:13:39,150 --> 00:13:41,280
but I didn't have the time to do it yet

353
00:13:41,280 --> 00:13:43,230
it makes implementation a little bit

354
00:13:43,230 --> 00:13:46,560
more difficult oh and yet as you can

355
00:13:46,560 --> 00:13:49,140
already see this implementation hits the

356
00:13:49,140 --> 00:13:51,390
wall at some point my design goal with

357
00:13:51,390 --> 00:13:52,650
this database is to make wonderful

358
00:13:52,650 --> 00:13:54,600
database for less than a million records

359
00:13:54,600 --> 00:13:56,850
so basically if you're new to note I

360
00:13:56,850 --> 00:13:58,230
mean how many people have played with

361
00:13:58,230 --> 00:14:01,680
node yet in this room all right not

362
00:14:01,680 --> 00:14:03,600
everybody so if you're new to note and

363
00:14:03,600 --> 00:14:04,980
you just want to get started as quick as

364
00:14:04,980 --> 00:14:06,720
possible and get like a little type

365
00:14:06,720 --> 00:14:09,300
project going I want this to be the

366
00:14:09,300 --> 00:14:11,790
database of choice that is easy swelled

367
00:14:11,790 --> 00:14:13,650
in that will work and you can even if

368
00:14:13,650 --> 00:14:15,390
your little project takes off it can

369
00:14:15,390 --> 00:14:16,980
even scare for a little while I mean a

370
00:14:16,980 --> 00:14:18,420
lot of applications are say i would say

371
00:14:18,420 --> 00:14:20,160
i don't know more than half of the

372
00:14:20,160 --> 00:14:21,390
applications that run on the web right

373
00:14:21,390 --> 00:14:22,980
now will never need more than 1 million

374
00:14:22,980 --> 00:14:24,870
records it's only it's really successful

375
00:14:24,870 --> 00:14:26,520
once and we are lucky when we get to see

376
00:14:26,520 --> 00:14:28,710
scaling problems but i think this

377
00:14:28,710 --> 00:14:30,240
database is really easy to migrate from

378
00:14:30,240 --> 00:14:31,650
because it doesn't do anything special

379
00:14:31,650 --> 00:14:33,930
that other databases can do but it does

380
00:14:33,930 --> 00:14:36,420
it really fast for the lesson 1 million

381
00:14:36,420 --> 00:14:40,350
record market but yeah basically after

382
00:14:40,350 --> 00:14:42,510
that you're hitting the wall I mean

383
00:14:42,510 --> 00:14:44,520
you're for each new biz clocking I might

384
00:14:44,520 --> 00:14:46,350
fix it but your queries are going to

385
00:14:46,350 --> 00:14:47,700
take a very long time iterating through

386
00:14:47,700 --> 00:14:49,380
all of that you're going to have to

387
00:14:49,380 --> 00:14:51,420
start in doing indexes yourself

388
00:14:51,420 --> 00:14:53,460
optimizations yourself which might be

389
00:14:53,460 --> 00:14:55,410
fun you you might be able to push this

390
00:14:55,410 --> 00:14:57,870
much further but at the same time not

391
00:14:57,870 --> 00:14:58,920
everybody wants to write its own

392
00:14:58,920 --> 00:15:01,500
database code but I think that's the

393
00:15:01,500 --> 00:15:05,490
next part I think maybe noches has the

394
00:15:05,490 --> 00:15:07,170
possibility of writing something like

395
00:15:07,170 --> 00:15:08,850
couch to be in it it has some non

396
00:15:08,850 --> 00:15:10,290
locking I oh it has excellent networking

397
00:15:10,290 --> 00:15:13,140
and it has a lot of other really good

398
00:15:13,140 --> 00:15:15,210
parts in the stack and very fast

399
00:15:15,210 --> 00:15:17,550
interpreter so what's the rest of my

400
00:15:17,550 --> 00:15:19,530
talk is but looking into the

401
00:15:19,530 --> 00:15:21,630
possibilities of actually taking note at

402
00:15:21,630 --> 00:15:22,610
building a more

403
00:15:22,610 --> 00:15:24,920
advanced system out of it send dirty

404
00:15:24,920 --> 00:15:27,260
dirty is just my interest in building

405
00:15:27,260 --> 00:15:28,579
such systems but I wouldn't have the

406
00:15:28,579 --> 00:15:30,980
time to build something compatible to

407
00:15:30,980 --> 00:15:33,410
are compatible comparable to CouchDB

408
00:15:33,410 --> 00:15:35,060
aratus that's going to be a big laugh

409
00:15:35,060 --> 00:15:37,279
effort but what I'm exploring is it's

410
00:15:37,279 --> 00:15:39,440
possible that's the v8 engine allow you

411
00:15:39,440 --> 00:15:41,769
to do it does not allow it to do it

412
00:15:41,769 --> 00:15:44,089
let's have a look again sir it's a

413
00:15:44,089 --> 00:15:45,740
problem we up against that's the

414
00:15:45,740 --> 00:15:47,300
internet traffic cross over time I

415
00:15:47,300 --> 00:15:50,860
started from 2000 and as you can see

416
00:15:50,860 --> 00:15:52,940
we're going to need to think of

417
00:15:52,940 --> 00:15:55,040
solutions for the data problem very

418
00:15:55,040 --> 00:15:56,480
quickly because the data is growing

419
00:15:56,480 --> 00:16:01,040
exponentially the number you just saw is

420
00:16:01,040 --> 00:16:04,070
there's 22 exabyte per month every month

421
00:16:04,070 --> 00:16:05,269
going through the internet right now

422
00:16:05,269 --> 00:16:09,230
it's 22 billion gigabytes I had no idea

423
00:16:09,230 --> 00:16:11,390
what that actually means but one exabyte

424
00:16:11,390 --> 00:16:14,180
is about 50,000 years of DVD quality

425
00:16:14,180 --> 00:16:16,790
video I had no idea so much porn exists

426
00:16:16,790 --> 00:16:20,230
but apparently apparently it does and

427
00:16:20,230 --> 00:16:22,790
yeah ninety percent of the internet

428
00:16:22,790 --> 00:16:25,279
traffic in 2013 is projected to be video

429
00:16:25,279 --> 00:16:28,100
so not all of its going to be data data

430
00:16:28,100 --> 00:16:29,390
in terms of what we still on a database

431
00:16:29,390 --> 00:16:33,290
but it's still going to be a lot so what

432
00:16:33,290 --> 00:16:34,579
is one of the things that I really like

433
00:16:34,579 --> 00:16:36,410
about my little key value store said

434
00:16:36,410 --> 00:16:38,209
might make an impact on solving this

435
00:16:38,209 --> 00:16:40,339
kind of data problems I think one of the

436
00:16:40,339 --> 00:16:43,190
things is flexible guarantees with most

437
00:16:43,190 --> 00:16:45,560
databases you make one big trade off

438
00:16:45,560 --> 00:16:47,480
most of the time either you're

439
00:16:47,480 --> 00:16:49,399
guaranteed said when the database says

440
00:16:49,399 --> 00:16:50,779
the record is written it's really on

441
00:16:50,779 --> 00:16:53,240
disk and it will stay there or it says

442
00:16:53,240 --> 00:16:55,070
well I has it on my list of things to do

443
00:16:55,070 --> 00:16:56,779
and I'll eventually get to it but if my

444
00:16:56,779 --> 00:16:58,279
power is being cut off the record is

445
00:16:58,279 --> 00:17:01,100
lost forever and has a big problem

446
00:17:01,100 --> 00:17:03,079
because I think a lot of applications

447
00:17:03,079 --> 00:17:05,329
actually have mixed needs they have data

448
00:17:05,329 --> 00:17:07,490
that needs to be really transactional

449
00:17:07,490 --> 00:17:09,110
you say it's stored it needs to be

450
00:17:09,110 --> 00:17:10,579
stored and a lot of other stuff you

451
00:17:10,579 --> 00:17:11,990
don't care if you lose a record here

452
00:17:11,990 --> 00:17:14,720
there and what you can do with nodes

453
00:17:14,720 --> 00:17:17,390
thanks to non-blocking i/o is you can

454
00:17:17,390 --> 00:17:20,809
set your key value pair and as soon as

455
00:17:20,809 --> 00:17:21,949
you said it it's written to the object

456
00:17:21,949 --> 00:17:23,990
you can access it again that's the

457
00:17:23,990 --> 00:17:26,150
console log record written to memory

458
00:17:26,150 --> 00:17:28,790
down there and then you get a call back

459
00:17:28,790 --> 00:17:30,470
when it's actually flushed to disk so

460
00:17:30,470 --> 00:17:32,660
you can get both events you can get okay

461
00:17:32,660 --> 00:17:34,400
it's ready to be worked with part of a

462
00:17:34,400 --> 00:17:35,130
query

463
00:17:35,130 --> 00:17:36,990
and it's ready to this so if you reboot

464
00:17:36,990 --> 00:17:40,560
me it will still be there I think that's

465
00:17:40,560 --> 00:17:43,170
really interesting concepts that is

466
00:17:43,170 --> 00:17:44,970
would be really difficult to pull off

467
00:17:44,970 --> 00:17:47,190
with any other embedded database

468
00:17:47,190 --> 00:17:53,880
technology well by the way what I also

469
00:17:53,880 --> 00:17:55,140
wanted to talk about how this actually

470
00:17:55,140 --> 00:17:59,430
works internally so right mechanism of

471
00:17:59,430 --> 00:18:01,410
dirty works that whenever a record has

472
00:18:01,410 --> 00:18:02,790
written it starts flashing it to disk

473
00:18:02,790 --> 00:18:04,530
right away and then if there's more

474
00:18:04,530 --> 00:18:06,660
records written with the set function

475
00:18:06,660 --> 00:18:09,000
and the disk is still busy flushing the

476
00:18:09,000 --> 00:18:11,220
first record it cues them all up so

477
00:18:11,220 --> 00:18:14,010
basically the when the first record is

478
00:18:14,010 --> 00:18:15,570
written to disk it looks at the back

479
00:18:15,570 --> 00:18:17,820
loss lock of maybe 1,000 items and says

480
00:18:17,820 --> 00:18:19,260
okay now I'm taking all of these

481
00:18:19,260 --> 00:18:20,850
chunking them to get them to long

482
00:18:20,850 --> 00:18:22,950
tracing string and writes that so all

483
00:18:22,950 --> 00:18:24,440
your rights are pretty much instantly

484
00:18:24,440 --> 00:18:27,900
which with red us I think depend only

485
00:18:27,900 --> 00:18:30,090
lock the I don't know I think they have

486
00:18:30,090 --> 00:18:31,920
two mechanisms now but I think one of

487
00:18:31,920 --> 00:18:34,080
them was to basically do it every one

488
00:18:34,080 --> 00:18:35,730
second or three seconds or something

489
00:18:35,730 --> 00:18:38,550
which you don't really have to you can

490
00:18:38,550 --> 00:18:40,650
use a queue when the disk is busy or

491
00:18:40,650 --> 00:18:42,780
write to disk when it's doing nothing I

492
00:18:42,780 --> 00:18:46,530
think this say have field change yeah

493
00:18:46,530 --> 00:18:50,450
okay so that let get it better um

494
00:18:50,450 --> 00:18:53,610
alright memory and disk high prints I

495
00:18:53,610 --> 00:18:55,560
think one thing I could really imagine

496
00:18:55,560 --> 00:18:59,100
this kind of databases to do is to be

497
00:18:59,100 --> 00:19:00,420
mixture of a database and your

498
00:19:00,420 --> 00:19:03,810
application so you might have some basic

499
00:19:03,810 --> 00:19:06,270
libraries to do data solve data kind of

500
00:19:06,270 --> 00:19:08,220
general data kind of problems for you

501
00:19:08,220 --> 00:19:09,840
but then you can also build memcache

502
00:19:09,840 --> 00:19:11,550
basically into it you don't have to

503
00:19:11,550 --> 00:19:14,280
clear your database and query an awesome

504
00:19:14,280 --> 00:19:15,960
memcached instance just to keep

505
00:19:15,960 --> 00:19:17,760
something very fresh and hot you can

506
00:19:17,760 --> 00:19:19,710
actually have your database do the

507
00:19:19,710 --> 00:19:21,750
caching itself and you can't really do

508
00:19:21,750 --> 00:19:23,250
that with other databases that easily

509
00:19:23,250 --> 00:19:25,020
because as a databases they don't know

510
00:19:25,020 --> 00:19:27,480
about your data but if you use about

511
00:19:27,480 --> 00:19:30,770
your specific knowledge about your data

512
00:19:30,770 --> 00:19:33,810
replication I think you could build up

513
00:19:33,810 --> 00:19:36,030
really nicely replicating data base with

514
00:19:36,030 --> 00:19:38,610
no chairs just because it's perfect for

515
00:19:38,610 --> 00:19:40,260
streaming I mean streaming is one of the

516
00:19:40,260 --> 00:19:42,570
main points of why node exists every

517
00:19:42,570 --> 00:19:44,490
other that technology kind of was fast

518
00:19:44,490 --> 00:19:47,280
before and was kind of usable but none

519
00:19:47,280 --> 00:19:48,640
of them made it really easy to

520
00:19:48,640 --> 00:19:50,080
stream and still do something else at

521
00:19:50,080 --> 00:19:52,000
the same time request responses where

522
00:19:52,000 --> 00:19:54,550
looked at at a singular event you get a

523
00:19:54,550 --> 00:19:56,230
request he process it is that a response

524
00:19:56,230 --> 00:19:58,180
but there's nothing in between with note

525
00:19:58,180 --> 00:20:01,600
streaming is really easy and also

526
00:20:01,600 --> 00:20:03,850
another thing that's really easy with in

527
00:20:03,850 --> 00:20:06,070
regards to that it snowed could hold an

528
00:20:06,070 --> 00:20:09,670
incoming connection if a replicated key

529
00:20:09,670 --> 00:20:12,760
or if a not yet replicated key is being

530
00:20:12,760 --> 00:20:14,950
requested what that means is some of

531
00:20:14,950 --> 00:20:16,300
your clients rights to one of your

532
00:20:16,300 --> 00:20:18,430
database servers in the cluster and then

533
00:20:18,430 --> 00:20:20,290
another client goes and asks another

534
00:20:20,290 --> 00:20:22,450
instance of the same database class sir

535
00:20:22,450 --> 00:20:24,070
for that key but the key has not

536
00:20:24,070 --> 00:20:26,080
replicated yet well note could actually

537
00:20:26,080 --> 00:20:29,140
say if I get a request in for keys that

538
00:20:29,140 --> 00:20:30,970
does not exist I wait for three seconds

539
00:20:30,970 --> 00:20:32,890
if it still comes in my answers a

540
00:20:32,890 --> 00:20:35,080
request as soon as I can meanwhile I let

541
00:20:35,080 --> 00:20:36,670
the connection hang I think said

542
00:20:36,670 --> 00:20:38,530
something where you could build really

543
00:20:38,530 --> 00:20:40,480
small systems that don't have to take

544
00:20:40,480 --> 00:20:42,010
the eventual consistency trade-off

545
00:20:42,010 --> 00:20:44,080
there's a lot of our systems take just

546
00:20:44,080 --> 00:20:46,120
by saying yeah we'll do eventual

547
00:20:46,120 --> 00:20:49,210
consistency but we can also hold a query

548
00:20:49,210 --> 00:20:51,040
for three seconds if we have a hopes

549
00:20:51,040 --> 00:20:53,160
that it's still being successfully

550
00:20:53,160 --> 00:20:57,730
executed in three seconds later web

551
00:20:57,730 --> 00:21:00,700
services you could also use no chess to

552
00:21:00,700 --> 00:21:03,100
act as a proxy for different database

553
00:21:03,100 --> 00:21:05,620
beckons because I don't believe one

554
00:21:05,620 --> 00:21:07,120
database is ever going to solve all your

555
00:21:07,120 --> 00:21:08,440
problems and fix everything especially

556
00:21:08,440 --> 00:21:10,630
when you go to a certain scale but it

557
00:21:10,630 --> 00:21:11,890
would be really nice to have a unified

558
00:21:11,890 --> 00:21:13,480
interface for your business questions

559
00:21:13,480 --> 00:21:15,310
that your your clients are asking and

560
00:21:15,310 --> 00:21:17,110
your cloud that's going to answer and I

561
00:21:17,110 --> 00:21:18,760
think no chairs could make a really nice

562
00:21:18,760 --> 00:21:21,130
clue in between maybe some oh no

563
00:21:21,130 --> 00:21:23,140
database or maybe not talking to a couch

564
00:21:23,140 --> 00:21:24,910
to be talking to rat us back end and

565
00:21:24,910 --> 00:21:27,070
just shifting this data together but

566
00:21:27,070 --> 00:21:28,120
also knowing about your business

567
00:21:28,120 --> 00:21:29,890
problems combining the data properly

568
00:21:29,890 --> 00:21:32,020
doing good cashing it kind of makes it

569
00:21:32,020 --> 00:21:34,540
act as a layer in between and you could

570
00:21:34,540 --> 00:21:36,670
even like query third-party services if

571
00:21:36,670 --> 00:21:37,840
you're building something really big

572
00:21:37,840 --> 00:21:39,010
that depends on a bunch of other

573
00:21:39,010 --> 00:21:40,930
business processes somewhere else your

574
00:21:40,930 --> 00:21:42,790
database could directly take that into

575
00:21:42,790 --> 00:21:47,140
account as well um yeah so that's the

576
00:21:47,140 --> 00:21:49,060
basic thing and I think there will be a

577
00:21:49,060 --> 00:21:51,760
lot of questions about this kind of

578
00:21:51,760 --> 00:21:53,770
crazy experiment I hope so we're period

579
00:21:53,770 --> 00:21:55,720
good idea soon but i'm also open to hear

580
00:21:55,720 --> 00:22:19,940
any that's a really bad ones

581
00:22:19,950 --> 00:22:24,910
okay yeah you just put an if statement

582
00:22:24,910 --> 00:22:26,260
and say if I under such a question

583
00:22:26,260 --> 00:22:47,410
properly if DD

584
00:22:47,420 --> 00:22:49,590
basically says when you get and set

585
00:22:49,590 --> 00:22:52,470
there's no I Oh happening with with

586
00:22:52,470 --> 00:22:54,150
dirty it's clearly in memory and the

587
00:22:54,150 --> 00:22:57,360
only iOS that happens it's actually flat

588
00:22:57,360 --> 00:23:01,480
flashing the record to disk eventually

589
00:23:01,490 --> 00:23:03,660
well there's no network interface you

590
00:23:03,660 --> 00:23:04,890
have no other way of getting at the

591
00:23:04,890 --> 00:23:11,960
database from the outside right so baby

592
00:23:11,960 --> 00:23:21,390
yep no i think i had i didn't have 50

593
00:23:21,390 --> 00:23:22,680
million records in the database because

594
00:23:22,680 --> 00:23:25,440
there's a problem with v8 right now be 8

595
00:23:25,440 --> 00:23:27,860
caps you at one gigabyte of heap usage

596
00:23:27,860 --> 00:23:30,150
one gigabyte is plenty to store 1

597
00:23:30,150 --> 00:23:32,760
million records memory usage on sisses 1

598
00:23:32,760 --> 00:23:34,230
million keys have an overhead of that

599
00:23:34,230 --> 00:23:37,320
around 27 megabytes that's if you choose

600
00:23:37,320 --> 00:23:39,720
store numbers as key value pairs and so

601
00:23:39,720 --> 00:23:41,220
the rest is going to be filled up by

602
00:23:41,220 --> 00:23:43,020
your data whatever lengths you keys are

603
00:23:43,020 --> 00:23:45,180
going to happen to your data but that

604
00:23:45,180 --> 00:23:47,490
get benchmark was also just 1 million

605
00:23:47,490 --> 00:23:50,010
maybe 1 or 10 million records and the

606
00:23:50,010 --> 00:23:52,740
keys and sibelius where numbers so that

607
00:23:52,740 --> 00:23:54,510
was the only thing going on I can

608
00:23:54,510 --> 00:24:01,820
actually show the code for the benchmark

609
00:24:01,830 --> 00:24:07,960
yeah but the main point of the benchmark

610
00:24:07,960 --> 00:24:10,630
was to see okay you can get a key which

611
00:24:10,630 --> 00:24:12,190
is cutting performance in half at this

612
00:24:12,190 --> 00:24:13,600
speed they're still pretty accessible

613
00:24:13,600 --> 00:24:15,610
acceptable for having so many function

614
00:24:15,610 --> 00:24:17,320
calls I mean the 10 million function

615
00:24:17,320 --> 00:24:20,170
colt so that's pretty good and one

616
00:24:20,170 --> 00:24:21,760
lesson maybe to be learned from that as

617
00:24:21,760 --> 00:24:23,380
if you're writing note code was a ton of

618
00:24:23,380 --> 00:24:25,180
callbacks and you're like and all those

619
00:24:25,180 --> 00:24:26,380
functions are going to slow my coat down

620
00:24:26,380 --> 00:24:28,600
now you'll need a lot of functions to do

621
00:24:28,600 --> 00:24:36,520
that a lot of function calls yep what

622
00:24:36,520 --> 00:24:44,020
function ya know for each it's not the

623
00:24:44,020 --> 00:24:51,700
native JavaScript for each it's yeah I

624
00:24:51,700 --> 00:24:53,110
think that was 1 million records and

625
00:24:53,110 --> 00:24:55,990
it's basically using for bar in which

626
00:24:55,990 --> 00:24:58,720
i'm going to replace with the array list

627
00:24:58,720 --> 00:25:05,490
of keys i think yeah

628
00:25:05,500 --> 00:25:16,420
oh yeah you shouldn't use you shouldn't

629
00:25:16,420 --> 00:25:18,400
try to evaluate this against Redis

630
00:25:18,400 --> 00:25:19,810
unless you're planning to have a very

631
00:25:19,810 --> 00:25:23,710
small project yeah but no it's not

632
00:25:23,710 --> 00:25:25,180
there's no query abstractions because

633
00:25:25,180 --> 00:25:27,100
all of that stuff I think it's the main

634
00:25:27,100 --> 00:25:28,600
thing that databases out to get wrong

635
00:25:28,600 --> 00:25:30,310
but because it's a hardest part and

636
00:25:30,310 --> 00:25:33,850
everybody likes it their own way all

637
00:25:33,850 --> 00:25:37,300
right all right um if you want to

638
00:25:37,300 --> 00:25:39,340
download it if you're already using note

639
00:25:39,340 --> 00:25:40,870
you probably have NPM the package

640
00:25:40,870 --> 00:25:43,570
manager so it's NPM install dirty dirty

641
00:25:43,570 --> 00:25:45,580
by the way the name comes from the fact

642
00:25:45,580 --> 00:25:47,830
that this database violates a lot of

643
00:25:47,830 --> 00:25:49,420
good practices that you would think when

644
00:25:49,420 --> 00:25:51,850
driving a database like a chasing attend

645
00:25:51,850 --> 00:25:53,470
the only thing it's kind of crazy but it

646
00:25:53,470 --> 00:25:55,060
works well for 1 million records so it's

647
00:25:55,060 --> 00:25:56,890
dirty hex that gets to chop down for

648
00:25:56,890 --> 00:25:59,230
really small stuff I also mentioned

649
00:25:59,230 --> 00:26:01,300
startup i'm working on trans so did we

650
00:26:01,300 --> 00:26:04,030
do video uploading and encoding it's all

651
00:26:04,030 --> 00:26:05,980
noches based if you're interested in

652
00:26:05,980 --> 00:26:09,610
that chat me up about it and yeah

653
00:26:09,610 --> 00:26:12,100
lossing be careful and don't hit the

654
00:26:12,100 --> 00:26:25,940
wall

