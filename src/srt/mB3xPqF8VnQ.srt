1
00:00:07,700 --> 00:00:10,830

I'll talk about using non JavaScript

2
00:00:10,830 --> 00:00:13,980
code or libraries in JavaScript it just

3
00:00:13,980 --> 00:00:16,199
before that two things I apologize for

4
00:00:16,199 --> 00:00:18,539
the resolution of the slides my laptop

5
00:00:18,539 --> 00:00:20,220
has been giving me some technical

6
00:00:20,220 --> 00:00:22,980
difficulties thank you to the organizers

7
00:00:22,980 --> 00:00:25,080
of the conference by the way you helped

8
00:00:25,080 --> 00:00:27,480
me with a few problems and second point

9
00:00:27,480 --> 00:00:29,369
please feel free to stop me with any

10
00:00:29,369 --> 00:00:32,009
questions at any point did I prefer to

11
00:00:32,009 --> 00:00:33,420
be asked questions and for you to wait

12
00:00:33,420 --> 00:00:38,100
for the end okay so non JavaScript code

13
00:00:38,100 --> 00:00:40,469
in JavaScript why is this even

14
00:00:40,469 --> 00:00:42,780
interesting what would be the point well

15
00:00:42,780 --> 00:00:43,829
the point is that there's a lot of

16
00:00:43,829 --> 00:00:46,230
existing code out there maybe it's open

17
00:00:46,230 --> 00:00:48,480
source or maybe you have a lot of code

18
00:00:48,480 --> 00:00:50,700
you've written in your company typically

19
00:00:50,700 --> 00:00:55,110
at C and C++ and it could simply be very

20
00:00:55,110 --> 00:00:59,670
time intensive to manually port it to

21
00:00:59,670 --> 00:01:01,079
JavaScript you don't want to start

22
00:01:01,079 --> 00:01:03,210
writing huge applications from scratch

23
00:01:03,210 --> 00:01:05,670
if you don't really need to now the

24
00:01:05,670 --> 00:01:07,170
things when you develop a native that

25
00:01:07,170 --> 00:01:11,070
you can reuse that code so i think we

26
00:01:11,070 --> 00:01:12,450
should be able to do that on the web too

27
00:01:12,450 --> 00:01:14,369
it's just a technical problem that's

28
00:01:14,369 --> 00:01:17,549
stopping us really so I'd like to start

29
00:01:17,549 --> 00:01:20,790
with sort of the cool stuff up front so

30
00:01:20,790 --> 00:01:24,000
with some demos so demo number one

31
00:01:24,000 --> 00:01:26,689
bullet so bullet is a physics engine

32
00:01:26,689 --> 00:01:29,340
it's used actually in several triple-a

33
00:01:29,340 --> 00:01:31,189
games it's open source it's very cool

34
00:01:31,189 --> 00:01:34,049
it's a hundred fifty thousand lines and

35
00:01:34,049 --> 00:01:35,939
it's pretty complicated because well

36
00:01:35,939 --> 00:01:37,259
it's a physics engine you don't want to

37
00:01:37,259 --> 00:01:39,450
start writing these from scratch if you

38
00:01:39,450 --> 00:01:41,909
don't need to because it's so useful it

39
00:01:41,909 --> 00:01:43,799
was actually manually ported to Java

40
00:01:43,799 --> 00:01:46,710
called a bullet J bullet was manually

41
00:01:46,710 --> 00:01:49,560
ported to JavaScript as bullet KS and

42
00:01:49,560 --> 00:01:51,689
there are some demos with this but there

43
00:01:51,689 --> 00:01:53,490
are really two problems with that

44
00:01:53,490 --> 00:01:57,299
approach these ports since their manual

45
00:01:57,299 --> 00:01:58,920
they tend to be partial the people that

46
00:01:58,920 --> 00:02:00,299
are doing this it's a lot of effort for

47
00:02:00,299 --> 00:02:03,659
them they don't port the entire bullet

48
00:02:03,659 --> 00:02:06,299
library as is they pour the parts that

49
00:02:06,299 --> 00:02:09,950
they focus on second of all they port a

50
00:02:09,950 --> 00:02:11,540
that shot of bullet at some particular

51
00:02:11,540 --> 00:02:14,750
point in time so there's always lag so

52
00:02:14,750 --> 00:02:16,760
the trunk version is I think right now

53
00:02:16,760 --> 00:02:19,129
about seven point releases later than

54
00:02:19,129 --> 00:02:21,500
bullet j/s well there are actually two

55
00:02:21,500 --> 00:02:24,280
manual ports here so there's double leg

56
00:02:24,280 --> 00:02:27,470
so mlas is a port of bullet to

57
00:02:27,470 --> 00:02:30,050
javascript with em scripting so it's

58
00:02:30,050 --> 00:02:32,090
completely automatic and for that reason

59
00:02:32,090 --> 00:02:34,640
it you get the entire library as is and

60
00:02:34,640 --> 00:02:35,989
you get the code in its current state

61
00:02:35,989 --> 00:02:38,690
have a few links but since networking

62
00:02:38,690 --> 00:02:40,010
isn't working for me i'll just show you

63
00:02:40,010 --> 00:02:45,230
a local demo and which hopefully will

64
00:02:45,230 --> 00:02:50,180
work ok so this is a simulation of a few

65
00:02:50,180 --> 00:02:54,680
cubes it's rendering using cubic V rjs

66
00:02:54,680 --> 00:02:57,079
they typically fall in a bit more

67
00:02:57,079 --> 00:03:02,540
interesting pattern so so this again

68
00:03:02,540 --> 00:03:04,160
this is bullet running on the web in

69
00:03:04,160 --> 00:03:06,709
JavaScript what's you might have seen

70
00:03:06,709 --> 00:03:09,049
this demo before what's cool about this

71
00:03:09,049 --> 00:03:12,019
right now is that it's actually possible

72
00:03:12,019 --> 00:03:16,519
to tweak the the demo in interesting

73
00:03:16,519 --> 00:03:20,450
ways so this is being used from

74
00:03:20,450 --> 00:03:24,530
JavaScript so for example here gnome is

75
00:03:24,530 --> 00:03:26,180
simply the number of cubes I can change

76
00:03:26,180 --> 00:03:29,569
that to say 20 and just reload the page

77
00:03:29,569 --> 00:03:32,329
and since it shut its JavaScript you

78
00:03:32,329 --> 00:03:35,530
immediately get a slightly more

79
00:03:35,530 --> 00:03:38,900
interesting result if this is actually a

80
00:03:38,900 --> 00:03:40,340
case where it's much more fun to do this

81
00:03:40,340 --> 00:03:42,109
in JavaScript than in C++ with that you

82
00:03:42,109 --> 00:03:43,850
need to rebuild your entire project just

83
00:03:43,850 --> 00:03:47,120
to change some parameters so you can do

84
00:03:47,120 --> 00:03:51,370
that and you can also change things like

85
00:03:51,370 --> 00:03:54,829
let me see reset positions is the

86
00:03:54,829 --> 00:03:57,230
JavaScript which defines where the

87
00:03:57,230 --> 00:03:59,450
bodies begin so let's change the x

88
00:03:59,450 --> 00:04:05,630
position to say I so eyes the index the

89
00:04:05,630 --> 00:04:07,819
number of the body you just said it to I

90
00:04:07,819 --> 00:04:11,780
it should just drop them in a line i

91
00:04:11,780 --> 00:04:15,200
think if i remember correctly yeah so

92
00:04:15,200 --> 00:04:19,690
just sort of falling like that and just

93
00:04:19,690 --> 00:04:21,919
another example we can make them fall

94
00:04:21,919 --> 00:04:23,220
from a higher distance

95
00:04:23,220 --> 00:04:32,070
as well see something else slightly so

96
00:04:32,070 --> 00:04:33,210
it's pretty much the same that they're

97
00:04:33,210 --> 00:04:36,900
falling from a higher distance okay so

98
00:04:36,900 --> 00:04:41,220
that's a first demo out of three that I

99
00:04:41,220 --> 00:04:44,760
wanted to show you second demo is sequel

100
00:04:44,760 --> 00:04:47,610
light so sequel I'd is a very popular

101
00:04:47,610 --> 00:04:51,000
open source database it actually could

102
00:04:51,000 --> 00:04:52,950
have become part of the web through a

103
00:04:52,950 --> 00:04:56,070
web sequel but there's the long quote

104
00:04:56,070 --> 00:04:58,050
here that explains why there's a problem

105
00:04:58,050 --> 00:04:59,880
with a standardization process basically

106
00:04:59,880 --> 00:05:06,480
i leave the code as is i don't comment

107
00:05:06,480 --> 00:05:11,100
on it it but i think the point that i'd

108
00:05:11,100 --> 00:05:13,140
like to make is that the issue with

109
00:05:13,140 --> 00:05:15,000
standardization is that you need to get

110
00:05:15,000 --> 00:05:18,620
people to work together on a specific

111
00:05:18,620 --> 00:05:21,630
API on a spec but if you just compile

112
00:05:21,630 --> 00:05:23,490
the code as is the JavaScript you don't

113
00:05:23,490 --> 00:05:24,990
need to convince anyone of anything you

114
00:05:24,990 --> 00:05:26,340
can just compile whatever you want it

115
00:05:26,340 --> 00:05:28,700
it'll run in all web browsers out there

116
00:05:28,700 --> 00:05:33,960
so here's a working progress demo of

117
00:05:33,960 --> 00:05:36,300
sequel light the resolution is making it

118
00:05:36,300 --> 00:05:38,330
a bit hard to read what's happening here

119
00:05:38,330 --> 00:05:44,460
but it basically well this is some quite

120
00:05:44,460 --> 00:05:46,440
boring sequel light code it'll just

121
00:05:46,440 --> 00:05:48,600
create a table create some stuff in that

122
00:05:48,600 --> 00:05:51,270
table and do a select from it if I hit

123
00:05:51,270 --> 00:05:53,790
execute you'll get key equals to text

124
00:05:53,790 --> 00:05:55,200
equals second item which is what's

125
00:05:55,200 --> 00:05:56,850
expected since we asked for the case

126
00:05:56,850 --> 00:05:59,040
where value is equal to 987 which is

127
00:05:59,040 --> 00:06:03,810
what's over here so we have that and of

128
00:06:03,810 --> 00:06:08,580
course I can do additional commands for

129
00:06:08,580 --> 00:06:11,700
thinking called it's tough so if i do

130
00:06:11,700 --> 00:06:16,229
that i get all the elements and the

131
00:06:16,229 --> 00:06:19,910
resolution is a bit annoying and where

132
00:06:19,910 --> 00:06:26,210
thank you

133
00:06:26,220 --> 00:06:29,470
and of course I can do it basically

134
00:06:29,470 --> 00:06:31,509
anything else in the sequel light syntax

135
00:06:31,509 --> 00:06:34,090
fight ask for less than hundred I get

136
00:06:34,090 --> 00:06:35,860
just the first item since the others had

137
00:06:35,860 --> 00:06:39,130
larger values and and I want to type

138
00:06:39,130 --> 00:06:40,720
this from scratch but here's an example

139
00:06:40,720 --> 00:06:43,360
of enjoying between two tables so

140
00:06:43,360 --> 00:06:45,190
actually it's easier to read it here so

141
00:06:45,190 --> 00:06:46,720
again it's just it's creating another

142
00:06:46,720 --> 00:06:49,150
table more stuff inserting some values

143
00:06:49,150 --> 00:06:51,160
and then it does a select which does

144
00:06:51,160 --> 00:06:54,639
adjoin over the value element so I'm

145
00:06:54,639 --> 00:06:59,849
just going to copy that and run it and

146
00:06:59,849 --> 00:07:03,220
this is the expected data there were two

147
00:07:03,220 --> 00:07:06,130
items for value equals 25 so the text

148
00:07:06,130 --> 00:07:07,539
first item is from the first table it's

149
00:07:07,539 --> 00:07:09,250
a change and then there's two text from

150
00:07:09,250 --> 00:07:10,840
the second table more stuff and get

151
00:07:10,840 --> 00:07:12,789
additional stuff but again this is just

152
00:07:12,789 --> 00:07:14,650
to show that you get the entire sequel

153
00:07:14,650 --> 00:07:16,630
I'd language by compiling the entire

154
00:07:16,630 --> 00:07:21,400
sequel aight implementation so that

155
00:07:21,400 --> 00:07:27,280
concludes demo to demo three Python Ruby

156
00:07:27,280 --> 00:07:29,110
and lua these are popular dynamic

157
00:07:29,110 --> 00:07:31,690
languages actually because they're so

158
00:07:31,690 --> 00:07:34,740
popular there are several projects to

159
00:07:34,740 --> 00:07:37,300
manually implement them in JavaScript

160
00:07:37,300 --> 00:07:39,520
but these suffer generally from the

161
00:07:39,520 --> 00:07:40,599
problems that i mentioned before about

162
00:07:40,599 --> 00:07:42,880
bullets the these ports are generally

163
00:07:42,880 --> 00:07:44,409
partial they don't implement the entire

164
00:07:44,409 --> 00:07:45,849
language there are a lot of corners in

165
00:07:45,849 --> 00:07:47,530
these languages they don't bother with

166
00:07:47,530 --> 00:07:50,740
they lag behind the trunk version of the

167
00:07:50,740 --> 00:07:54,460
language and worse in this case they

168
00:07:54,460 --> 00:07:58,030
typically targeted slightly modified

169
00:07:58,030 --> 00:07:59,849
version of the language for example

170
00:07:59,849 --> 00:08:03,430
pajamas for Python translates Python

171
00:08:03,430 --> 00:08:05,530
more or less as is into JavaScript so i

172
00:08:05,530 --> 00:08:07,419
end up with the semantics of javascript

173
00:08:07,419 --> 00:08:09,699
for example if you do some operations on

174
00:08:09,699 --> 00:08:11,520
numbers you'll get the behavior

175
00:08:11,520 --> 00:08:13,690
javascript has not the behavior of

176
00:08:13,690 --> 00:08:15,610
Python so you're writing something that

177
00:08:15,610 --> 00:08:17,020
looks like Python but it's not really

178
00:08:17,020 --> 00:08:19,389
Python on the other hand if you compile

179
00:08:19,389 --> 00:08:21,430
the entire language as is into

180
00:08:21,430 --> 00:08:22,930
JavaScript and again the benefit is you

181
00:08:22,930 --> 00:08:25,960
get exactly what you started out with so

182
00:08:25,960 --> 00:08:28,180
if I could connect in the network ID

183
00:08:28,180 --> 00:08:30,159
show you this website which was just on

184
00:08:30,159 --> 00:08:32,079
Hacker News repple de it which is really

185
00:08:32,079 --> 00:08:34,419
the nicer way to show this it uses

186
00:08:34,419 --> 00:08:35,529
Python Ruby

187
00:08:35,529 --> 00:08:38,019
with the code that I'm talking about

188
00:08:38,019 --> 00:08:41,249
here but instead i'll show you a local

189
00:08:41,249 --> 00:08:49,209
version of the python one so it just

190
00:08:49,209 --> 00:08:51,689
brings some numbers just some random

191
00:08:51,689 --> 00:08:55,360
syntax and it actually does import sis

192
00:08:55,360 --> 00:08:58,629
and writes version and that platform and

193
00:08:58,629 --> 00:09:00,009
the version of the platform are simply

194
00:09:00,009 --> 00:09:01,420
what was there when i compiled it

195
00:09:01,420 --> 00:09:04,029
locally on my linux machine it says

196
00:09:04,029 --> 00:09:06,220
apple and i assume because it was built

197
00:09:06,220 --> 00:09:12,069
using llvm but anyhow that's to sort of

198
00:09:12,069 --> 00:09:13,329
elaborate and what is it before about

199
00:09:13,329 --> 00:09:16,899
differences with the language it let's

200
00:09:16,899 --> 00:09:22,870
say let's say that I i have think i

201
00:09:22,870 --> 00:09:25,779
actually have a code just so i don't

202
00:09:25,779 --> 00:09:29,079
forget yet let's just briefly look at

203
00:09:29,079 --> 00:09:32,649
this code here so it does x equals to

204
00:09:32,649 --> 00:09:34,689
the maximum possible integer then it

205
00:09:34,689 --> 00:09:37,509
will print the type of X and X it'll add

206
00:09:37,509 --> 00:09:39,430
one to that so it's max inked plus one

207
00:09:39,430 --> 00:09:43,720
print the type and then print X to the

208
00:09:43,720 --> 00:09:46,180
power of 10 why this is interesting is

209
00:09:46,180 --> 00:09:49,720
because pythons handling of numbers is

210
00:09:49,720 --> 00:09:52,449
very different from JavaScript so if I

211
00:09:52,449 --> 00:09:55,660
execute this so the first value here

212
00:09:55,660 --> 00:09:59,709
this thing is type int its max int but

213
00:09:59,709 --> 00:10:02,040
when you add one to that in Python

214
00:10:02,040 --> 00:10:04,779
Python changes that to type long and

215
00:10:04,779 --> 00:10:06,579
type long is not just the long integer

216
00:10:06,579 --> 00:10:08,589
it can be basically any value so when I

217
00:10:08,589 --> 00:10:09,879
do that to the power of 10 you get this

218
00:10:09,879 --> 00:10:12,939
huge number over here so this is exactly

219
00:10:12,939 --> 00:10:15,100
the same result that I would get if I

220
00:10:15,100 --> 00:10:19,079
were just running for example Python

221
00:10:19,079 --> 00:10:23,649
natively here you see I get the exact

222
00:10:23,649 --> 00:10:25,990
same numbers in this case so this is the

223
00:10:25,990 --> 00:10:29,069
benefit of compiling it whereas in

224
00:10:29,069 --> 00:10:31,420
JavaScript natively for just open the

225
00:10:31,420 --> 00:10:36,850
console here and again I'd so this is

226
00:10:36,850 --> 00:10:38,949
code that does something similar it

227
00:10:38,949 --> 00:10:41,110
again it takes that max end and then

228
00:10:41,110 --> 00:10:44,920
shows it to the power of 10 and of

229
00:10:44,920 --> 00:10:45,960
course

230
00:10:45,960 --> 00:10:48,000
the results are very different in

231
00:10:48,000 --> 00:10:49,920
JavaScript the first number is fine but

232
00:10:49,920 --> 00:10:52,260
the second number is a double so you

233
00:10:52,260 --> 00:10:53,640
don't get the same thing we saw in

234
00:10:53,640 --> 00:10:57,480
Python with this so this just shows that

235
00:10:57,480 --> 00:10:59,970
you can implement the real version of

236
00:10:59,970 --> 00:11:02,130
Python on the web getting you the exact

237
00:11:02,130 --> 00:11:03,330
same behavior you would get in the

238
00:11:03,330 --> 00:11:06,720
console native code version unlike in

239
00:11:06,720 --> 00:11:09,800
sort of a manual court that does not

240
00:11:09,800 --> 00:11:14,160
copy the entire language as is I hope I

241
00:11:14,160 --> 00:11:17,700
was clear oh and I did want to do a

242
00:11:17,700 --> 00:11:20,430
fourth demo that I didn't plan on but

243
00:11:20,430 --> 00:11:22,050
given that the previous talk was about

244
00:11:22,050 --> 00:11:28,220
audio I thought it might be relevant so

245
00:11:28,220 --> 00:11:33,390
the previous talk mentioned the Web

246
00:11:33,390 --> 00:11:36,200
Audio spec and the Mozilla audio data

247
00:11:36,200 --> 00:11:40,070
API and I think the very valid reasoning

248
00:11:40,070 --> 00:11:43,020
given for preferring the Web Audio API

249
00:11:43,020 --> 00:11:45,720
was that it's easy to get to results

250
00:11:45,720 --> 00:11:47,130
very quickly you don't need to start

251
00:11:47,130 --> 00:11:48,960
writing the middleware or the libraries

252
00:11:48,960 --> 00:11:51,810
to actually see results but the reason

253
00:11:51,810 --> 00:11:54,030
is pretty similar to what i was talking

254
00:11:54,030 --> 00:11:56,280
about Earth earlier with the Mozilla

255
00:11:56,280 --> 00:11:59,280
audio data API you have access to the

256
00:11:59,280 --> 00:12:01,800
hardware to the audio partner all you

257
00:12:01,800 --> 00:12:05,280
need is to actually be able to have a

258
00:12:05,280 --> 00:12:06,870
library that creates audio in a

259
00:12:06,870 --> 00:12:08,850
convenient way we have that code it's

260
00:12:08,850 --> 00:12:12,000
written in C++ we just can't run it on

261
00:12:12,000 --> 00:12:14,580
the web but we can compile it to the web

262
00:12:14,580 --> 00:12:18,030
and this is a demo of using espeak which

263
00:12:18,030 --> 00:12:22,050
is a speech synthesis engine again

264
00:12:22,050 --> 00:12:23,460
something pretty complicated that you

265
00:12:23,460 --> 00:12:24,690
don't want to start writing from scratch

266
00:12:24,690 --> 00:12:27,750
and if the connection is working you

267
00:12:27,750 --> 00:12:32,460
should hear something but I guess it's

268
00:12:32,460 --> 00:12:38,070
not working so that was underwhelming

269
00:12:38,070 --> 00:12:43,160
I actually can't even hear it locally oh

270
00:12:43,160 --> 00:12:45,240
the people who are sitting in the front

271
00:12:45,240 --> 00:12:48,600
row might be able to hear it I doubt it

272
00:12:48,600 --> 00:12:58,050
I give up oh did you hear anything

273
00:12:58,050 --> 00:13:00,090
that's I think that's as close as I can

274
00:13:00,090 --> 00:13:08,620
get

275
00:13:08,630 --> 00:13:13,870
oh well again this was not a planned

276
00:13:13,870 --> 00:13:20,780
demo okay back to the scheduled

277
00:13:20,780 --> 00:13:23,420
programming so after showing you some

278
00:13:23,420 --> 00:13:25,040
demos I'd like to talk about the more

279
00:13:25,040 --> 00:13:27,680
boring aspects about how this works and

280
00:13:27,680 --> 00:13:31,340
how you can actually use it and so forth

281
00:13:31,340 --> 00:13:35,690
so how does this work the idea is you

282
00:13:35,690 --> 00:13:39,920
take your C or C++ code you want to get

283
00:13:39,920 --> 00:13:41,330
that into JavaScript but you need to go

284
00:13:41,330 --> 00:13:44,690
through an intermediary step of lvm bit

285
00:13:44,690 --> 00:13:47,720
code so llvm the low-level virtual

286
00:13:47,720 --> 00:13:50,500
machine is a compiler project much like

287
00:13:50,500 --> 00:13:55,010
GCC which can compile C code into native

288
00:13:55,010 --> 00:13:57,500
code but it can also compile into lvm

289
00:13:57,500 --> 00:13:59,540
bit code which is an intermediary is

290
00:13:59,540 --> 00:14:02,690
stage which the nice thing about is that

291
00:14:02,690 --> 00:14:05,150
is that it is extremely well documented

292
00:14:05,150 --> 00:14:08,540
and for that reason it's used here so we

293
00:14:08,540 --> 00:14:10,730
translate the high-level world medium

294
00:14:10,730 --> 00:14:15,260
level c code into this low-level a bit

295
00:14:15,260 --> 00:14:18,140
code and in script and then compiles

296
00:14:18,140 --> 00:14:21,110
that into javascript so this is the big

297
00:14:21,110 --> 00:14:25,760
picture of what happens but what

298
00:14:25,760 --> 00:14:29,510
actually goes on here so and if script

299
00:14:29,510 --> 00:14:31,970
when we try to translate bit code one to

300
00:14:31,970 --> 00:14:35,780
one so on the left here we have llvm bit

301
00:14:35,780 --> 00:14:36,950
code and on the right we have the

302
00:14:36,950 --> 00:14:40,760
corresponding javascript so for example

303
00:14:40,760 --> 00:14:42,800
the first thing here could you see the

304
00:14:42,800 --> 00:14:45,290
mouse cursor yet the first thing here is

305
00:14:45,290 --> 00:14:49,280
basically allocate which means allocate

306
00:14:49,280 --> 00:14:51,850
on the stack a 32-bit integer in

307
00:14:51,850 --> 00:14:53,690
JavaScript you can do something very

308
00:14:53,690 --> 00:14:55,520
similar by just doing VAR local

309
00:14:55,520 --> 00:14:58,280
variables stored on the stack similarly

310
00:14:58,280 --> 00:15:01,070
calling a function within a 32-bit

311
00:15:01,070 --> 00:15:04,010
integer parameter here is translated

312
00:15:04,010 --> 00:15:05,780
simply into a function call so this is a

313
00:15:05,780 --> 00:15:07,640
native JavaScript function called not

314
00:15:07,640 --> 00:15:12,170
some complicated a emulation of one and

315
00:15:12,170 --> 00:15:15,170
the last command is a mathematical

316
00:15:15,170 --> 00:15:18,829
ed adding 22 to the variable one and

317
00:15:18,829 --> 00:15:21,950
that turns into an ED so for the most

318
00:15:21,950 --> 00:15:23,630
part in scripting just tries to

319
00:15:23,630 --> 00:15:25,820
translate the bit code as is and that

320
00:15:25,820 --> 00:15:30,850
works for quite a lot but not everything

321
00:15:30,850 --> 00:15:34,339
one issue is that Seco typically

322
00:15:34,339 --> 00:15:36,470
allocates memory using malloc etc and it

323
00:15:36,470 --> 00:15:38,060
reads and writes from that memory you

324
00:15:38,060 --> 00:15:39,709
don't just put things on the stack you

325
00:15:39,709 --> 00:15:43,070
have the heat so we implement sort of a

326
00:15:43,070 --> 00:15:45,920
heap variable in javascript is a sin

327
00:15:45,920 --> 00:15:48,829
which is a single large array a normal

328
00:15:48,829 --> 00:15:51,519
JavaScript array of course and it

329
00:15:51,519 --> 00:15:54,709
represents the memory space so heap of X

330
00:15:54,709 --> 00:15:56,870
is a read heap of X equals something is

331
00:15:56,870 --> 00:16:01,570
a right and pointers X here are simply

332
00:16:01,570 --> 00:16:05,149
integers so i hope this sort of makes

333
00:16:05,149 --> 00:16:09,440
sense another complicated issue with the

334
00:16:09,440 --> 00:16:13,760
behavior of C++ is that so we saw in

335
00:16:13,760 --> 00:16:16,399
this lie that adding 22 is simply a

336
00:16:16,399 --> 00:16:19,579
dollar 1 + 22 but in general of course

337
00:16:19,579 --> 00:16:22,640
that's not correct for example in c x

338
00:16:22,640 --> 00:16:25,579
equals 5 and x divided by 2 gives you

339
00:16:25,579 --> 00:16:27,320
two it ramms down because it's an

340
00:16:27,320 --> 00:16:29,899
integer in javascript x equals 5 x

341
00:16:29,899 --> 00:16:33,100
divided by 2 gives you two and a half so

342
00:16:33,100 --> 00:16:35,420
this of course is fixable by doing math

343
00:16:35,420 --> 00:16:37,790
dot floor although even this actually is

344
00:16:37,790 --> 00:16:39,110
not correct because this gives the

345
00:16:39,110 --> 00:16:41,180
correct rounding behavior for positive

346
00:16:41,180 --> 00:16:43,089
integers with that negative ones but

347
00:16:43,089 --> 00:16:47,000
this works in most cases and there are

348
00:16:47,000 --> 00:16:48,920
similar issues with overflows signs so

349
00:16:48,920 --> 00:16:52,130
these are so c and java script or two

350
00:16:52,130 --> 00:16:55,550
very different languages they their

351
00:16:55,550 --> 00:16:57,829
semantics do not match one to one

352
00:16:57,829 --> 00:17:00,350
obviously so much of the challenge in

353
00:17:00,350 --> 00:17:03,019
writing a compiler from from the bit

354
00:17:03,019 --> 00:17:05,120
code but really from c to javascript is

355
00:17:05,120 --> 00:17:06,799
to get all these little behavior

356
00:17:06,799 --> 00:17:08,870
differences to make them completely

357
00:17:08,870 --> 00:17:10,819
vanish so there are a lot of details

358
00:17:10,819 --> 00:17:14,689
here that i will not bore you with but

359
00:17:14,689 --> 00:17:15,799
it will still worried with some other

360
00:17:15,799 --> 00:17:19,880
and more high level details so to get

361
00:17:19,880 --> 00:17:24,380
good performing code you really need to

362
00:17:24,380 --> 00:17:26,630
generate code that looks like this over

363
00:17:26,630 --> 00:17:27,790
here while and

364
00:17:27,790 --> 00:17:29,560
fourth you want to use native JavaScript

365
00:17:29,560 --> 00:17:32,710
loops and ifs the problem though is that

366
00:17:32,710 --> 00:17:34,510
when you're compiling this bit code you

367
00:17:34,510 --> 00:17:36,790
get what we see on the left basically

368
00:17:36,790 --> 00:17:39,910
these blocks of code so block one some

369
00:17:39,910 --> 00:17:42,430
commands then a branch to block to block

370
00:17:42,430 --> 00:17:45,940
two is another series of commands ending

371
00:17:45,940 --> 00:17:47,950
with a branch this is very low level

372
00:17:47,950 --> 00:17:50,110
it's like some commands plus go tues

373
00:17:50,110 --> 00:17:52,330
it's even lower level than the seco that

374
00:17:52,330 --> 00:17:54,280
we started out with this is the alluvium

375
00:17:54,280 --> 00:17:58,120
bit code so one of the challenges is to

376
00:17:58,120 --> 00:18:00,370
get from this code to something that

377
00:18:00,370 --> 00:18:02,590
looks like normal JavaScript loops and

378
00:18:02,590 --> 00:18:05,610
there's a big section in the in the

379
00:18:05,610 --> 00:18:08,140
optimizer an impression that tries to

380
00:18:08,140 --> 00:18:10,720
reason about these loops and to recruit

381
00:18:10,720 --> 00:18:14,280
to recreate them to something because

382
00:18:14,280 --> 00:18:17,430
this it simply runs much much faster

383
00:18:17,430 --> 00:18:20,500
with a with the loops without loops you

384
00:18:20,500 --> 00:18:22,270
can emulate go tues with various

385
00:18:22,270 --> 00:18:24,600
cumbersome ways it's extremely slowly

386
00:18:24,600 --> 00:18:27,760
with that approach so it's necessary to

387
00:18:27,760 --> 00:18:30,040
do this optimizing step and it's the

388
00:18:30,040 --> 00:18:31,450
second thing I've already sort of

389
00:18:31,450 --> 00:18:34,960
mentioned VAR x is a reasonable way to

390
00:18:34,960 --> 00:18:37,600
implement a variable on the stack it's

391
00:18:37,600 --> 00:18:39,070
of course fast because javascript

392
00:18:39,070 --> 00:18:40,690
engines have been heavily optimized for

393
00:18:40,690 --> 00:18:43,180
that however you can't do that for every

394
00:18:43,180 --> 00:18:45,220
variable for example if you take the

395
00:18:45,220 --> 00:18:48,670
address of a variable on the stack in c

396
00:18:48,670 --> 00:18:50,410
you can pass that to some other function

397
00:18:50,410 --> 00:18:53,530
and of course you cannot access bar x in

398
00:18:53,530 --> 00:18:55,870
javascript in another function so the

399
00:18:55,870 --> 00:18:57,700
optimizer needs to reason about when it

400
00:18:57,700 --> 00:19:00,280
can optimize by doing VAR x and when it

401
00:19:00,280 --> 00:19:06,880
can't ok so you've written your code it

402
00:19:06,880 --> 00:19:08,920
runs it's optimized but how do you

403
00:19:08,920 --> 00:19:10,870
actually access anything or do something

404
00:19:10,870 --> 00:19:12,310
with that code you're running it inside

405
00:19:12,310 --> 00:19:13,690
a web browsers are not on a normal

406
00:19:13,690 --> 00:19:16,150
machine with the files with a filesystem

407
00:19:16,150 --> 00:19:19,060
and so forth so basically an obscure

408
00:19:19,060 --> 00:19:22,180
iftin we've written standard see system

409
00:19:22,180 --> 00:19:23,710
API is in JavaScript we've basically

410
00:19:23,710 --> 00:19:27,310
implemented the C standard it lives see

411
00:19:27,310 --> 00:19:29,740
basically and also plastics and sdl not

412
00:19:29,740 --> 00:19:31,180
all of these but the parts that we've

413
00:19:31,180 --> 00:19:33,280
needed we've written a JavaScript

414
00:19:33,280 --> 00:19:34,840
implementation of them that sort of

415
00:19:34,840 --> 00:19:37,150
makes sense for the web so it uses an

416
00:19:37,150 --> 00:19:38,580
xhr to load file

417
00:19:38,580 --> 00:19:41,010
and so forth so just as an example of

418
00:19:41,010 --> 00:19:44,429
what this look looks like you can set up

419
00:19:44,429 --> 00:19:48,000
a virtual file system using some command

420
00:19:48,000 --> 00:19:50,130
that we added called FS that create lazy

421
00:19:50,130 --> 00:19:55,019
file so you give it a the directory the

422
00:19:55,019 --> 00:19:57,899
name of the file the URL from where it

423
00:19:57,899 --> 00:20:00,390
will actually do the load and the point

424
00:20:00,390 --> 00:20:02,960
is that the compiled code the C++ code

425
00:20:02,960 --> 00:20:05,130
uses the file system in a completely

426
00:20:05,130 --> 00:20:07,019
normal way you do not need to rewrite

427
00:20:07,019 --> 00:20:09,299
your C code the C code will include

428
00:20:09,299 --> 00:20:13,350
standard i/o do F open do F read but

429
00:20:13,350 --> 00:20:15,149
when it actually reads from this file

430
00:20:15,149 --> 00:20:18,690
that debt that we created here the

431
00:20:18,690 --> 00:20:20,429
JavaScript implementation will actually

432
00:20:20,429 --> 00:20:23,429
do an xhr and load that data so we've

433
00:20:23,429 --> 00:20:27,360
made it so you can use your existing C

434
00:20:27,360 --> 00:20:29,760
code but you sort of hook it up to the

435
00:20:29,760 --> 00:20:40,470
relevant things on the web

436
00:20:40,480 --> 00:20:44,780
okay and so how does it actually look

437
00:20:44,780 --> 00:20:48,290
when you eat when you try to eat try to

438
00:20:48,290 --> 00:20:53,270
use this to compile a project so just

439
00:20:53,270 --> 00:20:54,680
one more technical detail there are

440
00:20:54,680 --> 00:20:57,140
really two parts in this project there

441
00:20:57,140 --> 00:20:59,390
is the compiler which compiles llvm to

442
00:20:59,390 --> 00:21:01,070
javascript this is basically what I was

443
00:21:01,070 --> 00:21:03,590
talking about before it's really just

444
00:21:03,590 --> 00:21:05,060
concerned with getting the code into

445
00:21:05,060 --> 00:21:07,550
JavaScript in a way that works so it

446
00:21:07,550 --> 00:21:09,260
just gets it there but the problem is

447
00:21:09,260 --> 00:21:11,120
we're compiling this llvm bit code which

448
00:21:11,120 --> 00:21:13,490
is low level and we get something that's

449
00:21:13,490 --> 00:21:15,620
not easy to use for example if the code

450
00:21:15,620 --> 00:21:18,010
started a C++ you'll have name mangling

451
00:21:18,010 --> 00:21:20,810
you'll have these crazy long function

452
00:21:20,810 --> 00:21:23,630
names that really mean very simple

453
00:21:23,630 --> 00:21:24,890
things but you get them in a mangled

454
00:21:24,890 --> 00:21:27,170
form there's also lifecycle issues

455
00:21:27,170 --> 00:21:28,970
creating objects and destroying them

456
00:21:28,970 --> 00:21:30,620
it's not easy at all in the low-level

457
00:21:30,620 --> 00:21:34,070
bit code so you get code that works and

458
00:21:34,070 --> 00:21:35,450
if all you care about is taking a

459
00:21:35,450 --> 00:21:37,430
project and running it on the web as is

460
00:21:37,430 --> 00:21:39,020
that's fine and that's what most of

461
00:21:39,020 --> 00:21:41,030
these demos were except for the first

462
00:21:41,030 --> 00:21:43,130
one with bullet but if you want to use

463
00:21:43,130 --> 00:21:45,500
the libraries on the web in a convenient

464
00:21:45,500 --> 00:21:47,630
way you really need something else and

465
00:21:47,630 --> 00:21:50,000
that's what the bindings generator is

466
00:21:50,000 --> 00:21:53,060
it's the work of the past few months it

467
00:21:53,060 --> 00:21:54,980
parses not the bit code but the actual

468
00:21:54,980 --> 00:21:56,840
header files the dut h files in your

469
00:21:56,840 --> 00:21:59,480
project and generate some glue code to

470
00:21:59,480 --> 00:22:01,670
connect things so i'll give an example

471
00:22:01,670 --> 00:22:04,190
in two slides that will sort of i hope

472
00:22:04,190 --> 00:22:05,870
make sense of this but the idea is again

473
00:22:05,870 --> 00:22:07,850
that there's a compiler for the bit code

474
00:22:07,850 --> 00:22:09,710
and something else that creates the glue

475
00:22:09,710 --> 00:22:11,390
code that doesn't look at the vid khob

476
00:22:11,390 --> 00:22:16,400
it looks at the high level hitters okay

477
00:22:16,400 --> 00:22:17,870
so how does it actually look when you

478
00:22:17,870 --> 00:22:19,880
compile something to javascript this is

479
00:22:19,880 --> 00:22:22,910
slightly simplified but it gives you the

480
00:22:22,910 --> 00:22:25,240
main picture so you build your library

481
00:22:25,240 --> 00:22:28,700
almost normally you do make and

482
00:22:28,700 --> 00:22:32,810
configure sorry so you build the project

483
00:22:32,810 --> 00:22:35,350
pretty much normally except you use a

484
00:22:35,350 --> 00:22:38,810
different compiler which basically just

485
00:22:38,810 --> 00:22:40,730
changes some parameters gets it to

486
00:22:40,730 --> 00:22:42,830
generate it'll be a bit code instead of

487
00:22:42,830 --> 00:22:46,010
native code then you run the inscription

488
00:22:46,010 --> 00:22:48,230
compiler on that bit code this gives you

489
00:22:48,230 --> 00:22:50,360
some JavaScript you're on the unscripted

490
00:22:50,360 --> 00:22:51,710
bindings generator

491
00:22:51,710 --> 00:22:53,450
the headers this again gives you some

492
00:22:53,450 --> 00:22:55,700
JavaScript and you simply combine those

493
00:22:55,700 --> 00:22:59,059
into say library jas so if everything

494
00:22:59,059 --> 00:23:01,250
goes right this is pretty much what the

495
00:23:01,250 --> 00:23:06,470
process should be let's take look at

496
00:23:06,470 --> 00:23:09,470
sort of a tiny example of how the code

497
00:23:09,470 --> 00:23:14,080
would would look so if we have a C++ a a

498
00:23:14,080 --> 00:23:16,070
library that looks like this so these

499
00:23:16,070 --> 00:23:20,000
are two really silly classes a data

500
00:23:20,000 --> 00:23:22,880
class that gets an X and Y a processor

501
00:23:22,880 --> 00:23:26,870
class that gets data class instances you

502
00:23:26,870 --> 00:23:28,309
would use that on the web basically as

503
00:23:28,309 --> 00:23:30,710
follows you obviously import that the

504
00:23:30,710 --> 00:23:33,350
script into your web page and then you

505
00:23:33,350 --> 00:23:35,299
can use those objects in a normal way

506
00:23:35,299 --> 00:23:37,610
data one equals into data classic and

507
00:23:37,610 --> 00:23:40,190
that data class and C++ takes two

508
00:23:40,190 --> 00:23:43,460
integers in JavaScript you just pass it

509
00:23:43,460 --> 00:23:45,500
to integers and things are hooked up

510
00:23:45,500 --> 00:23:48,320
properly can create a new processor by

511
00:23:48,320 --> 00:23:50,510
doing a processor class and you can call

512
00:23:50,510 --> 00:23:53,750
methods on them as expected for

513
00:23:53,750 --> 00:23:58,250
comparison here's the C++ code pretty

514
00:23:58,250 --> 00:24:00,470
much the same so the idea with the

515
00:24:00,470 --> 00:24:04,190
bindings the thing is that it lets you

516
00:24:04,190 --> 00:24:08,020
use those those cephas clough classes in

517
00:24:08,020 --> 00:24:10,549
javascript in a way that really keeps

518
00:24:10,549 --> 00:24:12,529
the high level interface there so you

519
00:24:12,529 --> 00:24:14,059
can really use these as a library

520
00:24:14,059 --> 00:24:15,730
without needing to mess with any

521
00:24:15,730 --> 00:24:20,380
ugliness of the low-level compiled code

522
00:24:20,380 --> 00:24:25,909
few words about the this binding API so

523
00:24:25,909 --> 00:24:29,059
when you do new class and so forth of

524
00:24:29,059 --> 00:24:30,679
course you don't get a C++ object

525
00:24:30,679 --> 00:24:32,899
because you can't access that in

526
00:24:32,899 --> 00:24:34,700
JavaScript you don't want to it returns

527
00:24:34,700 --> 00:24:37,610
and said a rapper object which encloses

528
00:24:37,610 --> 00:24:40,100
the pointer to the data on the heap and

529
00:24:40,100 --> 00:24:42,860
so forth it has wrapper functions on it

530
00:24:42,860 --> 00:24:45,679
that convert arguments and make sure

531
00:24:45,679 --> 00:24:48,200
everything works so 5 a number typically

532
00:24:48,200 --> 00:24:50,510
doesn't need any conversion but if other

533
00:24:50,510 --> 00:24:51,679
inch there's an instance of a class

534
00:24:51,679 --> 00:24:54,080
it'll translate that into a pointer and

535
00:24:54,080 --> 00:24:56,929
again it does that for you automatically

536
00:24:56,929 --> 00:24:59,750
so you don't need to mess with it there

537
00:24:59,750 --> 00:25:03,309
are however some limitations so

538
00:25:03,309 --> 00:25:05,830
basically the issue is that JavaScript

539
00:25:05,830 --> 00:25:07,629
and C++ are not the same language their

540
00:25:07,629 --> 00:25:08,980
semantics are different again we saw

541
00:25:08,980 --> 00:25:11,259
this a bit before so they don't match

542
00:25:11,259 --> 00:25:14,409
perfectly for example when you create an

543
00:25:14,409 --> 00:25:18,999
instance you must destroy it manually

544
00:25:18,999 --> 00:25:22,480
the reason is that while doing new class

545
00:25:22,480 --> 00:25:25,090
creates an instance and of course it'll

546
00:25:25,090 --> 00:25:29,080
be GC at some point the compiled code is

547
00:25:29,080 --> 00:25:31,029
no way to tell when that object was G

548
00:25:31,029 --> 00:25:32,860
see if we could know that we would

549
00:25:32,860 --> 00:25:36,190
destroy the C++ objects at that point in

550
00:25:36,190 --> 00:25:39,340
time but we can't so you need to do the

551
00:25:39,340 --> 00:25:41,379
destroy manually so this is a bit

552
00:25:41,379 --> 00:25:42,490
cumbersome and there are a few other

553
00:25:42,490 --> 00:25:44,980
technical issues that I don't want to

554
00:25:44,980 --> 00:25:46,450
waste time I'm talking about but again

555
00:25:46,450 --> 00:25:47,860
the issue is that the languages do not

556
00:25:47,860 --> 00:25:50,440
match up perfectly so while you can

557
00:25:50,440 --> 00:25:53,129
write code that for the most part is

558
00:25:53,129 --> 00:25:57,549
pretty natural and close to the C++ it's

559
00:25:57,549 --> 00:25:58,990
definitely not perfect there are some

560
00:25:58,990 --> 00:26:02,289
limits some can be fixed but it'll never

561
00:26:02,289 --> 00:26:07,389
be a hundred percent identical so just

562
00:26:07,389 --> 00:26:12,190
to summarize the section about using the

563
00:26:12,190 --> 00:26:15,850
project so the product works well on a

564
00:26:15,850 --> 00:26:19,269
lot of real world code this is we've not

565
00:26:19,269 --> 00:26:21,159
been interested in working just on

566
00:26:21,159 --> 00:26:23,710
benchmarks but on actual code so we've

567
00:26:23,710 --> 00:26:25,990
ported things like doom which sadly they

568
00:26:25,990 --> 00:26:28,080
sent to dmca so we had to take it down

569
00:26:28,080 --> 00:26:31,809
hey so do them the popular game zelia

570
00:26:31,809 --> 00:26:37,360
compression a popular a PDF renderer

571
00:26:37,360 --> 00:26:41,580
open jpeg codec for jpeg 2000 images

572
00:26:41,580 --> 00:26:45,279
which actually i can show you locally i

573
00:26:45,279 --> 00:26:56,990
believe yeah open jpg

574
00:26:57,000 --> 00:27:03,070
so and that's a JPEG 2000 rendered to a

575
00:27:03,070 --> 00:27:05,410
canvas element so this is a file format

576
00:27:05,410 --> 00:27:07,060
not recognized by the browser in the

577
00:27:07,060 --> 00:27:09,490
native way but entirely in JavaScript it

578
00:27:09,490 --> 00:27:12,120
was translated into a canvas image

579
00:27:12,120 --> 00:27:16,780
basically and getting back to that free

580
00:27:16,780 --> 00:27:18,940
type which renders fonts and as already

581
00:27:18,940 --> 00:27:21,040
mentioned bullets equal I Python Ruby

582
00:27:21,040 --> 00:27:24,850
Lua so this works on real world code but

583
00:27:24,850 --> 00:27:26,770
again just to just a caveat about that

584
00:27:26,770 --> 00:27:29,170
this is for the compiler which generates

585
00:27:29,170 --> 00:27:31,900
working code the binding stuff which

586
00:27:31,900 --> 00:27:34,480
makes the code very easy to use is very

587
00:27:34,480 --> 00:27:36,970
new and obviously less mature so don't

588
00:27:36,970 --> 00:27:40,350
expect that to work out of the box as is

589
00:27:40,350 --> 00:27:44,080
two last points that I think I should

590
00:27:44,080 --> 00:27:46,450
make to port a library to JavaScript you

591
00:27:46,450 --> 00:27:48,070
do need to know the original language

592
00:27:48,070 --> 00:27:50,800
that you're translating it's not a one

593
00:27:50,800 --> 00:27:52,480
hundred percent automatic process that

594
00:27:52,480 --> 00:27:54,310
you just push a button and you get some

595
00:27:54,310 --> 00:27:57,820
code there are a few cases they're rare

596
00:27:57,820 --> 00:27:58,750
but there are a few cases where you

597
00:27:58,750 --> 00:28:00,910
might need to modify the original source

598
00:28:00,910 --> 00:28:03,550
code so you really do need to know the

599
00:28:03,550 --> 00:28:05,890
language if only just to know that the

600
00:28:05,890 --> 00:28:08,320
false positives that it that warnings

601
00:28:08,320 --> 00:28:09,430
that it mentions to you are false

602
00:28:09,430 --> 00:28:11,890
positives so you can't just compile

603
00:28:11,890 --> 00:28:14,380
something you don't understand we can

604
00:28:14,380 --> 00:28:16,150
make this better but right now it's

605
00:28:16,150 --> 00:28:19,960
definitely not there and while

606
00:28:19,960 --> 00:28:21,160
generating working code is

607
00:28:21,160 --> 00:28:24,250
straightforward in optimizing the code

608
00:28:24,250 --> 00:28:26,170
to get to maximum speed takes additional

609
00:28:26,170 --> 00:28:28,840
manual effort so again this is something

610
00:28:28,840 --> 00:28:30,700
that we can definitely fix but at this

611
00:28:30,700 --> 00:28:33,070
point you can get code to work typically

612
00:28:33,070 --> 00:28:36,100
fast optimizing it to maximum speed will

613
00:28:36,100 --> 00:28:41,440
take more work okay I have just a few

614
00:28:41,440 --> 00:28:43,570
more slides but I should address some

615
00:28:43,570 --> 00:28:46,570
something about speed so you might be

616
00:28:46,570 --> 00:28:48,460
thinking isn't this terribly slow this

617
00:28:48,460 --> 00:28:51,010
is JavaScript don't we need native apps

618
00:28:51,010 --> 00:28:53,950
Native Client dart Java flash if you

619
00:28:53,950 --> 00:28:56,880
can't read the rest doesn't matter

620
00:28:56,880 --> 00:28:59,080
don't we need these other things that

621
00:28:59,080 --> 00:29:01,570
are fast then isn't there are some

622
00:29:01,570 --> 00:29:03,460
problem that even if you get this code

623
00:29:03,460 --> 00:29:05,340
onto the web it'll just run too slowly

624
00:29:05,340 --> 00:29:07,840
so I think there are sort of two parts

625
00:29:07,840 --> 00:29:09,160
to this question the first part is

626
00:29:09,160 --> 00:29:12,010
whether JavaScript itself is fast enough

627
00:29:12,010 --> 00:29:13,179
for not a night we had to talk

628
00:29:13,179 --> 00:29:15,460
previously I think we know that by now

629
00:29:15,460 --> 00:29:18,910
javascript is fast enough but on the

630
00:29:18,910 --> 00:29:21,160
other hand perhaps this compiler method

631
00:29:21,160 --> 00:29:23,140
generates code that is not a match to

632
00:29:23,140 --> 00:29:25,030
what Jess engines are optimizing for

633
00:29:25,030 --> 00:29:27,970
were compiled a low-level bit code maybe

634
00:29:27,970 --> 00:29:29,919
it ends up just being very very slow

635
00:29:29,919 --> 00:29:32,410
even though it does work so the answer

636
00:29:32,410 --> 00:29:36,100
is no this actually isn't slow there are

637
00:29:36,100 --> 00:29:39,520
some numbers here they are all in time

638
00:29:39,520 --> 00:29:42,160
slower than GCC dash 0 3 which means

639
00:29:42,160 --> 00:29:46,960
that one is actual GCC native code and

640
00:29:46,960 --> 00:29:48,429
these numbers are all for spider monkey

641
00:29:48,429 --> 00:29:53,500
and ta means typed arrays so most of the

642
00:29:53,500 --> 00:29:56,200
numbers especially over here in the

643
00:29:56,200 --> 00:29:58,630
typed array area are not bad at all

644
00:29:58,630 --> 00:30:00,549
between two times slower than native

645
00:30:00,549 --> 00:30:02,260
code and five times slower than native

646
00:30:02,260 --> 00:30:05,799
code with this one sort of more

647
00:30:05,799 --> 00:30:08,890
depressing test but overall these are

648
00:30:08,890 --> 00:30:11,590
not too bad I would say in addition a

649
00:30:11,590 --> 00:30:13,630
one of the faster ones dl malik is

650
00:30:13,630 --> 00:30:15,700
actually not just a benchmark these

651
00:30:15,700 --> 00:30:18,070
other ones are benchmarks some some of

652
00:30:18,070 --> 00:30:21,520
them are well-known some not but dl

653
00:30:21,520 --> 00:30:23,500
malik is actually real world code it's a

654
00:30:23,500 --> 00:30:25,570
malik implementation used in a lot of

655
00:30:25,570 --> 00:30:28,270
places so the results are not bad i

656
00:30:28,270 --> 00:30:31,960
would argue to look at data from a

657
00:30:31,960 --> 00:30:34,510
different perspective so the computer

658
00:30:34,510 --> 00:30:37,840
language that shootout benchmark site at

659
00:30:37,840 --> 00:30:41,230
thalia that debian compares a lot of

660
00:30:41,230 --> 00:30:43,090
languages so all these all the numbers

661
00:30:43,090 --> 00:30:46,030
here are again times slower than native

662
00:30:46,030 --> 00:30:48,549
code and you can see obviously by

663
00:30:48,549 --> 00:30:51,070
definition C and C++ on top are all

664
00:30:51,070 --> 00:30:54,760
lungs Java pretty close but there are

665
00:30:54,760 --> 00:30:56,919
some places where it doesn't quite get

666
00:30:56,919 --> 00:30:59,320
to native speed skala Haskell and

667
00:30:59,320 --> 00:31:01,090
c-sharp are also fairly close and on the

668
00:31:01,090 --> 00:31:04,220
bottom you have Python and Ruby dynamic

669
00:31:04,220 --> 00:31:07,570
things which are not so fast and

670
00:31:07,570 --> 00:31:09,380
JavaScript in the middle here this is

671
00:31:09,380 --> 00:31:13,130
our data not from the shootout I think

672
00:31:13,130 --> 00:31:14,390
it's fair that the numbers you are much

673
00:31:14,390 --> 00:31:16,250
closer to the languages on top then the

674
00:31:16,250 --> 00:31:19,610
languages on bottom so I think

675
00:31:19,610 --> 00:31:21,280
definitely the speed is in a good place

676
00:31:21,280 --> 00:31:24,409
and also this is without JavaScript

677
00:31:24,409 --> 00:31:27,110
engines optimizing for it at all there

678
00:31:27,110 --> 00:31:28,820
are a few minor things that if they did

679
00:31:28,820 --> 00:31:30,500
they could run this specific type of

680
00:31:30,500 --> 00:31:32,480
code much faster so things are

681
00:31:32,480 --> 00:31:33,950
definitely good reason to believe we can

682
00:31:33,950 --> 00:31:37,460
get very very very very close to native

683
00:31:37,460 --> 00:31:42,919
code but some notes about that so this

684
00:31:42,919 --> 00:31:44,870
be can vary greatly between benchmarks

685
00:31:44,870 --> 00:31:48,409
we saw that on the data here from two to

686
00:31:48,409 --> 00:31:51,770
eight and a half it's not consistent

687
00:31:51,770 --> 00:31:53,419
like you see and see where you pretty

688
00:31:53,419 --> 00:31:54,770
much know the performance of the code

689
00:31:54,770 --> 00:31:56,539
that you write least it's simple enough

690
00:31:56,539 --> 00:31:59,690
and Java which had a range of 123 but at

691
00:31:59,690 --> 00:32:01,640
least it's pretty contained so here we

692
00:32:01,640 --> 00:32:04,640
have non predictability which is

693
00:32:04,640 --> 00:32:06,409
problematic for performance especially

694
00:32:06,409 --> 00:32:08,299
since we have multiple browsers with

695
00:32:08,299 --> 00:32:11,020
different j/s engines so you have

696
00:32:11,020 --> 00:32:15,200
unexpected speeds in many cases issue 2

697
00:32:15,200 --> 00:32:16,909
we have bugs in JavaScript engines that

698
00:32:16,909 --> 00:32:19,299
often just lead to slowness for example

699
00:32:19,299 --> 00:32:22,370
the memory space the heap variable that

700
00:32:22,370 --> 00:32:25,190
I mentioned which represents memory so

701
00:32:25,190 --> 00:32:27,140
basically every read and write ends up

702
00:32:27,140 --> 00:32:29,510
being an access of this large JavaScript

703
00:32:29,510 --> 00:32:32,210
array if that's not fully optimized so

704
00:32:32,210 --> 00:32:34,460
that every read from it is a literal

705
00:32:34,460 --> 00:32:36,380
rate from memory and a right to it as

706
00:32:36,380 --> 00:32:38,780
literal right to memory if you need to

707
00:32:38,780 --> 00:32:40,280
do any additional work for example if

708
00:32:40,280 --> 00:32:44,000
the heap is implemented as a hashed as a

709
00:32:44,000 --> 00:32:47,480
hashmap it'll be very very slow so there

710
00:32:47,480 --> 00:32:48,830
are cases where chance engines get

711
00:32:48,830 --> 00:32:50,000
confused and they decide to implement

712
00:32:50,000 --> 00:32:54,860
the heap in a slow way also jess engines

713
00:32:54,860 --> 00:32:56,870
have typically been optimized for fairly

714
00:32:56,870 --> 00:32:59,090
small benchmarks and also caught on the

715
00:32:59,090 --> 00:33:00,590
web was typically quite small they've

716
00:33:00,590 --> 00:33:02,059
not been optimized for very large

717
00:33:02,059 --> 00:33:05,360
scripts but here we're compiling 10 20

718
00:33:05,360 --> 00:33:08,030
megabytes of C++ code and dumping it on

719
00:33:08,030 --> 00:33:11,570
the web so that raises some issues that

720
00:33:11,570 --> 00:33:13,399
need to be fixed but again these are

721
00:33:13,399 --> 00:33:16,390
bugs and hopefully will be resolved

722
00:33:16,390 --> 00:33:18,310
and on the other hand we have a lot of

723
00:33:18,310 --> 00:33:21,520
things in new features and chess engines

724
00:33:21,520 --> 00:33:24,370
that are making code run faster so so

725
00:33:24,370 --> 00:33:28,050
type inference as I say optimizations

726
00:33:28,050 --> 00:33:30,490
also as I said earlier it's possible

727
00:33:30,490 --> 00:33:31,600
that jazz engines could optimize

728
00:33:31,600 --> 00:33:34,150
specifically for this type of code so if

729
00:33:34,150 --> 00:33:36,100
all that put together I I would argue

730
00:33:36,100 --> 00:33:38,220
that we're not quite at the speed of

731
00:33:38,220 --> 00:33:41,320
native code yet but we are getting quite

732
00:33:41,320 --> 00:33:45,760
close finally I'll leave you with

733
00:33:45,760 --> 00:33:50,350
thought about the future so imagine that

734
00:33:50,350 --> 00:33:51,820
you could just write this this is

735
00:33:51,820 --> 00:33:56,110
harmony module syntax module it see from

736
00:33:56,110 --> 00:33:58,600
someplace import printf printf hello

737
00:33:58,600 --> 00:34:00,370
world but imagine that you could do this

738
00:34:00,370 --> 00:34:03,640
for any library in any language so

739
00:34:03,640 --> 00:34:05,950
JavaScript basically basically becomes a

740
00:34:05,950 --> 00:34:11,470
universal a language or environment I

741
00:34:11,470 --> 00:34:13,149
guess where everything can be compiled

742
00:34:13,149 --> 00:34:16,570
into it and because of that JavaScript

743
00:34:16,570 --> 00:34:19,149
can use any code that exists anywhere

744
00:34:19,149 --> 00:34:21,610
just compiled to JavaScript and use it

745
00:34:21,610 --> 00:34:24,399
in a convenient way so I think this

746
00:34:24,399 --> 00:34:26,830
could really be very very beneficial for

747
00:34:26,830 --> 00:34:29,580
us on the web and again as an example

748
00:34:29,580 --> 00:34:32,320
just sort of as a follow up for the what

749
00:34:32,320 --> 00:34:35,230
I mentioned before about audio we can

750
00:34:35,230 --> 00:34:39,310
compile an entire audio library to C++

751
00:34:39,310 --> 00:34:42,220
to JavaScript and use that instead of

752
00:34:42,220 --> 00:34:45,550
waiting for some web a peep from for a

753
00:34:45,550 --> 00:34:48,940
Web Audio API to be standardized the

754
00:34:48,940 --> 00:34:50,740
ability to use any code that we won on

755
00:34:50,740 --> 00:34:53,169
the web could really help us do whatever

756
00:34:53,169 --> 00:34:54,909
we want on the web which i think is a

757
00:34:54,909 --> 00:35:15,290
good thing yeah that's it

758
00:35:15,300 --> 00:35:22,150
questions and flow this is like crazy

759
00:35:22,150 --> 00:35:24,940
powerful it's cool so my first question

760
00:35:24,940 --> 00:35:27,250
was more about the kind of F open

761
00:35:27,250 --> 00:35:28,630
support you know the kind of like

762
00:35:28,630 --> 00:35:30,099
standard file operations where you said

763
00:35:30,099 --> 00:35:33,400
you mapped it to xml httprequest I mean

764
00:35:33,400 --> 00:35:34,710
are they synchronous or asynchronous

765
00:35:34,710 --> 00:35:37,119
well you could you could do it both ways

766
00:35:37,119 --> 00:35:40,750
you could do it but so it's asynchronous

767
00:35:40,750 --> 00:35:42,580
then you would need some way for the

768
00:35:42,580 --> 00:35:45,070
compiled code to know when they when

769
00:35:45,070 --> 00:35:46,450
they arrived which would mean you would

770
00:35:46,450 --> 00:35:48,640
be creating a little API in C++ that is

771
00:35:48,640 --> 00:35:51,580
not part of standard IOH right but the

772
00:35:51,580 --> 00:35:53,140
standard one is just synchronous the

773
00:35:53,140 --> 00:35:54,250
standard one is synchronous so the

774
00:35:54,250 --> 00:35:55,480
information we have now is synchronous

775
00:35:55,480 --> 00:35:57,070
yes but there's nothing stopping you

776
00:35:57,070 --> 00:35:59,140
again from implementing a tiny addition

777
00:35:59,140 --> 00:36:00,580
to standard ayah which would be

778
00:36:00,580 --> 00:36:03,970
asynchronous and we are I there is a

779
00:36:03,970 --> 00:36:06,869
little header which adds a few functions

780
00:36:06,869 --> 00:36:09,369
right now like for example it can that

781
00:36:09,369 --> 00:36:12,550
you basically run any script from C++

782
00:36:12,550 --> 00:36:16,240
code just by doing eval well so you can

783
00:36:16,240 --> 00:36:18,700
you can bridge both ways and you can

784
00:36:18,700 --> 00:36:20,200
definitely get a synchronous behavior if

785
00:36:20,200 --> 00:36:21,190
you want but again it would be an

786
00:36:21,190 --> 00:36:24,010
extension of the standard c-suite yeah

787
00:36:24,010 --> 00:36:25,060
there's an eye meter that was the thing

788
00:36:25,060 --> 00:36:27,339
I worried about ya so I kind of one more

789
00:36:27,339 --> 00:36:30,220
question sorry about is um right is

790
00:36:30,220 --> 00:36:32,290
anyone right in the kind of the the

791
00:36:32,290 --> 00:36:35,070
wrapper for a web-like OpenGL to WebGL

792
00:36:35,070 --> 00:36:37,660
yes I mean we can get so many games on

793
00:36:37,660 --> 00:36:39,400
the web then yes I would be extremely

794
00:36:39,400 --> 00:36:41,260
happy to have that so a few words about

795
00:36:41,260 --> 00:36:45,010
that there is an a so first of all a

796
00:36:45,010 --> 00:36:47,710
this project is fully open source of

797
00:36:47,710 --> 00:36:49,480
course it's on github etc there is a

798
00:36:49,480 --> 00:36:52,089
closed source project called Mandrell

799
00:36:52,089 --> 00:36:54,880
which it's it uses some amount of code

800
00:36:54,880 --> 00:36:56,560
from this project which I only know

801
00:36:56,560 --> 00:36:57,849
because if you look at the compiled code

802
00:36:57,849 --> 00:36:59,530
that they generate you can actually see

803
00:36:59,530 --> 00:37:03,070
bits of this in there however they they

804
00:37:03,070 --> 00:37:04,660
say that they wrote a compiler entirely

805
00:37:04,660 --> 00:37:07,420
from scratch so I'm not entirely sure

806
00:37:07,420 --> 00:37:09,430
where the truth is but anyhow my point

807
00:37:09,430 --> 00:37:11,619
is they have what you just asked about

808
00:37:11,619 --> 00:37:13,839
yeah they have a compiler for OpenGL to

809
00:37:13,839 --> 00:37:16,030
WebGL I have no idea how it works it's

810
00:37:16,030 --> 00:37:18,220
closed source but they have some demos

811
00:37:18,220 --> 00:37:21,099
of games just compiled to WebGL yeah I'm

812
00:37:21,099 --> 00:37:23,230
myself not in OpenGL hacker so I don't

813
00:37:23,230 --> 00:37:23,859
know but I would

814
00:37:23,859 --> 00:37:27,640
love to get help in doing this and the

815
00:37:27,640 --> 00:37:28,869
fact that there's a close thing that

816
00:37:28,869 --> 00:37:30,549
does it I think shows it it's possible

817
00:37:30,549 --> 00:37:33,220
yeah it'll be awesome I mean we coo coo

818
00:37:33,220 --> 00:37:44,440
thank you

819
00:37:44,450 --> 00:37:47,010
so the performance numbers you showed

820
00:37:47,010 --> 00:37:50,430
are basically I assume based on like a

821
00:37:50,430 --> 00:37:52,740
couple of runs right oh sure yeah yeah I

822
00:37:52,740 --> 00:37:55,170
mean they have reached right so I was

823
00:37:55,170 --> 00:37:56,520
wondering about to start up dying

824
00:37:56,520 --> 00:37:58,020
because I assume these funds are kind of

825
00:37:58,020 --> 00:38:00,870
large and I mean the thing that killed

826
00:38:00,870 --> 00:38:02,970
and one of the thing that killed Java

827
00:38:02,970 --> 00:38:05,520
applets was startup night so in an issue

828
00:38:05,520 --> 00:38:08,580
well yes I mean if you look 10 megabytes

829
00:38:08,580 --> 00:38:10,350
of JavaScript code just the parsing

830
00:38:10,350 --> 00:38:13,770
takes some amount of time and depending

831
00:38:13,770 --> 00:38:16,950
on the engine there were there bugs and

832
00:38:16,950 --> 00:38:18,810
all the engines about trying to compile

833
00:38:18,810 --> 00:38:20,130
code to eagerly but they're getting

834
00:38:20,130 --> 00:38:21,740
better about them so they don't optimize

835
00:38:21,740 --> 00:38:25,230
too early so yes there is some startup

836
00:38:25,230 --> 00:38:29,190
issue probably not represented in these

837
00:38:29,190 --> 00:38:31,080
tests because they were all designed to

838
00:38:31,080 --> 00:38:33,480
run for a reasonable amount of time so

839
00:38:33,480 --> 00:38:36,600
if it tests takes just the one one

840
00:38:36,600 --> 00:38:38,580
millisecond in C in C it's not

841
00:38:38,580 --> 00:38:40,140
reasonable to compare it to anything so

842
00:38:40,140 --> 00:38:41,640
I think most of these run at about one

843
00:38:41,640 --> 00:38:45,410
second and see so startup is pretty much

844
00:38:45,410 --> 00:38:48,030
eliminated but there is some amount of

845
00:38:48,030 --> 00:38:49,920
startup issue yes and it'll be hard to

846
00:38:49,920 --> 00:38:56,540
eliminate entirely

847
00:38:56,550 --> 00:39:00,300
how viable would it be to say use a

848
00:39:00,300 --> 00:39:04,930
javascript library of GCC compiled with

849
00:39:04,930 --> 00:39:09,580
em script at javascript library yeah it

850
00:39:09,580 --> 00:39:11,800
like create a JavaScript library with

851
00:39:11,800 --> 00:39:18,670
and script ug sorry GCC gpg I jpg I

852
00:39:18,670 --> 00:39:20,230
would like to say I would like to have

853
00:39:20,230 --> 00:39:22,960
gpg in java and i would like to compile

854
00:39:22,960 --> 00:39:25,450
it with em script how viable would it be

855
00:39:25,450 --> 00:39:27,370
to means that in production is it fast

856
00:39:27,370 --> 00:39:30,730
enough I mean this I mean I I would

857
00:39:30,730 --> 00:39:32,860
assume yes unless there's some technical

858
00:39:32,860 --> 00:39:36,310
detail to the implementation mg of gpg

859
00:39:36,310 --> 00:39:38,020
that I'm not aware of but it's pretty

860
00:39:38,020 --> 00:39:41,290
typical it right there dig if they don't

861
00:39:41,290 --> 00:39:43,120
use any magical so you would go to

862
00:39:43,120 --> 00:39:45,490
reduction with something like that what

863
00:39:45,490 --> 00:39:46,900
I think it could work yes I haven't

864
00:39:46,900 --> 00:39:48,880
actually tried it but I don't see any

865
00:39:48,880 --> 00:40:08,720
reason why not

866
00:40:08,730 --> 00:40:10,860
hi I was wondering what the memory use

867
00:40:10,860 --> 00:40:14,100
is like let's say I have a 100k lightly

868
00:40:14,100 --> 00:40:16,320
as a library that would generate hundred

869
00:40:16,320 --> 00:40:18,480
K of native code how big does the

870
00:40:18,480 --> 00:40:20,790
javascript file end up being to download

871
00:40:20,790 --> 00:40:22,590
and and how much memory is it going to

872
00:40:22,590 --> 00:40:25,080
take in the browser when it runs and it

873
00:40:25,080 --> 00:40:29,190
ends up after run it through through a

874
00:40:29,190 --> 00:40:33,450
min afire it ends up similar size to the

875
00:40:33,450 --> 00:40:36,540
native code x actually may be a factor

876
00:40:36,540 --> 00:40:38,720
of one and a half or so but it's not

877
00:40:38,720 --> 00:40:42,660
ridiculously low it large but after you

878
00:40:42,660 --> 00:40:45,030
run gzip on it assuming your website she

879
00:40:45,030 --> 00:40:46,590
sips everything it basically ends up the

880
00:40:46,590 --> 00:40:50,190
same size so in terms of that in terms

881
00:40:50,190 --> 00:40:51,960
of code size I think it's very

882
00:40:51,960 --> 00:40:54,480
comparable to native code as far as the

883
00:40:54,480 --> 00:40:57,330
amount of memory it takes a the amount

884
00:40:57,330 --> 00:41:00,300
of memory that compiled code takes it

885
00:41:00,300 --> 00:41:02,640
depends on the jas engine I don't know

886
00:41:02,640 --> 00:41:05,160
actual numbers the amount of memory

887
00:41:05,160 --> 00:41:08,160
taken at runtime so actually as a slide

888
00:41:08,160 --> 00:41:11,190
here shows there there are a few options

889
00:41:11,190 --> 00:41:14,010
there like then getting to almost any of

890
00:41:14,010 --> 00:41:15,180
the technical details but there are a

891
00:41:15,180 --> 00:41:17,640
few ways to generate code one of the

892
00:41:17,640 --> 00:41:19,710
ways uses typed arrays with a shared

893
00:41:19,710 --> 00:41:22,200
memory buffer in which case the amount

894
00:41:22,200 --> 00:41:23,970
of memory you would use at runtime again

895
00:41:23,970 --> 00:41:25,860
aside for code the amount of memory for

896
00:41:25,860 --> 00:41:27,600
data would be a hundred percent

897
00:41:27,600 --> 00:41:29,970
identical to C++ because you be using a

898
00:41:29,970 --> 00:41:32,310
typed array that's literally the same

899
00:41:32,310 --> 00:41:36,060
thing so you can use a very similar

900
00:41:36,060 --> 00:41:37,920
amount of memory in this as to the

901
00:41:37,920 --> 00:41:43,380
native code version hi so um you you

902
00:41:43,380 --> 00:41:47,520
compile the sea I mean lvm compiled the

903
00:41:47,520 --> 00:41:51,410
C or C++ to bytecode to lv my code and

904
00:41:51,410 --> 00:41:54,360
you can buy this bytecode to to

905
00:41:54,360 --> 00:41:56,640
JavaScript yes by doing that apparently

906
00:41:56,640 --> 00:41:58,620
you lose viable names and you have some

907
00:41:58,620 --> 00:42:01,620
sort of ritual reverse-engineering to do

908
00:42:01,620 --> 00:42:06,050
too yes recreate while oops why not

909
00:42:06,050 --> 00:42:09,750
compiling directly from C or C++ using

910
00:42:09,750 --> 00:42:14,640
ceiling or and yes I mean that was one

911
00:42:14,640 --> 00:42:17,370
one approach for this compiling see

912
00:42:17,370 --> 00:42:19,200
directly would probably be pretty

913
00:42:19,200 --> 00:42:20,430
reasonable

914
00:42:20,430 --> 00:42:24,440
but C++ is horribly complicated to parse

915
00:42:24,440 --> 00:42:26,570
ridiculously complicated I

916
00:42:26,570 --> 00:42:29,160
underestimated its you don't want to

917
00:42:29,160 --> 00:42:32,160
write it write that from stretch it took

918
00:42:32,160 --> 00:42:34,560
ceilings several years of intensive

919
00:42:34,560 --> 00:42:36,180
effort to get to the point where now it

920
00:42:36,180 --> 00:42:39,360
can compile most C++ code so that's

921
00:42:39,360 --> 00:42:42,270
simply too much work to do but second

922
00:42:42,270 --> 00:42:45,360
point by compiling the bit code you can

923
00:42:45,360 --> 00:42:47,070
potentially compile many more languages

924
00:42:47,070 --> 00:42:49,470
if you get Haskell to compile to hell

925
00:42:49,470 --> 00:42:51,120
via a bit code which I believe it can

926
00:42:51,120 --> 00:42:52,500
there's no reason why you couldn't

927
00:42:52,500 --> 00:42:54,960
compile that into JavaScript too so

928
00:42:54,960 --> 00:42:56,730
there's also a benefit from that and

929
00:42:56,730 --> 00:43:00,210
third part to the answer yes there is a

930
00:43:00,210 --> 00:43:02,310
lot of additional work to get back at

931
00:43:02,310 --> 00:43:04,800
the high level data that you lost but I

932
00:43:04,800 --> 00:43:07,200
think we're pretty close to getting

933
00:43:07,200 --> 00:43:09,090
there so it is much more feasible to do

934
00:43:09,090 --> 00:43:15,840
that then to compile the C++ hi um I was

935
00:43:15,840 --> 00:43:17,760
wondering are you modifying the native

936
00:43:17,760 --> 00:43:19,440
code to not depend on integer overflow

937
00:43:19,440 --> 00:43:21,930
are you actually clipping every integer

938
00:43:21,930 --> 00:43:25,290
after every operation and first of all

939
00:43:25,290 --> 00:43:27,270
it would be better if you would modify

940
00:43:27,270 --> 00:43:29,910
than the original source code to not

941
00:43:29,910 --> 00:43:32,010
rely and overflows etc but that's not

942
00:43:32,010 --> 00:43:38,630
realistic so yeah very briefly to get

943
00:43:38,630 --> 00:43:41,280
precise behavior you do need to do

944
00:43:41,280 --> 00:43:44,010
clipping and so forth and I think I have

945
00:43:44,010 --> 00:43:45,480
a slight which mentions a few of the

946
00:43:45,480 --> 00:43:48,330
issues there overflows also signs and

947
00:43:48,330 --> 00:43:52,950
rounding part of the reason why getting

948
00:43:52,950 --> 00:43:54,990
optimized code takes time is that the

949
00:43:54,990 --> 00:43:57,660
default setting will perform that

950
00:43:57,660 --> 00:43:59,430
clipping and sign correction etc on

951
00:43:59,430 --> 00:44:01,500
every line of code which makes it very

952
00:44:01,500 --> 00:44:04,800
slow but the optimizer can do sort of

953
00:44:04,800 --> 00:44:07,170
like like pgo it can basically run the

954
00:44:07,170 --> 00:44:09,540
code see where it actually needs to do

955
00:44:09,540 --> 00:44:12,150
those Corrections generate a profile and

956
00:44:12,150 --> 00:44:14,040
then compile it with that and only

957
00:44:14,040 --> 00:44:15,980
perform the corrections where necessary

958
00:44:15,980 --> 00:44:18,810
so the right way to get fast before my

959
00:44:18,810 --> 00:44:20,190
code is either to modify the original

960
00:44:20,190 --> 00:44:22,440
source so it doesn't need it or to do

961
00:44:22,440 --> 00:44:24,690
this pgo like thing which is a tool that

962
00:44:24,690 --> 00:44:26,580
comes with a compile that basically gets

963
00:44:26,580 --> 00:44:30,570
you to the same place I hope that makes

