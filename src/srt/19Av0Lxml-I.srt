1
00:00:14,870 --> 00:00:15,870
Thanks.

2
00:00:15,870 --> 00:00:18,700
So yeah, I'm really excited to be here, talking
about making

3
00:00:18,700 --> 00:00:21,620
relational cool again, and the subtitle is...

4
00:00:21,620 --> 00:00:23,420
Or JavaScript on ACID.

5
00:00:23,420 --> 00:00:27,210
And like
I said, my name is Tim Griesser, Tgriesser

6
00:00:27,210 --> 00:00:31,140
on Github, and I'm here really
excited to be talking about SQL.

7
00:00:31,140 --> 00:00:34,390
Or is it Ess-kyoo-ell?

8
00:00:34,390 --> 00:00:40,390
I know it's an issue
that really divides programmers.

9
00:00:40,390 --> 00:00:46,700
So I Googled it, and the first result I came
across was this English language and use in

10
00:00:46,700 --> 00:00:47,969
Stack Exchange.

11
00:00:47,969 --> 00:00:51,440
Which I thought
was fitting, given that we're at a programming

12
00:00:51,440 --> 00:00:53,180
conference.

13
00:00:53,180 --> 00:00:55,760
And the first thing
you'll notice is I'm not a member of the English

14
00:00:55,760 --> 00:01:01,129
language and usage, so if I
make any mistakes up here, you'll know why.

15
00:01:01,129 --> 00:01:05,260
But the answer was that it was in
fact first called the structured English query

16
00:01:05,260 --> 00:01:08,430
language, and so that acronym
was SEQUEL.

17
00:01:08,430 --> 00:01:15,070
And then that was abbreviated as SQL.

18
00:01:15,070 --> 00:01:16,570
Now it's a matter of
preference.

19
00:01:16,570 --> 00:01:18,900
And there's an urban legend that it came after
the structured

20
00:01:18,900 --> 00:01:25,610
query language, which is the worst urban legend
I ever heard.

21
00:01:25,610 --> 00:01:30,320
So I learned
something new, and now I'm a member.

22
00:01:30,320 --> 00:01:35,570
It was a big day.

23
00:01:35,570 --> 00:01:39,120
But it's appropriate
that we're talking about relational databases

24
00:01:39,120 --> 00:01:43,090
at a JavaScript conference,
because I think there's a lot of similar features

25
00:01:43,090 --> 00:01:45,100
between the two.

26
00:01:45,100 --> 00:01:47,550
At a
language level, maybe not so much.

27
00:01:47,550 --> 00:01:53,670
Relational, SQL is static and strongly
typed, declarative, and in some ways procedural,

28
00:01:53,670 --> 00:01:58,280
and JavaScript is as loosely
typed as you can get while still being a programming

29
00:01:58,280 --> 00:02:05,950
language, and it's object
oriented, which leads to some interesting

30
00:02:05,950 --> 00:02:12,840
debates as to how to write the code
correctly, and it shares some of the same

31
00:02:12,840 --> 00:02:17,590
operators, but we know in JavaScript
the operators don't do what we want some of

32
00:02:17,590 --> 00:02:19,720
the time.

33
00:02:19,720 --> 00:02:23,280
So what do I mean when I
say is theres a lot of similarities between

34
00:02:23,280 --> 00:02:25,280
SQL and JavaScript?

35
00:02:25,280 --> 00:02:29,680
They both sort
of share this similar quality that is not

36
00:02:29,680 --> 00:02:33,689
often attained by all languages,
which is what I like to term -- languages

37
00:02:33,689 --> 00:02:36,319
that will probably never die.

38
00:02:36,319 --> 00:02:38,900
As
much as people try to kill off JavaScript

39
00:02:38,900 --> 00:02:44,170
with different other languages that
will supersede it, it sort has this monopoly.

40
00:02:44,170 --> 00:02:45,500
It's the language of the web.

41
00:02:45,500 --> 00:02:47,819
It's the language that runs in web browsers.

42
00:02:47,819 --> 00:02:51,200
And similarly, SQL has so much
momentum.

43
00:02:51,200 --> 00:02:55,519
It's been around since the '70s and it's been
around forever.

44
00:02:55,519 --> 00:02:58,379
This
is a slide that we often show when we're talking

45
00:02:58,379 --> 00:03:01,200
about JavaScript, just sort
of illustrating that it runs everywhere.

46
00:03:01,200 --> 00:03:05,790
In the browsers, but also your
television and your server and your nodebots

47
00:03:05,790 --> 00:03:09,430
and copters and also on your
phones, and I think the same could be sort

48
00:03:09,430 --> 00:03:10,750
of said about SQL.

49
00:03:10,750 --> 00:03:13,529
Is that it
powers the largest websites in the world.

50
00:03:13,529 --> 00:03:21,200
It's behind Facebook and Wikipedia,
and also down to SQL-lite, flat file storage,

51
00:03:21,200 --> 00:03:27,760
which is in more places than you
would imagine on your phones.

52
00:03:27,760 --> 00:03:31,350
So coming to node.js a couple years ago, I
was

53
00:03:31,350 --> 00:03:32,420
sort of surprised.

54
00:03:32,420 --> 00:03:34,930
It seems like these two would be such a great
fit.

55
00:03:34,930 --> 00:03:37,769
They're
both everywhere.

56
00:03:37,769 --> 00:03:40,810
Why is there not more support for it?

57
00:03:40,810 --> 00:03:44,819
And I think the reason
is that node starts with no, and no is the

58
00:03:44,819 --> 00:03:50,650
beginning of NoSQL, and around the
time that node came out, it was like -- let's

59
00:03:50,650 --> 00:03:55,170
rethink the entire way that
we're writing server side applications with

60
00:03:55,170 --> 00:03:56,700
this evented IO model.

61
00:03:56,700 --> 00:04:00,200
And at the
time, it was sort of like -- let's rethink

62
00:04:00,200 --> 00:04:04,540
the standard relational database,
because we're hitting web scale and we need

63
00:04:04,540 --> 00:04:07,269
to get past that.

64
00:04:07,269 --> 00:04:13,769
And so around the time that sort of the height
of the NoSQL phase or moment --

65
00:04:13,769 --> 00:04:18,421
it's still going, of course -- is when node
came out, and that's why there was

66
00:04:18,421 --> 00:04:19,421
so much of this.

67
00:04:19,421 --> 00:04:23,389
So all the tutorials I felt like for node
were node and

68
00:04:23,389 --> 00:04:26,500
Mongo, getting started -- they have literally
taken the software and web

69
00:04:26,500 --> 00:04:31,740
industries by storm.

70
00:04:31,740 --> 00:04:34,470
You've got Mongo express angular node, which
everybody

71
00:04:34,470 --> 00:04:44,620
has heard of, and then my favorite, the LeBron
stack, level DB slam dunk.

72
00:04:44,620 --> 00:04:47,460
And
what happened to relational algebra?

73
00:04:47,460 --> 00:04:48,460
Right?

74
00:04:48,460 --> 00:04:50,860
This is proven and time tested.

75
00:04:50,860 --> 00:04:55,400
And SQL works great for a lot of things.

76
00:04:55,400 --> 00:04:59,400
And this stack overflow post that I
came across sort of summed up what I was thinking,

77
00:04:59,400 --> 00:05:03,759
coming to node from
outside.

78
00:05:03,759 --> 00:05:06,340
Are relational databases a poor fit?

79
00:05:06,340 --> 00:05:09,660
And this is sort of long, so let me just
pick out a few things.

80
00:05:09,660 --> 00:05:15,139
There's a degree of antipathy toward relational
databases, is an observation you could make

81
00:05:15,139 --> 00:05:17,479
of the node community.

82
00:05:17,479 --> 00:05:20,710
And that
they're poorly supported, compared to non-relational

83
00:05:20,710 --> 00:05:21,710
databases.

84
00:05:21,710 --> 00:05:22,810
I sort of
agree with this.

85
00:05:22,810 --> 00:05:27,580
Listening to the node up podcasts, listening
to couch DB and

86
00:05:27,580 --> 00:05:33,159
Mongo, I guess it was like -- relational databases
aren't cool anymore.

87
00:05:33,159 --> 00:05:36,851
I dug
a little and found there actually are really

88
00:05:36,851 --> 00:05:42,280
great libraries for working with
SQL in node.

89
00:05:42,280 --> 00:05:52,320
All the popular Open Source, and Oracle came
out with another

90
00:05:52,320 --> 00:05:53,320
one.

91
00:05:53,320 --> 00:05:57,229
But there's not a common API all of them.

92
00:05:57,229 --> 00:06:01,120
Node didn't assume that a
relational database was a given.

93
00:06:01,120 --> 00:06:07,259
In all other language systems, there's a
standard for how you're interacting with common

94
00:06:07,259 --> 00:06:08,800
patterns of a database.

95
00:06:08,800 --> 00:06:11,169
How
you connect, how you disconnect.

96
00:06:11,169 --> 00:06:12,169
That doesn't exist.

97
00:06:12,169 --> 00:06:16,539
So what that lends to is
that all the different clients have a different

98
00:06:16,539 --> 00:06:20,370
way of dealing with these
things that should be pretty common.

99
00:06:20,370 --> 00:06:25,379
And there's also, I guess -- the next
thing I noticed was that the higher level

100
00:06:25,379 --> 00:06:27,960
abstractions were lacking a little
bit.

101
00:06:27,960 --> 00:06:31,150
And what I mean by that is that a lot of them
were database-specific.

102
00:06:31,150 --> 00:06:34,039
So there
was a great query builder, but it works for

103
00:06:34,039 --> 00:06:36,509
postgres, specifically.

104
00:06:36,509 --> 00:06:39,940
Another
great one for another language, and no way

105
00:06:39,940 --> 00:06:42,440
to use the same for both.

106
00:06:42,440 --> 00:06:43,740
Different
APIs.

107
00:06:43,740 --> 00:06:47,120
Or there's a mix of an ORM layer and a query
layer, so there's no

108
00:06:47,120 --> 00:06:52,189
ability to drop down and use just vanilla
SQL if you need to.

109
00:06:52,189 --> 00:06:55,659
One that was big
for me is the lack of transaction APIs.

110
00:06:55,659 --> 00:06:58,300
So there wasn't any mention of
transactions.

111
00:06:58,300 --> 00:07:01,350
In any of the higher level libraries that
I had seen at the

112
00:07:01,350 --> 00:07:02,350
time.

113
00:07:02,350 --> 00:07:05,840
And that is sort of what the second subtitle
of the talk is that I'll

114
00:07:05,840 --> 00:07:06,979
get to in a little bit.

115
00:07:06,979 --> 00:07:09,129
And then there was the jack of all trades,
where it's

116
00:07:09,129 --> 00:07:14,610
sort of like -- hey, you can use the same
save API to save to Redis or Mongo

117
00:07:14,610 --> 00:07:17,460
or relational database or the file system.

118
00:07:17,460 --> 00:07:18,479
It's like...

119
00:07:18,479 --> 00:07:23,289
If you have the same
API for all these different specialized data

120
00:07:23,289 --> 00:07:28,020
stores, you're really not taking
advantage of the best use cases for each of

121
00:07:28,020 --> 00:07:29,020
them.

122
00:07:29,020 --> 00:07:30,940
Or there's sort of what I
call the DIY.

123
00:07:30,940 --> 00:07:34,180
Like, it gets you most of the way, but modularity.

124
00:07:34,180 --> 00:07:37,500
So you have
to assemble all these.

125
00:07:37,500 --> 00:07:41,330
The pooling, the construction, the abstracting
the

126
00:07:41,330 --> 00:07:42,990
database API.

127
00:07:42,990 --> 00:07:46,941
So the ecosystem -- I would definitely agree
with the Stack

128
00:07:46,941 --> 00:07:53,560
Overflow post, that there's a need there,
that needs to be filled.

129
00:07:53,560 --> 00:07:55,200
But I really wanted this to happen.

130
00:07:55,200 --> 00:07:56,720
I really love writing JavaScript.

131
00:07:56,720 --> 00:07:58,460
So I was
like...

132
00:07:58,460 --> 00:07:59,870
Maybe we can do something better.

133
00:07:59,870 --> 00:08:02,880
And at the time, I had been writing
a lot of PHP.

134
00:08:02,880 --> 00:08:06,569
This was back in 2012, in a framework called
Laravel, which some

135
00:08:06,569 --> 00:08:07,569
might have heard of.

136
00:08:07,569 --> 00:08:13,759
And it makes writing PHP pretty tolerable.

137
00:08:13,759 --> 00:08:15,560
And I was also
using a lot of backbones.

138
00:08:15,560 --> 00:08:16,560
So I was thinking...

139
00:08:16,560 --> 00:08:20,410
Maybe I can take some of the
ideas from both of these, and I sort of translated

140
00:08:20,410 --> 00:08:25,280
the query builder from
Laravel into this project called Knex.JS.

141
00:08:25,280 --> 00:08:29,800
And this sort of illustrates what
pieces were taken from each, but the eloquent

142
00:08:29,800 --> 00:08:33,950
ORM from Laravel and some of the
ideas from backbone into bookshelf, and mix

143
00:08:33,950 --> 00:08:38,840
into promises -- and so I'm going
to talk about these two libraries that I have

144
00:08:38,840 --> 00:08:41,530
put together, connects and
bookshelf.

145
00:08:41,530 --> 00:08:43,470
The first is Knex.

146
00:08:43,470 --> 00:08:48,889
If you're not familiar with where the name
comes from, it's this toy that was popular

147
00:08:48,889 --> 00:08:50,570
in the '90s.

148
00:08:50,570 --> 00:08:53,010
It's sort of like a
cheaper version of Legos.

149
00:08:53,010 --> 00:08:56,070
You can assemble all these pieces together
and build

150
00:08:56,070 --> 00:08:58,310
pretty cool-looking things.

151
00:08:58,310 --> 00:09:04,529
And actually, it's really great if you're
procrastinating, making conference slides.

152
00:09:04,529 --> 00:09:09,560
I decided to make this little
motorcycle here.

153
00:09:09,560 --> 00:09:14,089
All right, JSConf.

154
00:09:14,089 --> 00:09:16,950
But the reason that I think...

155
00:09:16,950 --> 00:09:22,279
What Knex
tries to do is standardize some of the inconsistencies

156
00:09:22,279 --> 00:09:23,440
in SQL.

157
00:09:23,440 --> 00:09:28,420
So SQL is a
language -- an ANSI language specification.

158
00:09:28,420 --> 00:09:33,949
But it's not like it is, what
we're used to with, like, ES5 or ES6 and beyond.

159
00:09:33,949 --> 00:09:36,930
Where we sort of have this
compatibility table, and we see that Babel

160
00:09:36,930 --> 00:09:41,519
is in ahead of everything else, in
terms of implementing all the different features.

161
00:09:41,519 --> 00:09:45,339
But it feels more like the
can I use.

162
00:09:45,339 --> 00:09:47,060
Sort of like a language guideline.

163
00:09:47,060 --> 00:09:55,300
There are features that exist in
some dialects but not others.

164
00:09:55,300 --> 00:09:59,170
It doesn't fail, or it fails sometimes, or
--

165
00:09:59,170 --> 00:10:04,310
different inconsistencies that Knex tries
to paper over.

166
00:10:04,310 --> 00:10:07,370
This is an
illustration of the different pieces as they're

167
00:10:07,370 --> 00:10:09,490
coming over internally.

168
00:10:09,490 --> 00:10:12,170
Have
things like connection pooling, to make sure

169
00:10:12,170 --> 00:10:14,779
you're getting connections that
you don't have to continually reconnect to

170
00:10:14,779 --> 00:10:19,040
the database every time you reissue
a query, mixes in different grammars from

171
00:10:19,040 --> 00:10:25,529
the different dialects, and creates
a client that's used in the schema and normal

172
00:10:25,529 --> 00:10:27,680
query building, as well as
transactions.

173
00:10:27,680 --> 00:10:30,610
Which I sort of break out entirely, because
I'm going to spend a

174
00:10:30,610 --> 00:10:35,050
little bit of time on those, and on top of
that, we have higher level APIs for

175
00:10:35,050 --> 00:10:39,399
doing some familiar migrations and seeding
as you would see for something like

176
00:10:39,399 --> 00:10:41,040
Rails.

177
00:10:41,040 --> 00:10:45,100
So how you get started with Knex is just give
it a connection string.

178
00:10:45,100 --> 00:10:47,730
If you
want to configure the pool, you can do that.

179
00:10:47,730 --> 00:10:51,720
And it works against a number of
different databases.

180
00:10:51,720 --> 00:10:53,360
Including Oracle, which is pretty cool.

181
00:10:53,360 --> 00:10:54,760
Somebody just
opened a pull request.

182
00:10:54,760 --> 00:10:57,079
And it's like -- oh, I don't use Oracle, but
it's

183
00:10:57,079 --> 00:11:00,209
awesome that you opened a pull request.

184
00:11:00,209 --> 00:11:01,500
Yay, Open Source.

185
00:11:01,500 --> 00:11:05,070
And it also supports
web SQL, but I don't really recommend that,

186
00:11:05,070 --> 00:11:07,820
because that's deprecated.

187
00:11:07,820 --> 00:11:11,100
Browsers killed that off.

188
00:11:11,100 --> 00:11:20,410
So you can select all from accounts, where
activated

189
00:11:20,410 --> 00:11:24,700
is one, and then you call then on it, and
it has the familiar promise chaining

190
00:11:24,700 --> 00:11:29,139
API, so it issues that query and returns the
result of the query and then you

191
00:11:29,139 --> 00:11:34,120
can catch the error if that happens in the
standard promise -- it's actually

192
00:11:34,120 --> 00:11:37,180
great that I don't have to argue too much
in favor of promise, now that

193
00:11:37,180 --> 00:11:38,180
they're actually in the spec.

194
00:11:38,180 --> 00:11:43,779
But when I was starting out, that was a thing,
whether it was -- it was still up for debate

195
00:11:43,779 --> 00:11:46,339
whether you should use that.

196
00:11:46,339 --> 00:11:47,560
Also it does joins.

197
00:11:47,560 --> 00:11:50,529
I don't have to read it out too much, but
joins with

198
00:11:50,529 --> 00:11:55,550
multiple clauses, and then subqueries, so
anywhere -- so here we have a where

199
00:11:55,550 --> 00:12:00,279
in clause, and anywhere you might want to
use a subquery, the general rule of

200
00:12:00,279 --> 00:12:05,079
thumb is that you can pass a function and
then use the context of that closure

201
00:12:05,079 --> 00:12:07,920
as a new subquery.

202
00:12:07,920 --> 00:12:10,970
And then from there, I'm not going to dive
into all the

203
00:12:10,970 --> 00:12:13,269
features, because that's what documentation
is for.

204
00:12:13,269 --> 00:12:16,100
But you can do raw
queries, like if you have a specialized query

205
00:12:16,100 --> 00:12:17,779
that you don't want to...

206
00:12:17,779 --> 00:12:19,399
That
maybe does some things that aren't supported

207
00:12:19,399 --> 00:12:26,300
by Knex, you can issue those,
aggregates, subquery aliasing, and it tries

208
00:12:26,300 --> 00:12:28,660
hard not to let you screw up.

209
00:12:28,660 --> 00:12:31,320
It
tries to catch different errors or paper over

210
00:12:31,320 --> 00:12:35,910
things for you, so you don't
make too many mistakes.

211
00:12:35,910 --> 00:12:38,829
And so the subtitle of the talk, as I mentioned,
is

212
00:12:38,829 --> 00:12:40,029
JavaScript on ACID.

213
00:12:40,029 --> 00:12:44,420
So this is not the ACID test, which...

214
00:12:44,420 --> 00:12:47,130
Some are probably
familiar with.

215
00:12:47,130 --> 00:12:50,310
I've mentioned this to someone, and they're
like -- oh, you mean the browser

216
00:12:50,310 --> 00:12:51,310
suite?

217
00:12:51,310 --> 00:12:52,310
No.

218
00:12:52,310 --> 00:12:53,310
Let me look that up, though.

219
00:12:53,310 --> 00:12:57,070
It's good to know that Chrome is
passing the ACID 3 test, as of today.

220
00:12:57,070 --> 00:13:03,980
But I mean atomicity, consistency,
isolation, and durability.

221
00:13:03,980 --> 00:13:06,851
I'm not going to go into each of them, because
that

222
00:13:06,851 --> 00:13:12,950
could be a separate talk about each of the
individual terms.

223
00:13:12,950 --> 00:13:16,050
But transactions
-- I sort of sum up that.

224
00:13:16,050 --> 00:13:18,480
What they do is give you the ability to have
a

225
00:13:18,480 --> 00:13:22,410
snapshot state of the world as you're working
with your database.

226
00:13:22,410 --> 00:13:25,500
So what it
allows you to do is roll back to a certain

227
00:13:25,500 --> 00:13:31,399
point in time, and also prevent
other connections that might be working against

228
00:13:31,399 --> 00:13:35,649
your databases, from altering
rows as you're working within a single atomic

229
00:13:35,649 --> 00:13:38,100
unit of state.

230
00:13:38,100 --> 00:13:41,470
And this is kind
of difficult to do in node.

231
00:13:41,470 --> 00:13:46,441
You have to think about this API in advance,
because in order for this to work, you have

232
00:13:46,441 --> 00:13:51,160
to have the same database
connection passed to every single query that

233
00:13:51,160 --> 00:13:53,050
you're working against.

234
00:13:53,050 --> 00:13:55,110
So it's
not like in synchronous languages, where you

235
00:13:55,110 --> 00:13:58,920
could just sort of say -- okay,
start transaction here, and then all of these

236
00:13:58,920 --> 00:14:01,630
will run right here, and then
end it right here.

237
00:14:01,630 --> 00:14:03,190
Because you sort of...

238
00:14:03,190 --> 00:14:10,050
With the event I/O model, you sort
of lose that context as you go with the callback.

239
00:14:10,050 --> 00:14:11,170
You don't really know what's
happening.

240
00:14:11,170 --> 00:14:16,450
So the connection explicitly has to be passed
to every query.

241
00:14:16,450 --> 00:14:18,900
So
let's think about a situation where we would

242
00:14:18,900 --> 00:14:20,259
actually want to use
transactions.

243
00:14:20,259 --> 00:14:24,740
So here's a simple user flow situation, where
someone is registering for a

244
00:14:24,740 --> 00:14:25,740
website.

245
00:14:25,740 --> 00:14:28,540
And they register, and you give them an ID
and you have to send that

246
00:14:28,540 --> 00:14:32,790
to a third party service and then you have
to create maybe some other rows for

247
00:14:32,790 --> 00:14:34,950
that user, and then it's all done.

248
00:14:34,950 --> 00:14:36,399
They're all registered.

249
00:14:36,399 --> 00:14:40,660
So let's think
about what could go wrong in these four steps.

250
00:14:40,660 --> 00:14:45,220
So first you might depend on a
module which doesn't follow semantic versioning.

251
00:14:45,220 --> 00:14:48,819
So something breaks, and it's
completely out of your control, or the third

252
00:14:48,819 --> 00:14:53,269
party API that you're working
against sort of shuts down, and your data

253
00:14:53,269 --> 00:14:55,140
gets into a bad state.

254
00:14:55,140 --> 00:14:58,830
So in order
to deal with that, then, after step 2, if

255
00:14:58,830 --> 00:15:02,490
that fails, then you would have to
undo what happened in step 1.

256
00:15:02,490 --> 00:15:08,850
Or in step 3, where you're creating additional
rows to deal with that new user, maybe one

257
00:15:08,850 --> 00:15:12,930
or a few of them failed, so then
you have to make sure the ones that did go

258
00:15:12,930 --> 00:15:17,819
through get rolled back, and then
you have to unregister the user, and then

259
00:15:17,819 --> 00:15:20,160
say -- hey, something messed up.

260
00:15:20,160 --> 00:15:22,630
And
that ends up pushing a lot of logic into your

261
00:15:22,630 --> 00:15:24,279
application code that you have
to deal with.

262
00:15:24,279 --> 00:15:26,399
All of these potential bad states.

263
00:15:26,399 --> 00:15:30,029
Or you just don't deal with it, and then you
have potentially bad data in your

264
00:15:30,029 --> 00:15:31,029
application.

265
00:15:31,029 --> 00:15:34,250
Because you want this whole register user
flow to happen as one

266
00:15:34,250 --> 00:15:36,440
atomic event.

267
00:15:36,440 --> 00:15:39,140
Or here's another situation that can't be
handled by the last

268
00:15:39,140 --> 00:15:40,140
one.

269
00:15:40,140 --> 00:15:44,390
Your servers just catch on fire halfway through
registering the user.

270
00:15:44,390 --> 00:15:45,390
And
actually...

271
00:15:45,390 --> 00:15:47,790
I created these libraries so I would one day
have the ability to

272
00:15:47,790 --> 00:15:50,480
use this graphic in a keynote.

273
00:15:50,480 --> 00:15:51,730
No.

274
00:15:51,730 --> 00:15:52,970
But...

275
00:15:52,970 --> 00:15:59,220
So what Knex tries to do is you can
say Knex transaction, and then it creates

276
00:15:59,220 --> 00:16:04,130
an instance that you treat as a
normal query builder instance, but it knows

277
00:16:04,130 --> 00:16:08,380
what it's supposed to be on and
the fact that it's inside an transaction.

278
00:16:08,380 --> 00:16:13,069
So you can pass that to other
functions that can utilize it and work with

279
00:16:13,069 --> 00:16:18,700
it as if it's a normal API, but
behind the scenes, you have a transaction

280
00:16:18,700 --> 00:16:20,420
that you're dealing with.

281
00:16:20,420 --> 00:16:23,319
And
originally, the API was that you would just

282
00:16:23,319 --> 00:16:26,910
have to pass this explicitly to
every single query that you built.

283
00:16:26,910 --> 00:16:31,230
So you had the transaction object, and then
you could call commit or rollback at the very

284
00:16:31,230 --> 00:16:32,230
end.

285
00:16:32,230 --> 00:16:35,810
But that seemed to be kind
of error-prone, that users would sort of forget

286
00:16:35,810 --> 00:16:39,949
to pass it to every single
query necessary, and then they would have

287
00:16:39,949 --> 00:16:44,690
sort of queries not working on the
same connection, and it caused all sorts of

288
00:16:44,690 --> 00:16:45,690
errors.

289
00:16:45,690 --> 00:16:46,740
So this is the new API.

290
00:16:46,740 --> 00:16:51,899
And like I said, Knex tries to make it hard
to screw up, I guess.

291
00:16:51,899 --> 00:16:55,310
And so this
is a little boilerplate here -- every time

292
00:16:55,310 --> 00:17:00,220
we call commit and roll back, this
is a promise, and then we return the promise

293
00:17:00,220 --> 00:17:04,940
into the transaction, and we know
if the entire promise chain fulfills, the

294
00:17:04,940 --> 00:17:09,140
transaction should be committed, and
if it fails, the transaction should be rolled

295
00:17:09,140 --> 00:17:10,140
back.

296
00:17:10,140 --> 00:17:11,400
So that's pretty simple.

297
00:17:11,400 --> 00:17:13,069
Nesting transactions is new.

298
00:17:13,069 --> 00:17:15,140
And it's the idea that you shouldn't have
to

299
00:17:15,140 --> 00:17:19,309
worry about whether the client is already
inside a transaction.

300
00:17:19,309 --> 00:17:24,100
So if you call
Knex transaction on something that is already

301
00:17:24,100 --> 00:17:28,310
a transaction Knex, it should
just create a save point.

302
00:17:28,310 --> 00:17:31,030
And so a save point is sort of like a save
point in,

303
00:17:31,030 --> 00:17:32,030
like, a video game.

304
00:17:32,030 --> 00:17:34,100
Where you get to a certain point, and if something
fails

305
00:17:34,100 --> 00:17:37,480
beyond that, you don't go back to the very
beginning, but you go back to just

306
00:17:37,480 --> 00:17:39,150
right here.

307
00:17:39,150 --> 00:17:41,320
And so it does this transparently.

308
00:17:41,320 --> 00:17:43,340
You know, for you.

309
00:17:43,340 --> 00:17:47,490
And you don't have to
worry about it too much.

310
00:17:47,490 --> 00:17:51,770
So Knex likes to take what I call the batteries
included approach, where it does a lot of

311
00:17:51,770 --> 00:17:56,390
this for you, and also provides a
lot of different interfaces, like callbacks

312
00:17:56,390 --> 00:18:01,150
and streams and events, and two
string -- the different things you would want

313
00:18:01,150 --> 00:18:04,790
to work with in a nice manner.

314
00:18:04,790 --> 00:18:07,020
So that's pretty much just a high level overview
of Knex.

315
00:18:07,020 --> 00:18:08,970
And now I'm going to
jump into bookshelf.

316
00:18:08,970 --> 00:18:13,670
Which is an ORM, which stands for object relational
mapper.

317
00:18:13,670 --> 00:18:17,850
And in short what that tries to do is take
care of standard SQL

318
00:18:17,850 --> 00:18:20,890
queries for you, especially in common app
operations.

319
00:18:20,890 --> 00:18:24,250
So when you're building
an app, there's a lot of things that are pretty

320
00:18:24,250 --> 00:18:25,250
standard.

321
00:18:25,250 --> 00:18:31,080
Like insert, return,
fetch, save, dealing with -- relating different

322
00:18:31,080 --> 00:18:34,370
rows of data.

323
00:18:34,370 --> 00:18:36,559
And you don't
want to have to write all of this by hand.

324
00:18:36,559 --> 00:18:39,990
So it sort of abstracts that a
little bit for you, and takes a little bit

325
00:18:39,990 --> 00:18:46,070
of the flexibility away, but gives
you a nicer, higher level piece to work with.

326
00:18:46,070 --> 00:18:49,990
So the different association
types -- pretty familiar if you've ever worked

327
00:18:49,990 --> 00:18:52,630
with an ORM in another
language.

328
00:18:52,630 --> 00:18:54,680
One to one, one to many, many to many.

329
00:18:54,680 --> 00:18:58,701
Polymorphic -- I don't know
if these are necessarily a great idea, but

330
00:18:58,701 --> 00:19:00,120
sometimes they can be useful, I
guess.

331
00:19:00,120 --> 00:19:01,800
So it supports those.

332
00:19:01,800 --> 00:19:03,010
And it builds on top of Knex.

333
00:19:03,010 --> 00:19:05,330
So that's where I
was talking about having a separation between

334
00:19:05,330 --> 00:19:07,980
a query building layer and an
ORM layer.

335
00:19:07,980 --> 00:19:11,130
You should be able to write raw SQL when you
want and have

336
00:19:11,130 --> 00:19:16,000
something that works on top of that and also
allows you to drop back into it

337
00:19:16,000 --> 00:19:17,580
when you need.

338
00:19:17,580 --> 00:19:20,480
So this is sort of what it looks like, to
create a few models

339
00:19:20,480 --> 00:19:22,679
with associations.

340
00:19:22,679 --> 00:19:26,600
And you can also sort of filter with...

341
00:19:26,600 --> 00:19:29,520
So here we have
comments, which is has many to a comment,

342
00:19:29,520 --> 00:19:36,370
but we also have moderated comments,
and we can add in the where-moderated is true.

343
00:19:36,370 --> 00:19:42,539
And it also supports loading
where you're trying to add data to a collection

344
00:19:42,539 --> 00:19:48,450
of data, if you have 26 items,
you have 26 extra queries, so it tries to

345
00:19:48,450 --> 00:19:52,710
do one and then another query for
the extra related results.

346
00:19:52,710 --> 00:19:56,020
An example here is to find an account with
all the

347
00:19:56,020 --> 00:20:00,390
posts in the account, and then all the comments
under those posts and all the

348
00:20:00,390 --> 00:20:04,880
accounts that actually made the comments on
the posts for the account.

349
00:20:04,880 --> 00:20:09,100
So
that's what that it would look like, to provide

350
00:20:09,100 --> 00:20:12,380
with-related, and this is all
in the documentation.

351
00:20:12,380 --> 00:20:16,240
So I'm going to jump through this a little
bit.

352
00:20:16,240 --> 00:20:23,460
Also, as you constrain your loads, you can
dynamically constrain relations,

353
00:20:23,460 --> 00:20:25,110
and then load things after the fact.

354
00:20:25,110 --> 00:20:29,860
So if you want to fetch one row or a
collection of rows and then only load onto

355
00:20:29,860 --> 00:20:33,380
one, it allows you to do that as
well.

356
00:20:33,380 --> 00:20:37,630
And then as I was mentioning earlier, it allows
you to tap into the

357
00:20:37,630 --> 00:20:40,880
query chain, to dynamically add things that
are maybe a little more

358
00:20:40,880 --> 00:20:46,520
SQL-specific under the hood, as you're building
the select statement or other

359
00:20:46,520 --> 00:20:49,630
statements for the model.

360
00:20:49,630 --> 00:20:52,440
And so transactions in bookshelf aren't quite
where

361
00:20:52,440 --> 00:20:56,460
they are in Knex, where you still have to
pass the explicit object to each of

362
00:20:56,460 --> 00:20:58,390
the async calls.

363
00:20:58,390 --> 00:21:00,660
Turns out it's a little harder to retrofit
that, where you

364
00:21:00,660 --> 00:21:02,950
have a transactional bookshelf object.

365
00:21:02,950 --> 00:21:05,501
That's where it's going in the future.

366
00:21:05,501 --> 00:21:09,900
But transactions are absolutely supported
in bookshelf.

367
00:21:09,900 --> 00:21:12,720
And just a little bit
of where bookshelf sort of came from -- I

368
00:21:12,720 --> 00:21:18,070
mentioned that it came from some of
the ideas from backbone models and collections.

369
00:21:18,070 --> 00:21:21,770
And ultimately the idea was to
see if we could reuse some of the same models

370
00:21:21,770 --> 00:21:24,140
on the server and client.

371
00:21:24,140 --> 00:21:26,340
And
this was back in, like, 2012, back before

372
00:21:26,340 --> 00:21:29,860
I even knew there was a term for
doing this.

373
00:21:29,860 --> 00:21:31,110
Which I'm not going to say.

374
00:21:31,110 --> 00:21:35,680
Because he already covered it last
year.

375
00:21:35,680 --> 00:21:36,740
And I actually sort of got there.

376
00:21:36,740 --> 00:21:41,770
I was able to swap out bookshelf models and
collections for, like, the backbone TodoMVC

377
00:21:41,770 --> 00:21:44,360
and use it targeting webSQL.

378
00:21:44,360 --> 00:21:46,360
Which was kind of cool.

379
00:21:46,360 --> 00:21:47,789
I don't know.

380
00:21:47,789 --> 00:21:50,159
I built a to-do list.

381
00:21:50,159 --> 00:21:52,070
And that's pretty
special.

382
00:21:52,070 --> 00:21:56,010
But really, I think, shared models sound great,
but it's not really

383
00:21:56,010 --> 00:22:00,820
as great in practice, because you have to
know a lot more -- or there's sort

384
00:22:00,820 --> 00:22:02,159
of a limit to what you can do.

385
00:22:02,159 --> 00:22:06,130
You have to load all the data, and lose out
on

386
00:22:06,130 --> 00:22:07,169
a lot.

387
00:22:07,169 --> 00:22:10,890
Because you don't need as much of what you
would need on the server on

388
00:22:10,890 --> 00:22:12,650
the client, if you're just displaying it.

389
00:22:12,650 --> 00:22:13,650
So it sounds great.

390
00:22:13,650 --> 00:22:14,650
Not as great in
practice.

391
00:22:14,650 --> 00:22:17,150
And it's something that I'm sort of moving
away from, some of the

392
00:22:17,150 --> 00:22:22,630
model and collection conventions from backbone,
based on some of the things

393
00:22:22,630 --> 00:22:26,040
that I've learned, having been out there for
a little while.

394
00:22:26,040 --> 00:22:27,059
So you can read
more in the docs.

395
00:22:27,059 --> 00:22:29,630
I'm not going to go too much further into
it.

396
00:22:29,630 --> 00:22:31,600
But I think
one thing I would like to point out is that

397
00:22:31,600 --> 00:22:34,490
Knex and bookshelf are not the
first to do this.

398
00:22:34,490 --> 00:22:38,460
So I mentioned earlier there was already higher
level SQL

399
00:22:38,460 --> 00:22:41,770
abstractions in JavaScript that I saw, and
I was like -- oh, I'll build these

400
00:22:41,770 --> 00:22:42,990
instead.

401
00:22:42,990 --> 00:22:44,460
And hopefully it's not the last to do this.

402
00:22:44,460 --> 00:22:49,220
So a few other projects --
openrecord is a really great project that's

403
00:22:49,220 --> 00:22:54,200
using Knex under the hood, and it
provides more of an active record syntax.

404
00:22:54,200 --> 00:22:58,900
And SQLize is the big one, and is
still a big one.

405
00:22:58,900 --> 00:23:01,710
And it didn't have support for transactions.

406
00:23:01,710 --> 00:23:03,789
It had a
really...

407
00:23:03,789 --> 00:23:05,480
The APIs were sort of rough.

408
00:23:05,480 --> 00:23:07,330
And since then, it's come a long way.

409
00:23:07,330 --> 00:23:09,929
I've been really impressed with a lot of the
development happening with

410
00:23:09,929 --> 00:23:10,929
SQLize.

411
00:23:10,929 --> 00:23:13,490
So if you haven't looked at it for a while,
take another look.

412
00:23:13,490 --> 00:23:16,530
They're
doing cool things, especially around the new

413
00:23:16,530 --> 00:23:20,930
postgres features that are coming
out.

414
00:23:20,930 --> 00:23:25,740
A new one that I just saw recently, by someone
who had been frequently

415
00:23:25,740 --> 00:23:30,830
commenting on bookshelf and Knex projects,
and I guess maybe had some opinions

416
00:23:30,830 --> 00:23:34,270
that were different, created this Zuul.JS.

417
00:23:34,270 --> 00:23:36,110
And it's really impressive.

418
00:23:36,110 --> 00:23:39,179
It does
transactions, doesn't have quite the separation

419
00:23:39,179 --> 00:23:43,750
between the query building and
the ORM layer, but does a lot for you at the

420
00:23:43,750 --> 00:23:44,750
ORM layer.

421
00:23:44,750 --> 00:23:46,890
That's worth checking
out.

422
00:23:46,890 --> 00:23:52,010
SQL bricks is pretty similar to Knex, but
with different opinions.

423
00:23:52,010 --> 00:23:58,720
NodeSQL, by the guy who does the postgres
driver.

424
00:23:58,720 --> 00:24:04,610
Even the drivers have come a
long way since I looked at them in 2012.

425
00:24:04,610 --> 00:24:10,960
The node my SQL driver has a ton of
documentation and a lot of features added.

426
00:24:10,960 --> 00:24:17,779
It's really impressive how far it's
come in the last few years.

427
00:24:17,779 --> 00:24:19,890
Knex query lab allows you to demo this in
the

428
00:24:19,890 --> 00:24:22,450
browser and have it spit out SQL.

429
00:24:22,450 --> 00:24:28,630
Bookends does nested data loading and
querying really well.

430
00:24:28,630 --> 00:24:30,580
It's on top of bookshelf.

431
00:24:30,580 --> 00:24:38,620
And there's endpoints, a JSON
API compliant library, which has Knex and

432
00:24:38,620 --> 00:24:44,409
bookshelf under the hood, and larger
stack implementations like Sails, which has

433
00:24:44,409 --> 00:24:48,370
their own ORM, but they were
potentially talking about using Knex as the

434
00:24:48,370 --> 00:24:50,500
query builder under the hood.

435
00:24:50,500 --> 00:24:55,830
So
they're targeting all the different SQL drivers.

436
00:24:55,830 --> 00:24:57,130
That's just some of what's
out there.

437
00:24:57,130 --> 00:24:59,540
But I really don't think this is enough.

438
00:24:59,540 --> 00:25:00,610
So...

439
00:25:00,610 --> 00:25:01,669
We're still sort of
like...

440
00:25:01,669 --> 00:25:06,130
At this stage where node is a really young
ecosystem.

441
00:25:06,130 --> 00:25:08,340
And a lot of
times, you'll hear -- don't reinvent the wheel.

442
00:25:08,340 --> 00:25:09,730
Like it's already been done.

443
00:25:09,730 --> 00:25:11,140
But I sort of disagree with this.

444
00:25:11,140 --> 00:25:14,669
I think that people should absolutely be
reinventing the wheel.

445
00:25:14,669 --> 00:25:17,169
With an asterisk.

446
00:25:17,169 --> 00:25:18,600
Just not on the client side.

447
00:25:18,600 --> 00:25:20,870
Because
React already did this.

448
00:25:20,870 --> 00:25:22,870
No, I'm kidding there.

449
00:25:22,870 --> 00:25:26,300
But, like, we should have more experiments
out there, because I think the

450
00:25:26,300 --> 00:25:30,950
types of conversations we're having since
React are really different, about...

451
00:25:30,950 --> 00:25:32,690
Just the web in general.

452
00:25:32,690 --> 00:25:35,620
Because they questioned a lot of opinions.

453
00:25:35,620 --> 00:25:38,710
So I think
that -- take a look at other libraries.

454
00:25:38,710 --> 00:25:39,940
Take a look at other languages.

455
00:25:39,940 --> 00:25:42,679
Which
is what -- you know, a lot of what JavaScript

456
00:25:42,679 --> 00:25:43,679
is about.

457
00:25:43,679 --> 00:25:46,669
JavaScript is sort of
late to the party of being on the server.

458
00:25:46,669 --> 00:25:54,090
And a lot of the great ideas coming
out around async and ES7 and ES8 are looking

459
00:25:54,090 --> 00:25:55,980
at the best of what's around in
other languages.

460
00:25:55,980 --> 00:25:58,940
So I think it's really important -- like,
as I mentioned,

461
00:25:58,940 --> 00:26:04,179
these were adapted from the Laravel query
builder in PHP, and I would like to

462
00:26:04,179 --> 00:26:11,570
move a lot further toward SQL Alchemy and
query builder.

463
00:26:11,570 --> 00:26:18,640
But I would love to
see node become more of a target for traditional

464
00:26:18,640 --> 00:26:20,970
web applications.

465
00:26:20,970 --> 00:26:25,391
Prove that
Stack Overflow question wrong, and get more

466
00:26:25,391 --> 00:26:31,179
awareness out there, that you can
do this type of boring traditional website

467
00:26:31,179 --> 00:26:37,960
development in node, and I think
the more that that becomes something that's

468
00:26:37,960 --> 00:26:41,770
well known, the more people will
be writing JavaScript, and then more goes

469
00:26:41,770 --> 00:26:42,770
into the ecosystem.

470
00:26:42,770 --> 00:26:45,580
So that was sort
of the goal of creating these two libraries,

471
00:26:45,580 --> 00:26:48,530
to sort of say -- hey, you can do
this.

