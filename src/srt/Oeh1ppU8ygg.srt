1
00:00:09,920 --> 00:00:11,550

this is weird

2
00:00:11,550 --> 00:00:17,100
like really weird conference for node

3
00:00:17,100 --> 00:00:22,140
man so I actually have nothing

4
00:00:22,140 --> 00:00:25,169
interesting to say I don't do anything

5
00:00:25,169 --> 00:00:27,509
interesting these days I just fix bugs

6
00:00:27,509 --> 00:00:30,300
and try to progress node you know

7
00:00:30,300 --> 00:00:32,940
there's there's a lot of work to do and

8
00:00:32,940 --> 00:00:35,969
so I'm just going to talk about what is

9
00:00:35,969 --> 00:00:38,969
happening in the next version it's okay

10
00:00:38,969 --> 00:00:41,850
with you okay it's going to be extremely

11
00:00:41,850 --> 00:00:43,829
you can like go get coffee if you want I

12
00:00:43,829 --> 00:00:45,690
will not be offended I wanted to do a

13
00:00:45,690 --> 00:00:49,070
more interesting talk but yeah alright

14
00:00:49,070 --> 00:00:54,030
so first of all well I just put this

15
00:00:54,030 --> 00:00:56,399
slide in here because it's it's somewhat

16
00:00:56,399 --> 00:01:00,420
amazing like node seems to be attracting

17
00:01:00,420 --> 00:01:03,539
a lot of people to it there are 4,000

18
00:01:03,539 --> 00:01:05,339
people on the mailing list and if you go

19
00:01:05,339 --> 00:01:08,070
in the IRC at noon on Pacific Standard

20
00:01:08,070 --> 00:01:10,700
time you'll see 600 people idling there

21
00:01:10,700 --> 00:01:14,759
it is kind of a lot of people there's

22
00:01:14,759 --> 00:01:18,090
books and several books coming out I

23
00:01:18,090 --> 00:01:20,100
guess the Japanese book is going to be

24
00:01:20,100 --> 00:01:23,040
the first one it's 500 pages and will

25
00:01:23,040 --> 00:01:27,000
probably be done I don't know when is it

26
00:01:27,000 --> 00:01:32,820
going to be done guys like a month end

27
00:01:32,820 --> 00:01:34,829
of June okay

28
00:01:34,829 --> 00:01:36,659
of course most of us can't read it but

29
00:01:36,659 --> 00:01:39,979
we can look at it and it'll be pretty

30
00:01:39,979 --> 00:01:42,570
top is working on a book I think there's

31
00:01:42,570 --> 00:01:44,159
there's some others in the works there's

32
00:01:44,159 --> 00:01:46,020
there's translations in the various

33
00:01:46,020 --> 00:01:49,680
languages and we are spamming hacker

34
00:01:49,680 --> 00:01:52,800
news all the time

35
00:01:52,810 --> 00:01:55,119
because I don't know we like to click

36
00:01:55,119 --> 00:01:57,150
the up button

37
00:01:57,150 --> 00:02:02,290
okay so May 2009 initial release then we

38
00:02:02,290 --> 00:02:04,000
did the first stable release which was

39
00:02:04,000 --> 00:02:08,380
zipped to in late 2010 and we just came

40
00:02:08,380 --> 00:02:11,500
out with 0 4 which kind of had a bumpy

41
00:02:11,500 --> 00:02:13,780
first few versions and is still a bit

42
00:02:13,780 --> 00:02:18,280
bumpy with with SSL and stuff but it's

43
00:02:18,280 --> 00:02:21,610
getting better starting to feel kind of

44
00:02:21,610 --> 00:02:25,239
good about the new stuff that went into

45
00:02:25,239 --> 00:02:31,540
0 4 so 0 4 was all about fixing SSL and

46
00:02:31,540 --> 00:02:41,420
doing HTTP and

47
00:02:41,430 --> 00:02:45,090
hello didn't anybody hear what I just

48
00:02:45,090 --> 00:02:45,540
said

49
00:02:45,540 --> 00:02:49,980
no okay so zero for I mean the main

50
00:02:49,980 --> 00:02:52,830
focus was fixing the HTTP client

51
00:02:52,830 --> 00:02:56,879
interface and fixing the and and doing

52
00:02:56,879 --> 00:03:00,480
SSL properly with much thanks to Paul

53
00:03:00,480 --> 00:03:02,610
Clara and a lot of other people who

54
00:03:02,610 --> 00:03:09,030
worked on this so zero five is is our

55
00:03:09,030 --> 00:03:10,860
next unstable release which we're

56
00:03:10,860 --> 00:03:14,040
already working on and the the stable

57
00:03:14,040 --> 00:03:16,500
release will be zero six and that will

58
00:03:16,500 --> 00:03:19,010
be in about two to three months

59
00:03:19,010 --> 00:03:24,030
hopefully so the goal of this basically

60
00:03:24,030 --> 00:03:28,019
is windows compatibility we are taking

61
00:03:28,019 --> 00:03:32,730
it very seriously to which you know most

62
00:03:32,730 --> 00:03:35,120
of you people with all your glowing

63
00:03:35,120 --> 00:03:38,480
icons out there on your laptops I see

64
00:03:38,480 --> 00:03:41,569
you probably don't care so much because

65
00:03:41,569 --> 00:03:43,980
the typical response from web

66
00:03:43,980 --> 00:03:45,720
programmers is like what windows I mean

67
00:03:45,720 --> 00:03:49,079
who uses that but actually believe it or

68
00:03:49,079 --> 00:03:51,919
not I'm sure some of you believe it that

69
00:03:51,919 --> 00:03:54,690
Windows does account for a large number

70
00:03:54,690 --> 00:03:57,840
of the computers in the world in

71
00:03:57,840 --> 00:04:02,329
particular servers there are a lot of

72
00:04:02,329 --> 00:04:05,819
what's that exchange thing yeah mail

73
00:04:05,819 --> 00:04:09,780
thing that that windows people use 33%

74
00:04:09,780 --> 00:04:12,599
of servers according to Wikipedia we

75
00:04:12,599 --> 00:04:16,079
want that market like for node to really

76
00:04:16,079 --> 00:04:23,669
be a game it's total world domination we

77
00:04:23,669 --> 00:04:25,860
have to target that that audience it's

78
00:04:25,860 --> 00:04:28,680
it's not it's not acceptable to just

79
00:04:28,680 --> 00:04:33,990
ignore that and continue onwards so we

80
00:04:33,990 --> 00:04:37,110
do have a Windows port currently but

81
00:04:37,110 --> 00:04:40,500
it's it's cygwin and nobody likes cygwin

82
00:04:40,500 --> 00:04:42,330
everybody hates it it's just kind of

83
00:04:42,330 --> 00:04:45,599
something that you do to get by and it's

84
00:04:45,599 --> 00:04:47,970
buggy and it's slow and you wouldn't

85
00:04:47,970 --> 00:04:50,550
really run a server off of cygwin but

86
00:04:50,550 --> 00:04:52,800
you know it's a nice stopgap

87
00:04:52,800 --> 00:04:55,470
to help the windows people get going but

88
00:04:55,470 --> 00:04:57,330
from what I hear it's much better to

89
00:04:57,330 --> 00:05:01,379
just spin up a VMware instance of Lenox

90
00:05:01,379 --> 00:05:06,449
and run node there rather than in cygwin

91
00:05:06,449 --> 00:05:09,270
that's not real that's not a real

92
00:05:09,270 --> 00:05:14,550
Windows port so question I guess a

93
00:05:14,550 --> 00:05:15,960
reasonable question is is it even

94
00:05:15,960 --> 00:05:19,139
possible to do decent servers in Windows

95
00:05:19,139 --> 00:05:22,349
like obviously like the the rest of the

96
00:05:22,349 --> 00:05:25,530
OS is so awful like it would not be

97
00:05:25,530 --> 00:05:28,259
surprising that you know it is just

98
00:05:28,259 --> 00:05:30,479
simply impossible to write a decent

99
00:05:30,479 --> 00:05:33,719
server and by decent you know I mean

100
00:05:33,719 --> 00:05:36,810
could handle 10,000 idle connections and

101
00:05:36,810 --> 00:05:39,180
not you know just churn and spin to

102
00:05:39,180 --> 00:05:44,330
death right so it is possible actually

103
00:05:44,330 --> 00:05:47,520
Microsoft does have smart people and

104
00:05:47,520 --> 00:05:51,440
they do have you know fairly advanced

105
00:05:51,440 --> 00:05:54,990
techniques and in the in the api's but

106
00:05:54,990 --> 00:05:58,620
it's not the same as unit and I think

107
00:05:58,620 --> 00:06:00,930
that's why a lot of software doesn't

108
00:06:00,930 --> 00:06:03,719
actually make the make the jump from

109
00:06:03,719 --> 00:06:09,599
from UNIX to to Windows we are going to

110
00:06:09,599 --> 00:06:13,199
make the jump so in UNIX

111
00:06:13,199 --> 00:06:17,849
a good server software would mean that

112
00:06:17,849 --> 00:06:20,610
you do non-blocking sockets and that you

113
00:06:20,610 --> 00:06:23,729
use a constant time io multiplexer like

114
00:06:23,729 --> 00:06:26,819
KQ or eople like this is the definition

115
00:06:26,819 --> 00:06:29,699
of this is what you must do on UNIX

116
00:06:29,699 --> 00:06:34,639
systems to create a reasonable server

117
00:06:34,639 --> 00:06:41,610
Windows has the the UNIX e select but

118
00:06:41,610 --> 00:06:44,159
it's not constant time and that means

119
00:06:44,159 --> 00:06:46,800
like when you load it up with with save

120
00:06:46,800 --> 00:06:50,340
more than a hundred file descriptors it

121
00:06:50,340 --> 00:06:52,919
becomes slow it doesn't scale with the

122
00:06:52,919 --> 00:06:54,419
number of sockets that you want to load

123
00:06:54,419 --> 00:06:56,699
on this right your your your polling for

124
00:06:56,699 --> 00:06:59,460
for file system state for file

125
00:06:59,460 --> 00:07:01,949
descriptor state changes and it just it

126
00:07:01,949 --> 00:07:03,779
can't do that in a reasonable amount of

127
00:07:03,779 --> 00:07:04,380
time

128
00:07:04,380 --> 00:07:06,210
has to scan over all these sockets all

129
00:07:06,210 --> 00:07:11,070
the time so they also have this thing

130
00:07:11,070 --> 00:07:17,450
called WUSA event select which is better

131
00:07:17,450 --> 00:07:21,330
in that it's it's it doesn't have the

132
00:07:21,330 --> 00:07:24,630
the same properties of having to scan

133
00:07:24,630 --> 00:07:27,750
all the file descriptors every time but

134
00:07:27,750 --> 00:07:29,970
the the pulling mechanism which is WS a

135
00:07:29,970 --> 00:07:32,160
wait for multiple events these people

136
00:07:32,160 --> 00:07:36,600
and their names and is actually limited

137
00:07:36,600 --> 00:07:40,080
to 64 file descriptors per threat and

138
00:07:40,080 --> 00:07:41,460
they're actually not file descriptors

139
00:07:41,460 --> 00:07:45,860
here handles 64 sockets per per threat

140
00:07:45,860 --> 00:07:48,960
great yeah good choice like what what

141
00:07:48,960 --> 00:07:53,370
why 64 sockets per thread like no we

142
00:07:53,370 --> 00:07:57,060
want 20,000 like this is ridiculous so

143
00:07:57,060 --> 00:07:57,960
that's awesome

144
00:07:57,960 --> 00:08:02,130
right so at which point you learn these

145
00:08:02,130 --> 00:08:04,290
things and you're just like well I guess

146
00:08:04,290 --> 00:08:05,670
to our server is going to suck on

147
00:08:05,670 --> 00:08:12,030
Windows you know but we are nerds and so

148
00:08:12,030 --> 00:08:17,250
we we we get into reading documentation

149
00:08:17,250 --> 00:08:20,220
for long periods of time and you find

150
00:08:20,220 --> 00:08:23,400
out that it is actually possible to

151
00:08:23,400 --> 00:08:26,280
write really good servers on Windows

152
00:08:26,280 --> 00:08:28,320
with something called IO completion

153
00:08:28,320 --> 00:08:29,370
ports

154
00:08:29,370 --> 00:08:32,669
it's just that IO completion ports don't

155
00:08:32,669 --> 00:08:35,820
act the same way it's it's not the same

156
00:08:35,820 --> 00:08:38,340
concept as what you have in Unix in Unix

157
00:08:38,340 --> 00:08:42,690
you are as I said you're waiting for

158
00:08:42,690 --> 00:08:44,640
file descriptor state changes so you're

159
00:08:44,640 --> 00:08:47,850
waiting for you know that socket to

160
00:08:47,850 --> 00:08:49,710
become readable so that you can read

161
00:08:49,710 --> 00:08:51,900
from it doing a non-blocking read or

162
00:08:51,900 --> 00:08:53,490
you're waiting for that socket to become

163
00:08:53,490 --> 00:08:55,290
writable because you've got a big buffer

164
00:08:55,290 --> 00:08:59,880
of stuff to dump to it in Windows in in

165
00:08:59,880 --> 00:09:02,760
IO completion ports it's rather that you

166
00:09:02,760 --> 00:09:06,930
write to the socket and you get told

167
00:09:06,930 --> 00:09:09,390
when it's done so the the kernel manages

168
00:09:09,390 --> 00:09:12,360
the the send buffer for you and when you

169
00:09:12,360 --> 00:09:14,100
want to read from the socket you just

170
00:09:14,100 --> 00:09:15,930
read full you give it a buffer you read

171
00:09:15,930 --> 00:09:18,089
from it and then you go away

172
00:09:18,089 --> 00:09:20,339
calls you back in the future so somehow

173
00:09:20,339 --> 00:09:26,879
it's a higher level interface iocp also

174
00:09:26,879 --> 00:09:29,970
supports pipes which is cool but

175
00:09:29,970 --> 00:09:32,999
whatever but regular files is is really

176
00:09:32,999 --> 00:09:35,759
interesting so you can actually do have

177
00:09:35,759 --> 00:09:38,939
real asynchronous file IO in in the

178
00:09:38,939 --> 00:09:42,779
kernel on Windows and not have to do

179
00:09:42,779 --> 00:09:43,499
these tricks

180
00:09:43,499 --> 00:09:45,899
so if you're familiar with how we do

181
00:09:45,899 --> 00:09:48,779
this in in node we also do a synchronous

182
00:09:48,779 --> 00:09:51,269
file IO but we have to hack it so we we

183
00:09:51,269 --> 00:09:55,170
have userspace threads that we execute

184
00:09:55,170 --> 00:09:57,629
system calls in which is I mean totally

185
00:09:57,629 --> 00:10:00,059
stupid but there there's no way to get

186
00:10:00,059 --> 00:10:07,589
around that in UNIX um so one for one

187
00:10:07,589 --> 00:10:11,579
one point for Windows right the good

188
00:10:11,579 --> 00:10:14,910
thing is that nodes API as as we present

189
00:10:14,910 --> 00:10:19,410
it to users is already iocp Masek or

190
00:10:19,410 --> 00:10:26,819
whatever is already iocp ish so so you

191
00:10:26,819 --> 00:10:29,129
you do write to a socket and you get a

192
00:10:29,129 --> 00:10:32,189
callback when it's done you just receive

193
00:10:32,189 --> 00:10:34,470
data from from sockets so you don't have

194
00:10:34,470 --> 00:10:36,059
this kind of interface where you're

195
00:10:36,059 --> 00:10:39,209
you're polling for file system for for

196
00:10:39,209 --> 00:10:42,870
file descriptor state changes what does

197
00:10:42,870 --> 00:10:44,699
that mean it means that we can probably

198
00:10:44,699 --> 00:10:47,910
rework the plumbing without changing the

199
00:10:47,910 --> 00:10:51,720
user facing API so it's likely that 0/6

200
00:10:51,720 --> 00:10:54,800
won't have any API changes or if so

201
00:10:54,800 --> 00:10:57,300
relatively minor ones that we just have

202
00:10:57,300 --> 00:11:02,129
to fix but rather the whole the whole

203
00:11:02,129 --> 00:11:05,879
plumbing will be reworked to deal with

204
00:11:05,879 --> 00:11:11,459
this there have been some other attempts

205
00:11:11,459 --> 00:11:16,980
to create a server library that works on

206
00:11:16,980 --> 00:11:21,059
both UNIX and Windows but somehow none

207
00:11:21,059 --> 00:11:23,249
of them are acceptable Libby V which we

208
00:11:23,249 --> 00:11:27,149
use in in node currently does is very

209
00:11:27,149 --> 00:11:29,410
UNIX II it's a perfect perfect

210
00:11:29,410 --> 00:11:33,839
abstraction over UNIX IO multiplexers on

211
00:11:33,839 --> 00:11:36,970
Windows however it just doesn't have it

212
00:11:36,970 --> 00:11:39,670
you know Libby V is all about file

213
00:11:39,670 --> 00:11:41,470
descriptors and if they're readable or

214
00:11:41,470 --> 00:11:43,660
write a book it doesn't pour it on to

215
00:11:43,660 --> 00:11:48,310
unto iocp you can run Libby v on select

216
00:11:48,310 --> 00:11:50,889
on Windows but as we said before that's

217
00:11:50,889 --> 00:11:54,279
that's somewhat unacceptable

218
00:11:54,279 --> 00:11:58,480
there's live event so lib event - did

219
00:11:58,480 --> 00:12:02,139
some plumbing of their own and now runs

220
00:12:02,139 --> 00:12:07,180
on iocp on Windows but at least one

221
00:12:07,180 --> 00:12:10,389
person pointed out in a in a mailing

222
00:12:10,389 --> 00:12:13,300
list post that it's really bad like I

223
00:12:13,300 --> 00:12:14,290
don't know

224
00:12:14,290 --> 00:12:17,079
you can push like between two two

225
00:12:17,079 --> 00:12:19,240
sockets you can push like 100 megabits

226
00:12:19,240 --> 00:12:23,740
or something like through the loop back

227
00:12:23,740 --> 00:12:26,379
like the it doesn't seem like they've

228
00:12:26,379 --> 00:12:28,509
done a very good job of doing that like

229
00:12:28,509 --> 00:12:30,339
they they did a lot of work to sit on

230
00:12:30,339 --> 00:12:33,189
top of IOC P but somehow they they

231
00:12:33,189 --> 00:12:40,160
didn't achieve actual speed so fail um

232
00:12:40,170 --> 00:12:43,300
it also also a live event doesn't it

233
00:12:43,300 --> 00:12:44,980
doesn't deal with it's only dealing with

234
00:12:44,980 --> 00:12:47,589
sockets right and then there's boost

235
00:12:47,589 --> 00:12:52,779
ASIO which is this c++ monstrosity you

236
00:12:52,779 --> 00:12:54,519
know you you have to download it it's

237
00:12:54,519 --> 00:12:57,430
about 60 megabytes of source code and

238
00:12:57,430 --> 00:13:01,149
like it's just so many files and so much

239
00:13:01,149 --> 00:13:04,180
api apparently it does work though they

240
00:13:04,180 --> 00:13:06,370
do actually give you a poll on Lennox

241
00:13:06,370 --> 00:13:11,500
and iocp on on Windows but it's just so

242
00:13:11,500 --> 00:13:13,930
massive and it's just like seriously is

243
00:13:13,930 --> 00:13:15,519
this such a hard problem like all I want

244
00:13:15,519 --> 00:13:18,009
to do is like write to a socket like

245
00:13:18,009 --> 00:13:20,680
this is this is not such a difficult

246
00:13:20,680 --> 00:13:23,410
problem that we really require three

247
00:13:23,410 --> 00:13:26,139
hundred files and twelve thousand

248
00:13:26,139 --> 00:13:33,069
semicolons is what i WC gelled so it

249
00:13:33,069 --> 00:13:36,850
also doesn't support regular files this

250
00:13:36,850 --> 00:13:39,639
is all crap like the it's not all crap

251
00:13:39,639 --> 00:13:41,529
but it's it's just not acceptable for

252
00:13:41,529 --> 00:13:43,030
what we want to do

253
00:13:43,030 --> 00:13:45,610
and I just think the problem is is not

254
00:13:45,610 --> 00:13:49,270
that hard especially on now that we have

255
00:13:49,270 --> 00:13:52,090
Libby V on on UNIX which is a very sort

256
00:13:52,090 --> 00:13:54,940
of thin layer we can use Libby Beyond on

257
00:13:54,940 --> 00:13:58,390
UNIX to prop up this system and it's

258
00:13:58,390 --> 00:14:00,580
done you know most of the work for us

259
00:14:00,580 --> 00:14:02,560
for most of the operating systems and

260
00:14:02,560 --> 00:14:06,310
then on Windows we have iocp and so we

261
00:14:06,310 --> 00:14:08,860
just need to make like a little layer

262
00:14:08,860 --> 00:14:12,370
over that so that's this thing it's

263
00:14:12,370 --> 00:14:14,890
called lib Ohio it was called lib oh

264
00:14:14,890 --> 00:14:16,810
well and I think we'll change the name

265
00:14:16,810 --> 00:14:19,600
again just to just to confuse everybody

266
00:14:19,600 --> 00:14:23,700
because nobody will actually use it so

267
00:14:23,700 --> 00:14:26,290
currently this this is being done in a

268
00:14:26,290 --> 00:14:29,260
separate repository than node but that's

269
00:14:29,260 --> 00:14:32,710
just to kind of maintain purity we want

270
00:14:32,710 --> 00:14:34,690
all of our tests to B and C and we want

271
00:14:34,690 --> 00:14:36,490
to make sure that we're not you know

272
00:14:36,490 --> 00:14:40,050
tempted to jump into some laughs

273
00:14:40,050 --> 00:14:44,650
loveliness and you know use node to do

274
00:14:44,650 --> 00:14:46,180
the testing and stuff we want all this

275
00:14:46,180 --> 00:14:48,700
this to be very pure and and just

276
00:14:48,700 --> 00:14:55,210
dealing with with the C system so it's

277
00:14:55,210 --> 00:14:58,060
actually working the the TCP socket and

278
00:14:58,060 --> 00:15:01,930
server stuff basically is more or less

279
00:15:01,930 --> 00:15:04,390
working yeah there's some there's

280
00:15:04,390 --> 00:15:06,130
probably some bugs still so so we're

281
00:15:06,130 --> 00:15:10,410
writing a lot of tests and actually I

282
00:15:10,410 --> 00:15:13,540
would like to ask if you are interested

283
00:15:13,540 --> 00:15:15,550
in in system programming or you're

284
00:15:15,550 --> 00:15:17,980
you're somehow interested in this

285
00:15:17,980 --> 00:15:19,990
problem a great way to get involved with

286
00:15:19,990 --> 00:15:22,840
lib Ohio is to go in there and write a

287
00:15:22,840 --> 00:15:25,030
test I mean the tests are huge because

288
00:15:25,030 --> 00:15:26,830
they're C and you have to set up servers

289
00:15:26,830 --> 00:15:28,810
and stuff and it's it's not incredibly

290
00:15:28,810 --> 00:15:32,530
fun but but we do need some the the main

291
00:15:32,530 --> 00:15:34,450
point of this is is that we have two

292
00:15:34,450 --> 00:15:36,490
different implementations and so testing

293
00:15:36,490 --> 00:15:41,440
is everything in this system so since we

294
00:15:41,440 --> 00:15:44,020
have the the socket stuff the TCP socket

295
00:15:44,020 --> 00:15:47,260
stuff worked out more or less we're

296
00:15:47,260 --> 00:15:49,180
probably going to be dropping this into

297
00:15:49,180 --> 00:15:52,240
node master very soon now like next week

298
00:15:52,240 --> 00:15:56,000
which will just destroy everything but

299
00:15:56,000 --> 00:15:59,470
that's okay

300
00:15:59,480 --> 00:16:03,230
Bert builder of of cloud kick is is

301
00:16:03,230 --> 00:16:05,390
doing the windows side and I'm doing the

302
00:16:05,390 --> 00:16:11,960
UNIX side so here's here's the nice

303
00:16:11,960 --> 00:16:14,630
architectural diagram it's actually not

304
00:16:14,630 --> 00:16:18,020
that nice um but it should be in two

305
00:16:18,020 --> 00:16:20,450
squares right because one's representing

306
00:16:20,450 --> 00:16:22,870
Windows and one's representing UNIX and

307
00:16:22,870 --> 00:16:26,720
whatever but you get the point is is

308
00:16:26,720 --> 00:16:29,750
that iocp is kind of a higher level

309
00:16:29,750 --> 00:16:33,410
interface then then what UNIX provides

310
00:16:33,410 --> 00:16:36,680
it's it's somehow more abstract and so

311
00:16:36,680 --> 00:16:39,560
we we kind of are sitting on top of that

312
00:16:39,560 --> 00:16:42,440
and on on UNIX we have to kind of shim

313
00:16:42,440 --> 00:16:44,210
that up with some extra libraries the

314
00:16:44,210 --> 00:16:49,430
Libby B and libo i/o so the goal of this

315
00:16:49,430 --> 00:16:54,680
is to avoid if def help we don't want

316
00:16:54,680 --> 00:16:57,380
the entire source code of node to just

317
00:16:57,380 --> 00:16:59,990
be littered with these preprocessor

318
00:16:59,990 --> 00:17:02,000
branches that you know have different

319
00:17:02,000 --> 00:17:04,910
implementations of every function the

320
00:17:04,910 --> 00:17:06,650
goal is to push all the platform and

321
00:17:06,650 --> 00:17:09,079
compatibility into this live Oh IO well

322
00:17:09,079 --> 00:17:11,569
as much as makes sense obviously like we

323
00:17:11,569 --> 00:17:14,020
don't want to get crazy about this but

324
00:17:14,020 --> 00:17:17,089
let's get crazy a little bit we'll push

325
00:17:17,089 --> 00:17:21,410
push it all down and then the the so

326
00:17:21,410 --> 00:17:23,240
we'll have all the the platform stuff

327
00:17:23,240 --> 00:17:25,790
into the this C library and then the

328
00:17:25,790 --> 00:17:28,250
binding layer and the JavaScript stuff

329
00:17:28,250 --> 00:17:31,640
should in the end be completely

330
00:17:31,640 --> 00:17:32,510
cross-platform

331
00:17:32,510 --> 00:17:35,450
ideally that's not the case right now so

332
00:17:35,450 --> 00:17:39,620
if you look at the net dot J I told you

333
00:17:39,620 --> 00:17:41,240
guys this would be a very boring talk I

334
00:17:41,240 --> 00:17:42,050
am

335
00:17:42,050 --> 00:17:47,720
I apologize I'm sure there will be like

336
00:17:47,720 --> 00:17:49,550
very nice

337
00:17:49,550 --> 00:17:52,900
I think sub stack made a Markov

338
00:17:52,900 --> 00:17:56,300
generating rap IRC log thing this will

339
00:17:56,300 --> 00:18:00,060
be fun

340
00:18:00,070 --> 00:18:02,580
yes so we will avoid if deaf hell

341
00:18:02,580 --> 00:18:05,200
another component of Windows is that

342
00:18:05,200 --> 00:18:07,209
Windows users don't typically have

343
00:18:07,209 --> 00:18:13,389
compiler tool chains so so we want to

344
00:18:13,389 --> 00:18:15,849
distribute executables and one thing

345
00:18:15,849 --> 00:18:17,409
that we've tried very hard in node is

346
00:18:17,409 --> 00:18:19,869
not to dynamically link to everything in

347
00:18:19,869 --> 00:18:21,759
the entire system although you know you

348
00:18:21,759 --> 00:18:23,169
give it to the Debian package maintainer

349
00:18:23,169 --> 00:18:25,149
x' and they're like static linking you

350
00:18:25,149 --> 00:18:29,299
guys are idiots let's tear this apart um

351
00:18:29,309 --> 00:18:37,719
Debian God so I'm glad that's being some

352
00:18:37,719 --> 00:18:40,149
applause um there's probably one guy

353
00:18:40,149 --> 00:18:43,349
that's like a Debian package Minturn

354
00:18:43,349 --> 00:18:46,539
node you know they call our executable

355
00:18:46,539 --> 00:18:48,399
nodejs instead of node because there's

356
00:18:48,399 --> 00:18:52,229
some like ham-radio node executable know

357
00:18:52,229 --> 00:18:54,879
we will get node okay the ham-radio

358
00:18:54,879 --> 00:19:03,519
thing can change its name so right on

359
00:19:03,519 --> 00:19:06,129
windows have you ever downloaded putty

360
00:19:06,129 --> 00:19:09,639
it's like an exe file so beautiful like

361
00:19:09,639 --> 00:19:12,099
I love that you just download it you run

362
00:19:12,099 --> 00:19:14,649
it it works that is basically what we

363
00:19:14,649 --> 00:19:17,349
will be able to do on Windows possibly

364
00:19:17,349 --> 00:19:20,950
if we're if we're careful so I would

365
00:19:20,950 --> 00:19:22,179
like to get to the state where we

366
00:19:22,179 --> 00:19:26,200
literally distribute a exe file and

367
00:19:26,200 --> 00:19:27,820
people can download that and now they

368
00:19:27,820 --> 00:19:31,839
have note yes

369
00:19:31,839 --> 00:19:34,299
it will be a nice user experience for

370
00:19:34,299 --> 00:19:37,719
the windows people npm the package

371
00:19:37,719 --> 00:19:42,729
manager are has a concept of building

372
00:19:42,729 --> 00:19:47,409
add-ons right if you download I can't

373
00:19:47,409 --> 00:19:49,029
even think of a library now something

374
00:19:49,029 --> 00:19:51,549
you know there's all these add-ons it

375
00:19:51,549 --> 00:19:53,820
will run through some GCC commands right

376
00:19:53,820 --> 00:19:56,919
Windows users don't like to do that they

377
00:19:56,919 --> 00:19:59,829
want binary stuff and actually a lot of

378
00:19:59,829 --> 00:20:02,049
UNIX users also want binary stuff so

379
00:20:02,049 --> 00:20:05,169
Isaac's been working on augmenting the

380
00:20:05,169 --> 00:20:08,789
the package repository to store binary

381
00:20:08,789 --> 00:20:11,590
compiled versions of the add-ons

382
00:20:11,590 --> 00:20:13,960
that most people will be able to

383
00:20:13,960 --> 00:20:18,850
download and just get a a pre pre

384
00:20:18,850 --> 00:20:25,960
compiled dll and something that I really

385
00:20:25,960 --> 00:20:29,679
want is long stack traces which I won't

386
00:20:29,679 --> 00:20:31,659
go into what that is basically stack

387
00:20:31,659 --> 00:20:34,299
traces that span events when you hit an

388
00:20:34,299 --> 00:20:42,220
exception this will point of contention

389
00:20:42,220 --> 00:20:47,140
yes so the primary thing that's

390
00:20:47,140 --> 00:20:49,029
preventing us from doing that is that we

391
00:20:49,029 --> 00:20:51,460
need entry points from the event loop

392
00:20:51,460 --> 00:20:53,470
into JavaScript and we need to know

393
00:20:53,470 --> 00:20:55,630
where all of those are and we need to

394
00:20:55,630 --> 00:20:57,909
have a hook that is unified so that we

395
00:20:57,909 --> 00:21:02,470
can do stuff there and currently it's

396
00:21:02,470 --> 00:21:05,320
just spattered around the the system

397
00:21:05,320 --> 00:21:07,419
it's just very hard to organize it we

398
00:21:07,419 --> 00:21:09,100
don't have kind of a single entry point

399
00:21:09,100 --> 00:21:10,929
where we can say okay now we are leaving

400
00:21:10,929 --> 00:21:14,470
Libby B and going into into JavaScript

401
00:21:14,470 --> 00:21:15,270
land

402
00:21:15,270 --> 00:21:19,000
so with this plumbing reworking in mind

403
00:21:19,000 --> 00:21:22,149
we know that we want that and so we will

404
00:21:22,149 --> 00:21:25,899
take special care to to get these hooks

405
00:21:25,899 --> 00:21:31,240
in there and as I said we don't want to

406
00:21:31,240 --> 00:21:34,990
go the Libby B Lib event to path so you

407
00:21:34,990 --> 00:21:36,850
know if we can't get gigabit throughput

408
00:21:36,850 --> 00:21:39,039
over the loopback with the pair of TCP

409
00:21:39,039 --> 00:21:42,130
sockets and have like 10,000 idle

410
00:21:42,130 --> 00:21:45,370
connections on a on a server on every OS

411
00:21:45,370 --> 00:21:47,549
then then clearly we have failed so

412
00:21:47,549 --> 00:21:49,990
hopefully we that will not be the case

413
00:21:49,990 --> 00:21:52,510
so we're trying to do benchmarking and

414
00:21:52,510 --> 00:21:54,880
testing early on in the development of

415
00:21:54,880 --> 00:21:57,270
this of this library so that we're not

416
00:21:57,270 --> 00:21:59,770
so we don't like wake up in like you

417
00:21:59,770 --> 00:22:01,630
know a year after our big refactor

418
00:22:01,630 --> 00:22:03,640
somebody mails the mailing list and it

419
00:22:03,640 --> 00:22:05,230
says oh I did this benchmark and it's

420
00:22:05,230 --> 00:22:08,710
terrible no so hopefully we will know

421
00:22:08,710 --> 00:22:11,230
where we're doing that is the end of my

422
00:22:11,230 --> 00:22:22,420
talk you can ask me questions

423
00:22:22,430 --> 00:22:24,530
so the question is are there any big

424
00:22:24,530 --> 00:22:27,290
things that I that we have to give up in

425
00:22:27,290 --> 00:22:32,930
order to do windows no actually not what

426
00:22:32,930 --> 00:22:35,450
we have to do I mean the big thing that

427
00:22:35,450 --> 00:22:37,520
we have to do is is we have to push some

428
00:22:37,520 --> 00:22:39,320
of this code that's written in

429
00:22:39,320 --> 00:22:42,710
JavaScript now the Lib Lib net-lib KS

430
00:22:42,710 --> 00:22:48,140
into Sealand and it's unclear right now

431
00:22:48,140 --> 00:22:52,960
if jumping between the c++ boundary and

432
00:22:52,960 --> 00:22:55,760
javascript which we will possibly be

433
00:22:55,760 --> 00:22:58,310
doing more of with this new binding

434
00:22:58,310 --> 00:23:02,240
because whatever that that may affect

435
00:23:02,240 --> 00:23:03,980
performance but we really won't know

436
00:23:03,980 --> 00:23:07,190
until we get there but otherwise I mean

437
00:23:07,190 --> 00:23:09,170
the the binding is very thin that we're

438
00:23:09,170 --> 00:23:11,330
not we're not doing a bunch of magic

439
00:23:11,330 --> 00:23:12,920
stuff here so we're just kind of

440
00:23:12,920 --> 00:23:16,780
massaging the api's into place so no I

441
00:23:16,780 --> 00:23:23,870
confidently so the question is have I

442
00:23:23,870 --> 00:23:25,070
thought much about what comes after

443
00:23:25,070 --> 00:23:32,840
windows compatibility yeah I mean there

444
00:23:32,840 --> 00:23:35,300
there's there's some more stuff we need

445
00:23:35,300 --> 00:23:40,040
to do still in particular there there

446
00:23:40,040 --> 00:23:42,020
there's a lot of cleanup stuff that

447
00:23:42,020 --> 00:23:44,000
needs to happen but we are quickly

448
00:23:44,000 --> 00:23:47,300
approaching a stable thing so there's

449
00:23:47,300 --> 00:23:49,790
not a ton of reworking this I want to do

450
00:23:49,790 --> 00:23:51,680
this thing now because this is going to

451
00:23:51,680 --> 00:23:55,850
basically be rewriting node we have a

452
00:23:55,850 --> 00:24:00,110
lot of tests now so we can kind of with

453
00:24:00,110 --> 00:24:01,610
some confidence say that we're going to

454
00:24:01,610 --> 00:24:05,390
actually make it but I yeah we're

455
00:24:05,390 --> 00:24:09,680
quickly approaching a 1.0 I don't worry

456
00:24:09,680 --> 00:24:11,840
about it I mean one thing I've learned

457
00:24:11,840 --> 00:24:14,180
is that like if you're not I mean we

458
00:24:14,180 --> 00:24:16,940
will make every effort to make every

459
00:24:16,940 --> 00:24:20,990
piece of core API work on both systems

460
00:24:20,990 --> 00:24:24,950
in the most decent way oh by the way the

461
00:24:24,950 --> 00:24:26,690
question was how can you prepare for

462
00:24:26,690 --> 00:24:31,299
Windows API blah

463
00:24:31,309 --> 00:24:33,980
just just hold off right I mean we might

464
00:24:33,980 --> 00:24:35,419
just crash and burn here and the world

465
00:24:35,419 --> 00:24:37,249
might explode so I mean don't worry

466
00:24:37,249 --> 00:24:39,110
about it yet Hey hopefully hopefully

467
00:24:39,110 --> 00:24:41,570
Scripps will just port over forward

468
00:24:41,570 --> 00:24:43,490
slashes windows can deal with those it's

469
00:24:43,490 --> 00:24:45,490
not it's not the worst thing on earth

470
00:24:45,490 --> 00:24:48,169
that's not that's not the the path

471
00:24:48,169 --> 00:24:51,129
problem is like the least of Windows

472
00:24:51,129 --> 00:24:54,830
differences what's the next big thing

473
00:24:54,830 --> 00:25:01,399
after Windows so just very vaguely I

474
00:25:01,399 --> 00:25:03,950
think that that we need some some system

475
00:25:03,950 --> 00:25:08,210
of connecting nodes together and kind of

476
00:25:08,210 --> 00:25:10,580
managing multiple nodes and opening

477
00:25:10,580 --> 00:25:13,389
channels between them that sort of thing

478
00:25:13,389 --> 00:25:16,759
what are the the biggest problems people

479
00:25:16,759 --> 00:25:23,529
have with node is that your question a

480
00:25:23,529 --> 00:25:26,960
lot of people come to it and say people

481
00:25:26,960 --> 00:25:28,639
can't program like this this is

482
00:25:28,639 --> 00:25:32,389
impossible like this this outside in

483
00:25:32,389 --> 00:25:34,129
word whatever spaghetti programming

484
00:25:34,129 --> 00:25:37,749
style is is impossible to program in I

485
00:25:37,749 --> 00:25:40,369
think those people haven't actually sat

486
00:25:40,369 --> 00:25:42,710
down and like tried to write a program

487
00:25:42,710 --> 00:25:44,659
or gotten deeply into it and I don't

488
00:25:44,659 --> 00:25:47,450
think that that's really a huge problem

489
00:25:47,450 --> 00:25:50,419
I think you can learn to do it's a

490
00:25:50,419 --> 00:25:52,669
different programming style for sure but

491
00:25:52,669 --> 00:25:55,730
you can learn to deal with that that

492
00:25:55,730 --> 00:26:00,230
style of programming um I think the the

493
00:26:00,230 --> 00:26:02,169
doubt that would be the made the most

494
00:26:02,169 --> 00:26:04,730
the largest complaint the the second

495
00:26:04,730 --> 00:26:07,879
largest complaint is the the point that

496
00:26:07,879 --> 00:26:11,629
node is a single threaded deal

497
00:26:11,629 --> 00:26:18,919
so I mean yeah you the you can't get

498
00:26:18,919 --> 00:26:22,039
node to be scheduled to multiple CPUs

499
00:26:22,039 --> 00:26:24,049
right so you you can't if you have this

500
00:26:24,049 --> 00:26:25,970
server you can't you can't

501
00:26:25,970 --> 00:26:28,789
naively take advantage of all the cores

502
00:26:28,789 --> 00:26:32,240
on your system but we have ways of doing

503
00:26:32,240 --> 00:26:34,730
dealing with that actually by I mean we

504
00:26:34,730 --> 00:26:37,100
have a method of doing pre fork servers

505
00:26:37,100 --> 00:26:39,919
and passing the server file descriptor

506
00:26:39,919 --> 00:26:41,570
between processes and accepting

507
00:26:41,570 --> 00:26:43,770
connections on each of them

508
00:26:43,770 --> 00:26:48,419
I do think as I as I said what the next

509
00:26:48,419 --> 00:26:50,400
big thing for note is that there is some

510
00:26:50,400 --> 00:26:53,610
work to do with organizing these

511
00:26:53,610 --> 00:26:55,590
multiple processes and making that

512
00:26:55,590 --> 00:26:57,330
easier and more approachable and

513
00:26:57,330 --> 00:27:00,120
possibly more native to note one thing I

514
00:27:00,120 --> 00:27:02,240
didn't talk about with Windows is that

515
00:27:02,240 --> 00:27:10,890
is that one minute 30 seconds okay one

516
00:27:10,890 --> 00:27:12,000
thing I didn't talk about with Windows

517
00:27:12,000 --> 00:27:13,500
is that Windows really hates processes

518
00:27:13,500 --> 00:27:16,140
and they don't it's not clear to us

519
00:27:16,140 --> 00:27:18,539
right now how we are going to do the pre

520
00:27:18,539 --> 00:27:20,460
fork server thing on Windows because you

521
00:27:20,460 --> 00:27:24,090
can't actually do the iocp except on

522
00:27:24,090 --> 00:27:25,950
multiple processes on the same file

523
00:27:25,950 --> 00:27:28,200
descriptor in Windows there's some

524
00:27:28,200 --> 00:27:30,360
trickery that we can do by having

525
00:27:30,360 --> 00:27:33,179
another thread and using select just for

526
00:27:33,179 --> 00:27:35,070
accepting sockets and then you know you

527
00:27:35,070 --> 00:27:36,750
can you can kind of get that into the

528
00:27:36,750 --> 00:27:40,590
main iocp event loop but that's not what

529
00:27:40,590 --> 00:27:42,750
Windows wants you to do they they want

530
00:27:42,750 --> 00:27:44,820
you to have multiple threads in one

531
00:27:44,820 --> 00:27:48,240
process and use iocp to dispatch to to

532
00:27:48,240 --> 00:27:51,030
these threads so one thing that's

533
00:27:51,030 --> 00:27:54,120
happening in in v8 3.2 which is the

534
00:27:54,120 --> 00:27:56,039
version right after us we're pegged to

535
00:27:56,039 --> 00:27:59,940
3.1 right now is they're doing a v8

536
00:27:59,940 --> 00:28:01,590
there they have a new feature called

537
00:28:01,590 --> 00:28:04,440
isolates which is basically you know

538
00:28:04,440 --> 00:28:06,510
they used a lot of global variables and

539
00:28:06,510 --> 00:28:08,070
now they're all packaging them up into

540
00:28:08,070 --> 00:28:10,559
into an object so that you can start

541
00:28:10,559 --> 00:28:14,820
multiple VMs inside of one process so

542
00:28:14,820 --> 00:28:16,620
these VMs are thick right I mean they're

543
00:28:16,620 --> 00:28:19,860
they're ten megabytes or something right

544
00:28:19,860 --> 00:28:22,470
they they don't share anything which is

545
00:28:22,470 --> 00:28:24,809
fine but that could be used and they're

546
00:28:24,809 --> 00:28:27,179
going to use this on Chrome we could use

547
00:28:27,179 --> 00:28:30,780
it to to start multiple v8 inside one

548
00:28:30,780 --> 00:28:35,210
process and use iocp to to schedule the

549
00:28:35,210 --> 00:28:38,010
isolates onto threads as they become

550
00:28:38,010 --> 00:28:38,460
available

551
00:28:38,460 --> 00:28:39,960
that would be the Windows II way to do

552
00:28:39,960 --> 00:28:42,539
it but we also don't want to get too far

553
00:28:42,539 --> 00:28:44,460
away from how UNIX does it so it's

554
00:28:44,460 --> 00:28:45,809
unclear if we should split the

555
00:28:45,809 --> 00:28:49,020
implementation or you know on on UNIX

556
00:28:49,020 --> 00:28:51,570
you use multiple processes on on Windows

557
00:28:51,570 --> 00:28:53,429
you use multiple threads or if we should

558
00:28:53,429 --> 00:28:56,450
just try to port this threading idea to

559
00:28:56,450 --> 00:29:01,250
unikz threads I mean kids these days no

560
00:29:01,250 --> 00:29:05,930
I don't know um okay well I guess I'm

