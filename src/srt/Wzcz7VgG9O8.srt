1
00:00:09,559 --> 00:00:11,880

thanks a lot everyone so just make it

2
00:00:11,880 --> 00:00:14,429
extra clear and are confusing I'm Dave

3
00:00:14,429 --> 00:00:17,670
and he's David and we built JavaScript

4
00:00:17,670 --> 00:00:20,699
kids and our dream in doing all this

5
00:00:20,699 --> 00:00:23,310
stuff is to run JavaScript as fast as II

6
00:00:23,310 --> 00:00:26,039
so sure that is pretty much totally

7
00:00:26,039 --> 00:00:28,349
crazy but it turns out that current

8
00:00:28,349 --> 00:00:29,609
systems actually are getting pretty

9
00:00:29,609 --> 00:00:32,219
close and there definitely will be lots

10
00:00:32,219 --> 00:00:34,260
of assembly on slides today as we show

11
00:00:34,260 --> 00:00:37,649
you the native code that does this so

12
00:00:37,649 --> 00:00:39,629
just a little bit of background really

13
00:00:39,629 --> 00:00:42,120
what sort of makes this hard right if

14
00:00:42,120 --> 00:00:44,520
you use a compiler that generally helps

15
00:00:44,520 --> 00:00:46,559
make your code run fast by pine native

16
00:00:46,559 --> 00:00:48,960
code so the thing that makes it hard for

17
00:00:48,960 --> 00:00:50,879
javascript is the fact that javascript

18
00:00:50,879 --> 00:00:52,649
is on time you don't have any type

19
00:00:52,649 --> 00:00:55,230
declarations anything and the reason is

20
00:00:55,230 --> 00:00:57,180
that having different types in the

21
00:00:57,180 --> 00:00:59,010
program means the processor needs to do

22
00:00:59,010 --> 00:01:01,500
different things so in JavaScript a plus

23
00:01:01,500 --> 00:01:03,210
B can actually do a lot of different

24
00:01:03,210 --> 00:01:04,860
things right if you're adding strings or

25
00:01:04,860 --> 00:01:06,229
finding numbers that's going to require

26
00:01:06,229 --> 00:01:09,270
different native code same thing for

27
00:01:09,270 --> 00:01:10,740
properties if you look at these two

28
00:01:10,740 --> 00:01:12,600
things here if we try to access this

29
00:01:12,600 --> 00:01:15,509
color property on a string or an object

30
00:01:15,509 --> 00:01:16,740
you actually have to do different things

31
00:01:16,740 --> 00:01:19,890
so you need different code and in davis

32
00:01:19,890 --> 00:01:21,000
it turns out to get even more

33
00:01:21,000 --> 00:01:23,070
complicated so in here i just added

34
00:01:23,070 --> 00:01:24,450
something we're adding a couple of

35
00:01:24,450 --> 00:01:26,189
floating-point numbers as an

36
00:01:26,189 --> 00:01:28,770
optimization the engine often tries to

37
00:01:28,770 --> 00:01:30,659
do things with integers but you might

38
00:01:30,659 --> 00:01:32,460
need floats and so even though they're

39
00:01:32,460 --> 00:01:34,439
the same jst few actually need different

40
00:01:34,439 --> 00:01:37,200
get code for even those two things and

41
00:01:37,200 --> 00:01:39,240
it's also the same here for these two

42
00:01:39,240 --> 00:01:40,770
objects on the bottom they both have a

43
00:01:40,770 --> 00:01:42,299
color property if both has the same

44
00:01:42,299 --> 00:01:44,820
value but in most jits you actually need

45
00:01:44,820 --> 00:01:46,979
to run a little bit different code to

46
00:01:46,979 --> 00:01:50,070
make that happen so today we're going to

47
00:01:50,070 --> 00:01:52,470
talk about two different kinds of jets

48
00:01:52,470 --> 00:01:54,810
here so first there's the simpler

49
00:01:54,810 --> 00:01:57,780
untyped jet and the idea of that one is

50
00:01:57,780 --> 00:01:59,070
for every little piece of your

51
00:01:59,070 --> 00:02:00,719
JavaScript program you generate some

52
00:02:00,719 --> 00:02:02,430
native code that handles all possible

53
00:02:02,430 --> 00:02:04,590
types so it's like you drop down this so

54
00:02:04,590 --> 00:02:06,479
a multi tool that can do everything for

55
00:02:06,479 --> 00:02:08,970
every statement in your program and the

56
00:02:08,970 --> 00:02:10,300
good thing about that is it's

57
00:02:10,300 --> 00:02:12,280
simple to do and the generated code can

58
00:02:12,280 --> 00:02:13,990
run no matter what types a program

59
00:02:13,990 --> 00:02:16,090
actually has but the code is pretty big

60
00:02:16,090 --> 00:02:17,530
because you're generating a lot of code

61
00:02:17,530 --> 00:02:19,360
maybe some of it won't even run and it's

62
00:02:19,360 --> 00:02:22,300
a little bit hard to optimize so that

63
00:02:22,300 --> 00:02:23,440
one actually turns out to give you a

64
00:02:23,440 --> 00:02:24,910
pretty fast code if you want to get even

65
00:02:24,910 --> 00:02:26,890
better what you can do is usually called

66
00:02:26,890 --> 00:02:29,260
a type so in this one either by

67
00:02:29,260 --> 00:02:31,090
using some type inference or just

68
00:02:31,090 --> 00:02:33,220
measuring dynamically you try to guess

69
00:02:33,220 --> 00:02:34,810
types for each variable and then you

70
00:02:34,810 --> 00:02:36,340
generate code specialized for those

71
00:02:36,340 --> 00:02:38,890
types so in this case you know for each

72
00:02:38,890 --> 00:02:40,300
statement in the program you try to

73
00:02:40,300 --> 00:02:42,430
figure out the types are use a little

74
00:02:42,430 --> 00:02:44,800
bit of specialized code just for that so

75
00:02:44,800 --> 00:02:46,330
you get sort of smaller code and it's

76
00:02:46,330 --> 00:02:48,880
more optimized the disadvantage is that

77
00:02:48,880 --> 00:02:50,950
you do have to recompile of types change

78
00:02:50,950 --> 00:02:52,450
right so if you were sort of guessed

79
00:02:52,450 --> 00:02:55,300
there would be a nail so you used a

80
00:02:55,300 --> 00:02:56,590
hammer and your compiler and it turns

81
00:02:56,590 --> 00:02:58,090
out there's a screw that's not really

82
00:02:58,090 --> 00:02:59,680
going to work you need to do something

83
00:02:59,680 --> 00:03:03,010
else so now on to the assembly and damn

84
00:03:03,010 --> 00:03:05,490
it's gonna start out by telling us about

85
00:03:05,490 --> 00:03:12,490
math is this here this isn't your first

86
00:03:12,490 --> 00:03:17,500
sight of it hey go yeah have a thing so

87
00:03:17,500 --> 00:03:19,480
to start off let's take this sample

88
00:03:19,480 --> 00:03:22,060
function here takes in a left and right

89
00:03:22,060 --> 00:03:24,280
variable and just adds them and let's

90
00:03:24,280 --> 00:03:25,480
see how this would work in an untyped

91
00:03:25,480 --> 00:03:28,690
compiler so an untyped compiler wants to

92
00:03:28,690 --> 00:03:30,250
handle everything so we want to generate

93
00:03:30,250 --> 00:03:32,230
code that will handle all possible types

94
00:03:32,230 --> 00:03:34,750
for left and right but we want to start

95
00:03:34,750 --> 00:03:37,750
somewhere simple so let's start off with

96
00:03:37,750 --> 00:03:39,880
just assuming that left and right are

97
00:03:39,880 --> 00:03:42,690
going to be numbers and as you know

98
00:03:42,690 --> 00:03:46,180
JavaScript semantics say that JavaScript

99
00:03:46,180 --> 00:03:48,550
numbers are always floating point but

100
00:03:48,550 --> 00:03:50,260
machines can use both integers and

101
00:03:50,260 --> 00:03:54,400
floats and integers tend to be faster so

102
00:03:54,400 --> 00:03:56,350
if we call this function with say five

103
00:03:56,350 --> 00:03:57,670
and ten we want to treat those as

104
00:03:57,670 --> 00:04:01,750
integers instead of floats so let's

105
00:04:01,750 --> 00:04:03,550
start off let's say our compiler has a

106
00:04:03,550 --> 00:04:05,920
register allocator and it decides that

107
00:04:05,920 --> 00:04:07,660
the left and right hand side should be

108
00:04:07,660 --> 00:04:10,870
in registers eax and edx we might

109
00:04:10,870 --> 00:04:12,430
generate just this one instruction

110
00:04:12,430 --> 00:04:14,620
machine instruction that says add the

111
00:04:14,620 --> 00:04:19,200
two integers in registers EDX and eax

112
00:04:19,200 --> 00:04:22,630
both say eax is actually a pointer to a

113
00:04:22,630 --> 00:04:23,720
string

114
00:04:23,720 --> 00:04:28,430
and EDX is number 35 so this is bad

115
00:04:28,430 --> 00:04:30,800
because we'll just be adding a number to

116
00:04:30,800 --> 00:04:34,310
a string which is I'm sorry a number to

117
00:04:34,310 --> 00:04:36,980
a pointer to memory which is completely

118
00:04:36,980 --> 00:04:39,500
bogus and at best at some kind of

119
00:04:39,500 --> 00:04:43,190
security risk so we can't do that so

120
00:04:43,190 --> 00:04:45,710
what we need to do is insert type checks

121
00:04:45,710 --> 00:04:48,320
before the ad and that's this code in

122
00:04:48,320 --> 00:04:50,720
magenta here and now the compiler needs

123
00:04:50,720 --> 00:04:52,610
to keep track with both the types and

124
00:04:52,610 --> 00:04:56,150
the values of the variables so let's see

125
00:04:56,150 --> 00:04:57,530
what would happen when we run this code

126
00:04:57,530 --> 00:05:01,690
let's say we're adding numbers 27 and 35

127
00:05:01,690 --> 00:05:05,300
the first thing we'll do is check to see

128
00:05:05,300 --> 00:05:08,150
if the left hands type and register EDI

129
00:05:08,150 --> 00:05:12,950
is 32 an integer and it is so that check

130
00:05:12,950 --> 00:05:15,830
passes next we'll check the right hand

131
00:05:15,830 --> 00:05:19,250
sides type and the ebx register and it

132
00:05:19,250 --> 00:05:22,310
is an integer so that passes and now we

133
00:05:22,310 --> 00:05:26,600
can just take the values in eax 27 EDX

134
00:05:26,600 --> 00:05:31,880
35 add them and we get our result just

135
00:05:31,880 --> 00:05:35,810
62 so does this always work but let's

136
00:05:35,810 --> 00:05:38,720
see what if we call F with a huge number

137
00:05:38,720 --> 00:05:41,870
so this is the maximum signed integer

138
00:05:41,870 --> 00:05:43,790
that can be represented on a 32-bit

139
00:05:43,790 --> 00:05:48,200
machine and this time if we add them the

140
00:05:48,200 --> 00:05:49,700
machine is not going to have enough bits

141
00:05:49,700 --> 00:05:52,490
to represent the actual result so it'll

142
00:05:52,490 --> 00:05:56,540
just overflow and get negative 2 so

143
00:05:56,540 --> 00:05:57,710
let's see what's supposed to happen in

144
00:05:57,710 --> 00:05:59,110
JavaScript when we add these two numbers

145
00:05:59,110 --> 00:06:02,840
we actually get four billion and as four

146
00:06:02,840 --> 00:06:06,169
billion equal to negative two no so we

147
00:06:06,169 --> 00:06:08,330
have to do something there and luckily

148
00:06:08,330 --> 00:06:11,180
the machine sets an overflow bit on the

149
00:06:11,180 --> 00:06:14,120
CPU whenever an overflow occurs so we

150
00:06:14,120 --> 00:06:16,370
can just check that bit and when it

151
00:06:16,370 --> 00:06:19,900
happens do floating-point math instead

152
00:06:19,900 --> 00:06:23,770
so what about floats let's say we pass f

153
00:06:23,770 --> 00:06:26,900
2.7 and pie and we want that to be fast

154
00:06:26,900 --> 00:06:31,280
too so in this case we can extend each

155
00:06:31,280 --> 00:06:32,870
of these little type checks with another

156
00:06:32,870 --> 00:06:33,880
block of code

157
00:06:33,880 --> 00:06:35,950
that will try to coerce the two inputs

158
00:06:35,950 --> 00:06:39,310
to floating point numbers and if those

159
00:06:39,310 --> 00:06:41,080
pass and it can get floats out of them

160
00:06:41,080 --> 00:06:43,420
it will add them together and continue

161
00:06:43,420 --> 00:06:46,090
running jit code as you can see this on

162
00:06:46,090 --> 00:06:49,030
compiling this whole add expression for

163
00:06:49,030 --> 00:06:52,840
numbers is about 30 instructions so

164
00:06:52,840 --> 00:06:54,220
let's write a little benchmark let's say

165
00:06:54,220 --> 00:06:57,130
we have a 2-d game and we said we want

166
00:06:57,130 --> 00:06:58,510
to compute the distance between this

167
00:06:58,510 --> 00:07:01,690
lady and the cow we might use Euclidean

168
00:07:01,690 --> 00:07:04,000
distance or something so this is a small

169
00:07:04,000 --> 00:07:06,160
benchmark that loops over two variables

170
00:07:06,160 --> 00:07:08,050
and just computes the distance between

171
00:07:08,050 --> 00:07:13,480
them and in an untyped compiler each of

172
00:07:13,480 --> 00:07:15,880
those little sub expressions would be

173
00:07:15,880 --> 00:07:18,430
compiled separately and in the end we

174
00:07:18,430 --> 00:07:21,190
get about 230 instructions for the

175
00:07:21,190 --> 00:07:24,820
entirety of the loop and that seems like

176
00:07:24,820 --> 00:07:26,890
a lot but despite that jager monkey the

177
00:07:26,890 --> 00:07:29,560
n-type compiler in Firefox can run 100

178
00:07:29,560 --> 00:07:31,330
million iterations of that in one second

179
00:07:31,330 --> 00:07:33,280
which is pretty cool for JavaScript it

180
00:07:33,280 --> 00:07:35,020
means in one second you can do 100

181
00:07:35,020 --> 00:07:38,790
million operations but can we do better

182
00:07:38,790 --> 00:07:41,580
so let's say we had a type compiler and

183
00:07:41,580 --> 00:07:44,740
the type compiler can just maybe it

184
00:07:44,740 --> 00:07:46,780
wants to assume that every value in this

185
00:07:46,780 --> 00:07:49,590
function is going to be an integer and

186
00:07:49,590 --> 00:07:51,540
then we can start making observations

187
00:07:51,540 --> 00:07:55,390
like this a minus I times a minus I will

188
00:07:55,390 --> 00:07:57,060
never change inside the intervals loop

189
00:07:57,060 --> 00:07:59,830
so we can actually pull it out into the

190
00:07:59,830 --> 00:08:02,980
outer loop and this is called hoisting

191
00:08:02,980 --> 00:08:05,380
and why couldn't we do that in an

192
00:08:05,380 --> 00:08:07,780
untyped chip well let's say we had this

193
00:08:07,780 --> 00:08:10,860
crazy object with a value of hook and

194
00:08:10,860 --> 00:08:12,910
every time the value of function is

195
00:08:12,910 --> 00:08:14,710
called it increases this goal variable

196
00:08:14,710 --> 00:08:17,110
called ham if you were to pass this

197
00:08:17,110 --> 00:08:21,040
object into our benchmark JavaScript

198
00:08:21,040 --> 00:08:22,420
semantics say that ham has to be

199
00:08:22,420 --> 00:08:24,310
increased every time the object is used

200
00:08:24,310 --> 00:08:26,440
in one of those arithmetic expressions

201
00:08:26,440 --> 00:08:28,780
so the hoisting is only valid if we've

202
00:08:28,780 --> 00:08:30,880
proved or assumed that every variable in

203
00:08:30,880 --> 00:08:35,770
the function is an integer then we can

204
00:08:35,770 --> 00:08:38,530
make another observation in P minus J

205
00:08:38,530 --> 00:08:41,140
times B minus J we don't have to compute

206
00:08:41,140 --> 00:08:43,900
P minus J twice so we can just throw

207
00:08:43,900 --> 00:08:45,850
that in a temporary variable and that's

208
00:08:45,850 --> 00:08:46,900
called redundancy

209
00:08:46,900 --> 00:08:50,800
elimination so in the type jit this is a

210
00:08:50,800 --> 00:08:53,290
sample of assembly from Mozilla's in

211
00:08:53,290 --> 00:08:55,180
development type called Iron Monkey

212
00:08:55,180 --> 00:08:57,940
it's not the full assembly I've removed

213
00:08:57,940 --> 00:08:59,920
some crappy register allocation

214
00:08:59,920 --> 00:09:01,810
instructions so we'll get to this

215
00:09:01,810 --> 00:09:05,080
eventually but as you can see there's

216
00:09:05,080 --> 00:09:07,960
just a subtraction multiplication and in

217
00:09:07,960 --> 00:09:10,480
addition we still have our overflow

218
00:09:10,480 --> 00:09:13,030
checks and on the multiplication there's

219
00:09:13,030 --> 00:09:15,580
also this test instruction and that's

220
00:09:15,580 --> 00:09:18,280
testing 40 because in JavaScript if you

221
00:09:18,280 --> 00:09:20,980
have say negative 1 times 0 that

222
00:09:20,980 --> 00:09:23,410
actually has to yield negative 0 which

223
00:09:23,410 --> 00:09:25,810
can't be represented in an integer so we

224
00:09:25,810 --> 00:09:28,870
have to check for that and I'm monkey

225
00:09:28,870 --> 00:09:31,420
runs this in 250 milliseconds so that's

226
00:09:31,420 --> 00:09:34,270
Forks faster than the untyped yet but if

227
00:09:34,270 --> 00:09:35,830
it was a little smarter it could

228
00:09:35,830 --> 00:09:38,050
recognize that if you have an expression

229
00:09:38,050 --> 00:09:40,150
eight times a it'll never be negative so

230
00:09:40,150 --> 00:09:41,890
we could get this down to six

231
00:09:41,890 --> 00:09:44,560
instructions and that runs in just 220

232
00:09:44,560 --> 00:09:46,720
milliseconds or four and a half times

233
00:09:46,720 --> 00:09:50,710
faster than the untyped it so our goal

234
00:09:50,710 --> 00:09:52,750
is to get as fast to see how close do we

235
00:09:52,750 --> 00:09:55,870
get to that so in see this is just for

236
00:09:55,870 --> 00:09:58,180
instructions really three our

237
00:09:58,180 --> 00:10:00,220
subtraction multiplication add and then

238
00:10:00,220 --> 00:10:04,570
a register move and see one's this in 97

239
00:10:04,570 --> 00:10:07,360
milliseconds so an untyped it got within

240
00:10:07,360 --> 00:10:09,940
10 X of C and at type Jake gets within

241
00:10:09,940 --> 00:10:12,220
two or three acts of see that's actually

242
00:10:12,220 --> 00:10:13,840
really cool considering that three or

243
00:10:13,840 --> 00:10:16,180
four years ago javascript was a hundred

244
00:10:16,180 --> 00:10:19,710
x slower than C but how can we do better

245
00:10:19,710 --> 00:10:21,970
well in this case it's actually pretty

246
00:10:21,970 --> 00:10:24,280
hard there's this semantic gap where

247
00:10:24,280 --> 00:10:26,350
JavaScript just does not have integers

248
00:10:26,350 --> 00:10:31,480
it only has floats and C has integers so

249
00:10:31,480 --> 00:10:33,600
it does not need those overflow checks

250
00:10:33,600 --> 00:10:35,920
and now dave is going to talk about

251
00:10:35,920 --> 00:10:44,380
property access

252
00:10:44,390 --> 00:10:47,970
okay so this is the other major type of

253
00:10:47,970 --> 00:10:48,870
jade code that we're going to show you

254
00:10:48,870 --> 00:10:51,060
is how objects and object properties

255
00:10:51,060 --> 00:10:53,070
work and in general this is one of the

256
00:10:53,070 --> 00:10:54,960
most important optimizations in practice

257
00:10:54,960 --> 00:10:57,180
it gets a huge speed up it's important

258
00:10:57,180 --> 00:11:01,050
for real programs and so I'm going to

259
00:11:01,050 --> 00:11:03,210
because it's complicated right Jas

260
00:11:03,210 --> 00:11:04,980
obvious properties are complicated and

261
00:11:04,980 --> 00:11:06,630
the jit code gets complicated too i

262
00:11:06,630 --> 00:11:08,790
boiled this down to pretty much the

263
00:11:08,790 --> 00:11:10,290
simplest thing I could possibly think of

264
00:11:10,290 --> 00:11:13,440
just evaluating one level expression no

265
00:11:13,440 --> 00:11:16,350
next it's just to get a property and I'm

266
00:11:16,350 --> 00:11:18,120
thinking of kind of a linked list here

267
00:11:18,120 --> 00:11:19,830
that I can diverse I did that so I could

268
00:11:19,830 --> 00:11:21,690
sort of do some benchmarks and show the

269
00:11:21,690 --> 00:11:24,540
performance so in order to show you how

270
00:11:24,540 --> 00:11:26,160
you get these things first I have to

271
00:11:26,160 --> 00:11:28,320
show you what's inside a GS object so

272
00:11:28,320 --> 00:11:30,090
here's the constructor I have in mind

273
00:11:30,090 --> 00:11:32,220
and this is from spider monkey a

274
00:11:32,220 --> 00:11:34,320
simplified version of how that objects

275
00:11:34,320 --> 00:11:35,940
represented it's just this little memory

276
00:11:35,940 --> 00:11:38,190
object to see struct so there's some

277
00:11:38,190 --> 00:11:39,750
stuff in there like the prototype and

278
00:11:39,750 --> 00:11:41,880
things you'd expect but the most

279
00:11:41,880 --> 00:11:43,890
important things there are first there's

280
00:11:43,890 --> 00:11:45,960
the shape and that's something that

281
00:11:45,960 --> 00:11:47,790
gives the object format so the main

282
00:11:47,790 --> 00:11:49,380
things it has are a list of properties

283
00:11:49,380 --> 00:11:51,900
and then a slot index as to where you

284
00:11:51,900 --> 00:11:54,420
can actually find each one and the thing

285
00:11:54,420 --> 00:11:55,440
to note about the use is they're

286
00:11:55,440 --> 00:11:58,050
generally shared so if you have what the

287
00:11:58,050 --> 00:11:59,580
system will try to do is every object

288
00:11:59,580 --> 00:12:01,260
that looks like this it will try to make

289
00:12:01,260 --> 00:12:02,730
sure it gets the same shape and has

290
00:12:02,730 --> 00:12:05,640
shape 45 so you can easily tell that it

291
00:12:05,640 --> 00:12:08,490
does and then the automated fingers this

292
00:12:08,490 --> 00:12:09,900
laws and that's just where the values

293
00:12:09,900 --> 00:12:11,460
are held it's just a little array of

294
00:12:11,460 --> 00:12:14,460
JavaScript values and so to look up the

295
00:12:14,460 --> 00:12:16,170
next property what you do if you're not

296
00:12:16,170 --> 00:12:18,000
using a jit is first you go to this

297
00:12:18,000 --> 00:12:20,760
shape table you find next you see okay

298
00:12:20,760 --> 00:12:23,130
that's in slot 1 and then you go over to

299
00:12:23,130 --> 00:12:25,530
 you read slot 1 you say okay that

300
00:12:25,530 --> 00:12:27,920
you read slot 1 you say okay that
has type special and the values though

301
00:12:27,920 --> 00:12:31,020
so let's start a gentes in an untyped it

302
00:12:31,020 --> 00:12:33,210
like Jager monkey so we'll just start

303
00:12:33,210 --> 00:12:36,420
off first thing we'll do is load up the

304
00:12:36,420 --> 00:12:38,580
type tag and verify that it's an object

305
00:12:38,580 --> 00:12:40,470
it's just like before we have some fast

306
00:12:40,470 --> 00:12:41,970
path for object we need to make sure we

307
00:12:41,970 --> 00:12:44,430
have that so we're just loading a tag

308
00:12:44,430 --> 00:12:46,680
from Emory we compared to this FF 87

309
00:12:46,680 --> 00:12:48,960
which tells us it's an object so if

310
00:12:48,960 --> 00:12:50,970
that's good then we continue on now

311
00:12:50,970 --> 00:12:52,980
oh the value note there is some little

312
00:12:52,980 --> 00:12:54,689
register allocation glitch here fairly

313
00:12:54,689 --> 00:12:57,050
harmless but these things do happen and

314
00:12:57,050 --> 00:13:00,810
so now we have the object one operates

315
00:13:00,810 --> 00:13:03,779
what do we do next well the n-type Jade

316
00:13:03,779 --> 00:13:05,639
actually has a problem here right for

317
00:13:05,639 --> 00:13:07,199
that one we want to generate fast code

318
00:13:07,199 --> 00:13:08,699
that handles all the types but here's

319
00:13:08,699 --> 00:13:10,079
the text you can get you could get an

320
00:13:10,079 --> 00:13:11,670
object that has a type that looks like

321
00:13:11,670 --> 00:13:13,680
this here's a different type of object

322
00:13:13,680 --> 00:13:15,720
requires different jet code here's a

323
00:13:15,720 --> 00:13:17,850
different type of object even more jet

324
00:13:17,850 --> 00:13:20,550
code so really there's a infinite number

325
00:13:20,550 --> 00:13:22,889
of possible types here so there's no way

326
00:13:22,889 --> 00:13:24,089
that you could generate them all and

327
00:13:24,089 --> 00:13:25,800
worse than that the JIT doesn't even

328
00:13:25,800 --> 00:13:28,379
know like what they are what shapes they

329
00:13:28,379 --> 00:13:29,759
would have how you'd identify them

330
00:13:29,759 --> 00:13:32,279
anything at all so pretty much at this

331
00:13:32,279 --> 00:13:34,709
point we get to go to the simplicity and

332
00:13:34,709 --> 00:13:37,829
ease of self-modifying code and so this

333
00:13:37,829 --> 00:13:39,540
is called inline caching it's a bit of

334
00:13:39,540 --> 00:13:41,279
historical term it's from the self

335
00:13:41,279 --> 00:13:42,959
research that really pioneered a lot of

336
00:13:42,959 --> 00:13:45,300
optimization for dynamic languages and

337
00:13:45,300 --> 00:13:47,370
so to show you how that works i'm going

338
00:13:47,370 --> 00:13:49,110
to work backwards so first i'm going to

339
00:13:49,110 --> 00:13:51,120
show you the code we want to get so this

340
00:13:51,120 --> 00:13:52,709
would be code that would run fast and

341
00:13:52,709 --> 00:13:55,350
get the next property for the shake 45

342
00:13:55,350 --> 00:13:58,170
so we have that top that operates that I

343
00:13:58,170 --> 00:13:59,550
already showed you that gets the object

344
00:13:59,550 --> 00:14:01,500
so the next thing we need to do is make

345
00:14:01,500 --> 00:14:04,500
sure that we have shape 45 so in this

346
00:14:04,500 --> 00:14:07,470
blue code here ESI hose the object so

347
00:14:07,470 --> 00:14:09,750
we're just loading that shape field we

348
00:14:09,750 --> 00:14:13,110
test it keep going it's matches so then

349
00:14:13,110 --> 00:14:14,790
the next thing we do is we load that

350
00:14:14,790 --> 00:14:16,529
slots porn air out of the same object

351
00:14:16,529 --> 00:14:18,930
and then at the bottom here we load the

352
00:14:18,930 --> 00:14:21,559
type and value so this ESI plus 12

353
00:14:21,559 --> 00:14:25,410
that's loading from the slot array type

354
00:14:25,410 --> 00:14:29,370
and then we load the value so the only

355
00:14:29,370 --> 00:14:30,809
problem here is that these values in

356
00:14:30,809 --> 00:14:32,550
white you don't know that my compile

357
00:14:32,550 --> 00:14:34,199
time we don't know what the shape is we

358
00:14:34,199 --> 00:14:35,699
don't know its shape to expect or what

359
00:14:35,699 --> 00:14:37,439
the floor mats are and the idea of

360
00:14:37,439 --> 00:14:39,120
inline caching is to really say well

361
00:14:39,120 --> 00:14:40,649
let's just generate a template here and

362
00:14:40,649 --> 00:14:42,870
then have it modify itself to the right

363
00:14:42,870 --> 00:14:45,629
code at runtime so here is the actual

364
00:14:45,629 --> 00:14:48,180
code it's the same thing except as w

365
00:14:48,180 --> 00:14:50,339
values in those positions and I'll just

366
00:14:50,339 --> 00:14:52,620
show you how it works by running it so

367
00:14:52,620 --> 00:14:54,899
first we run this top part that gets the

368
00:14:54,899 --> 00:14:57,509
type it's this FFA 7 it matches we keep

369
00:14:57,509 --> 00:15:00,389
going then we wrote up this value then

370
00:15:00,389 --> 00:15:01,529
we do our little funky right

371
00:15:01,529 --> 00:15:03,870
allocation thing so now we load the

372
00:15:03,870 --> 00:15:06,720
shape which is 45 and we compare that

373
00:15:06,720 --> 00:15:09,269
with this 8f does not match so we jump

374
00:15:09,269 --> 00:15:12,839
to the C++ function get prob so get

375
00:15:12,839 --> 00:15:14,220
prompt there's a few things first it

376
00:15:14,220 --> 00:15:15,779
sort of looks up that shape and finds

377
00:15:15,779 --> 00:15:17,819
the property and then it uses that to

378
00:15:17,819 --> 00:15:20,309
catch this code so it says okay the

379
00:15:20,309 --> 00:15:22,800
shapes 45 so I'll patch that and it also

380
00:15:22,800 --> 00:15:24,240
knows what these offsets should be

381
00:15:24,240 --> 00:15:26,879
patches those finally it gets the actual

382
00:15:26,879 --> 00:15:28,199
value because of course you need to do

383
00:15:28,199 --> 00:15:29,699
that or to keep running properly and

384
00:15:29,699 --> 00:15:33,120
keeps going so next time you ride it

385
00:15:33,120 --> 00:15:35,430
works pretty much you know how that code

386
00:15:35,430 --> 00:15:37,110
I showed you so we were on the first

387
00:15:37,110 --> 00:15:40,740
part gets this value and type then we

388
00:15:40,740 --> 00:15:42,569
load up the shape this time it matches

389
00:15:42,569 --> 00:15:44,639
so we can go on to our fast property

390
00:15:44,639 --> 00:15:46,649
access code we get the slots or eight

391
00:15:46,649 --> 00:15:48,870
kind of looks like this thing and then

392
00:15:48,870 --> 00:15:50,790
we get to load out the type and then we

393
00:15:50,790 --> 00:15:54,689
load up the value from that okay so that

394
00:15:54,689 --> 00:15:55,800
actually work pretty well it got a

395
00:15:55,800 --> 00:15:57,269
tattoo above instructions it runs really

396
00:15:57,269 --> 00:15:59,430
fast but Java scripts a dynamic language

397
00:15:59,430 --> 00:16:00,779
and we want to be able to take advantage

398
00:16:00,779 --> 00:16:03,959
of that so you know here is the shape of

399
00:16:03,959 --> 00:16:05,670
object that we generate a fast path for

400
00:16:05,670 --> 00:16:07,529
but somebody might write a program where

401
00:16:07,529 --> 00:16:09,509
they do this right maybe you pass things

402
00:16:09,509 --> 00:16:11,220
that have a label food property as well

403
00:16:11,220 --> 00:16:13,889
and we really do want to make this work

404
00:16:13,889 --> 00:16:16,470
correctly and run fast and it turns out

405
00:16:16,470 --> 00:16:18,930
the icy thing really does it it's almost

406
00:16:18,930 --> 00:16:21,870
exactly the same thing so if you run the

407
00:16:21,870 --> 00:16:24,389
code again with this new shape of object

408
00:16:24,389 --> 00:16:27,389
does the first part is set value so now

409
00:16:27,389 --> 00:16:29,639
we get the shape which is 70 compare

410
00:16:29,639 --> 00:16:32,189
that to 45 and it's not evil so now we

411
00:16:32,189 --> 00:16:35,490
jump to this get pop function again so a

412
00:16:35,490 --> 00:16:37,019
gift fob again it's going to look up

413
00:16:37,019 --> 00:16:40,170
that shape and find the property and now

414
00:16:40,170 --> 00:16:42,000
it's supposed to patch into shape and

415
00:16:42,000 --> 00:16:44,100
slot offsets but actually that wouldn't

416
00:16:44,100 --> 00:16:45,870
be a very good idea here because we

417
00:16:45,870 --> 00:16:48,179
could patch disseminate cody fast for

418
00:16:48,179 --> 00:16:49,769
that new shape but it's slow for the old

419
00:16:49,769 --> 00:16:51,480
shapes so we're kind of stuck right we

420
00:16:51,480 --> 00:16:52,980
sort of either have to be fast for only

421
00:16:52,980 --> 00:16:55,199
one or else we're constantly patching

422
00:16:55,199 --> 00:16:57,470
and constant patching is definitely slow

423
00:16:57,470 --> 00:16:59,759
so instead we're just going to generate

424
00:16:59,759 --> 00:17:01,800
a new code for the new shape off the

425
00:17:01,800 --> 00:17:04,020
side so it looks like this it's almost

426
00:17:04,020 --> 00:17:06,360
exactly the same really the only

427
00:17:06,360 --> 00:17:07,949
difference is we're comparing with shape

428
00:17:07,949 --> 00:17:11,100
70 instead of 45 those offsets 12 and

429
00:17:11,100 --> 00:17:13,380
eight they could be different if it was

430
00:17:13,380 --> 00:17:15,329
position that object happens not to be

431
00:17:15,329 --> 00:17:17,550
in this example and then we need to

432
00:17:17,550 --> 00:17:19,380
detach these jumps a little bit right so

433
00:17:19,380 --> 00:17:21,120
before if we didn't match we jump

434
00:17:21,120 --> 00:17:23,010
straight to get prob but now I want to

435
00:17:23,010 --> 00:17:24,420
jump to this new little fast function

436
00:17:24,420 --> 00:17:26,880
here and then we'll jump back so at this

437
00:17:26,880 --> 00:17:28,890
point we now have it fast for both

438
00:17:28,890 --> 00:17:30,570
shapes and you can really extend this

439
00:17:30,570 --> 00:17:31,890
process and definitely right it can

440
00:17:31,890 --> 00:17:34,470
handle prototypes you know you can do

441
00:17:34,470 --> 00:17:36,390
get setters really anything you want and

442
00:17:36,390 --> 00:17:38,910
just generate as many of these as you

443
00:17:38,910 --> 00:17:42,210
need ok so now I just want to show you

444
00:17:42,210 --> 00:17:45,600
what a type compiler can do for this by

445
00:17:45,600 --> 00:17:48,330
taking this untyped property access code

446
00:17:48,330 --> 00:17:50,370
and just seeing how we can speed it up a

447
00:17:50,370 --> 00:17:53,340
little bit so the first thing to observe

448
00:17:53,340 --> 00:17:55,500
is that in these objects so I put one on

449
00:17:55,500 --> 00:17:57,150
here so it has that prototype shape

450
00:17:57,150 --> 00:18:00,150
slots sometimes but not always the Jets

451
00:18:00,150 --> 00:18:02,040
has an optimization we'll put the value

452
00:18:02,040 --> 00:18:04,350
slots right inside the object so if you

453
00:18:04,350 --> 00:18:06,000
do that you don't really need to load

454
00:18:06,000 --> 00:18:07,560
that slots pointer and then load the

455
00:18:07,560 --> 00:18:10,500
value you could just see oh actually

456
00:18:10,500 --> 00:18:12,360
they're at these offsets so we'll just

457
00:18:12,360 --> 00:18:13,890
load it that way and we just eliminate

458
00:18:13,890 --> 00:18:16,200
one load the untyped compiler can't

459
00:18:16,200 --> 00:18:17,670
really do that because it has to really

460
00:18:17,670 --> 00:18:19,380
conservative and assume the object could

461
00:18:19,380 --> 00:18:21,450
look like anything the types compiler

462
00:18:21,450 --> 00:18:23,100
gets to wait longer and say oh I know

463
00:18:23,100 --> 00:18:24,570
exactly what these objects look like

464
00:18:24,570 --> 00:18:29,730
before it generates any code so next if

465
00:18:29,730 --> 00:18:30,870
you look at the bottom here you'll see

466
00:18:30,870 --> 00:18:32,910
that we're loading this tight tag that's

467
00:18:32,910 --> 00:18:36,300
what ESI plus 28 is into EDX and then

468
00:18:36,300 --> 00:18:37,980
what you don't see on this screen is

469
00:18:37,980 --> 00:18:39,480
that gets stored the memory and then it

470
00:18:39,480 --> 00:18:41,010
gets reloaded again and then we test

471
00:18:41,010 --> 00:18:42,300
again so we're sort of getting this

472
00:18:42,300 --> 00:18:44,070
thing just to move it around about three

473
00:18:44,070 --> 00:18:46,320
times then test it the types compiler

474
00:18:46,320 --> 00:18:48,450
could actually see that and optimize it

475
00:18:48,450 --> 00:18:50,370
better and say you know what we should

476
00:18:50,370 --> 00:18:51,750
just test it at the bottom because

477
00:18:51,750 --> 00:18:53,880
that's all we really need to do so

478
00:18:53,880 --> 00:18:55,530
that's two more instructions out we

479
00:18:55,530 --> 00:18:57,930
freed of her register so here's a little

480
00:18:57,930 --> 00:18:59,100
thing you don't really need type for

481
00:18:59,100 --> 00:19:01,200
this but you know it just so happens we

482
00:19:01,200 --> 00:19:03,030
generate this move and compare but you

483
00:19:03,030 --> 00:19:04,530
could do that with just one instruction

484
00:19:04,530 --> 00:19:07,740
so we'll do that and then the last thing

485
00:19:07,740 --> 00:19:10,050
is to look here at the bottom right when

486
00:19:10,050 --> 00:19:12,000
we get this node next value it goes into

487
00:19:12,000 --> 00:19:14,550
ESI in my example program that gets

488
00:19:14,550 --> 00:19:17,040
stored in node so again it sort of gets

489
00:19:17,040 --> 00:19:18,690
sort out and then at the top we're

490
00:19:18,690 --> 00:19:20,400
reloading it just to put it back

491
00:19:20,400 --> 00:19:23,100
SI we can say hey let's just leave it at

492
00:19:23,100 --> 00:19:26,460
ESI this will work completely so we move

493
00:19:26,460 --> 00:19:29,220
to our free to register so here's the

494
00:19:29,220 --> 00:19:30,900
theoretical code that we get if we start

495
00:19:30,900 --> 00:19:32,490
of use a type of pattern optimize it as

496
00:19:32,490 --> 00:19:34,140
hard as we can that I reduced from that

497
00:19:34,140 --> 00:19:36,960
jam code just has five instructions it's

498
00:19:36,960 --> 00:19:38,550
really just two checks says do we have

499
00:19:38,550 --> 00:19:40,770
an object doesn't have this shape load

500
00:19:40,770 --> 00:19:43,050
the value so if you compare a see right

501
00:19:43,050 --> 00:19:44,820
I'll let's see what need to do is the

502
00:19:44,820 --> 00:19:48,300
green thing but it's quite folks so iron

503
00:19:48,300 --> 00:19:49,890
monkey is not at the stage where you can

504
00:19:49,890 --> 00:19:51,690
actually compile this code yet so let's

505
00:19:51,690 --> 00:19:53,640
give some props to crankshaft and show a

506
00:19:53,640 --> 00:19:55,650
better version of how they did it so I

507
00:19:55,650 --> 00:19:57,240
just started out in my program and you

508
00:19:57,240 --> 00:19:58,320
can see that it's actually very much

509
00:19:58,320 --> 00:20:01,080
like what I came up with so the top here

510
00:20:01,080 --> 00:20:03,510
they have a test to verify it's an

511
00:20:03,510 --> 00:20:05,700
object just like we're doing those looks

512
00:20:05,700 --> 00:20:08,040
different because instead of using sort

513
00:20:08,040 --> 00:20:10,560
of separate type and value areas they

514
00:20:10,560 --> 00:20:13,230
just put the last bit of the object they

515
00:20:13,230 --> 00:20:14,730
just set it to one that's how they say a

516
00:20:14,730 --> 00:20:17,430
snob drink so and then they check the

517
00:20:17,430 --> 00:20:19,380
shape it's actually very similar to ours

518
00:20:19,380 --> 00:20:21,270
you can see that they're just loading a

519
00:20:21,270 --> 00:20:23,430
value and comparing that with some shape

520
00:20:23,430 --> 00:20:25,230
in their case they have to have this

521
00:20:25,230 --> 00:20:26,640
little minus one there because their

522
00:20:26,640 --> 00:20:28,260
object pointer has that extra one from

523
00:20:28,260 --> 00:20:30,540
the tag otherwise the same and then they

524
00:20:30,540 --> 00:20:31,800
just load a field out so it looks

525
00:20:31,800 --> 00:20:35,730
exactly like that all right so here's

526
00:20:35,730 --> 00:20:36,870
the performance that you get when you

527
00:20:36,870 --> 00:20:38,630
use all these things in a classic

528
00:20:38,630 --> 00:20:41,580
interpreter spider monkey if I search

529
00:20:41,580 --> 00:20:43,200
the link list with 1 million elements

530
00:20:43,200 --> 00:20:45,840
like this it takes 100 milliseconds so

531
00:20:45,840 --> 00:20:47,880
if we use an untied from piracy ICS we

532
00:20:47,880 --> 00:20:49,470
get like a three or four x speed up down

533
00:20:49,470 --> 00:20:52,680
to 29 that's jager monkey and if you use

534
00:20:52,680 --> 00:20:54,630
a time compiler like crankshaft I found

535
00:20:54,630 --> 00:20:56,910
that you are actually you know almost

536
00:20:56,910 --> 00:21:00,150
within 1.5 x of C but definitely 2x very

537
00:21:00,150 --> 00:21:02,580
very close and that's your even the

538
00:21:02,580 --> 00:21:05,940
highly optimized seen so last things

539
00:21:05,940 --> 00:21:08,070
that are like yes we actually can run

540
00:21:08,070 --> 00:21:09,900
JavaScript within two or three ecstasy

541
00:21:09,900 --> 00:21:11,940
sometimes now and in fact with floating

542
00:21:11,940 --> 00:21:13,440
point things because we don't have that

543
00:21:13,440 --> 00:21:15,450
semantic gap we found programs where it

544
00:21:15,450 --> 00:21:18,900
runs just as fast and jazz to see and we

545
00:21:18,900 --> 00:21:20,580
really would like to keep getting faster

546
00:21:20,580 --> 00:21:21,930
and faster there's a bunch of stuff we

547
00:21:21,930 --> 00:21:24,060
can do but to really get there we need

548
00:21:24,060 --> 00:21:26,490
to bridge this semantic gap we're sort

549
00:21:26,490 --> 00:21:27,450
of the processors

550
00:21:27,450 --> 00:21:29,340
semantics Jas has others were two

551
00:21:29,340 --> 00:21:31,679
different and sort of if we could nudge

552
00:21:31,679 --> 00:21:33,360
either one a little bit close together

553
00:21:33,360 --> 00:21:36,750
we might be able to get there so thank

554
00:21:36,750 --> 00:21:47,930
you

555
00:21:47,940 --> 00:21:59,389
awesome any questions

556
00:21:59,399 --> 00:22:12,730
oh yeah Eric

557
00:22:12,740 --> 00:22:17,330
for the for the untyped compiler when

558
00:22:17,330 --> 00:22:19,370
you're checking the shape and it doesn't

559
00:22:19,370 --> 00:22:22,390
match you're doing a jump to the stub

560
00:22:22,390 --> 00:22:25,280
how does it know where it was called

561
00:22:25,280 --> 00:22:30,260
from the stuff is there's a journey so

562
00:22:30,260 --> 00:22:31,910
there's actually several different ways

563
00:22:31,910 --> 00:22:33,350
of doing that do you remember which way

564
00:22:33,350 --> 00:22:36,590
we're doing it right now the jump

565
00:22:36,590 --> 00:22:38,920
actually goes to a little path that

566
00:22:38,920 --> 00:22:41,480
bakes in all the information you need to

567
00:22:41,480 --> 00:22:48,200
to patch the code all right now the

568
00:22:48,200 --> 00:23:01,960
question over there

569
00:23:01,970 --> 00:23:04,360
how do you handle the cache invalidation

570
00:23:04,360 --> 00:23:08,270
like you mean you major in line cash for

571
00:23:08,270 --> 00:23:10,940
the structure of the objects are the

572
00:23:10,940 --> 00:23:13,850
shapes better and people change the

573
00:23:13,850 --> 00:23:17,900
upper side like the prototype and oh how

574
00:23:17,900 --> 00:23:22,100
does invalidation of caching works so

575
00:23:22,100 --> 00:23:24,980
there's actually the flexure question is

576
00:23:24,980 --> 00:23:27,740
kind of complicated but the example you

577
00:23:27,740 --> 00:23:29,330
gave doesn't really require the

578
00:23:29,330 --> 00:23:31,760
invalidation of the cash so if you

579
00:23:31,760 --> 00:23:33,710
change the prototype of an object that

580
00:23:33,710 --> 00:23:36,830
will change its shape so the next time

581
00:23:36,830 --> 00:23:38,630
you have that code maybe it's now shape

582
00:23:38,630 --> 00:23:40,700
46 because you change the prototype so

583
00:23:40,700 --> 00:23:42,740
it doesn't run but there are cases where

584
00:23:42,740 --> 00:23:44,090
you have to do that because if you do a

585
00:23:44,090 --> 00:23:47,810
GC garbage collection then often that

586
00:23:47,810 --> 00:23:49,520
will sort of clean up a bunch of old

587
00:23:49,520 --> 00:23:51,350
shapes and it might change shape IDs and

588
00:23:51,350 --> 00:23:53,570
things like that so on certain events

589
00:23:53,570 --> 00:23:55,160
like that you actually do have to go

590
00:23:55,160 --> 00:23:56,780
through and basically purge all the

591
00:23:56,780 --> 00:23:59,150
inline caches and reset them to the

592
00:23:59,150 --> 00:24:01,820
original state so and and it turns out

593
00:24:01,820 --> 00:24:03,440
that doesn't really bother performance

594
00:24:03,440 --> 00:24:04,790
too much because they kind of you know

595
00:24:04,790 --> 00:24:11,210
get turned back on pretty quickly you

596
00:24:11,210 --> 00:24:14,090
mentioned that you would like to see the

597
00:24:14,090 --> 00:24:16,970
the instruction set four cpus or your

598
00:24:16,970 --> 00:24:19,430
javascript a lineup so where you could

599
00:24:19,430 --> 00:24:20,690
optimize things better what would you

600
00:24:20,690 --> 00:24:23,810
like to have included in javascript the

601
00:24:23,810 --> 00:24:26,900
language to help you achieve better

602
00:24:26,900 --> 00:24:32,030
better speeds well I guess I don't

603
00:24:32,030 --> 00:24:33,980
really want to make specific suggestions

604
00:24:33,980 --> 00:24:35,120
because I think that should be up to

605
00:24:35,120 --> 00:24:36,740
people that are sort of really language

606
00:24:36,740 --> 00:24:39,170
designers it's kind of more like hinting

607
00:24:39,170 --> 00:24:41,930
at what we do need but so I think typed

608
00:24:41,930 --> 00:24:44,900
arrays help and the binary data API

609
00:24:44,900 --> 00:24:47,600
that's coming in es6 if you're familiar

610
00:24:47,600 --> 00:24:49,610
with that one so it's time to raise you

611
00:24:49,610 --> 00:24:51,230
can actually create an object for you

612
00:24:51,230 --> 00:24:52,940
say this is an array of doubles for

613
00:24:52,940 --> 00:24:55,310
example and that means you can get a lot

614
00:24:55,310 --> 00:24:56,690
better storage because you don't have to

615
00:24:56,690 --> 00:24:58,460
store all these type tags and things you

616
00:24:58,460 --> 00:25:00,170
really just store the numbers you know

617
00:25:00,170 --> 00:25:01,220
when you read them out you know exactly

618
00:25:01,220 --> 00:25:04,250
what you get things like that so

619
00:25:04,250 --> 00:25:08,240
otherwise I think and so that it

620
00:25:08,240 --> 00:25:10,100
basically gives you something like see

621
00:25:10,100 --> 00:25:11,660
raised by an errand data API

622
00:25:11,660 --> 00:25:13,430
gives you something like see struts so

623
00:25:13,430 --> 00:25:15,380
you can be fast that way the main thing

624
00:25:15,380 --> 00:25:17,330
is integers right that's sort of the

625
00:25:17,330 --> 00:25:19,430
hard line and I could imagine different

626
00:25:19,430 --> 00:25:20,870
things like if there is even just a

627
00:25:20,870 --> 00:25:23,480
little dynamic type like new in 32 or

628
00:25:23,480 --> 00:25:25,280
something like that in JavaScript like

629
00:25:25,280 --> 00:25:27,050
that would work there's other ways of

630
00:25:27,050 --> 00:25:28,400
doing it to you could imagine creating a

631
00:25:28,400 --> 00:25:29,900
library that just has integer math

632
00:25:29,900 --> 00:25:32,120
functions in it teach the jits how to

633
00:25:32,120 --> 00:25:34,520
how to see those but it's really all

634
00:25:34,520 --> 00:25:37,190
just about I guess some way to express I

635
00:25:37,190 --> 00:25:40,010
want integer semantics now and then you

636
00:25:40,010 --> 00:25:41,990
can compile it exactly the integer math

637
00:25:41,990 --> 00:25:44,210
on the processor and be fully fast so

638
00:25:44,210 --> 00:25:47,840
that's pretty much what you need another

639
00:25:47,840 --> 00:25:53,900
question all right let's give these guys

640
00:25:53,900 --> 00:25:55,130
another own applause for making

