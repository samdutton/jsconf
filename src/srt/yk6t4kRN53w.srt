1
00:00:15,360 --> 00:00:16,920

I'm going to tell you the story of how

2
00:00:16,920 --> 00:00:19,560
assumption metamagic hat and my name is

3
00:00:19,560 --> 00:00:22,410
all of lasses and can you see that all

4
00:00:22,410 --> 00:00:24,990
the way back I hope the text size is

5
00:00:24,990 --> 00:00:26,759
good enough so so you'll find on Twitter

6
00:00:26,759 --> 00:00:29,880
a solo and so I'm going to start up by

7
00:00:29,880 --> 00:00:31,380
talking a bit about correct code so

8
00:00:31,380 --> 00:00:33,690
correct code is a great thing write code

9
00:00:33,690 --> 00:00:35,570
that works as we intended it to work

10
00:00:35,570 --> 00:00:37,559
that's perfect that is what we are

11
00:00:37,559 --> 00:00:40,829
striving for is programmers code that

12
00:00:40,829 --> 00:00:43,559
crashes needs improvement it's clearly

13
00:00:43,559 --> 00:00:46,079
not correct unless we intend it to crash

14
00:00:46,079 --> 00:00:48,690
but at least it crashes so we we know

15
00:00:48,690 --> 00:00:49,920
that there is an issue with a bit of

16
00:00:49,920 --> 00:00:51,650
code so we can go back and correct it

17
00:00:51,650 --> 00:00:54,239
the real issue is when we have incorrect

18
00:00:54,239 --> 00:00:56,190
code that keeps on running that is a

19
00:00:56,190 --> 00:00:58,470
recipe for disaster I think I strongly

20
00:00:58,470 --> 00:01:00,300
believe it is and I strongly believe

21
00:01:00,300 --> 00:01:02,550
that we sometimes as programmers focused

22
00:01:02,550 --> 00:01:04,470
too much about creating programs that

23
00:01:04,470 --> 00:01:06,899
doesn't crash while that should never be

24
00:01:06,899 --> 00:01:08,670
our main goal our main goal should be to

25
00:01:08,670 --> 00:01:11,399
produce correct programs and in the

26
00:01:11,399 --> 00:01:14,130
choice of a program that doesn't crash

27
00:01:14,130 --> 00:01:15,750
that keeps on running while it's

28
00:01:15,750 --> 00:01:18,090
incorrect and a program that crashes

29
00:01:18,090 --> 00:01:20,520
early phase fast so that we know that

30
00:01:20,520 --> 00:01:22,729
there's an issue I always pick that one

31
00:01:22,729 --> 00:01:24,840
so I guess what I'm saying is that

32
00:01:24,840 --> 00:01:26,340
crashing it's a good thing we should

33
00:01:26,340 --> 00:01:28,260
crash more we can tell our buses you

34
00:01:28,260 --> 00:01:29,970
know crashing that's a good good thing

35
00:01:29,970 --> 00:01:32,909
and fail fast as an ID that is actually

36
00:01:32,909 --> 00:01:36,180
key to making the robust programs not

37
00:01:36,180 --> 00:01:38,790
only fail fast in robust system you know

38
00:01:38,790 --> 00:01:40,320
where we have like redundancy that kind

39
00:01:40,320 --> 00:01:42,390
of junk but also in you know the normal

40
00:01:42,390 --> 00:01:44,520
day-to-day code we write fail fast I

41
00:01:44,520 --> 00:01:45,960
think it's something that makes coding

42
00:01:45,960 --> 00:01:49,080
more fun and eat better better programs

43
00:01:49,080 --> 00:01:52,530
of course it's no silver bullet in

44
00:01:52,530 --> 00:01:55,619
itself right so another code is that we

45
00:01:55,619 --> 00:01:57,810
actually need to write code that works

46
00:01:57,810 --> 00:01:59,430
getting the code right not necessarily

47
00:01:59,430 --> 00:02:01,650
from the beginning but we need to

48
00:02:01,650 --> 00:02:03,090
iterate on its order it actually works

49
00:02:03,090 --> 00:02:06,299
some time but hey let's admit that we

50
00:02:06,299 --> 00:02:08,069
make coding mistakes all the time and

51
00:02:08,069 --> 00:02:10,500
that has nothing to do with whether we

52
00:02:10,500 --> 00:02:12,720
have worked with this language that

53
00:02:12,720 --> 00:02:14,579
we're now using for a year or two where

54
00:02:14,579 --> 00:02:16,459
it would done it for two decades or

55
00:02:16,459 --> 00:02:18,599
whatever you know we make coding

56
00:02:18,599 --> 00:02:20,099
mistakes all the time of different types

57
00:02:20,099 --> 00:02:23,370
and ironically we even make a lot of

58
00:02:23,370 --> 00:02:24,450
mistakes when we are troubleshooting

59
00:02:24,450 --> 00:02:26,550
code when we are in the kind of debug

60
00:02:26,550 --> 00:02:28,050
mode will go back to code base and try

61
00:02:28,050 --> 00:02:28,890
to fix things

62
00:02:28,890 --> 00:02:30,330
we do a lot of mistakes and a lot of

63
00:02:30,330 --> 00:02:33,150
mistakes that makes us you know that

64
00:02:33,150 --> 00:02:34,830
stops us from actually identifying the

65
00:02:34,830 --> 00:02:37,650
correct correct issue but also that

66
00:02:37,650 --> 00:02:39,480
makes this fixed issue in the wrong ways

67
00:02:39,480 --> 00:02:43,200
and the reason for this is because I

68
00:02:43,200 --> 00:02:45,690
think it's most has a lot to do with

69
00:02:45,690 --> 00:02:48,360
with assumptions so today's systems are

70
00:02:48,360 --> 00:02:51,630
so complex and that we need to rely on a

71
00:02:51,630 --> 00:02:52,920
lot of abstraction to get things done

72
00:02:52,920 --> 00:02:55,709
and that's when we are using other

73
00:02:55,709 --> 00:02:56,850
people's called results when you're

74
00:02:56,850 --> 00:02:58,680
writing code we need to do it with a lot

75
00:02:58,680 --> 00:03:00,870
of abstractions and we need to rely on a

76
00:03:00,870 --> 00:03:02,340
lot of assumptions so for instance when

77
00:03:02,340 --> 00:03:04,530
it comes to languages there if I use a

78
00:03:04,530 --> 00:03:06,390
language that has a program in contract

79
00:03:06,390 --> 00:03:08,040
that looks very similar to other

80
00:03:08,040 --> 00:03:09,690
languages are used before I kind of

81
00:03:09,690 --> 00:03:11,670
assumed that it works the same I would

82
00:03:11,670 --> 00:03:13,380
be very surprised if an if statement had

83
00:03:13,380 --> 00:03:15,750
you know a negated condition in a

84
00:03:15,750 --> 00:03:17,760
language when I'm used to working in

85
00:03:17,760 --> 00:03:19,170
some ways and more or less every

86
00:03:19,170 --> 00:03:22,440
language created before it and it's also

87
00:03:22,440 --> 00:03:24,000
the same with libraries right so we we

88
00:03:24,000 --> 00:03:25,530
design libraries and ap is with

89
00:03:25,530 --> 00:03:27,720
different patterns and if we are in node

90
00:03:27,720 --> 00:03:30,989
and and Sony and we start using in a

91
00:03:30,989 --> 00:03:33,360
library that doesn't really follow the

92
00:03:33,360 --> 00:03:36,690
standard patterns API patterns of known

93
00:03:36,690 --> 00:03:38,370
modules we get surprised sometimes we

94
00:03:38,370 --> 00:03:41,400
model our libraries after other popular

95
00:03:41,400 --> 00:03:43,049
library like a query but you let them

96
00:03:43,049 --> 00:03:44,790
work slightly different people will get

97
00:03:44,790 --> 00:03:47,130
surprised and and it would be hard to do

98
00:03:47,130 --> 00:03:51,480
things so the way I like to think of my

99
00:03:51,480 --> 00:03:53,100
brain is that basically it's like a

100
00:03:53,100 --> 00:03:55,470
cache pretty small cash but fast it's an

101
00:03:55,470 --> 00:03:57,540
l1 cache or something that can only keep

102
00:03:57,540 --> 00:03:59,940
so much things in my brain and again

103
00:03:59,940 --> 00:04:01,440
therefore I need to rely on a lot of

104
00:04:01,440 --> 00:04:03,989
assumptions to get things done now

105
00:04:03,989 --> 00:04:06,150
unfortunately there's often a big

106
00:04:06,150 --> 00:04:07,590
disconnect between assumptions and

107
00:04:07,590 --> 00:04:10,290
reality meaning assumptions what I think

108
00:04:10,290 --> 00:04:11,940
the program does in reality what the

109
00:04:11,940 --> 00:04:14,579
program really does it might be small

110
00:04:14,579 --> 00:04:17,400
truth once like misspelling width and

111
00:04:17,400 --> 00:04:21,600
height which always seem to be a problem

112
00:04:21,600 --> 00:04:23,400
at least when we will try to identify

113
00:04:23,400 --> 00:04:25,110
the problem because it's masked by our

114
00:04:25,110 --> 00:04:27,300
brains it off by once you know when we

115
00:04:27,300 --> 00:04:29,700
loop one too much or 12 little the

116
00:04:29,700 --> 00:04:31,050
different corner cases when we're

117
00:04:31,050 --> 00:04:32,880
implementing an algorithm or two and we

118
00:04:32,880 --> 00:04:34,169
don't cover that we thought that it

119
00:04:34,169 --> 00:04:35,310
would be in the general case but it

120
00:04:35,310 --> 00:04:37,020
wasn't there's a disconnect there and

121
00:04:37,020 --> 00:04:40,919
and in design in general I think the

122
00:04:40,919 --> 00:04:42,810
most obvious case on

123
00:04:42,810 --> 00:04:44,669
on that there actually is such a

124
00:04:44,669 --> 00:04:46,110
disconnect and how is the problem is

125
00:04:46,110 --> 00:04:49,530
when we are debugging when we are but we

126
00:04:49,530 --> 00:04:51,330
know that there is an issue in our code

127
00:04:51,330 --> 00:04:54,840
perhaps for some reason like a core dump

128
00:04:54,840 --> 00:04:57,540
or a crash log or whatever it is we know

129
00:04:57,540 --> 00:04:58,889
that there is an issue in this function

130
00:04:58,889 --> 00:05:00,300
it's a function of 10 lines of code or

131
00:05:00,300 --> 00:05:02,490
something and we have taken upon us the

132
00:05:02,490 --> 00:05:05,220
task to fix that bug right so we take

133
00:05:05,220 --> 00:05:06,960
that up in our edit or we put a full

134
00:05:06,960 --> 00:05:09,150
screen on the screen and we just go line

135
00:05:09,150 --> 00:05:11,100
by line trying to read it out trying to

136
00:05:11,100 --> 00:05:12,300
reason with ourselves what it's tough

137
00:05:12,300 --> 00:05:13,889
dust and it should really work right I

138
00:05:13,889 --> 00:05:15,419
have no idea what it doesn't work

139
00:05:15,419 --> 00:05:17,729
because it should so if this was C and

140
00:05:17,729 --> 00:05:19,470
it was in like the early 90s or

141
00:05:19,470 --> 00:05:20,370
something that we could blade in the

142
00:05:20,370 --> 00:05:22,200
compiler because the compiler was always

143
00:05:22,200 --> 00:05:24,000
wrong you see how to bugs sometimes in

144
00:05:24,000 --> 00:05:25,530
code generations we can all say hey it's

145
00:05:25,530 --> 00:05:27,180
a compiler mistake so I guess the

146
00:05:27,180 --> 00:05:28,500
analogy for today is that we should

147
00:05:28,500 --> 00:05:31,139
blame guys like Eric and the slob on

148
00:05:31,139 --> 00:05:32,820
others in the VA team or or whoever

149
00:05:32,820 --> 00:05:35,070
right because the vm might be wrong but

150
00:05:35,070 --> 00:05:36,600
often it isn't often it's actually our

151
00:05:36,600 --> 00:05:39,900
mistakes we are just not able to find

152
00:05:39,900 --> 00:05:42,360
the issues in that code because we have

153
00:05:42,360 --> 00:05:44,100
already have our assumption of how it

154
00:05:44,100 --> 00:05:47,100
works what you can do then is that you

155
00:05:47,100 --> 00:05:48,630
can ask a friend or click or whatever it

156
00:05:48,630 --> 00:05:51,320
is perhaps a friend and a colleague and

157
00:05:51,320 --> 00:05:53,910
ask both of them to come ask them that

158
00:05:53,910 --> 00:05:56,669
person to come sit right next to you so

159
00:05:56,669 --> 00:05:58,740
you could you could explain the code to

160
00:05:58,740 --> 00:06:01,310
him or her if you start doing that and

161
00:06:01,310 --> 00:06:03,479
you start it's playing so this is the

162
00:06:03,479 --> 00:06:04,919
function it's called blah blah you know

163
00:06:04,919 --> 00:06:06,810
first of all I set up my variables here

164
00:06:06,810 --> 00:06:08,610
and I have this this in that object a

165
00:06:08,610 --> 00:06:10,050
senator at module and I get something

166
00:06:10,050 --> 00:06:13,590
back and then adjust and then you pause

167
00:06:13,590 --> 00:06:15,930
because that's that's the moment of

168
00:06:15,930 --> 00:06:17,940
enlightenment this the silent moment of

169
00:06:17,940 --> 00:06:19,710
enlightenment when you realized exactly

170
00:06:19,710 --> 00:06:21,539
what issue was and your friend you don't

171
00:06:21,539 --> 00:06:22,919
have to do anything because what

172
00:06:22,919 --> 00:06:25,039
happened was that you force yourself to

173
00:06:25,039 --> 00:06:27,210
kind of step outside of your own

174
00:06:27,210 --> 00:06:29,010
assumptions because you knew that your

175
00:06:29,010 --> 00:06:30,900
friend didn't have the same context of

176
00:06:30,900 --> 00:06:33,240
this of this program like you did so you

177
00:06:33,240 --> 00:06:34,650
have to explain it in more detail and

178
00:06:34,650 --> 00:06:36,660
you have to go reevaluate those

179
00:06:36,660 --> 00:06:38,310
assumptions in your own brain one more

180
00:06:38,310 --> 00:06:42,000
time and that made you fix the bug how

181
00:06:42,000 --> 00:06:43,889
many have you know anyone else but the

182
00:06:43,889 --> 00:06:45,960
mean that I had done that sometimes many

183
00:06:45,960 --> 00:06:47,760
of you yeah does anyone know the

184
00:06:47,760 --> 00:06:51,479
technique it has a name Oh all of you

185
00:06:51,479 --> 00:06:53,280
knows it okay pressure should just end

186
00:06:53,280 --> 00:06:54,780
this Tokyo you know this already so

187
00:06:54,780 --> 00:06:56,460
rabid up computing

188
00:06:56,460 --> 00:06:58,139
you have this rubber tag instead so you

189
00:06:58,139 --> 00:06:59,130
cannot have your friend and your

190
00:06:59,130 --> 00:07:00,870
colleague and your rubber duck or

191
00:07:00,870 --> 00:07:02,699
perhaps in the same cut all of them

192
00:07:02,699 --> 00:07:04,380
freebie this I don't know you can have

193
00:07:04,380 --> 00:07:05,880
them you can just talk to a rubber duck

194
00:07:05,880 --> 00:07:07,770
hey Doc I have this issue and you know

195
00:07:07,770 --> 00:07:11,190
things will sell themselves okay so

196
00:07:11,190 --> 00:07:13,080
that's for disconnect the brain is a

197
00:07:13,080 --> 00:07:14,610
beautiful device right the beautiful

198
00:07:14,610 --> 00:07:17,669
thing can you read this I mean can you

199
00:07:17,669 --> 00:07:19,410
read it and can you see it and can you

200
00:07:19,410 --> 00:07:23,699
read it you can't read it can you see

201
00:07:23,699 --> 00:07:25,860
that it's you can see this right so we

202
00:07:25,860 --> 00:07:27,360
can read it it's according to recent

203
00:07:27,360 --> 00:07:28,830
research the human brain is perfectly

204
00:07:28,830 --> 00:07:30,599
able to blah blah blah it's a weird

205
00:07:30,599 --> 00:07:32,130
thing because our brain is so good at

206
00:07:32,130 --> 00:07:35,340
pattern matching and at at fixing errors

207
00:07:35,340 --> 00:07:37,500
so the trick here is that you fix the

208
00:07:37,500 --> 00:07:39,030
first and last letter in each and every

209
00:07:39,030 --> 00:07:40,530
word in the sentence and you can swap

210
00:07:40,530 --> 00:07:41,880
the others around you need to keep

211
00:07:41,880 --> 00:07:43,560
letters but you can swap them around but

212
00:07:43,560 --> 00:07:45,270
the brain just fixed it for you that is

213
00:07:45,270 --> 00:07:47,550
exactly why it's hard sometimes to find

214
00:07:47,550 --> 00:07:49,110
the width and the height that was

215
00:07:49,110 --> 00:07:51,419
misspelled and to fix them unless we use

216
00:07:51,419 --> 00:07:55,110
tolling for it so the brain tries to be

217
00:07:55,110 --> 00:07:57,150
your friend tries to fix things so thank

218
00:07:57,150 --> 00:07:58,800
you very much brain sometimes that is

219
00:07:58,800 --> 00:08:01,650
really really helpful at other times it

220
00:08:01,650 --> 00:08:03,000
isn't and I think you know this

221
00:08:03,000 --> 00:08:04,979
assumption this Robert a computing

222
00:08:04,979 --> 00:08:07,820
debugging case if what's another one

223
00:08:07,820 --> 00:08:11,729
what's one of those cases why am I

224
00:08:11,729 --> 00:08:13,560
saying all this well what I'm getting to

225
00:08:13,560 --> 00:08:15,090
you is that we should think much more

226
00:08:15,090 --> 00:08:17,039
about making our programs easier to

227
00:08:17,039 --> 00:08:19,020
reason about that should be a priority

228
00:08:19,020 --> 00:08:20,820
of ours when we start coding and when we

229
00:08:20,820 --> 00:08:23,219
you know when you design our code and we

230
00:08:23,219 --> 00:08:25,080
when we maintain it we talked very much

231
00:08:25,080 --> 00:08:26,729
about how to optimize it how to use for

232
00:08:26,729 --> 00:08:28,680
a fancy programming construct how to use

233
00:08:28,680 --> 00:08:31,199
the latest library the latest framework

234
00:08:31,199 --> 00:08:32,729
latest language Slater's language

235
00:08:32,729 --> 00:08:36,690
language the latest mythology you know

236
00:08:36,690 --> 00:08:41,339
scrum leme x space and all the rage

237
00:08:41,339 --> 00:08:43,560
these days used to be but now it's TDD

238
00:08:43,560 --> 00:08:45,990
still and we talk so much about all the

239
00:08:45,990 --> 00:08:47,399
different technique and stuff we can go

240
00:08:47,399 --> 00:08:48,990
and read about them download and use

241
00:08:48,990 --> 00:08:51,120
some stuff but we seem to not

242
00:08:51,120 --> 00:08:53,040
communicate that much about kind of

243
00:08:53,040 --> 00:08:54,720
other core issues here when we are

244
00:08:54,720 --> 00:08:56,130
programming about the fact that we make

245
00:08:56,130 --> 00:08:58,110
mistakes we make mistakes all the time

246
00:08:58,110 --> 00:09:00,600
if we could reduce those mistakes we

247
00:09:00,600 --> 00:09:02,670
would be much more productive it might

248
00:09:02,670 --> 00:09:04,350
not sound like a super sexy thing to

249
00:09:04,350 --> 00:09:05,430
talk about but it's really really

250
00:09:05,430 --> 00:09:07,380
important and it's not boring at all

251
00:09:07,380 --> 00:09:10,170
either it actually makes our jobs

252
00:09:10,170 --> 00:09:12,990
our hobbies much more fun I think so

253
00:09:12,990 --> 00:09:16,079
easier to reason about is increasingly

254
00:09:16,079 --> 00:09:18,240
important now I guess in this community

255
00:09:18,240 --> 00:09:21,120
with JavaScript because we have

256
00:09:21,120 --> 00:09:22,860
JavaScript on the server we know that we

257
00:09:22,860 --> 00:09:24,149
have it in the browser and especially in

258
00:09:24,149 --> 00:09:25,290
browser I mean things have changed

259
00:09:25,290 --> 00:09:26,850
dramatically right from being small

260
00:09:26,850 --> 00:09:29,399
things to two apps that are moving all

261
00:09:29,399 --> 00:09:31,139
the way to the client straps really

262
00:09:31,139 --> 00:09:34,230
scale in terms of size of the code base

263
00:09:34,230 --> 00:09:35,660
but also in terms of size of the teams

264
00:09:35,660 --> 00:09:38,180
when we scale it inside so the team's

265
00:09:38,180 --> 00:09:40,199
these things with assumptions becomes

266
00:09:40,199 --> 00:09:41,670
even harder because we need to find a

267
00:09:41,670 --> 00:09:43,110
way to communicate them between each

268
00:09:43,110 --> 00:09:44,610
other it's not enough anymore that I

269
00:09:44,610 --> 00:09:47,010
have my ADIZ or how I should write code

270
00:09:47,010 --> 00:09:49,649
we need communicate it also so we need

271
00:09:49,649 --> 00:09:51,510
to think about stuff like there's no

272
00:09:51,510 --> 00:09:53,070
suitable for this we need to think about

273
00:09:53,070 --> 00:09:55,769
stuff like motorized in our code putting

274
00:09:55,769 --> 00:09:57,269
it into different modules making sure

275
00:09:57,269 --> 00:09:58,680
that they have it discreet

276
00:09:58,680 --> 00:10:00,269
responsibilities so that we can maintain

277
00:10:00,269 --> 00:10:02,430
stuff we need to think about stuff like

278
00:10:02,430 --> 00:10:04,589
a style guide if we are on a team now

279
00:10:04,589 --> 00:10:06,329
how do you write code and why do we do

280
00:10:06,329 --> 00:10:08,970
it if you missed Angus talk yesterday

281
00:10:08,970 --> 00:10:10,949
which it was an awesome talk I think the

282
00:10:10,949 --> 00:10:13,680
most important takeaway from that was

283
00:10:13,680 --> 00:10:15,870
that we shouldn't listen to gospel we

284
00:10:15,870 --> 00:10:17,339
shouldn't just take gospel as truth

285
00:10:17,339 --> 00:10:19,500
because there's so much gospel in the

286
00:10:19,500 --> 00:10:20,880
world right in programming from both

287
00:10:20,880 --> 00:10:23,339
sides from all sides and but we should

288
00:10:23,339 --> 00:10:25,320
take informed decisions and we are

289
00:10:25,320 --> 00:10:28,320
adults so we should allow ourselves to

290
00:10:28,320 --> 00:10:30,930
take whatever decisions we feel are

291
00:10:30,930 --> 00:10:33,360
right for us and for our teams but at

292
00:10:33,360 --> 00:10:34,560
least they need to be informed we need

293
00:10:34,560 --> 00:10:36,269
to be to understand the trade-offs there

294
00:10:36,269 --> 00:10:38,699
because there is always a trade-off so

295
00:10:38,699 --> 00:10:40,320
you give something by using for instance

296
00:10:40,320 --> 00:10:42,899
the language construct with or whatever

297
00:10:42,899 --> 00:10:45,000
it is and you lose something by doing

298
00:10:45,000 --> 00:10:48,540
that perhaps so that's just some of the

299
00:10:48,540 --> 00:10:49,980
things and I'm going to talk more

300
00:10:49,980 --> 00:10:51,540
specifically about subsetting language

301
00:10:51,540 --> 00:10:54,839
for this but before that i'm going to

302
00:10:54,839 --> 00:10:56,220
talk about assert how many hair here

303
00:10:56,220 --> 00:10:58,350
have used a cert or are used insert in

304
00:10:58,350 --> 00:11:00,990
the DJ s awesome how many are using

305
00:11:00,990 --> 00:11:02,550
asserts for something that isn't in

306
00:11:02,550 --> 00:11:04,350
their test suite but in there normal

307
00:11:04,350 --> 00:11:07,889
code okay quite a few but not that money

308
00:11:07,889 --> 00:11:10,290
and that's what I want to talk about

309
00:11:10,290 --> 00:11:12,240
using a cert but not in your test suite

310
00:11:12,240 --> 00:11:14,190
but in your code directly that is how we

311
00:11:14,190 --> 00:11:16,290
actually started out using insert when

312
00:11:16,290 --> 00:11:17,370
we created this programming construct

313
00:11:17,370 --> 00:11:18,660
not for JavaScript but for other

314
00:11:18,660 --> 00:11:20,730
languages that we were using certain on

315
00:11:20,730 --> 00:11:23,160
our test Suites so the idea assert is

316
00:11:23,160 --> 00:11:23,520
based

317
00:11:23,520 --> 00:11:25,380
it's a statement and you feel it an

318
00:11:25,380 --> 00:11:26,610
expression the expression is an

319
00:11:26,610 --> 00:11:29,910
assumption to say hey I assert this this

320
00:11:29,910 --> 00:11:31,350
is my assumption this needs to be true

321
00:11:31,350 --> 00:11:33,150
in a difference if it isn't then the

322
00:11:33,150 --> 00:11:37,140
following code you know can I have no

323
00:11:37,140 --> 00:11:38,670
idea what it does in that case I can

324
00:11:38,670 --> 00:11:40,680
take no responsibility for that boss so

325
00:11:40,680 --> 00:11:42,900
you know this needs to be true and it's

326
00:11:42,900 --> 00:11:44,340
a way of documenting their that

327
00:11:44,340 --> 00:11:46,680
codifying that assumption but getting it

328
00:11:46,680 --> 00:11:48,180
verified because once it runs what

329
00:11:48,180 --> 00:11:50,310
happens is that assert just check this

330
00:11:50,310 --> 00:11:52,410
expression and if it's truth Lee nothing

331
00:11:52,410 --> 00:11:54,570
happens the program just continues but

332
00:11:54,570 --> 00:11:56,990
if it's false e then the program crashes

333
00:11:56,990 --> 00:12:00,180
and crashes fast instantly it crashes

334
00:12:00,180 --> 00:12:02,040
directly there and it gives you the

335
00:12:02,040 --> 00:12:03,540
information you need because not only

336
00:12:03,540 --> 00:12:05,160
does it crash in the realest certain

337
00:12:05,160 --> 00:12:07,020
limitation but it also prints out your

338
00:12:07,020 --> 00:12:09,170
log or whatever it is the string ified

339
00:12:09,170 --> 00:12:11,460
representation of your expression to get

340
00:12:11,460 --> 00:12:15,180
rid of function line and file name so

341
00:12:15,180 --> 00:12:16,740
you can easily see from the log you know

342
00:12:16,740 --> 00:12:18,720
where things went wrong so what happens

343
00:12:18,720 --> 00:12:20,490
is that we can document and verify our

344
00:12:20,490 --> 00:12:22,290
assumptions and we cannot fail faster

345
00:12:22,290 --> 00:12:24,510
this is very powerful and very easy to

346
00:12:24,510 --> 00:12:26,760
use so here are just three you see those

347
00:12:26,760 --> 00:12:28,620
three examples how you can use them for

348
00:12:28,620 --> 00:12:30,750
instance you can assert that an object

349
00:12:30,750 --> 00:12:33,660
state is free so perhaps I'll be

350
00:12:33,660 --> 00:12:36,180
pressing made a custom allocator or like

351
00:12:36,180 --> 00:12:38,760
an object pool or something I now pick

352
00:12:38,760 --> 00:12:40,740
this object as candidate for giving out

353
00:12:40,740 --> 00:12:42,990
to someone like a cached new or

354
00:12:42,990 --> 00:12:45,060
something and but before that I just

355
00:12:45,060 --> 00:12:46,500
want to verify that it's actually tied

356
00:12:46,500 --> 00:12:47,910
as free because otherwise i will now

357
00:12:47,910 --> 00:12:50,070
start writing over something else its

358
00:12:50,070 --> 00:12:51,840
way or just protecting me from what i

359
00:12:51,840 --> 00:12:54,180
know should be the case but I'm since

360
00:12:54,180 --> 00:12:55,800
I'm only 99 percent sure that the code

361
00:12:55,800 --> 00:12:57,390
currently works that way I actually

362
00:12:57,390 --> 00:12:59,100
documented for me and for others in the

363
00:12:59,100 --> 00:13:02,010
future we can also do other stuff india

364
00:13:02,010 --> 00:13:03,990
is like assert organs length 3 plickers

365
00:13:03,990 --> 00:13:06,630
to that sounds pretty stupid I think to

366
00:13:06,630 --> 00:13:08,430
too many why would you assert on your

367
00:13:08,430 --> 00:13:09,990
ornaments length that's like user input

368
00:13:09,990 --> 00:13:11,610
and everything well first of all this

369
00:13:11,610 --> 00:13:14,210
isn't in a public API there's this shoot

370
00:13:14,210 --> 00:13:16,230
you can search more about that on the

371
00:13:16,230 --> 00:13:18,120
web about using a certain that we're not

372
00:13:18,120 --> 00:13:19,230
talking about the search now and talking

373
00:13:19,230 --> 00:13:22,020
about internal api's but for instance

374
00:13:22,020 --> 00:13:24,060
when i do refactoring in jazz so when i

375
00:13:24,060 --> 00:13:25,830
when i change the air over function in

376
00:13:25,830 --> 00:13:28,590
JS from like two to three or from three

377
00:13:28,590 --> 00:13:31,110
to two arguments and most of the time

378
00:13:31,110 --> 00:13:32,400
when i do that i'm pretty confident that

379
00:13:32,400 --> 00:13:34,230
I casual the cold side today update then

380
00:13:34,230 --> 00:13:35,910
too but sometimes I'm not one hundred

381
00:13:35,910 --> 00:13:37,350
percent confident that I do that

382
00:13:37,350 --> 00:13:38,310
and we're not one hundred percent

383
00:13:38,310 --> 00:13:40,350
confident that my tests actually catches

384
00:13:40,350 --> 00:13:42,180
that in that case I just drop in a

385
00:13:42,180 --> 00:13:44,310
search there you know it cost me like

386
00:13:44,310 --> 00:13:46,170
five seconds to write it and I keep it

387
00:13:46,170 --> 00:13:47,460
until the I do the next commit because

388
00:13:47,460 --> 00:13:49,230
if one call site now when I run all the

389
00:13:49,230 --> 00:13:51,600
tests and when I when I try the program

390
00:13:51,600 --> 00:13:53,220
out if one call site actually

391
00:13:53,220 --> 00:13:55,530
accidentally was not updated then a cert

392
00:13:55,530 --> 00:13:56,940
will fire immediately and I can just

393
00:13:56,940 --> 00:13:59,880
remove it it's very cheap the last third

394
00:13:59,880 --> 00:14:01,620
example is just you know type of cast it

395
00:14:01,620 --> 00:14:02,940
should be a number and by the way it

396
00:14:02,940 --> 00:14:04,350
should be a real number it shouldn't be

397
00:14:04,350 --> 00:14:06,330
infinity neither the positive or the

398
00:14:06,330 --> 00:14:07,980
negative one and should certainly not be

399
00:14:07,980 --> 00:14:10,590
an an and if you got a man in your

400
00:14:10,590 --> 00:14:12,960
program by the way in jas that's more or

401
00:14:12,960 --> 00:14:17,160
less always a sign that you in that your

402
00:14:17,160 --> 00:14:19,530
code is incorrect rarely do we write

403
00:14:19,530 --> 00:14:22,440
code where we actually do get man and

404
00:14:22,440 --> 00:14:24,060
that that's the intended result is

405
00:14:24,060 --> 00:14:25,320
Morris always that we have like user

406
00:14:25,320 --> 00:14:26,700
data or something that we didn't

407
00:14:26,700 --> 00:14:28,800
sanitize enough or just another code a

408
00:14:28,800 --> 00:14:31,380
mistake so that's how a cert works we

409
00:14:31,380 --> 00:14:33,360
can use it in in jas we can use it when

410
00:14:33,360 --> 00:14:34,770
you string inside representation so

411
00:14:34,770 --> 00:14:36,690
there's a link there I'm going to post

412
00:14:36,690 --> 00:14:38,670
the slides later for for an example how

413
00:14:38,670 --> 00:14:40,140
to choose a framework I created to to

414
00:14:40,140 --> 00:14:43,890
actually do real asserts in JS what it

415
00:14:43,890 --> 00:14:45,120
gives us is that it makes the code

416
00:14:45,120 --> 00:14:46,500
easier to reason about but because now

417
00:14:46,500 --> 00:14:48,180
we have codified our assumptions it's

418
00:14:48,180 --> 00:14:50,610
there for me like in an hour when I

419
00:14:50,610 --> 00:14:52,410
forgot what I right but I wrote or for

420
00:14:52,410 --> 00:14:55,050
me a month from now when I really forgot

421
00:14:55,050 --> 00:14:57,720
what i wrote or for my team members to

422
00:14:57,720 --> 00:14:59,610
read and understand my assumptions it's

423
00:14:59,610 --> 00:15:02,130
really powerful the code becomes more

424
00:15:02,130 --> 00:15:04,260
robust because it fails fast just like

425
00:15:04,260 --> 00:15:05,970
you want it because we certainly don't

426
00:15:05,970 --> 00:15:08,370
want the code that just keep on keep me

427
00:15:08,370 --> 00:15:10,620
running it very much so simplifies

428
00:15:10,620 --> 00:15:12,840
refactoring and code changes because now

429
00:15:12,840 --> 00:15:14,610
I I am confident in the code I'm

430
00:15:14,610 --> 00:15:15,900
confident that thanks to all these

431
00:15:15,900 --> 00:15:17,670
asserts together with my test suite you

432
00:15:17,670 --> 00:15:19,920
know when I do stuff when I change stuff

433
00:15:19,920 --> 00:15:24,270
internally in my api's if they if I do

434
00:15:24,270 --> 00:15:26,100
things incorrectly then their search

435
00:15:26,100 --> 00:15:29,880
will fire most likely overall it gives

436
00:15:29,880 --> 00:15:31,740
us more confidence i think it invites us

437
00:15:31,740 --> 00:15:33,450
to do more changes through code but

438
00:15:33,450 --> 00:15:34,890
sometimes when we feel that code is a

439
00:15:34,890 --> 00:15:38,700
bit fragile we're afraid of that as a

440
00:15:38,700 --> 00:15:41,250
side effect which I realized very

441
00:15:41,250 --> 00:15:42,630
recently after getting and point out to

442
00:15:42,630 --> 00:15:44,190
me it's sometimes actually makes it

443
00:15:44,190 --> 00:15:46,400
easier to write our units tests too

444
00:15:46,400 --> 00:15:49,080
because if we go really far and do the

445
00:15:49,080 --> 00:15:50,940
various search rich programming includes

446
00:15:50,940 --> 00:15:53,370
resurgence in our code then our units

447
00:15:53,370 --> 00:15:54,960
ethically focus more about providing

448
00:15:54,960 --> 00:15:57,240
input through functions and seeing you

449
00:15:57,240 --> 00:15:58,650
know if the function doesn't crash then

450
00:15:58,650 --> 00:16:00,870
then it could be okay so it's not that

451
00:16:00,870 --> 00:16:02,880
extreme but but some artists can become

452
00:16:02,880 --> 00:16:05,090
easier and it doesn't slow you down

453
00:16:05,090 --> 00:16:08,100
trust me if you haven't tried using a

454
00:16:08,100 --> 00:16:09,420
search this way it never slows you down

455
00:16:09,420 --> 00:16:11,490
it speeds you up because writing that

456
00:16:11,490 --> 00:16:13,050
search takes very little time if you

457
00:16:13,050 --> 00:16:14,700
don't write it I can assure you that

458
00:16:14,700 --> 00:16:16,290
when you read the code when you write a

459
00:16:16,290 --> 00:16:17,580
code your anyway is going to have the

460
00:16:17,580 --> 00:16:19,200
conversation with yourself you know what

461
00:16:19,200 --> 00:16:20,490
is the code real doing well I think it's

462
00:16:20,490 --> 00:16:22,200
doing that you're going to do that you

463
00:16:22,200 --> 00:16:23,760
know over and over again and your

464
00:16:23,760 --> 00:16:25,020
colleagues have no clue what your

465
00:16:25,020 --> 00:16:28,650
assumption was so it speeds you up other

466
00:16:28,650 --> 00:16:30,540
assumptions Yammer's in das you know

467
00:16:30,540 --> 00:16:33,030
every language has its awesome parts and

468
00:16:33,030 --> 00:16:35,880
it's you know less awesome parts it's no

469
00:16:35,880 --> 00:16:37,620
different there here are some assumption

470
00:16:37,620 --> 00:16:39,030
jammers for me something that increases

471
00:16:39,030 --> 00:16:42,060
the disconnect gap for me undefined and

472
00:16:42,060 --> 00:16:45,240
all we have two of them which

473
00:16:45,240 --> 00:16:47,370
complicates things a bit the books types

474
00:16:47,370 --> 00:16:49,350
which doesn't play at all nicely with

475
00:16:49,350 --> 00:16:51,930
the primitive types so we therefore most

476
00:16:51,930 --> 00:16:54,330
don't use them the functions go first is

477
00:16:54,330 --> 00:16:55,830
the block scope we all know about that

478
00:16:55,830 --> 00:16:57,030
it's an assumption Yammer for many

479
00:16:57,030 --> 00:16:59,190
especially those new to the language but

480
00:16:59,190 --> 00:17:00,990
it can be actually be an assumption

481
00:17:00,990 --> 00:17:02,370
Yammer for those who are working for

482
00:17:02,370 --> 00:17:05,250
many years to surprises me once in a

483
00:17:05,250 --> 00:17:08,430
while still the global pollution is more

484
00:17:08,430 --> 00:17:09,569
less a fixed problem with these five

485
00:17:09,569 --> 00:17:11,970
strict mode the faulty values we have so

486
00:17:11,970 --> 00:17:13,860
many of them why do we have that but we

487
00:17:13,860 --> 00:17:15,569
just have so many false values it's a

488
00:17:15,569 --> 00:17:16,829
bit more complicated to have them in our

489
00:17:16,829 --> 00:17:20,250
heads they keep on running the sign of

490
00:17:20,250 --> 00:17:21,990
jay is in general it's very much keep on

491
00:17:21,990 --> 00:17:23,160
running or keep on tracking that's how

492
00:17:23,160 --> 00:17:25,500
it's designed so it's it's it's not

493
00:17:25,500 --> 00:17:27,270
designed to fail fast it's opposite of

494
00:17:27,270 --> 00:17:29,400
it I was thinking about saying that is

495
00:17:29,400 --> 00:17:32,310
the it's the not equals to fail fast but

496
00:17:32,310 --> 00:17:33,990
I realize that I might put in the queer

497
00:17:33,990 --> 00:17:35,460
Singh operator so it might be a still do

498
00:17:35,460 --> 00:17:37,380
the same thing so but keep on running

499
00:17:37,380 --> 00:17:39,480
and and then you can mix drinks and

500
00:17:39,480 --> 00:17:41,280
numbers in arithmetic operation that's a

501
00:17:41,280 --> 00:17:43,650
huge assumption jammers in Jas not only

502
00:17:43,650 --> 00:17:44,970
can you do that but you can actually mix

503
00:17:44,970 --> 00:17:47,010
any type and any type in your arithmetic

504
00:17:47,010 --> 00:17:49,260
operations actually in more as any

505
00:17:49,260 --> 00:17:50,820
operation you use you can use any type

506
00:17:50,820 --> 00:17:52,470
and that's what I'm going to talk a bit

507
00:17:52,470 --> 00:17:56,580
more about now plus is the ultimate keep

508
00:17:56,580 --> 00:18:00,060
on running thing in Jas so plus exactly

509
00:18:00,060 --> 00:18:01,980
like our brain before an example in

510
00:18:01,980 --> 00:18:04,290
order to swap characters that piped into

511
00:18:04,290 --> 00:18:04,830
the brain

512
00:18:04,830 --> 00:18:07,860
as a stream plus says let me fix that

513
00:18:07,860 --> 00:18:09,840
for you I think I know what do you mean

514
00:18:09,840 --> 00:18:11,850
you gave me all know and gaming

515
00:18:11,850 --> 00:18:14,130
undefined but hey you know I know what

516
00:18:14,130 --> 00:18:17,760
do you mean you wanna have a man seldom

517
00:18:17,760 --> 00:18:20,190
do you want to have a man I mean Nance

518
00:18:20,190 --> 00:18:22,860
should be your more or less prohibited

519
00:18:22,860 --> 00:18:24,600
in the language they are more less

520
00:18:24,600 --> 00:18:26,929
always the result of a coding mistake

521
00:18:26,929 --> 00:18:29,159
but it is what it is right and we have

522
00:18:29,159 --> 00:18:31,200
learned to deliver this and some some of

523
00:18:31,200 --> 00:18:32,580
us say that hey you know it's so

524
00:18:32,580 --> 00:18:34,740
expressive the plus is so expressive and

525
00:18:34,740 --> 00:18:35,909
so is minus by the way it's very

526
00:18:35,909 --> 00:18:37,320
expressive I can do anything with it I

527
00:18:37,320 --> 00:18:39,120
would like to see that anything and

528
00:18:39,120 --> 00:18:41,100
because I think that it's just you know

529
00:18:41,100 --> 00:18:42,720
it just more error-prone while there are

530
00:18:42,720 --> 00:18:44,909
so many dynamic beautiful parts of jay

531
00:18:44,909 --> 00:18:46,110
is that really helps us do real

532
00:18:46,110 --> 00:18:48,600
expressive stuff and i think again in

533
00:18:48,600 --> 00:18:50,880
angus presentation yesterday like weed

534
00:18:50,880 --> 00:18:52,440
you can actually do more expressive

535
00:18:52,440 --> 00:18:54,149
stuff by using but there are drawbacks

536
00:18:54,149 --> 00:18:56,610
to you too plus and other operators you

537
00:18:56,610 --> 00:19:01,320
know our are very not failing fast but

538
00:19:01,320 --> 00:19:02,789
keep on running but they don't give us

539
00:19:02,789 --> 00:19:05,580
much in return and for science see my

540
00:19:05,580 --> 00:19:08,220
now stroke slice it was that correct it

541
00:19:08,220 --> 00:19:10,889
should be part of my french i hope it

542
00:19:10,889 --> 00:19:12,870
was but weak typing in a dynamically

543
00:19:12,870 --> 00:19:14,460
type language is not very helpful at all

544
00:19:14,460 --> 00:19:17,399
it just isn't and i think we need to

545
00:19:17,399 --> 00:19:18,990
think about that too in the jays

546
00:19:18,990 --> 00:19:20,340
community I think we need to talk about

547
00:19:20,340 --> 00:19:22,350
that and I think we need to talk about

548
00:19:22,350 --> 00:19:25,350
that that is a very rare thing very very

549
00:19:25,350 --> 00:19:27,179
few other than ample type language share

550
00:19:27,179 --> 00:19:29,820
this property Oh ours and we need to

551
00:19:29,820 --> 00:19:31,350
think about that so look at Ruby or

552
00:19:31,350 --> 00:19:33,240
Python or most other lisps at least

553
00:19:33,240 --> 00:19:34,980
after the 60s look at the proper closure

554
00:19:34,980 --> 00:19:38,820
for instance where is all of them are so

555
00:19:38,820 --> 00:19:40,529
it's not a binary the screen whether

556
00:19:40,529 --> 00:19:41,940
you're weak or strong but they are very

557
00:19:41,940 --> 00:19:44,820
much so stronger typed than J is so weak

558
00:19:44,820 --> 00:19:46,230
typing in this context basically means

559
00:19:46,230 --> 00:19:48,059
that if you take an operator like a

560
00:19:48,059 --> 00:19:50,639
binary operator taking two operands in a

561
00:19:50,639 --> 00:19:51,840
weakly typed language they will try to

562
00:19:51,840 --> 00:19:53,399
do something with the type of the type

563
00:19:53,399 --> 00:19:55,500
convert them implicitly what we call

564
00:19:55,500 --> 00:19:57,539
type creations in the jas to do

565
00:19:57,539 --> 00:19:59,639
something good with it exactly is a plus

566
00:19:59,639 --> 00:20:02,159
tries to do and I argued that that is

567
00:20:02,159 --> 00:20:03,929
the wrong thing to do it doesn't help us

568
00:20:03,929 --> 00:20:06,870
at all in the plus case can you read

569
00:20:06,870 --> 00:20:11,610
this in the past case a plus B what it

570
00:20:11,610 --> 00:20:14,309
does is that first of all it converts a

571
00:20:14,309 --> 00:20:17,010
and B to primitives so primitives and j

572
00:20:17,010 --> 00:20:18,480
is then we have undefined know

573
00:20:18,480 --> 00:20:20,210
all a boolean a number or straight

574
00:20:20,210 --> 00:20:22,890
that's what we get now it does so by

575
00:20:22,890 --> 00:20:25,590
calling a value of and then a two-string

576
00:20:25,590 --> 00:20:27,690
it calls a two-string unless a value of

577
00:20:27,690 --> 00:20:29,640
return the primitive so if you return an

578
00:20:29,640 --> 00:20:31,770
object from that why you should do that

579
00:20:31,770 --> 00:20:33,600
it's going to call it to string two

580
00:20:33,600 --> 00:20:35,460
unless a is a date because de tarso

581
00:20:35,460 --> 00:20:37,860
picker india is that we actually deeply

582
00:20:37,860 --> 00:20:39,840
embedded those in the semantics of the

583
00:20:39,840 --> 00:20:41,490
language so if it's a date we're going

584
00:20:41,490 --> 00:20:42,840
to do it in opposite direction opposite

585
00:20:42,840 --> 00:20:45,000
order and then if at least one of them

586
00:20:45,000 --> 00:20:46,290
is a string that we can work the other

587
00:20:46,290 --> 00:20:47,820
two a string and we concatenate them and

588
00:20:47,820 --> 00:20:51,660
if they otherwise we convert both two

589
00:20:51,660 --> 00:20:54,990
numbers and we add them and I must admit

590
00:20:54,990 --> 00:20:57,330
that first time I realize this coming to

591
00:20:57,330 --> 00:20:59,880
jay is my head exploded my head exploded

592
00:20:59,880 --> 00:21:01,470
when I realized that under the hood when

593
00:21:01,470 --> 00:21:04,130
I do when I perform the first operator

594
00:21:04,130 --> 00:21:07,440
j/s Matt might do a string to number

595
00:21:07,440 --> 00:21:09,299
conversion implicitly for me because

596
00:21:09,299 --> 00:21:12,179
that was unheard of for me from all of

597
00:21:12,179 --> 00:21:14,160
the other language I worked with and I

598
00:21:14,160 --> 00:21:15,540
thought you know that can't be very

599
00:21:15,540 --> 00:21:17,040
helpful at all that gives the illusion

600
00:21:17,040 --> 00:21:18,780
that you can mix drinks in numbers and

601
00:21:18,780 --> 00:21:20,549
produce meaningful results while you can

602
00:21:20,549 --> 00:21:22,290
you can't do that in any kind of larger

603
00:21:22,290 --> 00:21:27,000
scale there's the double equals in

604
00:21:27,000 --> 00:21:29,220
triple equals thing right again Angus

605
00:21:29,220 --> 00:21:31,320
talked about that and I'm so so my

606
00:21:31,320 --> 00:21:33,360
position that is that I prefer to Bleak

607
00:21:33,360 --> 00:21:34,890
walls because I understand its semantics

608
00:21:34,890 --> 00:21:36,870
easily and i can tell that to you now

609
00:21:36,870 --> 00:21:38,549
while double equals is more complicated

610
00:21:38,549 --> 00:21:40,440
I think there's exactly one use case for

611
00:21:40,440 --> 00:21:42,929
double equals and it's safe and Angus

612
00:21:42,929 --> 00:21:44,490
talk about that too it double equals

613
00:21:44,490 --> 00:21:45,960
know if you really think that it's

614
00:21:45,960 --> 00:21:48,240
important to say double equals null and

615
00:21:48,240 --> 00:21:50,700
you meet button by that meaning equal to

616
00:21:50,700 --> 00:21:52,799
null or undefined and you prefer the

617
00:21:52,799 --> 00:21:54,090
short notation instead of creating a

618
00:21:54,090 --> 00:21:55,650
function or something for it then by all

619
00:21:55,650 --> 00:21:57,419
means do that we can statically verify

620
00:21:57,419 --> 00:21:59,820
that you're actually just doing a double

621
00:21:59,820 --> 00:22:02,190
equals null and that's safe for others i

622
00:22:02,190 --> 00:22:03,660
personally prefer triple equals it's

623
00:22:03,660 --> 00:22:05,880
yours to keep my question is where is my

624
00:22:05,880 --> 00:22:09,480
triple plus has anyone seen it I found a

625
00:22:09,480 --> 00:22:11,400
double plus but it didn't really do what

626
00:22:11,400 --> 00:22:13,559
I intended to do so where is my triple

627
00:22:13,559 --> 00:22:15,630
plus you know what when I searched for

628
00:22:15,630 --> 00:22:18,059
it I finally sold magic hat full of

629
00:22:18,059 --> 00:22:20,520
surprises in jas so on the top row i

630
00:22:20,520 --> 00:22:23,100
found the comparison operators and then

631
00:22:23,100 --> 00:22:25,470
the art mythix and then the bitwise and

632
00:22:25,470 --> 00:22:28,049
the shifts the euro- and increment

633
00:22:28,049 --> 00:22:30,299
decrement wow there's so many surprises

634
00:22:30,299 --> 00:22:32,100
in there because they accepted

635
00:22:32,100 --> 00:22:33,390
anything I gave them in a game is

636
00:22:33,390 --> 00:22:34,830
something in return that was mostly not

637
00:22:34,830 --> 00:22:37,890
useful unless the input was useful so my

638
00:22:37,890 --> 00:22:39,179
question then was what if we could

639
00:22:39,179 --> 00:22:40,740
restrict the hats to something less

640
00:22:40,740 --> 00:22:42,870
surprising could we ask you to do what

641
00:22:42,870 --> 00:22:45,990
we wanted to do and nothing more here's

642
00:22:45,990 --> 00:22:47,820
my suggestion let's take the first row

643
00:22:47,820 --> 00:22:49,950
and let's say that for ordering for

644
00:22:49,950 --> 00:22:51,780
comparison operators they accept strings

645
00:22:51,780 --> 00:22:55,110
or number but never mix so a number less

646
00:22:55,110 --> 00:22:56,580
than a number we know what that's

647
00:22:56,580 --> 00:22:58,590
supposed to do number the number

648
00:22:58,590 --> 00:23:00,600
conversion and a string less than a

649
00:23:00,600 --> 00:23:02,250
string you shake lexical ordering right

650
00:23:02,250 --> 00:23:05,970
that is everything that makes sense we

651
00:23:05,970 --> 00:23:07,559
don't need to accept anything else so if

652
00:23:07,559 --> 00:23:09,299
you give it a mix a string in a number

653
00:23:09,299 --> 00:23:10,799
which should give them a null and

654
00:23:10,799 --> 00:23:12,419
something or none define or something

655
00:23:12,419 --> 00:23:14,220
that would just crash we say it fast

656
00:23:14,220 --> 00:23:15,390
because we know that we have an issue

657
00:23:15,390 --> 00:23:18,270
now in our program for plus we lacks a

658
00:23:18,270 --> 00:23:19,770
bit more we give it a stringer number in

659
00:23:19,770 --> 00:23:21,929
any combination why is that why can't we

660
00:23:21,929 --> 00:23:23,640
say number plus number is addition

661
00:23:23,640 --> 00:23:26,159
string string string concatenation well

662
00:23:26,159 --> 00:23:28,350
because you often do swing plus number

663
00:23:28,350 --> 00:23:30,960
and by that you mean a convert to number

664
00:23:30,960 --> 00:23:32,159
two string and then concatenate them so

665
00:23:32,159 --> 00:23:33,960
let's allow that still for everything

666
00:23:33,960 --> 00:23:36,809
else numbers that's it why would you

667
00:23:36,809 --> 00:23:38,850
ever want to do anything other than

668
00:23:38,850 --> 00:23:40,590
numbers on these guys it doesn't make

669
00:23:40,590 --> 00:23:42,960
any sense so for all those so for them

670
00:23:42,960 --> 00:23:45,659
for bitwise operators and the shifts and

671
00:23:45,659 --> 00:23:48,419
the increment decrement just do it with

672
00:23:48,419 --> 00:23:52,140
numbers how would we do that well we

673
00:23:52,140 --> 00:23:54,120
would instead of writing VAR x 1 equals

674
00:23:54,120 --> 00:23:57,179
1 plus y we would say x2 equals dunder

675
00:23:57,179 --> 00:23:59,610
add 1 comma y and we would create

676
00:23:59,610 --> 00:24:01,650
Thunder AB with two assertions and then

677
00:24:01,650 --> 00:24:03,960
return the plus so that would be

678
00:24:03,960 --> 00:24:05,580
slightly inconvenient right because now

679
00:24:05,580 --> 00:24:07,260
we have to rewrite our entire programs

680
00:24:07,260 --> 00:24:09,539
so press we can't change plus after all

681
00:24:09,539 --> 00:24:17,400
and here is when I try to do a demo can

682
00:24:17,400 --> 00:24:20,450
you see this is it visible yes

683
00:24:20,450 --> 00:24:22,950
hallelujah okay so let's create an

684
00:24:22,950 --> 00:24:24,720
average function so for now let's just

685
00:24:24,720 --> 00:24:26,610
say that we have some kind of translated

686
00:24:26,610 --> 00:24:29,700
version to the right even though it's

687
00:24:29,700 --> 00:24:33,360
going to a very rad what is happening to

688
00:24:33,360 --> 00:24:39,399
my average x and y

689
00:24:39,399 --> 00:24:42,729
okay so average that should be returned

690
00:24:42,729 --> 00:24:48,339
X plus y divided by 2 huh there we go oh

691
00:24:48,339 --> 00:24:49,899
it looks the same ok so it's some kind

692
00:24:49,899 --> 00:24:51,369
of translation going out but it seems to

693
00:24:51,369 --> 00:24:52,869
be the same for now doesn't matter let's

694
00:24:52,869 --> 00:24:54,820
print something to the to the console in

695
00:24:54,820 --> 00:24:57,940
the blow let's print average 0 1 & 2

696
00:24:57,940 --> 00:25:04,259
what is that any 11.5 let's do it yay

697
00:25:04,259 --> 00:25:10,960
whoa go Jay is 1.5 okay really in 1.5

698
00:25:10,960 --> 00:25:14,320
okay good let's try it with something

699
00:25:14,320 --> 00:25:16,839
else to try it with you engage we can

700
00:25:16,839 --> 00:25:18,820
mix ring some numbers freely and jas

701
00:25:18,820 --> 00:25:21,249
actually fixes that for it so the

702
00:25:21,249 --> 00:25:23,320
average of one is ring too it's also

703
00:25:23,320 --> 00:25:29,859
it's six so here's just the realization

704
00:25:29,859 --> 00:25:32,200
we cannot mix strings the numbers freely

705
00:25:32,200 --> 00:25:33,940
we always need to know whether a

706
00:25:33,940 --> 00:25:35,859
variable is to string or number and if

707
00:25:35,859 --> 00:25:36,999
we fool ourselves into thinking

708
00:25:36,999 --> 00:25:38,440
something else you know that's a recipe

709
00:25:38,440 --> 00:25:41,619
for disaster we don't want to do that so

710
00:25:41,619 --> 00:25:43,269
it's six why is it six because you take

711
00:25:43,269 --> 00:25:45,879
you take it one number 1 plus ring too

712
00:25:45,879 --> 00:25:47,799
what happens you have a string

713
00:25:47,799 --> 00:25:49,659
conversion number one becomes string

714
00:25:49,659 --> 00:25:51,789
num1 you concatenate them into the

715
00:25:51,789 --> 00:25:55,570
string 12 string 12 / number two then

716
00:25:55,570 --> 00:25:56,919
you do the implicit string to number

717
00:25:56,919 --> 00:25:58,779
conversion so you get a number 12 / 2

718
00:25:58,779 --> 00:26:02,320
and you get a six other cases that are

719
00:26:02,320 --> 00:26:04,419
really coming in jayus is like we have

720
00:26:04,419 --> 00:26:05,529
this variable that we forgot to

721
00:26:05,529 --> 00:26:07,929
initialize like X for instance so say

722
00:26:07,929 --> 00:26:09,219
that we didn't initializer we've got an

723
00:26:09,219 --> 00:26:11,889
undefined from from a function or we we

724
00:26:11,889 --> 00:26:14,649
are looking at the object property that

725
00:26:14,649 --> 00:26:16,059
doesn't exist we're going to undefined

726
00:26:16,059 --> 00:26:18,639
and when we do that we get whoops when

727
00:26:18,639 --> 00:26:20,259
we do that we get man we have this

728
00:26:20,259 --> 00:26:21,879
useless man that doesn't help us

729
00:26:21,879 --> 00:26:23,049
remember thing we would prefer to have a

730
00:26:23,049 --> 00:26:25,359
crash right so here's how I crash this

731
00:26:25,359 --> 00:26:28,749
so instead let's just add a directive

732
00:26:28,749 --> 00:26:30,460
here let's say use restrict how many

733
00:26:30,460 --> 00:26:33,399
have used es5 strict mode okay use

734
00:26:33,399 --> 00:26:35,379
restrict works similarly you can add the

735
00:26:35,379 --> 00:26:36,909
directive to your top of your program or

736
00:26:36,909 --> 00:26:38,789
through two parts your program to

737
00:26:38,789 --> 00:26:40,779
function now you see what happened there

738
00:26:40,779 --> 00:26:43,450
translator replace plus and division to

739
00:26:43,450 --> 00:26:44,739
this function called the down recalls

740
00:26:44,739 --> 00:26:47,200
that has the type assertion if you're

741
00:26:47,200 --> 00:26:48,489
not run this we're down to find we're

742
00:26:48,489 --> 00:26:50,950
going to get BAM restrict mold plus

743
00:26:50,950 --> 00:26:52,990
called me a number not define you get a

744
00:26:52,990 --> 00:26:54,040
exception thrown and you're going to get

745
00:26:54,040 --> 00:26:55,900
you're going to get precise information

746
00:26:55,900 --> 00:26:58,960
about line and everything if you do it

747
00:26:58,960 --> 00:27:02,380
with a to this ring to same thing you're

748
00:27:02,380 --> 00:27:03,490
going to get an exception you're going

749
00:27:03,490 --> 00:27:05,230
to get an error and you're going to be

750
00:27:05,230 --> 00:27:08,320
aware of their in this case you actually

751
00:27:08,320 --> 00:27:09,850
don't get exception on the plus because

752
00:27:09,850 --> 00:27:11,320
in restrict mode we actually allowed a

753
00:27:11,320 --> 00:27:12,970
number plus dream because you would like

754
00:27:12,970 --> 00:27:14,920
to do that but we got it on the X on the

755
00:27:14,920 --> 00:27:17,230
division a string / a number that's not

756
00:27:17,230 --> 00:27:19,840
allowed so that's how we can try to fix

757
00:27:19,840 --> 00:27:21,670
this so the idea very strict mode n is

758
00:27:21,670 --> 00:27:23,530
to say I promise to limit myself to a

759
00:27:23,530 --> 00:27:26,170
subset I use a checker that translates

760
00:27:26,170 --> 00:27:27,370
my code and you search this type of

761
00:27:27,370 --> 00:27:29,350
search and in my program and of course I

762
00:27:29,350 --> 00:27:30,850
then execute the checked verse and while

763
00:27:30,850 --> 00:27:33,370
I'm being while I'm developing I still

764
00:27:33,370 --> 00:27:35,170
keep my tests this is no replacement for

765
00:27:35,170 --> 00:27:37,750
tests whenever I break through a subset

766
00:27:37,750 --> 00:27:40,120
promise the program phase fast so I'm

767
00:27:40,120 --> 00:27:41,770
informed of the issue and I can correct

768
00:27:41,770 --> 00:27:44,200
my program and the beautiful thing is

769
00:27:44,200 --> 00:27:45,760
that all the semantics I described to

770
00:27:45,760 --> 00:27:47,380
you that's a subset of the existing

771
00:27:47,380 --> 00:27:49,630
semantics in in the language today so we

772
00:27:49,630 --> 00:27:51,190
don't add anything we just remove parts

773
00:27:51,190 --> 00:27:52,720
which means that once our program is

774
00:27:52,720 --> 00:27:54,190
correct we can just deploy the original

775
00:27:54,190 --> 00:27:55,480
program you don't need to deploy the

776
00:27:55,480 --> 00:27:57,720
translator one it takes six it executes

777
00:27:57,720 --> 00:27:59,860
identically in restrict mode and normal

778
00:27:59,860 --> 00:28:03,280
nodejs what do we gain the program is

779
00:28:03,280 --> 00:28:05,230
easier to reason about now because when

780
00:28:05,230 --> 00:28:07,210
i read source code that has to use

781
00:28:07,210 --> 00:28:09,640
restrictor active I have a certain

782
00:28:09,640 --> 00:28:11,020
understanding I know more about

783
00:28:11,020 --> 00:28:12,520
semantics I know more about the meaning

784
00:28:12,520 --> 00:28:14,380
of the program just like a search it's

785
00:28:14,380 --> 00:28:16,120
the same thing and whenever I need to

786
00:28:16,120 --> 00:28:18,809
fix bugs in it the Assumption versions

787
00:28:18,809 --> 00:28:21,010
reality disconnect just became a lot

788
00:28:21,010 --> 00:28:23,470
smaller I know now for a fact that we

789
00:28:23,470 --> 00:28:26,230
can't get a non out of that unless we

790
00:28:26,230 --> 00:28:28,240
fed a man into the plus operator we

791
00:28:28,240 --> 00:28:29,800
can't get a man out of it for instance

792
00:28:29,800 --> 00:28:31,870
so my program becomes more robust is

793
00:28:31,870 --> 00:28:34,630
this the right subset I mean anyone

794
00:28:34,630 --> 00:28:38,020
could create a subset right so I guess

795
00:28:38,020 --> 00:28:39,580
the way to evaluate it is that it can't

796
00:28:39,580 --> 00:28:40,900
get in a way we need to be able to write

797
00:28:40,900 --> 00:28:42,309
their programs like like we would like

798
00:28:42,309 --> 00:28:44,620
to do and he should work and apply it to

799
00:28:44,620 --> 00:28:46,600
existing product the subject mismatch

800
00:28:46,600 --> 00:28:49,210
should be tiny so then just very very

801
00:28:49,210 --> 00:28:50,920
briefly now but I tried to you know just

802
00:28:50,920 --> 00:28:53,170
take a big piece of code take that slab

803
00:28:53,170 --> 00:28:55,960
the use restrictive on top of it run

804
00:28:55,960 --> 00:28:57,730
everything to the translator and then

805
00:28:57,730 --> 00:28:59,110
execute the test suite for the program

806
00:28:59,110 --> 00:29:00,760
just to see you know how many errors do

807
00:29:00,760 --> 00:29:03,220
we get and this this is in code that

808
00:29:03,220 --> 00:29:04,419
actually works so the errors should be

809
00:29:04,419 --> 00:29:06,850
indicative of a subset mismatch you know

810
00:29:06,850 --> 00:29:08,860
somebody wanted to do things that is not

811
00:29:08,860 --> 00:29:10,750
allowed to interest Rick mode if he

812
00:29:10,750 --> 00:29:12,520
advanced you know no big mismatch

813
00:29:12,520 --> 00:29:14,590
whatsoever I had to change a handful of

814
00:29:14,590 --> 00:29:16,360
lines it found a bad practice in

815
00:29:16,360 --> 00:29:18,760
cracking yeah works fine it catches the

816
00:29:18,760 --> 00:29:20,170
old man back the undefined plus

817
00:29:20,170 --> 00:29:21,670
something would produce the man in

818
00:29:21,670 --> 00:29:23,830
jQuery great match to and actually found

819
00:29:23,830 --> 00:29:27,010
a bag which we fixed in case Lane very

820
00:29:27,010 --> 00:29:29,320
very good match to found a debatable

821
00:29:29,320 --> 00:29:31,240
practice I I said it bad practice but

822
00:29:31,240 --> 00:29:33,490
then we did a degree in it so it's the

823
00:29:33,490 --> 00:29:35,620
debatable to practice so from this

824
00:29:35,620 --> 00:29:38,980
experience yeah and finding issues was

825
00:29:38,980 --> 00:29:42,280
very unexpected this is kind of driven

826
00:29:42,280 --> 00:29:43,690
under hood by a framework called yet

827
00:29:43,690 --> 00:29:45,730
shaper sources source rewriting an

828
00:29:45,730 --> 00:29:47,590
engine that i created a year and half

829
00:29:47,590 --> 00:29:50,620
ago it's only a shaped org MIT license

830
00:29:50,620 --> 00:29:52,240
you can download and play with it it

831
00:29:52,240 --> 00:29:53,500
runs you know you can run in a browser

832
00:29:53,500 --> 00:29:55,330
and actually you can now even run it on

833
00:29:55,330 --> 00:29:56,500
the fly you can get your stick mode

834
00:29:56,500 --> 00:29:58,720
checking on your program in your on the

835
00:29:58,720 --> 00:30:00,850
fly if you want to thank you some AMD

836
00:30:00,850 --> 00:30:03,670
magic there is strict mode checker is a

837
00:30:03,670 --> 00:30:05,080
plug into this there are others to

838
00:30:05,080 --> 00:30:06,670
assert that we talked about that's what

839
00:30:06,670 --> 00:30:09,910
will give you nice good assertions bit

840
00:30:09,910 --> 00:30:11,260
wiser watch your a yielder which

841
00:30:11,260 --> 00:30:12,880
transforms your yield style code to

842
00:30:12,880 --> 00:30:15,400
normal code time for me to wrap up if

843
00:30:15,400 --> 00:30:16,810
you want to use restrict go through

844
00:30:16,810 --> 00:30:19,270
sigma dot orgs let's try downloading a

845
00:30:19,270 --> 00:30:21,160
shaper put it in your tool chain if you

846
00:30:21,160 --> 00:30:22,330
don't want to run it each and every time

847
00:30:22,330 --> 00:30:24,010
you run your program because perhaps you

848
00:30:24,010 --> 00:30:25,150
don't like the idea of having a tool

849
00:30:25,150 --> 00:30:26,740
chain or in you know slowing down your

850
00:30:26,740 --> 00:30:28,120
tool chain at least you can run it

851
00:30:28,120 --> 00:30:30,040
before you're executing your tests

852
00:30:30,040 --> 00:30:31,600
doesn't really cost you anything but it

853
00:30:31,600 --> 00:30:33,820
might help you expose something if it

854
00:30:33,820 --> 00:30:35,470
matches or doesn't match your subset let

855
00:30:35,470 --> 00:30:37,060
me know i'm really interested in hearing

856
00:30:37,060 --> 00:30:39,400
that there's no luck in you can just

857
00:30:39,400 --> 00:30:41,320
remove the use restrictor ecting no one

858
00:30:41,320 --> 00:30:42,850
needs to know that you enter in the

859
00:30:42,850 --> 00:30:44,170
first place you know but it gives you

860
00:30:44,170 --> 00:30:45,760
just a subset it just is still just

861
00:30:45,760 --> 00:30:49,510
JavaScript to wrap up this whole idea

862
00:30:49,510 --> 00:30:51,730
easier to reason about so choose your

863
00:30:51,730 --> 00:30:54,340
subset you know consider the pros and

864
00:30:54,340 --> 00:30:56,410
cons of different subsets consider pros

865
00:30:56,410 --> 00:30:58,390
or cons of different constructs and

866
00:30:58,390 --> 00:31:00,100
style guides and choose your together

867
00:31:00,100 --> 00:31:01,920
with your team if your own team

868
00:31:01,920 --> 00:31:04,450
definitely consider using tools to help

869
00:31:04,450 --> 00:31:07,390
verify those such as jess hint or or

870
00:31:07,390 --> 00:31:10,390
restrict mode or whatever it is consider

871
00:31:10,390 --> 00:31:11,830
this idea of sprinkling a surgeon's in

872
00:31:11,830 --> 00:31:13,180
your code it might be a good thing you

873
00:31:13,180 --> 00:31:15,340
might like it a try it absolutely

874
00:31:15,340 --> 00:31:17,070
prototypes getting your API is right

875
00:31:17,070 --> 00:31:19,450
challenge your assumptions especially so

876
00:31:19,450 --> 00:31:20,770
when you are in debugging

877
00:31:20,770 --> 00:31:23,110
old I if you don't have a rubber duck

878
00:31:23,110 --> 00:31:25,480
handy and room remember that reading

879
00:31:25,480 --> 00:31:27,310
code is the skills so keep practicing

880
00:31:27,310 --> 00:31:29,640
practicing it and learn from others and

881
00:31:29,640 --> 00:31:32,740
have fun so this was a story about how

882
00:31:32,740 --> 00:31:34,540
assumption met a magic hat denial of

883
00:31:34,540 --> 00:31:44,050
Leicester's thank you I'm not sure

884
00:31:44,050 --> 00:31:46,000
whether we have time for question one

885
00:31:46,000 --> 00:31:56,590
question am I got you so let's see em

886
00:31:56,590 --> 00:31:58,170
what are you thinking about checking

887
00:31:58,170 --> 00:32:00,970
indexes on the race using some kind of

888
00:32:00,970 --> 00:32:03,820
this transformation as well yeah so you

889
00:32:03,820 --> 00:32:05,590
could do that another question often get

890
00:32:05,590 --> 00:32:07,060
is you know should we check for it to to

891
00:32:07,060 --> 00:32:08,380
change truthiness it should we check

892
00:32:08,380 --> 00:32:10,180
that so in terms of toothless now that's

893
00:32:10,180 --> 00:32:11,680
very very deeply burden language is hard

894
00:32:11,680 --> 00:32:13,690
to do anything sure we could do that we

895
00:32:13,690 --> 00:32:15,460
could override the the index operator

896
00:32:15,460 --> 00:32:18,660
and create a add under index function

897
00:32:18,660 --> 00:32:21,610
I'm not sure how much that would give us

898
00:32:21,610 --> 00:32:24,370
because in das it's I mean it's common

899
00:32:24,370 --> 00:32:26,350
practice to to reference a property that

900
00:32:26,350 --> 00:32:28,120
doesn't exist say dot something and

901
00:32:28,120 --> 00:32:29,800
check what is undefined so that would be

902
00:32:29,800 --> 00:32:30,910
really surprising is that started

903
00:32:30,910 --> 00:32:33,970
crashing I'm not sure how how common

904
00:32:33,970 --> 00:32:36,010
practice it is actually to index an

905
00:32:36,010 --> 00:32:37,540
index in an array that doesn't exist and

906
00:32:37,540 --> 00:32:39,310
see whether it's undefined or not but I

907
00:32:39,310 --> 00:32:41,230
think it's common enough that it will

908
00:32:41,230 --> 00:32:43,290
kind of you know get people a bit

909
00:32:43,290 --> 00:32:45,340
worried about using this subset

910
00:32:45,340 --> 00:32:46,660
otherwise I think it's a good idea it

