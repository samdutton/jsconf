1
00:00:00,030 --> 00:00:05,160

hello how y'all doing ready the clouds

2
00:00:05,160 --> 00:00:06,870
have been fantastic I'm super happy that

3
00:00:06,870 --> 00:00:07,830
I was actually able to get here as my

4
00:00:07,830 --> 00:00:09,990
first Cascadia J s been meaning to come

5
00:00:09,990 --> 00:00:11,490
for a couple of years it's been

6
00:00:11,490 --> 00:00:13,860
absolutely phenomenal unfortunately

7
00:00:13,860 --> 00:00:15,089
after the talk I'm gonna have to walk

8
00:00:15,089 --> 00:00:16,440
off the stage and right out to the lift

9
00:00:16,440 --> 00:00:17,789
the airport I'm gonna miss the party

10
00:00:17,789 --> 00:00:19,140
tonight I hope y'all have fun it's

11
00:00:19,140 --> 00:00:21,510
something an absolute blast

12
00:00:21,510 --> 00:00:25,230
so I'm James J a snow online pretty much

13
00:00:25,230 --> 00:00:27,029
everywhere it's whitter github

14
00:00:27,029 --> 00:00:30,420
you've gmail you know feel free to reach

15
00:00:30,420 --> 00:00:31,769
out anytime if you want to talk about

16
00:00:31,769 --> 00:00:35,630
node we're contributing to open source I

17
00:00:35,630 --> 00:00:39,530
work for these folks are a company

18
00:00:39,530 --> 00:00:41,460
headquartered on the southern coast of

19
00:00:41,460 --> 00:00:43,350
Ireland a tiny little village you would

20
00:00:43,350 --> 00:00:44,820
have no idea that there was an

21
00:00:44,820 --> 00:00:46,219
international software company there

22
00:00:46,219 --> 00:00:48,180
there's about a hundred and thirty of us

23
00:00:48,180 --> 00:00:52,620
spread about over 24 countries they pay

24
00:00:52,620 --> 00:00:54,989
me to work on node full-time my

25
00:00:54,989 --> 00:00:57,180
literally on the platform itself and I

26
00:00:57,180 --> 00:01:00,840
also manage the consulting team there so

27
00:01:00,840 --> 00:01:04,409
not only do I get to build node I get to

28
00:01:04,409 --> 00:01:06,330
help go out and teach people how to use

29
00:01:06,330 --> 00:01:10,799
it and how to use it better so it you

30
00:01:10,799 --> 00:01:12,390
know it's really exciting for me because

31
00:01:12,390 --> 00:01:14,130
you know I get to see every day they do

32
00:01:14,130 --> 00:01:16,140
the really amazing things that people

33
00:01:16,140 --> 00:01:19,110
are using node for but they also get to

34
00:01:19,110 --> 00:01:22,080
see the kind of the misconceptions or

35
00:01:22,080 --> 00:01:25,140
the mistakes that are made not from the

36
00:01:25,140 --> 00:01:27,090
fault you know from the engineering

37
00:01:27,090 --> 00:01:29,250
teams faults but largely due to

38
00:01:29,250 --> 00:01:30,360
misconceptions of the programming

39
00:01:30,360 --> 00:01:31,860
language things that we did not

40
00:01:31,860 --> 00:01:33,930
communicate properly about the platform

41
00:01:33,930 --> 00:01:37,340
how it works and there's a lot of

42
00:01:37,340 --> 00:01:39,270
misconception out there about how the

43
00:01:39,270 --> 00:01:44,759
node internals actually function for the

44
00:01:44,759 --> 00:01:47,729
past probably a year whenever a customer

45
00:01:47,729 --> 00:01:49,409
comes to our team and they're saying

46
00:01:49,409 --> 00:01:51,899
well our node app is kind of slow we

47
00:01:51,899 --> 00:01:54,540
need to figure out why my first question

48
00:01:54,540 --> 00:01:58,290
is are you using promises and if they

49
00:01:58,290 --> 00:02:01,469
say yeah my first response is you're

50
00:02:01,469 --> 00:02:05,070
using them wrong because typically folks

51
00:02:05,070 --> 00:02:07,259
are actually using them wrong and it's

52
00:02:07,259 --> 00:02:09,149
and it's not their fault it's just the

53
00:02:09,149 --> 00:02:11,790
promise abstraction there are some

54
00:02:11,790 --> 00:02:13,410
nuances about it and

55
00:02:13,410 --> 00:02:15,390
how it interacts with node and the event

56
00:02:15,390 --> 00:02:17,520
loop and things like next tick and

57
00:02:17,520 --> 00:02:19,710
timers and you know all these you know

58
00:02:19,710 --> 00:02:22,200
different things that can really trip

59
00:02:22,200 --> 00:02:24,900
some folks up so I'm here to talk a

60
00:02:24,900 --> 00:02:26,490
little bit about you know how all this

61
00:02:26,490 --> 00:02:28,980
stuff comes together so a lot of people

62
00:02:28,980 --> 00:02:32,220
see node kinda like this some people

63
00:02:32,220 --> 00:02:36,360
think it's a toy right I can just look

64
00:02:36,360 --> 00:02:39,450
at this for four hours I have like three

65
00:02:39,450 --> 00:02:42,810
of these at home you know but you know

66
00:02:42,810 --> 00:02:44,040
it's like you look at it it's like okay

67
00:02:44,040 --> 00:02:45,600
what's happening inside I'm flipping a

68
00:02:45,600 --> 00:02:47,460
switch something's happening but I don't

69
00:02:47,460 --> 00:02:49,170
quite know what's there so we're gonna

70
00:02:49,170 --> 00:02:51,510
my talk about how we can peer in what's

71
00:02:51,510 --> 00:02:53,220
going on and I'm going to talk about how

72
00:02:53,220 --> 00:02:55,710
note itself functions under the covers

73
00:02:55,710 --> 00:02:57,780
with regards to the event loop so what's

74
00:02:57,780 --> 00:02:59,820
happening inside this may be a little

75
00:02:59,820 --> 00:03:04,620
bit hard to read but this code prints a

76
00:03:04,620 --> 00:03:09,690
series of console statements to the

77
00:03:09,690 --> 00:03:12,570
console right your challenge is to

78
00:03:12,570 --> 00:03:15,090
figure out without running the code

79
00:03:15,090 --> 00:03:17,790
right now have a link where you can go

80
00:03:17,790 --> 00:03:20,340
out and running it try to figure out the

81
00:03:20,340 --> 00:03:22,530
order in which these statements are

82
00:03:22,530 --> 00:03:26,490
printed there are a couple promises in

83
00:03:26,490 --> 00:03:28,830
here there is a set immediate there's a

84
00:03:28,830 --> 00:03:31,380
next tick this new thing called cue

85
00:03:31,380 --> 00:03:32,670
micro test because we didn't have things

86
00:03:32,670 --> 00:03:36,750
confusing enough set timeouts does it

87
00:03:36,750 --> 00:03:38,820
promise all it's a lot going on in this

88
00:03:38,820 --> 00:03:41,520
thing so it can be rather difficult to

89
00:03:41,520 --> 00:03:44,820
see what is happening these are pretty

90
00:03:44,820 --> 00:03:46,560
much all the ways of scheduling a

91
00:03:46,560 --> 00:03:49,440
synchronous activity within node right

92
00:03:49,440 --> 00:03:51,600
so we have promise we have event emitter

93
00:03:51,600 --> 00:03:53,220
many meters been in there from you know

94
00:03:53,220 --> 00:03:55,770
almost the beginning async/await which

95
00:03:55,770 --> 00:03:58,350
is absolutely love next tick and set

96
00:03:58,350 --> 00:04:01,290
immediate which you know they actually

97
00:04:01,290 --> 00:04:02,720
should have been reversed in the names

98
00:04:02,720 --> 00:04:04,980
the one missing from here is like set

99
00:04:04,980 --> 00:04:07,739
interval and cue micro tasks is this one

100
00:04:07,739 --> 00:04:12,060
we just added a couple of weeks ago it

101
00:04:12,060 --> 00:04:14,910
is similar to promises among you know

102
00:04:14,910 --> 00:04:17,609
when you do a problem of promise then

103
00:04:17,609 --> 00:04:19,799
right it does the same kind of task

104
00:04:19,799 --> 00:04:22,680
where you can kind of manually add a and

105
00:04:22,680 --> 00:04:25,470
an item there that only works right now

106
00:04:25,470 --> 00:04:29,370
in node in master right so if you're

107
00:04:29,370 --> 00:04:33,480
building from the master or node 11 so

108
00:04:33,480 --> 00:04:35,520
if you you know if you try out this code

109
00:04:35,520 --> 00:04:37,890
in no date or no ten you just have two

110
00:04:37,890 --> 00:04:39,660
comments out that Q micro test line

111
00:04:39,660 --> 00:04:42,480
they're right in the middle but like I

112
00:04:42,480 --> 00:04:45,000
said you challenge you just you can grow

113
00:04:45,000 --> 00:04:46,620
it and grab this if you want to write

114
00:04:46,620 --> 00:04:48,510
that down so I look at the code see if

115
00:04:48,510 --> 00:04:51,600
we can figure it out if any of you

116
00:04:51,600 --> 00:04:52,890
figure out the order

117
00:04:52,890 --> 00:04:55,140
you know without actually running the

118
00:04:55,140 --> 00:04:57,810
codes let me know because I only know of

119
00:04:57,810 --> 00:04:59,760
a couple of people within note and

120
00:04:59,760 --> 00:05:01,290
within another project itself they could

121
00:05:01,290 --> 00:05:05,280
figure it out on the first try huh but

122
00:05:05,280 --> 00:05:07,110
in order to figure out that you know to

123
00:05:07,110 --> 00:05:08,730
see what this code is doing in order to

124
00:05:08,730 --> 00:05:09,870
be able to reason about it there are

125
00:05:09,870 --> 00:05:12,470
four critical concepts we need to know

126
00:05:12,470 --> 00:05:15,900
the first one is the event loop what it

127
00:05:15,900 --> 00:05:18,020
is basically how it works

128
00:05:18,020 --> 00:05:22,050
the next one is the next tick Q alright

129
00:05:22,050 --> 00:05:24,300
this is the thing that the process next

130
00:05:24,300 --> 00:05:27,360
ticket function interacts with the third

131
00:05:27,360 --> 00:05:30,150
one is two micro tasks you alright this

132
00:05:30,150 --> 00:05:32,430
is the thing that promises interact with

133
00:05:32,430 --> 00:05:36,300
and the fourth is this concept there's

134
00:05:36,300 --> 00:05:38,570
no such thing as asynchronous JavaScript

135
00:05:38,570 --> 00:05:42,210
it does not exist all right you can

136
00:05:42,210 --> 00:05:44,820
schedule the execution of eight of

137
00:05:44,820 --> 00:05:47,430
JavaScript asynchronously but you cannot

138
00:05:47,430 --> 00:05:50,310
run JavaScript asynchronously all right

139
00:05:50,310 --> 00:05:53,220
very very important concept when it

140
00:05:53,220 --> 00:05:54,480
comes to understanding what's happening

141
00:05:54,480 --> 00:05:58,370
within a node process and how that is

142
00:05:58,370 --> 00:06:01,740
performing so this might be a picture

143
00:06:01,740 --> 00:06:03,450
you've seen before it's a very abstract

144
00:06:03,450 --> 00:06:06,660
view of the event loop all right it's

145
00:06:06,660 --> 00:06:08,580
this thing you know it turns around and

146
00:06:08,580 --> 00:06:10,830
around and does stuff right but what

147
00:06:10,830 --> 00:06:14,310
exactly is it doing this is you know

148
00:06:14,310 --> 00:06:17,370
this is a better view in my opinion what

149
00:06:17,370 --> 00:06:19,290
the event loop does is essentially

150
00:06:19,290 --> 00:06:21,900
delivering messages right so you can

151
00:06:21,900 --> 00:06:23,880
imagine you know I'm a letter carrier

152
00:06:23,880 --> 00:06:26,220
right and I have a stack of letters

153
00:06:26,220 --> 00:06:28,230
right but I need to deliver so I have

154
00:06:28,230 --> 00:06:30,120
one right now I'm gonna give it to

155
00:06:30,120 --> 00:06:33,270
somebody and I can't just go and to the

156
00:06:33,270 --> 00:06:35,669
next person in Port handing letters out

157
00:06:35,669 --> 00:06:37,260
what I have to do is when I give it to

158
00:06:37,260 --> 00:06:38,830
somebody I

159
00:06:38,830 --> 00:06:41,410
to wait until they do whatever they're

160
00:06:41,410 --> 00:06:44,020
gonna do with it right they read it they

161
00:06:44,020 --> 00:06:46,180
figure out you know what what response

162
00:06:46,180 --> 00:06:47,500
they're gonna give they write out a

163
00:06:47,500 --> 00:06:49,570
response right and then and then they

164
00:06:49,570 --> 00:06:51,430
tell me that they're done okay

165
00:06:51,430 --> 00:06:54,190
so then I go to the next person and I

166
00:06:54,190 --> 00:06:55,660
can hand them their letter and then I

167
00:06:55,660 --> 00:06:57,820
have to wait all right and then I go to

168
00:06:57,820 --> 00:07:00,120
the next person and hand them theirs

169
00:07:00,120 --> 00:07:03,820
that is what the event loop does it

170
00:07:03,820 --> 00:07:06,850
takes a queue of messages so cute you

171
00:07:06,850 --> 00:07:09,850
know we're callbacks right events that

172
00:07:09,850 --> 00:07:12,130
have occurred and it goes through and

173
00:07:12,130 --> 00:07:14,920
hands those off to JavaScript functions

174
00:07:14,920 --> 00:07:17,980
to execute all right it can only do one

175
00:07:17,980 --> 00:07:19,420
of these at a time

176
00:07:19,420 --> 00:07:23,380
all right one of the really important

177
00:07:23,380 --> 00:07:28,170
concepts to understand is that in node

178
00:07:28,170 --> 00:07:31,660
you have a call stack so you have the

179
00:07:31,660 --> 00:07:35,260
event loop running down here you have

180
00:07:35,260 --> 00:07:37,960
some C++ code and then you have some

181
00:07:37,960 --> 00:07:40,870
JavaScript code all right every time the

182
00:07:40,870 --> 00:07:42,880
event loop gets a notification it's

183
00:07:42,880 --> 00:07:45,070
gonna call through C++ up to the

184
00:07:45,070 --> 00:07:48,280
JavaScript all right and then when that

185
00:07:48,280 --> 00:07:50,770
JavaScript returns back all the way down

186
00:07:50,770 --> 00:07:52,780
to the event loop you can move on to the

187
00:07:52,780 --> 00:07:54,790
next task and run the next stack of

188
00:07:54,790 --> 00:07:58,210
JavaScript code okay now this is

189
00:07:58,210 --> 00:07:59,920
critically important because over here

190
00:07:59,920 --> 00:08:02,650
on the side are these two little things

191
00:08:02,650 --> 00:08:06,640
here one is the next tick queue and the

192
00:08:06,640 --> 00:08:10,780
other is the micro task you when code is

193
00:08:10,780 --> 00:08:12,730
running in JavaScript and you call

194
00:08:12,730 --> 00:08:15,190
process next tick it's just going to

195
00:08:15,190 --> 00:08:17,590
drop a function into that X to Q and

196
00:08:17,590 --> 00:08:20,110
leave it there when you schedule a

197
00:08:20,110 --> 00:08:21,460
problem when you call a promise and

198
00:08:21,460 --> 00:08:24,880
interview in resolves to the dot dot Ben

199
00:08:24,880 --> 00:08:27,910
or dot catch or dot finally what's gonna

200
00:08:27,910 --> 00:08:29,770
happen is that function handler is gonna

201
00:08:29,770 --> 00:08:31,480
be dropped into micro test queue and

202
00:08:31,480 --> 00:08:34,240
it's lefted there okay it's not until

203
00:08:34,240 --> 00:08:36,490
the threat of execution we you know that

204
00:08:36,490 --> 00:08:38,560
stack unwinds back to that javascript

205
00:08:38,560 --> 00:08:41,590
c++ layer that that next to queue and

206
00:08:41,590 --> 00:08:44,440
the micro task queue is drained so all

207
00:08:44,440 --> 00:08:46,390
of those functions will not be called

208
00:08:46,390 --> 00:08:49,570
until control returns back to the c++

209
00:08:49,570 --> 00:08:51,130
layer

210
00:08:51,130 --> 00:08:54,269
you know from that from that call okay

211
00:08:54,269 --> 00:08:57,910
so we can only execute one task at a

212
00:08:57,910 --> 00:08:59,529
time all of these tab

213
00:08:59,529 --> 00:09:00,790
you know these asynchronous tasks that

214
00:09:00,790 --> 00:09:02,320
are scheduled getting an end up getting

215
00:09:02,320 --> 00:09:05,290
queued in the micro task queue or the or

216
00:09:05,290 --> 00:09:06,970
the next tick queue unless they're a

217
00:09:06,970 --> 00:09:08,740
timer which works entirely different

218
00:09:08,740 --> 00:09:12,759
timer will run on the event loop either

219
00:09:12,759 --> 00:09:15,040
on the next turn or some you know set of

220
00:09:15,040 --> 00:09:16,480
milliseconds or seconds Africa okay you

221
00:09:16,480 --> 00:09:20,230
know as the event loop turns but still

222
00:09:20,230 --> 00:09:21,910
if you're going through and doing all

223
00:09:21,910 --> 00:09:23,440
the scheduling it still only runs one

224
00:09:23,440 --> 00:09:24,480
thing at a time

225
00:09:24,480 --> 00:09:26,889
so when javascript is running the event

226
00:09:26,889 --> 00:09:29,949
loop is not the event loop past the

227
00:09:29,949 --> 00:09:32,560
pause whenever you are whatever it's

228
00:09:32,560 --> 00:09:33,790
executing this code which means you

229
00:09:33,790 --> 00:09:36,880
can't collect i/o events no network

230
00:09:36,880 --> 00:09:38,889
traffic is being okay no network

231
00:09:38,889 --> 00:09:41,230
connections are being are being

232
00:09:41,230 --> 00:09:41,829
processed

233
00:09:41,829 --> 00:09:46,000
it's just executing that code we call

234
00:09:46,000 --> 00:09:47,769
this event loop delay and it's the

235
00:09:47,769 --> 00:09:49,959
single most important concept for node

236
00:09:49,959 --> 00:09:51,970
performance all right this is the thing

237
00:09:51,970 --> 00:09:53,980
that will kill your note note

238
00:09:53,980 --> 00:09:57,430
applications from from running so this

239
00:09:57,430 --> 00:09:59,620
is an example you know whenever you're

240
00:09:59,620 --> 00:10:01,449
doing any kind of large synchronous

241
00:10:01,449 --> 00:10:04,029
activity right you're just killing

242
00:10:04,029 --> 00:10:05,560
everything you're killing performance

243
00:10:05,560 --> 00:10:07,990
they're not letting no do it do what it

244
00:10:07,990 --> 00:10:11,319
does which is a synchronous i/o okay so

245
00:10:11,319 --> 00:10:14,680
again javascript is not synchronous but

246
00:10:14,680 --> 00:10:15,459
here's a trick question

247
00:10:15,459 --> 00:10:17,410
had to leave it'll you know a trick

248
00:10:17,410 --> 00:10:19,300
question because the answer should be

249
00:10:19,300 --> 00:10:21,819
obvious it's very the fact that I'm

250
00:10:21,819 --> 00:10:24,130
asking it the answer is no not all

251
00:10:24,130 --> 00:10:26,350
javascript in note runs within the event

252
00:10:26,350 --> 00:10:28,180
loop and this comes is a big surprise

253
00:10:28,180 --> 00:10:30,790
for a lot of people now here's another

254
00:10:30,790 --> 00:10:32,709
question does it all run within the same

255
00:10:32,709 --> 00:10:36,220
event loop as of no ten no it does not

256
00:10:36,220 --> 00:10:38,980
we now have proper worker threads every

257
00:10:38,980 --> 00:10:40,810
worker thread has its own event loop and

258
00:10:40,810 --> 00:10:42,579
node instance running this is all

259
00:10:42,579 --> 00:10:44,649
running within a single process I'm not

260
00:10:44,649 --> 00:10:45,970
gonna get into that now but it makes

261
00:10:45,970 --> 00:10:47,380
things significantly more complicated

262
00:10:47,380 --> 00:10:51,069
but a hell of a lot more fun so this is

263
00:10:51,069 --> 00:10:52,990
gonna be a blast working with with this

264
00:10:52,990 --> 00:10:54,399
hopefully workers will come out of

265
00:10:54,399 --> 00:10:55,839
experimental by no.12

266
00:10:55,839 --> 00:11:01,750
and you know yeah I can't wait but there

267
00:11:01,750 --> 00:11:04,270
are three main phases two nodes startup

268
00:11:04,270 --> 00:11:07,240
there's the bootstrap there's main and

269
00:11:07,240 --> 00:11:09,010
event loop you know folks have some

270
00:11:09,010 --> 00:11:12,640
different names for these things what

271
00:11:12,640 --> 00:11:14,740
happens during boot strap is nodes

272
00:11:14,740 --> 00:11:18,459
loading its own JavaScript right who's

273
00:11:18,459 --> 00:11:22,270
doing serverless stuff all right all

274
00:11:22,270 --> 00:11:23,800
right who have had problems with cold

275
00:11:23,800 --> 00:11:25,020
start times

276
00:11:25,020 --> 00:11:27,760
that's because node is damn slow loading

277
00:11:27,760 --> 00:11:29,860
itself it has a whole bunch of

278
00:11:29,860 --> 00:11:32,170
JavaScript that it needs to load and

279
00:11:32,170 --> 00:11:33,910
then it needs to load the user code on

280
00:11:33,910 --> 00:11:35,890
top of that right which is which happens

281
00:11:35,890 --> 00:11:38,740
during main during this time it's

282
00:11:38,740 --> 00:11:41,020
loading it off it's compar Singh the the

283
00:11:41,020 --> 00:11:42,970
JavaScript it's compiling it and then

284
00:11:42,970 --> 00:11:45,279
executing it and there's a lot of boot

285
00:11:45,279 --> 00:11:47,529
up that needs to happen within node

286
00:11:47,529 --> 00:11:49,990
itself to to make sure that it's that

287
00:11:49,990 --> 00:11:52,870
it's able to run the event loop has

288
00:11:52,870 --> 00:11:55,450
started after main scope exits all right

289
00:11:55,450 --> 00:11:57,670
and only if asynchronous tasks were

290
00:11:57,670 --> 00:12:00,550
scheduled so this is an example so we

291
00:12:00,550 --> 00:12:04,630
have this bootstrap by JS file excuse me

292
00:12:04,630 --> 00:12:07,720
and one of the statements here is this

293
00:12:07,720 --> 00:12:10,180
console log right we have the

294
00:12:10,180 --> 00:12:12,520
performance API this no timing object

295
00:12:12,520 --> 00:12:14,260
gives you some timestamp of when things

296
00:12:14,260 --> 00:12:17,709
within node kicked off or when they when

297
00:12:17,709 --> 00:12:19,180
they completed this loop start tells you

298
00:12:19,180 --> 00:12:21,370
when the event loops was actually

299
00:12:21,370 --> 00:12:24,459
started after that yeah after your code

300
00:12:24,459 --> 00:12:26,620
it started running so in bootstrap Jas

301
00:12:26,620 --> 00:12:28,810
here this first console log statement

302
00:12:28,810 --> 00:12:30,579
loop start is gonna be minus one which

303
00:12:30,579 --> 00:12:32,320
indicates that the loop has not actually

304
00:12:32,320 --> 00:12:34,690
started you schedule some asynchronous

305
00:12:34,690 --> 00:12:36,550
activities set immediate when that runs

306
00:12:36,550 --> 00:12:38,829
you check loop start again and you'll

307
00:12:38,829 --> 00:12:41,470
see an actual timestamp there so this

308
00:12:41,470 --> 00:12:43,899
initial code this top scope right

309
00:12:43,899 --> 00:12:45,760
top-level scope this is running within

310
00:12:45,760 --> 00:12:47,260
that main scope right

311
00:12:47,260 --> 00:12:49,420
at this point the event loop is not

312
00:12:49,420 --> 00:12:52,959
running why is this important in this

313
00:12:52,959 --> 00:12:55,060
code if you want to start reasoning

314
00:12:55,060 --> 00:12:57,279
about what this is doing and the order

315
00:12:57,279 --> 00:12:59,589
of execution you have to start thinking

316
00:12:59,589 --> 00:13:01,300
about what is running within the event

317
00:13:01,300 --> 00:13:03,160
loop and what is not running within the

318
00:13:03,160 --> 00:13:04,510
event loop you also have to start

319
00:13:04,510 --> 00:13:06,100
thinking about what is running within

320
00:13:06,100 --> 00:13:08,050
the the micro task queue what is running

321
00:13:08,050 --> 00:13:09,910
within the process next to what is a

322
00:13:09,910 --> 00:13:12,310
timer and how all of these things and

323
00:13:12,310 --> 00:13:13,300
relates from one another

324
00:13:13,300 --> 00:13:17,240
it is extremely complicated to visual

325
00:13:17,240 --> 00:13:18,890
even conceptually how these things

326
00:13:18,890 --> 00:13:20,210
interact with one another

327
00:13:20,210 --> 00:13:22,130
we've fortunately we built some tools to

328
00:13:22,130 --> 00:13:24,280
figure that to start to visualize this

329
00:13:24,280 --> 00:13:26,900
so the first rule of nodejs performance

330
00:13:26,900 --> 00:13:29,300
know when your code is running know ya

331
00:13:29,300 --> 00:13:33,680
know each individual function so the

332
00:13:33,680 --> 00:13:35,330
first tool that we've that we have

333
00:13:35,330 --> 00:13:38,900
within those are trace events trace

334
00:13:38,900 --> 00:13:42,200
events are a file format that that came

335
00:13:42,200 --> 00:13:46,130
out of v8 and chrome it's a right now

336
00:13:46,130 --> 00:13:48,290
it's a JSON format that gets outputted

337
00:13:48,290 --> 00:13:51,860
by the engine and by node whenever

338
00:13:51,860 --> 00:13:54,020
significant events happen with the core

339
00:13:54,020 --> 00:13:55,420
we have to go through and actually

340
00:13:55,420 --> 00:13:58,010
implement the code to emit these we are

341
00:13:58,010 --> 00:14:01,130
in the process now of expanding the type

342
00:14:01,130 --> 00:14:03,290
of information that can come out of node

343
00:14:03,290 --> 00:14:06,080
through trace events one of the key bits

344
00:14:06,080 --> 00:14:07,820
of information we can get right now is

345
00:14:07,820 --> 00:14:10,310
what a synchronous activity is happening

346
00:14:10,310 --> 00:14:12,710
over the lifetime of that of that

347
00:14:12,710 --> 00:14:15,620
application we can use this I will show

348
00:14:15,620 --> 00:14:17,420
in just a minute to visualize the

349
00:14:17,420 --> 00:14:19,010
activity happening within that

350
00:14:19,010 --> 00:14:22,760
application the next important tool is

351
00:14:22,760 --> 00:14:24,770
async Kooks this is the low-level API

352
00:14:24,770 --> 00:14:27,530
which is what we use to actually emit

353
00:14:27,530 --> 00:14:30,230
the trace events to see what is

354
00:14:30,230 --> 00:14:31,880
happening so whenever a new object is

355
00:14:31,880 --> 00:14:34,970
created whenever a callback is invoked

356
00:14:34,970 --> 00:14:39,350
the async hooks API is called this third

357
00:14:39,350 --> 00:14:41,450
one it's not actually in core it's

358
00:14:41,450 --> 00:14:43,520
another tool it's a it's an external

359
00:14:43,520 --> 00:14:45,110
tool they by team in uniform and near

360
00:14:45,110 --> 00:14:46,480
foreign-built it's all open source

361
00:14:46,480 --> 00:14:49,490
called bubble bubble bubble problem

362
00:14:49,490 --> 00:14:52,820
profiling I'll show you how this works

363
00:14:52,820 --> 00:14:54,500
and how it relates to all this but it's

364
00:14:54,500 --> 00:14:57,620
built on top of of trace events so the

365
00:14:57,620 --> 00:14:59,300
first thing I pick until we have is

366
00:14:59,300 --> 00:15:01,640
built into chrome itself this is the

367
00:15:01,640 --> 00:15:04,280
chrome trace viewer it's a very

368
00:15:04,280 --> 00:15:07,820
unassuming simple UI may be a little bit

369
00:15:07,820 --> 00:15:09,830
hard to read because of the colors that

370
00:15:09,830 --> 00:15:13,580
are there but it can read this JSON file

371
00:15:13,580 --> 00:15:16,940
that is emitted by the node process and

372
00:15:16,940 --> 00:15:19,490
by v8 and depending on what categories

373
00:15:19,490 --> 00:15:22,040
of trace events you've you've asked it

374
00:15:22,040 --> 00:15:24,200
to emit you pull this in and it gives

375
00:15:24,200 --> 00:15:27,140
you a timeline of when those things were

376
00:15:27,140 --> 00:15:28,520
occurring so this is looking at that

377
00:15:28,520 --> 00:15:29,310
timing file

378
00:15:29,310 --> 00:15:31,199
and we see that there was an immediate

379
00:15:31,199 --> 00:15:33,240
scheduled right that was the said

380
00:15:33,240 --> 00:15:35,519
immediate that we had and that is a

381
00:15:35,519 --> 00:15:37,470
persistent object to exist over time

382
00:15:37,470 --> 00:15:40,860
right and then at some point that gets

383
00:15:40,860 --> 00:15:43,050
executed we have two of those that are

384
00:15:43,050 --> 00:15:44,790
happening here we have multiple promises

385
00:15:44,790 --> 00:15:46,740
and this will show you the entire

386
00:15:46,740 --> 00:15:50,970
lifecycle of these of these things we

387
00:15:50,970 --> 00:15:52,769
have within nodes these things called

388
00:15:52,769 --> 00:15:54,660
tick objects those are the next tick

389
00:15:54,660 --> 00:15:57,139
things that are scheduled on that queue

390
00:15:57,139 --> 00:16:00,360
we can also see when v8 was actually

391
00:16:00,360 --> 00:16:03,329
executing code and the interesting thing

392
00:16:03,329 --> 00:16:05,519
about this is we can actually if we

393
00:16:05,519 --> 00:16:09,480
drill in and see zoom in on this you see

394
00:16:09,480 --> 00:16:11,459
it actually gets fairly complicated we

395
00:16:11,459 --> 00:16:13,439
can see the exact transition points when

396
00:16:13,439 --> 00:16:15,720
v8 to go you know when v8 is done

397
00:16:15,720 --> 00:16:18,329
executing the JavaScript code and when

398
00:16:18,329 --> 00:16:20,759
control returns back to that c++ layer

399
00:16:20,759 --> 00:16:22,620
and things like the next tick queue and

400
00:16:22,620 --> 00:16:25,529
the micro task queue get executed this

401
00:16:25,529 --> 00:16:27,809
is extremely helpful if you know what a

402
00:16:27,809 --> 00:16:29,790
synchronous activity your application is

403
00:16:29,790 --> 00:16:31,350
scheduling for you to know what the

404
00:16:31,350 --> 00:16:33,449
actual performance impact of that code

405
00:16:33,449 --> 00:16:36,120
is you can see those transition points

406
00:16:36,120 --> 00:16:38,639
you can see when this you know this big

407
00:16:38,639 --> 00:16:40,680
json.parse thing you might have in there

408
00:16:40,680 --> 00:16:42,870
you know how long how much time that's

409
00:16:42,870 --> 00:16:44,309
taking up and what else

410
00:16:44,309 --> 00:16:46,170
it is delaying now it takes a bit of

411
00:16:46,170 --> 00:16:48,180
practice to figure out what you know

412
00:16:48,180 --> 00:16:50,339
what's going on in here and it's not the

413
00:16:50,339 --> 00:16:54,029
best use of our interface it is evolving

414
00:16:54,029 --> 00:16:56,399
over time but it's extremely useful to

415
00:16:56,399 --> 00:16:59,759
see see these transition points all

416
00:16:59,759 --> 00:17:03,540
right so let's go back here bootstrap

417
00:17:03,540 --> 00:17:05,459
trace events something we enabled in in

418
00:17:05,459 --> 00:17:08,490
core if you use this command line you

419
00:17:08,490 --> 00:17:13,020
can see let's see here you can see

420
00:17:13,020 --> 00:17:17,130
exactly when node itself executes its

421
00:17:17,130 --> 00:17:20,490
various bootstrap phases so when it when

422
00:17:20,490 --> 00:17:22,559
does it start the event loop when is it

423
00:17:22,559 --> 00:17:24,809
compiling its own code those kind of

424
00:17:24,809 --> 00:17:26,549
things so we're going to set up some

425
00:17:26,549 --> 00:17:28,890
categories we're gonna do v8 we're gonna

426
00:17:28,890 --> 00:17:32,510
go node VM and we're gonna say node

427
00:17:32,510 --> 00:17:37,710
bootstrap and I mean look at that

428
00:17:37,710 --> 00:17:42,080
the but I don't want to give away the

429
00:17:42,080 --> 00:17:46,740
order of it alright so there we have it

430
00:17:46,740 --> 00:17:50,180
we can come back in here look at our

431
00:17:50,180 --> 00:17:54,330
node trace file and we can see in here

432
00:17:54,330 --> 00:17:55,740
there's a bug in Windows it's not

433
00:17:55,740 --> 00:17:57,060
actually telling me what it should say

434
00:17:57,060 --> 00:17:59,120
under this context context apply script

435
00:17:59,120 --> 00:18:01,560
it should tell me the exact file names

436
00:18:01,560 --> 00:18:04,470
that I was requiring and that's nodes

437
00:18:04,470 --> 00:18:08,190
own library and your code that's running

438
00:18:08,190 --> 00:18:09,960
in here it'll tell you when it was

439
00:18:09,960 --> 00:18:11,670
required it will tell you exactly how

440
00:18:11,670 --> 00:18:13,080
long it take to load it how long it took

441
00:18:13,080 --> 00:18:15,000
to compile it and how long it took to

442
00:18:15,000 --> 00:18:17,070
execute it and then show you the exact

443
00:18:17,070 --> 00:18:19,830
ordering of the loading of your

444
00:18:19,830 --> 00:18:22,230
dependencies over time and you can you

445
00:18:22,230 --> 00:18:24,000
know if you look at that with the async

446
00:18:24,000 --> 00:18:26,370
activity information turned on you can

447
00:18:26,370 --> 00:18:28,980
also see that activity occurring

448
00:18:28,980 --> 00:18:31,860
relative to turns of the event loop so

449
00:18:31,860 --> 00:18:33,900
you can see exactly when all of your

450
00:18:33,900 --> 00:18:36,300
your code is being run and exactly how

451
00:18:36,300 --> 00:18:40,230
long it's it took dacing traced events

452
00:18:40,230 --> 00:18:42,810
this is the thing that takes the async

453
00:18:42,810 --> 00:18:44,670
hooks information and exports it out to

454
00:18:44,670 --> 00:18:48,180
the to that trace event log and this

455
00:18:48,180 --> 00:18:50,880
gets quite a bit more complicated so if

456
00:18:50,880 --> 00:18:54,840
we want to take the same one and we're

457
00:18:54,840 --> 00:18:58,230
gonna say node base and cooks this is

458
00:18:58,230 --> 00:19:00,210
this all of this is just built into the

459
00:19:00,210 --> 00:19:02,370
node binary right now works for 10 and

460
00:19:02,370 --> 00:19:04,460
11 there's some support in it for 8

461
00:19:04,460 --> 00:19:07,530
there are some bugs in it so everybody

462
00:19:07,530 --> 00:19:09,740
should be on 10 anyway so upgrade

463
00:19:09,740 --> 00:19:12,830
alright so we're gonna run this again

464
00:19:12,830 --> 00:19:15,900
we're gonna come back here load this

465
00:19:15,900 --> 00:19:20,970
back up and in here we see there's you

466
00:19:20,970 --> 00:19:22,110
know quite a bit more detail this is

467
00:19:22,110 --> 00:19:23,340
where we're seeing all of those promise

468
00:19:23,340 --> 00:19:25,260
objects the immediate stew timer is the

469
00:19:25,260 --> 00:19:27,450
next kicks and and we can see the

470
00:19:27,450 --> 00:19:29,070
execution of these things relative to

471
00:19:29,070 --> 00:19:30,830
one another

472
00:19:30,830 --> 00:19:37,590
all right the the Therese Event Viewer

473
00:19:37,590 --> 00:19:40,530
is good it provides a lot of detail it's

474
00:19:40,530 --> 00:19:42,330
really hard to process if you have an

475
00:19:42,330 --> 00:19:45,600
extremely complicated application just

476
00:19:45,600 --> 00:19:47,100
this last week I was you know at a

477
00:19:47,100 --> 00:19:49,020
customer we you know in a

478
00:19:49,020 --> 00:19:51,840
20 and I think was a 20 second benchmark

479
00:19:51,840 --> 00:19:54,450
of their code we ran through and they

480
00:19:54,450 --> 00:19:56,310
ended up just in that 20 seconds they

481
00:19:56,310 --> 00:19:58,140
had created something like 15,000

482
00:19:58,140 --> 00:20:03,840
promises about 10,000 next ticks and a

483
00:20:03,840 --> 00:20:05,940
whole bunch else the the the trace event

484
00:20:05,940 --> 00:20:07,710
file was massive and it just killed

485
00:20:07,710 --> 00:20:09,960
chrome when I tried to load the you know

486
00:20:09,960 --> 00:20:14,270
loaded in the viewer it's extremely

487
00:20:14,270 --> 00:20:16,230
complicated and there's a lot of data

488
00:20:16,230 --> 00:20:17,730
that's there so we needed a different

489
00:20:17,730 --> 00:20:20,280
way of viewing it so we created a tool

490
00:20:20,280 --> 00:20:22,230
called clinic this is all open source

491
00:20:22,230 --> 00:20:25,610
you can get it from you know yeah NPM

492
00:20:25,610 --> 00:20:29,400
from clinic use yarn whatever and what

493
00:20:29,400 --> 00:20:31,350
it is designed to do is help you

494
00:20:31,350 --> 00:20:32,910
diagnose performance problems within

495
00:20:32,910 --> 00:20:37,920
your application bubble props is one of

496
00:20:37,920 --> 00:20:40,190
the tools here and it's very simple

497
00:20:40,190 --> 00:20:47,190
clinic bubble node again I don't wanna

498
00:20:47,190 --> 00:20:51,450
give away the result we're gonna let it

499
00:20:51,450 --> 00:20:52,890
do its thing for a few minutes what it's

500
00:20:52,890 --> 00:20:54,810
doing right now is it's exporting that

501
00:20:54,810 --> 00:20:57,030
vet file and then it's going to go

502
00:20:57,030 --> 00:21:01,650
through and actually analyze the all of

503
00:21:01,650 --> 00:21:03,600
that async activity and then it's going

504
00:21:03,600 --> 00:21:06,690
to give you a display of that

505
00:21:06,690 --> 00:21:09,120
asynchronous activity what this is

506
00:21:09,120 --> 00:21:11,820
showing you is the aggregate latency

507
00:21:11,820 --> 00:21:14,550
caused by a synchronous activity within

508
00:21:14,550 --> 00:21:16,290
Europe and within your application you

509
00:21:16,290 --> 00:21:17,850
can explore this you can kind of drill

510
00:21:17,850 --> 00:21:19,560
down into it you can see exactly what

511
00:21:19,560 --> 00:21:21,450
promise has happened the UI we're still

512
00:21:21,450 --> 00:21:21,960
working on it

513
00:21:21,960 --> 00:21:24,390
some application you know some of them

514
00:21:24,390 --> 00:21:25,680
turn out we have a whole gallery of a

515
00:21:25,680 --> 00:21:28,800
really crazy artwork from this thing but

516
00:21:28,800 --> 00:21:30,150
what it's basically showing you is how

517
00:21:30,150 --> 00:21:32,190
long it took to transition from one

518
00:21:32,190 --> 00:21:34,140
asynchronous activity within your code

519
00:21:34,140 --> 00:21:36,090
to another so where's the trace event

520
00:21:36,090 --> 00:21:38,910
you can see or see it over a time line

521
00:21:38,910 --> 00:21:40,740
right you can see - the transition

522
00:21:40,740 --> 00:21:42,060
points what this is going to do is

523
00:21:42,060 --> 00:21:44,880
aggregate those and show you exactly how

524
00:21:44,880 --> 00:21:46,770
much time in each part of your

525
00:21:46,770 --> 00:21:50,370
application node was spending and notice

526
00:21:50,370 --> 00:21:52,500
doing work right or how much time it was

527
00:21:52,500 --> 00:21:54,680
spending waiting for work to be done

528
00:21:54,680 --> 00:21:59,490
okay so let me show you let me ask you

529
00:21:59,490 --> 00:22:02,419
this one I promise is asynchronous

530
00:22:02,419 --> 00:22:05,610
it is a trick question do promises

531
00:22:05,610 --> 00:22:08,820
execute concurrently there's a lot of

532
00:22:08,820 --> 00:22:10,260
confusion about this I had an argument

533
00:22:10,260 --> 00:22:12,210
with a guy a couple months ago who is

534
00:22:12,210 --> 00:22:14,640
just absolutely adamant that promise all

535
00:22:14,640 --> 00:22:16,820
executed everything concurrently the

536
00:22:16,820 --> 00:22:20,130
challenge is a does it all right when

537
00:22:20,130 --> 00:22:22,110
you have an async function right and

538
00:22:22,110 --> 00:22:24,540
that async function wraps purely

539
00:22:24,540 --> 00:22:28,770
synchronous code right then it's then

540
00:22:28,770 --> 00:22:30,750
it's just gonna execute synchronously so

541
00:22:30,750 --> 00:22:33,150
when you have this promise that all food

542
00:22:33,150 --> 00:22:35,190
and bar who's gonna run completely bars

543
00:22:35,190 --> 00:22:36,960
gonna run completely after it all right

544
00:22:36,960 --> 00:22:40,200
what about promise race same thing races

545
00:22:40,200 --> 00:22:41,700
that race says whichever one finishes

546
00:22:41,700 --> 00:22:44,820
first give me that right well if if the

547
00:22:44,820 --> 00:22:47,190
async functions here are all purely

548
00:22:47,190 --> 00:22:49,200
synchronous you're gonna have the exact

549
00:22:49,200 --> 00:22:51,690
same effect foo which is a much longer

550
00:22:51,690 --> 00:22:52,799
loop it's gonna block the event loop

551
00:22:52,799 --> 00:22:55,049
that's gonna finish first and so in this

552
00:22:55,049 --> 00:22:56,610
particular case race is not doing you

553
00:22:56,610 --> 00:22:59,400
any good now if those functions actually

554
00:22:59,400 --> 00:23:01,410
have a synchronous activity like this a

555
00:23:01,410 --> 00:23:04,020
wait time out then yes bar will finish

556
00:23:04,020 --> 00:23:06,750
first and you know in the promise race

557
00:23:06,750 --> 00:23:10,320
will do what you expect it to do all

558
00:23:10,320 --> 00:23:12,210
right running out of time some to skip

559
00:23:12,210 --> 00:23:13,470
ahead I want to show you this example

560
00:23:13,470 --> 00:23:14,700
we're a quick so this is a real-world

561
00:23:14,700 --> 00:23:16,740
example from an application we profile

562
00:23:16,740 --> 00:23:18,660
just about a week ago all right using

563
00:23:18,660 --> 00:23:23,299
bubble cross this is the high level

564
00:23:23,299 --> 00:23:25,080
asynchronous activity happening in this

565
00:23:25,080 --> 00:23:27,780
application it's a mess because this was

566
00:23:27,780 --> 00:23:31,200
very poorly written code and we can

567
00:23:31,200 --> 00:23:33,870
drill down in here and we can see now

568
00:23:33,870 --> 00:23:39,330
yep there's more activity here let's see

569
00:23:39,330 --> 00:23:41,970
we can find there's some promise changed

570
00:23:41,970 --> 00:23:46,049
in here like deep promise chains this

571
00:23:46,049 --> 00:23:47,730
this is the code that was creating about

572
00:23:47,730 --> 00:23:52,049
ten thousand promises within a twenty

573
00:23:52,049 --> 00:23:53,790
second run this is the one I was looking

574
00:23:53,790 --> 00:23:57,030
for this is extremely poorly written

575
00:23:57,030 --> 00:23:59,130
scheduling code all this is doing is

576
00:23:59,130 --> 00:24:01,260
scheduling that this was about a

577
00:24:01,260 --> 00:24:03,980
thousand promises in a single

578
00:24:03,980 --> 00:24:06,330
synchronous loop and then they weren't

579
00:24:06,330 --> 00:24:08,010
allowed to execute and then as soon as

580
00:24:08,010 --> 00:24:10,799
the the control returned all that

581
00:24:10,799 --> 00:24:12,750
executed all at once you know one after

582
00:24:12,750 --> 00:24:14,850
the other and then each of those were

583
00:24:14,850 --> 00:24:16,800
also scheduling promises I could drill

584
00:24:16,800 --> 00:24:20,550
down here many more levels I'm have time

585
00:24:20,550 --> 00:24:24,450
to do that but the point is you know in

586
00:24:24,450 --> 00:24:25,710
order to be able to visualize and reason

587
00:24:25,710 --> 00:24:26,940
about this stuff I mean you know the

588
00:24:26,940 --> 00:24:28,560
whole reason this is such a mess is the

589
00:24:28,560 --> 00:24:31,320
team forgot to think about when their

590
00:24:31,320 --> 00:24:33,990
code is being executed they were

591
00:24:33,990 --> 00:24:36,540
wrapping synchronous code with promises

592
00:24:36,540 --> 00:24:38,610
thinking that that you know by

593
00:24:38,610 --> 00:24:40,020
sprinkling a little you know promise

594
00:24:40,020 --> 00:24:41,070
magic everything was going to be

595
00:24:41,070 --> 00:24:43,020
asynchronous or they're using it for

596
00:24:43,020 --> 00:24:45,030
convenience right you know hey if we're

597
00:24:45,030 --> 00:24:46,440
using promises one place we have to use

598
00:24:46,440 --> 00:24:48,990
promises everywhere that is a

599
00:24:48,990 --> 00:24:50,880
misconception about promises and if you

600
00:24:50,880 --> 00:24:54,030
continually abuse promises that way then

601
00:24:54,030 --> 00:24:55,710
your code is just gonna get slower and

602
00:24:55,710 --> 00:24:58,740
slower and slower because of the

603
00:24:58,740 --> 00:25:01,260
additional allocations of promise these

604
00:25:01,260 --> 00:25:03,240
objects and all these async up resources

605
00:25:03,240 --> 00:25:06,030
and all the scheduling overhead doesn't

606
00:25:06,030 --> 00:25:07,980
mean that your synchronous code is gonna

607
00:25:07,980 --> 00:25:13,220
run any faster okay so that's that's it

608
00:25:13,220 --> 00:25:15,570
because I just wanted to kind of peel

609
00:25:15,570 --> 00:25:16,710
and I'll peel back the curtain little

610
00:25:16,710 --> 00:25:18,870
bit how the event loop runs how these

611
00:25:18,870 --> 00:25:20,550
things work together and some of the

612
00:25:20,550 --> 00:25:21,870
tools you can use to start visualizing

613
00:25:21,870 --> 00:25:24,030
this stuff feel free

614
00:25:24,030 --> 00:25:26,850
reach out set up je a snow anywhere if

615
00:25:26,850 --> 00:25:27,840
you want to talk about some of this

616
00:25:27,840 --> 00:25:30,810
stuff need some more pointers on kind of

617
00:25:30,810 --> 00:25:32,580
how these things are going or you know

618
00:25:32,580 --> 00:25:34,320
how to make your node applications

619
00:25:34,320 --> 00:25:35,760
faster just reach out and let me know

620
00:25:35,760 --> 00:25:39,640
Thanks

