1
00:00:10,470 --> 00:00:21,570

I

2
00:00:21,580 --> 00:00:24,340
you

3
00:00:24,350 --> 00:00:26,690
hi I'm children I'm talking about

4
00:00:26,690 --> 00:00:29,360
regular expression and basically how to

5
00:00:29,360 --> 00:00:30,860
implement them in charl script so this

6
00:00:30,860 --> 00:00:33,800
is what i did i do a lot of projects

7
00:00:33,800 --> 00:00:36,080
like PDF chairs where you render pdfs in

8
00:00:36,080 --> 00:00:39,400
firefox or developer tools heck gecko

9
00:00:39,400 --> 00:00:41,600
member OpenStreetMap data in the browser

10
00:00:41,600 --> 00:00:44,120
but it is like my first real cyber check

11
00:00:44,120 --> 00:00:46,220
that I push to some kind of answer pre

12
00:00:46,220 --> 00:00:49,700
have to present this so somewhat of

13
00:00:49,700 --> 00:00:51,680
motivation why did this was like yeah

14
00:00:51,680 --> 00:00:53,870
you you know dislike regular expressions

15
00:00:53,870 --> 00:00:56,300
they are so small they're so cute but

16
00:00:56,300 --> 00:00:58,760
how many of you re find it painful to

17
00:00:58,760 --> 00:01:00,559
write them and takes hours he for you to

18
00:01:00,559 --> 00:01:03,110
read them yeah many hands in the air so

19
00:01:03,110 --> 00:01:05,300
this was like me so like yeah they look

20
00:01:05,300 --> 00:01:07,250
cute they are nice but they're they're

21
00:01:07,250 --> 00:01:10,220
they're really hard to get right so many

22
00:01:10,220 --> 00:01:12,200
people ask me why am i doing

23
00:01:12,200 --> 00:01:14,120
re-implementing this in Charles script

24
00:01:14,120 --> 00:01:17,570
well the reason was I want to be able to

25
00:01:17,570 --> 00:01:20,270
debug record expressions I want to write

26
00:01:20,270 --> 00:01:22,490
my own compiler in record in in

27
00:01:22,490 --> 00:01:24,049
transcript that basically compared to

28
00:01:24,049 --> 00:01:25,820
regular expression from transcript to

29
00:01:25,820 --> 00:01:27,590
JavaScript code again and want to

30
00:01:27,590 --> 00:01:29,990
present a chase come for you so it was

31
00:01:29,990 --> 00:01:32,450
like yeah my talk got accepted so ask

32
00:01:32,450 --> 00:01:35,060
you and then actually well now that

33
00:01:35,060 --> 00:01:36,890
means I got to get is working so that

34
00:01:36,890 --> 00:01:39,770
was the hard part but let's give a demo

35
00:01:39,770 --> 00:01:44,899
so this is what this is jay Furyk github

36
00:01:44,899 --> 00:01:48,109
I Oh Rach xjs you want to try it out so

37
00:01:48,109 --> 00:01:51,140
what we can do in the console is you

38
00:01:51,140 --> 00:01:55,609
know not only would do just new records

39
00:01:55,609 --> 00:01:59,780
a B then you would do regular expression

40
00:01:59,780 --> 00:02:02,600
execute foo AV and get something back

41
00:02:02,600 --> 00:02:06,880
and now what you can do do same thing

42
00:02:06,880 --> 00:02:11,460
just with the javascript implementation

43
00:02:11,470 --> 00:02:15,980
you so that works but what's cooler is

44
00:02:15,980 --> 00:02:18,620
am the debugger parts so here you can

45
00:02:18,620 --> 00:02:21,890
write your regular expression and you

46
00:02:21,890 --> 00:02:23,240
basically have some input and you see

47
00:02:23,240 --> 00:02:25,819
what matches so here you see what

48
00:02:25,819 --> 00:02:28,160
happens so at the top it it looks at a

49
00:02:28,160 --> 00:02:31,190
and B then tries to match a but that

50
00:02:31,190 --> 00:02:32,960
doesn't work because it's be so it goes

51
00:02:32,960 --> 00:02:35,960
back then it matches be and yeah that's

52
00:02:35,960 --> 00:02:38,090
successful that's pretty cool so

53
00:02:38,090 --> 00:02:40,640
try something more complex you see yeah

54
00:02:40,640 --> 00:02:42,349
that's that's not regular X so let's

55
00:02:42,349 --> 00:02:44,510
write a litte bit more cool thing is

56
00:02:44,510 --> 00:02:45,920
once you implement the regular

57
00:02:45,920 --> 00:02:48,110
expressions you are pretty good at

58
00:02:48,110 --> 00:02:51,950
writing them it turns out so it's like

59
00:02:51,950 --> 00:02:58,700
this and now we can do hello and you see

60
00:02:58,700 --> 00:03:01,819
matches in real yr there's a little bit

61
00:03:01,819 --> 00:03:04,700
to learn something so this is now what

62
00:03:04,700 --> 00:03:07,310
happens is like it tries to you know

63
00:03:07,310 --> 00:03:10,640
repeat this a few times so it matches aw

64
00:03:10,640 --> 00:03:13,130
machines the chapter it matches they

65
00:03:13,130 --> 00:03:15,620
tries next time and like are the column

66
00:03:15,620 --> 00:03:18,260
doesn't work so does back-trace now calm

67
00:03:18,260 --> 00:03:21,260
words it tries to match multiple em

68
00:03:21,260 --> 00:03:23,989
spaces so another space no no that's not

69
00:03:23,989 --> 00:03:26,420
a space anymore so got to backtrack okay

70
00:03:26,420 --> 00:03:28,299
now repeat the W yeah that's the word

71
00:03:28,299 --> 00:03:30,530
there's nothing else but yeah I'm all

72
00:03:30,530 --> 00:03:33,379
right on so that's it and what you also

73
00:03:33,379 --> 00:03:35,239
get is you get the results of your

74
00:03:35,239 --> 00:03:37,670
matches so you see the a and B are in

75
00:03:37,670 --> 00:03:39,769
groups you can share this to your

76
00:03:39,769 --> 00:03:41,540
friends so if they come along oh this is

77
00:03:41,540 --> 00:03:42,859
not matching you can fix it and give

78
00:03:42,859 --> 00:03:44,690
them the link again so it's basic just

79
00:03:44,690 --> 00:03:46,489
putting this in the hash you breathe on

80
00:03:46,489 --> 00:03:48,980
school and you also get a parse tree for

81
00:03:48,980 --> 00:03:50,750
basically the door directly expression

82
00:03:50,750 --> 00:03:52,700
there right up here so that's pretty

83
00:03:52,700 --> 00:03:58,579
cool so let's see how this works so this

84
00:03:58,579 --> 00:04:00,319
is like an overview of what I'm going to

85
00:04:00,319 --> 00:04:02,599
talk about so basically you're going to

86
00:04:02,599 --> 00:04:04,459
tell you a little bit how the past trees

87
00:04:04,459 --> 00:04:06,919
build how to internal node list works

88
00:04:06,919 --> 00:04:08,930
which is basically what amateur uses

89
00:04:08,930 --> 00:04:10,970
them to really go with string and see

90
00:04:10,970 --> 00:04:14,150
whether it matches on art and then about

91
00:04:14,150 --> 00:04:17,180
how to regular expression reg ex object

92
00:04:17,180 --> 00:04:19,820
itself a few things about it and then

93
00:04:19,820 --> 00:04:21,769
writing the chit and some conclusion

94
00:04:21,769 --> 00:04:27,169
stuff so let's talk about past 3am the

95
00:04:27,169 --> 00:04:29,419
parse tree basically in computer science

96
00:04:29,419 --> 00:04:31,729
means that if you have some string you

97
00:04:31,729 --> 00:04:33,169
give some rip em structured

98
00:04:33,169 --> 00:04:35,930
representation of that string and that

99
00:04:35,930 --> 00:04:38,360
structures described by a crammer rules

100
00:04:38,360 --> 00:04:40,700
in a high-level what we want to achieve

101
00:04:40,700 --> 00:04:43,070
is we have records that we put in we

102
00:04:43,070 --> 00:04:45,289
have a parser and it generates the

103
00:04:45,289 --> 00:04:48,110
posturing so let's take a look at an

104
00:04:48,110 --> 00:04:49,880
example so here we have this expression

105
00:04:49,880 --> 00:04:51,310
where you have

106
00:04:51,310 --> 00:04:53,650
OOP and then inside you have a B or C

107
00:04:53,650 --> 00:04:57,580
and if we will the past 3-4 this this

108
00:04:57,580 --> 00:04:59,920
looks likely so at the top we have group

109
00:04:59,920 --> 00:05:02,200
then we have this Junction because we

110
00:05:02,200 --> 00:05:04,900
have I a B or C then we have an

111
00:05:04,900 --> 00:05:06,640
alternative that means the can be

112
00:05:06,640 --> 00:05:08,800
multiple things following each other and

113
00:05:08,800 --> 00:05:10,450
then we have the character a and

114
00:05:10,450 --> 00:05:15,400
character p and as a set a B or C so we

115
00:05:15,400 --> 00:05:18,550
have the sea on the other side so this

116
00:05:18,550 --> 00:05:22,480
is what a parse tree looks like am the

117
00:05:22,480 --> 00:05:25,090
part of that I'd wrote it's completely

118
00:05:25,090 --> 00:05:28,180
handwritten I took a computer science

119
00:05:28,180 --> 00:05:30,130
class on compilers and that we used a

120
00:05:30,130 --> 00:05:33,010
generator and I was I'm still young so I

121
00:05:33,010 --> 00:05:34,570
thought well now write one my own my own

122
00:05:34,570 --> 00:05:36,640
and call a bit painful but you're gonna

123
00:05:36,640 --> 00:05:39,850
see there's only basic error handling

124
00:05:39,850 --> 00:05:42,610
which could be improved and the thing is

125
00:05:42,610 --> 00:05:45,040
that it uses regular expressions itself

126
00:05:45,040 --> 00:05:46,720
so it's kind of cheating that you write

127
00:05:46,720 --> 00:05:48,460
your regular expression parser for

128
00:05:48,460 --> 00:05:49,990
transcript which uses regular

129
00:05:49,990 --> 00:05:51,670
expressions from JavaScript again and

130
00:05:51,670 --> 00:05:55,470
but i hope i can just replace them with

131
00:05:55,470 --> 00:05:59,290
tractor off or compile my my own thing

132
00:05:59,290 --> 00:06:01,000
to a transcript function and use it

133
00:06:01,000 --> 00:06:04,810
there em but what I also try to do is

134
00:06:04,810 --> 00:06:07,420
for the past three that it emits that to

135
00:06:07,420 --> 00:06:09,910
contain useful information so for

136
00:06:09,910 --> 00:06:12,130
example if you have a regular expression

137
00:06:12,130 --> 00:06:15,100
like a bee or troop and they basically

138
00:06:15,100 --> 00:06:17,710
give back reference it's not obvious

139
00:06:17,710 --> 00:06:21,460
that / one means it is a reference for

140
00:06:21,460 --> 00:06:23,020
example if you would have a slash to

141
00:06:23,020 --> 00:06:25,180
there would not be such a group and you

142
00:06:25,180 --> 00:06:26,830
need to figure out what to do and the

143
00:06:26,830 --> 00:06:28,990
parts are already says the kid type is

144
00:06:28,990 --> 00:06:30,730
referenced so it's really reference and

145
00:06:30,730 --> 00:06:33,280
its reference group not one and you also

146
00:06:33,280 --> 00:06:35,650
got it from to that means where the

147
00:06:35,650 --> 00:06:37,540
characters starting and ending and it

148
00:06:37,540 --> 00:06:38,890
got this raw string which basically

149
00:06:38,890 --> 00:06:40,960
means okay this is part of pass three is

150
00:06:40,960 --> 00:06:45,130
this backslash one ok so now

151
00:06:45,130 --> 00:06:47,200
implementing the parcel was kind of fun

152
00:06:47,200 --> 00:06:49,060
because this is like the official

153
00:06:49,060 --> 00:06:51,070
grammar from the echamos back so try to

154
00:06:51,070 --> 00:06:52,840
follow this back so this is where it

155
00:06:52,840 --> 00:06:56,200
starts wait continues a little bit more

156
00:06:56,200 --> 00:06:59,200
and this is the final end so took me a

157
00:06:59,200 --> 00:07:01,960
little bit long to implement this but

158
00:07:01,960 --> 00:07:04,660
yet it's pretty working now um

159
00:07:04,660 --> 00:07:06,970
these are actually just the grammar

160
00:07:06,970 --> 00:07:09,250
rules for character classes it was a

161
00:07:09,250 --> 00:07:11,080
blog post complaining the directly

162
00:07:11,080 --> 00:07:15,460
expression grammar is so horrible it

163
00:07:15,460 --> 00:07:17,710
turns out that it got to be that like

164
00:07:17,710 --> 00:07:20,530
that way for this reason and for example

165
00:07:20,530 --> 00:07:23,710
if you have a regular expression where

166
00:07:23,710 --> 00:07:26,560
you have just a character arrange a ana

167
00:07:26,560 --> 00:07:29,290
minors that's an actual interpreted as

168
00:07:29,290 --> 00:07:32,950
you I've imagined a or minors so if you

169
00:07:32,950 --> 00:07:35,110
execute it against a minus sign that

170
00:07:35,110 --> 00:07:37,230
that actually results in something

171
00:07:37,230 --> 00:07:40,900
whereas if you have a minus B and you

172
00:07:40,900 --> 00:07:43,120
execute it against just a minus sign

173
00:07:43,120 --> 00:07:45,430
that doesn't match because it really

174
00:07:45,430 --> 00:07:47,140
means the ranges of characters between a

175
00:07:47,140 --> 00:07:52,390
and B and but so you you see you need to

176
00:07:52,390 --> 00:07:54,370
keep some kind of track or state whether

177
00:07:54,370 --> 00:07:56,530
you have a minus and something following

178
00:07:56,530 --> 00:07:58,360
or you have a minus and actually

179
00:07:58,360 --> 00:08:00,250
character following but we have a

180
00:08:00,250 --> 00:08:02,590
context-free grammar here so there's no

181
00:08:02,590 --> 00:08:05,110
real way to encode a state and their own

182
00:08:05,110 --> 00:08:06,790
way to encode estate is to have more

183
00:08:06,790 --> 00:08:08,980
grammar rules and that's why disposed up

184
00:08:08,980 --> 00:08:13,390
such horrible a lot um someone's on a

185
00:08:13,390 --> 00:08:16,360
passer so um I think looking back I

186
00:08:16,360 --> 00:08:17,860
might should have used the parser

187
00:08:17,860 --> 00:08:20,530
generator which would have made more

188
00:08:20,530 --> 00:08:22,900
errors and more bear error messages and

189
00:08:22,900 --> 00:08:26,500
also helped me too yep tube to choose

190
00:08:26,500 --> 00:08:30,340
right mmm easily I try to read follow

191
00:08:30,340 --> 00:08:32,410
this back as close as possible but their

192
00:08:32,410 --> 00:08:34,690
thumbs things they're not in the specs

193
00:08:34,690 --> 00:08:37,510
for example or I'm a transcript engine

194
00:08:37,510 --> 00:08:39,400
directly expression down there which is

195
00:08:39,400 --> 00:08:41,110
the closing brackets it's valid where's

196
00:08:41,110 --> 00:08:43,990
there's no such rule in the grammar and

197
00:08:43,990 --> 00:08:47,970
passing numbers is pretty interesting um

198
00:08:47,970 --> 00:08:51,520
so this is in the parts that smell

199
00:08:51,520 --> 00:08:53,710
expression so as I already said if you

200
00:08:53,710 --> 00:08:56,260
have like two truths any of them as / to

201
00:08:56,260 --> 00:08:59,200
that meetings a reference for sure but

202
00:08:59,200 --> 00:09:01,210
what if you have number that's not a

203
00:09:01,210 --> 00:09:04,240
reference and so actually turns out if

204
00:09:04,240 --> 00:09:06,280
it's an actual number you got to

205
00:09:06,280 --> 00:09:09,520
interpret this like you got to do ya get

206
00:09:09,520 --> 00:09:11,350
an actual number and then use a string

207
00:09:11,350 --> 00:09:13,360
character off to represent what

208
00:09:13,360 --> 00:09:15,730
characters should match against if it's

209
00:09:15,730 --> 00:09:17,850
not an octal number

210
00:09:17,850 --> 00:09:19,170
just interpret the number basically

211
00:09:19,170 --> 00:09:22,440
without a backslash but at least in v8 a

212
00:09:22,440 --> 00:09:24,120
spider monkey does something different

213
00:09:24,120 --> 00:09:26,459
it was took me some hours to get these

214
00:09:26,459 --> 00:09:29,940
small details right but it's now passing

215
00:09:29,940 --> 00:09:33,750
all the tests okay so now that we have

216
00:09:33,750 --> 00:09:36,600
to parse tree and we're looking at the

217
00:09:36,600 --> 00:09:38,250
node list which is basically you think

218
00:09:38,250 --> 00:09:40,470
that match uses to execute against

219
00:09:40,470 --> 00:09:43,079
regular expression and so we convert

220
00:09:43,079 --> 00:09:45,540
parse tree to note list and stave

221
00:09:45,540 --> 00:09:47,639
structure for the matter so simple

222
00:09:47,639 --> 00:09:50,100
example is if you have red X a and B

223
00:09:50,100 --> 00:09:53,490
this looks like maybe you have a node of

224
00:09:53,490 --> 00:09:57,060
type care character with data a then you

225
00:09:57,060 --> 00:09:59,699
have one of em thay to be and then

226
00:09:59,699 --> 00:10:02,069
basically you you are done so that's it

227
00:10:02,069 --> 00:10:05,040
a little bit more complicated example is

228
00:10:05,040 --> 00:10:07,589
like this if you have like a crouppen

229
00:10:07,589 --> 00:10:09,720
which repeats multiple times and then

230
00:10:09,720 --> 00:10:12,180
followed by see that's internal

231
00:10:12,180 --> 00:10:14,069
represented by you have a repeat block

232
00:10:14,069 --> 00:10:17,009
which has a certain ID and you specify

233
00:10:17,009 --> 00:10:19,560
how how much or how less you want to

234
00:10:19,560 --> 00:10:22,439
match so it starts minimum 0 times and

235
00:10:22,439 --> 00:10:25,620
I'm finding any times you want so then

236
00:10:25,620 --> 00:10:28,589
you have a new node basic saying this

237
00:10:28,589 --> 00:10:31,800
should be the begin croup success okay

238
00:10:31,800 --> 00:10:34,110
here are starting the first index then

239
00:10:34,110 --> 00:10:35,610
you have an alternative because you have

240
00:10:35,610 --> 00:10:38,430
a B or C again so you have to character

241
00:10:38,430 --> 00:10:40,920
a B and character c then you have a

242
00:10:40,920 --> 00:10:43,350
drawing point and then you have a hand

243
00:10:43,350 --> 00:10:44,759
croup stitch that you can say ok when I

244
00:10:44,759 --> 00:10:47,100
can't pass along here I ended this group

245
00:10:47,100 --> 00:10:49,380
so this is the sub sub match that should

246
00:10:49,380 --> 00:10:52,380
track then you go to repeat again and

247
00:10:52,380 --> 00:10:55,110
then I we could go there or if you

248
00:10:55,110 --> 00:10:57,050
follow the sea and then you're done and

249
00:10:57,050 --> 00:11:01,110
this is the thing in brackets is now

250
00:11:01,110 --> 00:11:03,389
basically the a B or C that we've seen

251
00:11:03,389 --> 00:11:05,610
before and you see that from the parse

252
00:11:05,610 --> 00:11:08,250
tree to this representation yet from at

253
00:11:08,250 --> 00:11:11,069
least for me it's way more obvious how

254
00:11:11,069 --> 00:11:13,319
maybe the matter going to walk around is

255
00:11:13,319 --> 00:11:18,209
mmm and I'd like industry structure ok

256
00:11:18,209 --> 00:11:22,589
so then others they look pretty

257
00:11:22,589 --> 00:11:25,410
complicated to build but actually is

258
00:11:25,410 --> 00:11:27,990
it's easy to do if you do some kind of

259
00:11:27,990 --> 00:11:29,760
walking of our past 3 which is pretty

260
00:11:29,760 --> 00:11:30,760
calm for compiled

261
00:11:30,760 --> 00:11:33,970
technics and then you just bind one node

262
00:11:33,970 --> 00:11:39,610
after the other um so 11 side story for

263
00:11:39,610 --> 00:11:42,280
NOC list so there is this backslash s

264
00:11:42,280 --> 00:11:44,320
which basically and matches whitespace

265
00:11:44,320 --> 00:11:46,930
all line terminators and if you look up

266
00:11:46,930 --> 00:11:51,220
the white spaces it it says basically

267
00:11:51,220 --> 00:11:53,530
what you what you should match the like

268
00:11:53,530 --> 00:11:55,480
tabs vertical tabs and then the last

269
00:11:55,480 --> 00:11:58,410
point any other unicode space separator

270
00:11:58,410 --> 00:12:01,900
so huh yeah that's that's hard to get

271
00:12:01,900 --> 00:12:03,820
right right but the cool thing is

272
00:12:03,820 --> 00:12:06,160
there's a springer and people ready to

273
00:12:06,160 --> 00:12:08,320
chop there so i just copied the function

274
00:12:08,320 --> 00:12:11,350
from there that's how i got lucky and

275
00:12:11,350 --> 00:12:13,690
that's also the reason why i basically

276
00:12:13,690 --> 00:12:17,830
license records as records jsps dean and

277
00:12:17,830 --> 00:12:20,830
to be compatible with s premar and also

278
00:12:20,830 --> 00:12:22,300
that maybe there can be some code

279
00:12:22,300 --> 00:12:26,440
exchange good so next I want to talk

280
00:12:26,440 --> 00:12:28,300
about a mattress so the matter is really

281
00:12:28,300 --> 00:12:30,130
think that basic tastes directly

282
00:12:30,130 --> 00:12:31,810
expression representation and the input

283
00:12:31,810 --> 00:12:34,450
string and tells you what parts matches

284
00:12:34,450 --> 00:12:42,010
and or if not um the way it works is

285
00:12:42,010 --> 00:12:44,290
basically passing two arguments so you

286
00:12:44,290 --> 00:12:45,820
have something like a state which is

287
00:12:45,820 --> 00:12:47,920
your string and where your string your

288
00:12:47,920 --> 00:12:49,780
are you what are you matches and also to

289
00:12:49,780 --> 00:12:51,940
trace a steady recorded and the notice

290
00:12:51,940 --> 00:12:54,520
that we're selling before and it tries

291
00:12:54,520 --> 00:12:57,940
to do all kind of possible matches to

292
00:12:57,940 --> 00:13:00,340
draw it till he finds 10 it says well

293
00:13:00,340 --> 00:13:02,920
there's no other way way and the way of

294
00:13:02,920 --> 00:13:05,920
this I try something and if it fails I

295
00:13:05,920 --> 00:13:08,560
just backtrack it's done by am calling

296
00:13:08,560 --> 00:13:12,250
the mat recursively and if if it's

297
00:13:12,250 --> 00:13:13,630
raised faith so if it tries to do

298
00:13:13,630 --> 00:13:15,010
something is as well I kind of continue

299
00:13:15,010 --> 00:13:17,320
here the function just returns and the

300
00:13:17,320 --> 00:13:19,810
outer function try something else so

301
00:13:19,810 --> 00:13:23,260
here's an example how does the word we

302
00:13:23,260 --> 00:13:24,850
started with this day which is basically

303
00:13:24,850 --> 00:13:28,360
our input string ABC and now we try to

304
00:13:28,360 --> 00:13:30,490
match that against this regular

305
00:13:30,490 --> 00:13:32,590
expression so we're there we have like

306
00:13:32,590 --> 00:13:34,660
our input string and down there is like

307
00:13:34,660 --> 00:13:37,390
this node list representation that I've

308
00:13:37,390 --> 00:13:41,560
built before m and now what it does is

309
00:13:41,560 --> 00:13:43,630
it looks at first character so that's

310
00:13:43,630 --> 00:13:44,170
eight

311
00:13:44,170 --> 00:13:46,470
that looks good so moves to next one and

312
00:13:46,470 --> 00:13:48,940
now it has the option either to match B

313
00:13:48,940 --> 00:13:52,540
or C so it chooses ok I choose the first

314
00:13:52,540 --> 00:13:55,180
one and before it goes into dirt makes a

315
00:13:55,180 --> 00:13:57,040
clone of the current state so we are

316
00:13:57,040 --> 00:14:01,329
talking about s prime now so we said

317
00:14:01,329 --> 00:14:04,410
test be yep that's good so we move to d

318
00:14:04,410 --> 00:14:07,839
which st up the works basically we ran

319
00:14:07,839 --> 00:14:11,680
the file so we are done so if that

320
00:14:11,680 --> 00:14:13,870
doesn't work because you know the first

321
00:14:13,870 --> 00:14:16,149
option is not working and it looks like

322
00:14:16,149 --> 00:14:20,760
this so we have the same thing again we

323
00:14:20,760 --> 00:14:24,850
come here we try to match be and we

324
00:14:24,850 --> 00:14:26,589
cloned this but actually this time it

325
00:14:26,589 --> 00:14:27,850
doesn't work because we have to see at

326
00:14:27,850 --> 00:14:29,500
that position so what we do we do

327
00:14:29,500 --> 00:14:31,750
backtracking and so we jump out the

328
00:14:31,750 --> 00:14:35,579
function we try to match see this time

329
00:14:35,579 --> 00:14:38,620
with another so it is also another clone

330
00:14:38,620 --> 00:14:43,870
state as double Prime we try to match ok

331
00:14:43,870 --> 00:14:45,370
now my slides another in right officer

332
00:14:45,370 --> 00:14:48,190
so we do we test where the sea works

333
00:14:48,190 --> 00:14:52,540
against that thing it does we try that

334
00:14:52,540 --> 00:14:58,350
works and we are done again ok um and

335
00:14:58,350 --> 00:15:00,610
while we're doing this we are also

336
00:15:00,610 --> 00:15:02,560
recording this trace information that's

337
00:15:02,560 --> 00:15:04,540
basically used for the debugger that

338
00:15:04,540 --> 00:15:06,370
it's all before that you can see where

339
00:15:06,370 --> 00:15:08,290
is due back dragging in what part is

340
00:15:08,290 --> 00:15:11,709
matching and there are some pitfalls if

341
00:15:11,709 --> 00:15:13,690
you implement this matter so one thing

342
00:15:13,690 --> 00:15:17,769
that came across is basically if you if

343
00:15:17,769 --> 00:15:19,750
you have a loop when you go back and you

344
00:15:19,750 --> 00:15:22,089
get to reset all the mattress that you

345
00:15:22,089 --> 00:15:25,660
did before so example and the the crew p

346
00:15:25,660 --> 00:15:30,430
if you loop the outer ABC once more you

347
00:15:30,430 --> 00:15:34,120
got to reset the inner group for be ok

348
00:15:34,120 --> 00:15:36,339
that's that someone were the inspectors

349
00:15:36,339 --> 00:15:38,380
but you also need to reset the count of

350
00:15:38,380 --> 00:15:40,660
four to be so there was back there

351
00:15:40,660 --> 00:15:43,329
basically of the first time ABC matches

352
00:15:43,329 --> 00:15:46,029
it would still not reset the counter for

353
00:15:46,029 --> 00:15:48,430
this be in a group and then just tries

354
00:15:48,430 --> 00:15:51,220
to con new matching a and plus one piece

355
00:15:51,220 --> 00:15:53,829
next time which didn't work also you

356
00:15:53,829 --> 00:15:55,959
have two problems with infinity loops so

357
00:15:55,959 --> 00:15:57,510
for example the expression

358
00:15:57,510 --> 00:15:59,550
they're busy you could say while it's

359
00:15:59,550 --> 00:16:02,310
just trying to match as many times an

360
00:16:02,310 --> 00:16:04,620
empty string which is basically infinity

361
00:16:04,620 --> 00:16:09,630
match but yeah the all the ancients just

362
00:16:09,630 --> 00:16:12,570
match the a and directly so you need to

363
00:16:12,570 --> 00:16:13,920
have some loop protection which you can

364
00:16:13,920 --> 00:16:16,560
do pretty easily by just saying well if

365
00:16:16,560 --> 00:16:19,050
you came and come here once more in this

366
00:16:19,050 --> 00:16:20,910
kind of loop or this repetition and

367
00:16:20,910 --> 00:16:22,800
there was no process you say okay then I

368
00:16:22,800 --> 00:16:24,930
just do the other way and don't go into

369
00:16:24,930 --> 00:16:29,730
group anymore okay so now we have we

370
00:16:29,730 --> 00:16:31,590
have liked you can pass in a regular

371
00:16:31,590 --> 00:16:33,810
expression and then you basically can

372
00:16:33,810 --> 00:16:35,670
build the past three we have to make

373
00:16:35,670 --> 00:16:38,100
sure but what you want to use expose

374
00:16:38,100 --> 00:16:40,110
some object that looks like the building

375
00:16:40,110 --> 00:16:41,670
regular expression to the user that you

376
00:16:41,670 --> 00:16:43,530
can play with it so it's about building

377
00:16:43,530 --> 00:16:46,350
the records J as object that you've seen

378
00:16:46,350 --> 00:16:49,380
before so it has just these two

379
00:16:49,380 --> 00:16:51,420
functions execute and test you could

380
00:16:51,420 --> 00:16:53,690
also think about string prototype em

381
00:16:53,690 --> 00:16:57,000
match etc but I said that's out of scope

382
00:16:57,000 --> 00:16:58,650
of this project so just concentrate on

383
00:16:58,650 --> 00:17:01,440
these two functions and that's

384
00:17:01,440 --> 00:17:06,020
repetition where we already did em and

385
00:17:06,020 --> 00:17:08,400
maybe it's you know the first attempt

386
00:17:08,400 --> 00:17:10,890
will be that it's I mean that looks

387
00:17:10,890 --> 00:17:13,589
pretty simple to rewrite just if you

388
00:17:13,589 --> 00:17:15,690
have something like execute it just take

389
00:17:15,690 --> 00:17:18,510
the regular expressions thing and you

390
00:17:18,510 --> 00:17:21,120
parse it you build a note list and then

391
00:17:21,120 --> 00:17:23,100
you just throw that a matter and see

392
00:17:23,100 --> 00:17:25,589
what comes back but it turns out that's

393
00:17:25,589 --> 00:17:27,600
not want to send the right thing to do

394
00:17:27,600 --> 00:17:30,930
and because down there as you see the

395
00:17:30,930 --> 00:17:32,310
first regular expression works fine

396
00:17:32,310 --> 00:17:34,740
Boston butter the last one doesn't and

397
00:17:34,740 --> 00:17:38,610
the reason is the ABC can match at an

398
00:17:38,610 --> 00:17:40,380
arbitrary position so it doesn't have to

399
00:17:40,380 --> 00:17:42,480
measure the first one but the first

400
00:17:42,480 --> 00:17:44,670
implementation just didn't you know

401
00:17:44,670 --> 00:17:47,280
looked at anything with a certain offset

402
00:17:47,280 --> 00:17:49,710
from the beginning so how could that be

403
00:17:49,710 --> 00:17:53,280
fixed so the easy fix is to do some kind

404
00:17:53,280 --> 00:17:57,060
of fake loop and so if we have ABC you

405
00:17:57,060 --> 00:17:58,710
just could convert that regular

406
00:17:58,710 --> 00:18:01,200
expression to basically say well try to

407
00:18:01,200 --> 00:18:05,610
match as as less possible any characters

408
00:18:05,610 --> 00:18:08,340
and then the ABC following and also Duke

409
00:18:08,340 --> 00:18:10,559
roofing around such that you recall

410
00:18:10,559 --> 00:18:13,919
where we actually did a match turns out

411
00:18:13,919 --> 00:18:18,779
the worse so where's the problem is you

412
00:18:18,779 --> 00:18:20,789
end up with a lot of recursion in this

413
00:18:20,789 --> 00:18:23,009
case because every time you do this kind

414
00:18:23,009 --> 00:18:25,320
of match something at the beginning this

415
00:18:25,320 --> 00:18:27,509
means another function call the way the

416
00:18:27,509 --> 00:18:29,610
mattress interpreted and for long

417
00:18:29,610 --> 00:18:33,570
strange we hit the v8 maximum function

418
00:18:33,570 --> 00:18:37,379
called stack size so the implementation

419
00:18:37,379 --> 00:18:41,070
that I did later was reaches don't start

420
00:18:41,070 --> 00:18:42,899
at the first precision or started first

421
00:18:42,899 --> 00:18:44,730
pictures and if this doesn't work move

422
00:18:44,730 --> 00:18:47,309
to the next position plus one and then

423
00:18:47,309 --> 00:18:50,940
do it um are things there for regular

424
00:18:50,940 --> 00:18:53,909
expressions are flags and so there's the

425
00:18:53,909 --> 00:18:56,159
multi-line flag that you can pass to and

426
00:18:56,159 --> 00:18:59,940
that only affects the assertions for the

427
00:18:59,940 --> 00:19:01,379
beginning and the end of regular

428
00:19:01,379 --> 00:19:03,029
expressions and they are pretty simple

429
00:19:03,029 --> 00:19:04,860
to get right that if you have a new line

430
00:19:04,860 --> 00:19:06,509
before after it should also match

431
00:19:06,509 --> 00:19:09,259
there's a global match which basically

432
00:19:09,259 --> 00:19:11,549
means you should repeat the next time

433
00:19:11,549 --> 00:19:14,039
for another precision that's also KH to

434
00:19:14,039 --> 00:19:16,740
implement the tomorrow hard part is

435
00:19:16,740 --> 00:19:20,669
ignore case so trivial implementation my

436
00:19:20,669 --> 00:19:23,429
idea might be jet you just take the

437
00:19:23,429 --> 00:19:25,409
input strings and your regular

438
00:19:25,409 --> 00:19:26,909
expression is just do upper case and

439
00:19:26,909 --> 00:19:30,299
then see where the character matches but

440
00:19:30,299 --> 00:19:32,399
actually this back specifies it's not

441
00:19:32,399 --> 00:19:34,619
just a to upper string conversation

442
00:19:34,619 --> 00:19:36,600
there are also some other small things

443
00:19:36,600 --> 00:19:38,340
that you get to watch out to for example

444
00:19:38,340 --> 00:19:39,960
if you do an upper string on the

445
00:19:39,960 --> 00:19:42,720
character or on the individual character

446
00:19:42,720 --> 00:19:45,119
if it ends up to be two characters

447
00:19:45,119 --> 00:19:47,340
afterwards you just use the the previous

448
00:19:47,340 --> 00:19:50,159
one and before doing the upper space so

449
00:19:50,159 --> 00:19:52,619
you need to apply a different kind of

450
00:19:52,619 --> 00:19:55,379
function and also you have fun with with

451
00:19:55,379 --> 00:19:57,749
ranges because if you have arranged a

452
00:19:57,749 --> 00:20:01,200
two curly brace and you do this ignore

453
00:20:01,200 --> 00:20:03,690
em case operation where you basically

454
00:20:03,690 --> 00:20:06,059
transform into upper case and you only

455
00:20:06,059 --> 00:20:08,549
want the a two-set good to go upper case

456
00:20:08,549 --> 00:20:11,159
and the other m characters to stay the

457
00:20:11,159 --> 00:20:15,929
same so this is um yep

458
00:20:15,929 --> 00:20:19,230
and well they're basically more fun to

459
00:20:19,230 --> 00:20:21,779
this so and the specs is there for all

460
00:20:21,779 --> 00:20:23,909
the input stuff you need to call what

461
00:20:23,909 --> 00:20:26,100
internal defined to strain into number

462
00:20:26,100 --> 00:20:29,490
functions so um here we have an example

463
00:20:29,490 --> 00:20:31,830
where we define the string as an object

464
00:20:31,830 --> 00:20:33,379
with two string function which returns

465
00:20:33,379 --> 00:20:37,200
false and we try to execute it against

466
00:20:37,200 --> 00:20:42,570
LS with an ignore case reg ex so does

467
00:20:42,570 --> 00:20:52,049
anybody know what this returns yeah

468
00:20:52,049 --> 00:20:55,499
match is good and so it returns LS and

469
00:20:55,499 --> 00:20:58,470
basically because it says the string you

470
00:20:58,470 --> 00:21:00,240
called the two string function which

471
00:21:00,240 --> 00:21:02,249
then returns false which is booting

472
00:21:02,249 --> 00:21:03,840
where you call the two string function

473
00:21:03,840 --> 00:21:06,299
again so you get false as a string and

474
00:21:06,299 --> 00:21:09,480
then you match again against the LS and

475
00:21:09,480 --> 00:21:13,070
then you you end up with two LS so

476
00:21:13,070 --> 00:21:15,419
that's the small things to get right

477
00:21:15,419 --> 00:21:21,409
there is the what I got nine minutes

478
00:21:21,409 --> 00:21:25,679
yeah and so but there's there's luckily

479
00:21:25,679 --> 00:21:28,409
a good test you from Acme script and

480
00:21:28,409 --> 00:21:31,350
we're where we try to get all five

481
00:21:31,350 --> 00:21:32,970
hundred and more tests passing and then

482
00:21:32,970 --> 00:21:36,450
you get all the small pitfalls um so

483
00:21:36,450 --> 00:21:38,730
yeah there's this wreck it xjo object

484
00:21:38,730 --> 00:21:40,649
got a little bit bigger it's 240 the

485
00:21:40,649 --> 00:21:44,490
lines of code so it was not as trivial

486
00:21:44,490 --> 00:21:46,740
but if you're working so now we come to

487
00:21:46,740 --> 00:21:49,080
to my favorite part to cheat compiler

488
00:21:49,080 --> 00:21:51,480
and so a lot of compilers and our life

489
00:21:51,480 --> 00:21:55,230
treats so um so no you what what we want

490
00:21:55,230 --> 00:21:56,639
to do is basically we take a regular

491
00:21:56,639 --> 00:21:58,619
expression and we really want to omit

492
00:21:58,619 --> 00:22:00,899
trial script code itself and so this

493
00:22:00,899 --> 00:22:02,700
means we're in wilmette a regular

494
00:22:02,700 --> 00:22:04,529
expression in a child scrip

495
00:22:04,529 --> 00:22:09,059
which just by that self is like a um the

496
00:22:09,059 --> 00:22:10,559
idea is that we can match the input

497
00:22:10,559 --> 00:22:13,769
stream faster or the input string faster

498
00:22:13,769 --> 00:22:17,009
by using finite state machines we all

499
00:22:17,009 --> 00:22:19,259
also support just a subset of Recca

500
00:22:19,259 --> 00:22:21,779
expression em to make our life easier

501
00:22:21,779 --> 00:22:24,179
but hopefully that gives us faster and

502
00:22:24,179 --> 00:22:28,470
more efficient matches um so for example

503
00:22:28,470 --> 00:22:31,919
I said well I support all features but I

504
00:22:31,919 --> 00:22:33,720
don't support group matches because it's

505
00:22:33,720 --> 00:22:35,220
a little bit hard to get right into the

506
00:22:35,220 --> 00:22:37,770
fa m no back reference and only 3d

507
00:22:37,770 --> 00:22:40,679
repetitions and there's also a lot of

508
00:22:40,679 --> 00:22:42,870
stuff missing because I just did their

509
00:22:42,870 --> 00:22:44,880
entire two implementations in three

510
00:22:44,880 --> 00:22:46,980
evening hacks so it's still under

511
00:22:46,980 --> 00:22:49,710
construction and that was is one thing

512
00:22:49,710 --> 00:22:51,299
wherever you want to get things right am

513
00:22:51,299 --> 00:22:53,610
done pretty fast so I just wrote this

514
00:22:53,610 --> 00:22:55,770
one line without any new returns in

515
00:22:55,770 --> 00:22:57,570
there just how you get really fast with

516
00:22:57,570 --> 00:23:00,570
that and it's also reminds me of code

517
00:23:00,570 --> 00:23:03,120
mirror in my yin how he writes code and

518
00:23:03,120 --> 00:23:05,309
there's some good thing to you that I

519
00:23:05,309 --> 00:23:08,429
got my leg I've noticed so let's let's

520
00:23:08,429 --> 00:23:09,929
see how does this should work so

521
00:23:09,929 --> 00:23:12,830
internally we create an NFA and DF a.m

522
00:23:12,830 --> 00:23:16,440
who knows about what that stands for and

523
00:23:16,440 --> 00:23:20,159
what it is okay only few people so try

524
00:23:20,159 --> 00:23:22,350
to go slow so if we have a regular

525
00:23:22,350 --> 00:23:25,679
expression A and B am in an NF a I

526
00:23:25,679 --> 00:23:27,510
explain what its lair but it's more

527
00:23:27,510 --> 00:23:30,000
confusing if I tell you so that looks

528
00:23:30,000 --> 00:23:31,860
like this so you have a big inning

529
00:23:31,860 --> 00:23:33,720
stayed with the zero you have a

530
00:23:33,720 --> 00:23:35,669
transition a which means if there is a

531
00:23:35,669 --> 00:23:37,320
character a matching in the state you go

532
00:23:37,320 --> 00:23:39,659
to one if there's a be matching good too

533
00:23:39,659 --> 00:23:42,630
and whatever there is which is a signal

534
00:23:42,630 --> 00:23:44,039
for light by this epsilon you can just

535
00:23:44,039 --> 00:23:45,809
go to end state and the end states are

536
00:23:45,809 --> 00:23:47,700
with this college so if you have

537
00:23:47,700 --> 00:23:50,240
something more complicated a B or B um

538
00:23:50,240 --> 00:23:52,710
it looks like this you can go from the

539
00:23:52,710 --> 00:23:54,960
first one you can't go to first Ephram

540
00:23:54,960 --> 00:23:57,600
from zero state go to first or third and

541
00:23:57,600 --> 00:24:00,360
then I've there's be I got for the

542
00:24:00,360 --> 00:24:02,429
fourth one the problem with this and if

543
00:24:02,429 --> 00:24:04,549
a thing is you have London

544
00:24:04,549 --> 00:24:07,830
non-deterministic and because for the

545
00:24:07,830 --> 00:24:08,909
first one you don't know where you

546
00:24:08,909 --> 00:24:12,299
should go to stay one or two or three so

547
00:24:12,299 --> 00:24:14,909
in DFA you solve this and basically say

548
00:24:14,909 --> 00:24:17,159
ok the it's a bit more complicated but

549
00:24:17,159 --> 00:24:20,580
am basically you true the transitions

550
00:24:20,580 --> 00:24:22,919
that are the same and in this case you

551
00:24:22,919 --> 00:24:24,600
come up with that you could do a

552
00:24:24,600 --> 00:24:26,970
transition by a and then you're in final

553
00:24:26,970 --> 00:24:28,830
state or if there's be you go and also

554
00:24:28,830 --> 00:24:30,330
go to another state where is the final

555
00:24:30,330 --> 00:24:34,470
state um so the implementation basically

556
00:24:34,470 --> 00:24:38,309
dust is it converts direct object to non

557
00:24:38,309 --> 00:24:40,289
deterministic final automator which is

558
00:24:40,289 --> 00:24:41,480
what NFA stands

559
00:24:41,480 --> 00:24:43,490
or use that you turn it into

560
00:24:43,490 --> 00:24:45,860
deterministic finite automata and then

561
00:24:45,860 --> 00:24:47,929
there's a code generator which ria emits

562
00:24:47,929 --> 00:24:50,240
javascript code so this is the

563
00:24:50,240 --> 00:24:54,880
javascript code that emits for a or b so

564
00:24:54,880 --> 00:24:57,679
it's like an outer loop and then we have

565
00:24:57,679 --> 00:25:00,380
this state zeros the one instead two and

566
00:25:00,380 --> 00:25:03,080
there are these transitions in there and

567
00:25:03,080 --> 00:25:05,960
if the character first time is a it does

568
00:25:05,960 --> 00:25:07,820
the transition to stay one if it's Abby

569
00:25:07,820 --> 00:25:13,220
it goes to second one m and the alphabet

570
00:25:13,220 --> 00:25:16,220
for this one is a be so the alphabet

571
00:25:16,220 --> 00:25:18,620
means what characters are used in this

572
00:25:18,620 --> 00:25:22,429
to describe the decisions m and I was

573
00:25:22,429 --> 00:25:24,380
wondering when this could be a little

574
00:25:24,380 --> 00:25:27,140
bit optimized for example if you think

575
00:25:27,140 --> 00:25:29,720
about re huge character ranges you would

576
00:25:29,720 --> 00:25:32,630
have to add all the transitions for

577
00:25:32,630 --> 00:25:36,890
character a to unicode 777 so maybe

578
00:25:36,890 --> 00:25:39,530
there is a better solution and I just

579
00:25:39,530 --> 00:25:41,000
because I'm running out of time going to

580
00:25:41,000 --> 00:25:42,830
briefly what I did was introducing

581
00:25:42,830 --> 00:25:46,400
alphabet classes so the basic idea is

582
00:25:46,400 --> 00:25:48,740
like this if if we have something like

583
00:25:48,740 --> 00:25:51,290
sea air weapon Rekha expression with 0

584
00:25:51,290 --> 00:25:54,200
and then 1 29 it looks like okay we have

585
00:25:54,200 --> 00:25:56,630
one transition from 0 to 1 state and

586
00:25:56,630 --> 00:26:00,260
then from the 129 stay at from the 12

587
00:26:00,260 --> 00:26:02,270
Tuesday we have a transitions for

588
00:26:02,270 --> 00:26:05,030
characters 129 so our alphabet goes from

589
00:26:05,030 --> 00:26:08,690
0 to 1 29 and but this looks pretty

590
00:26:08,690 --> 00:26:11,270
similar to at the transition that we

591
00:26:11,270 --> 00:26:14,360
have before with 0 a 0 then we have an a

592
00:26:14,360 --> 00:26:16,250
we go to one and then from there we can

593
00:26:16,250 --> 00:26:19,070
do be into this to second one so which

594
00:26:19,070 --> 00:26:22,309
is basically say okay our a is 0 and b

595
00:26:22,309 --> 00:26:24,260
is everything from one to nine and then

596
00:26:24,260 --> 00:26:26,540
we basically and make it a little bit

597
00:26:26,540 --> 00:26:29,870
yep the alphabet easier again now in a

598
00:26:29,870 --> 00:26:32,330
more complicated setup basically if you

599
00:26:32,330 --> 00:26:34,669
have more complicated you think about a

600
00:26:34,669 --> 00:26:37,610
number line you basically you think out

601
00:26:37,610 --> 00:26:40,040
what are the intersections and then you

602
00:26:40,040 --> 00:26:43,309
come up with your alphabet again so this

603
00:26:43,309 --> 00:26:46,100
is what basically apply to regular

604
00:26:46,100 --> 00:26:48,470
expression this looks like up there you

605
00:26:48,470 --> 00:26:51,020
have many transitions for a two E and C

606
00:26:51,020 --> 00:26:52,909
to set and down there you only have two

607
00:26:52,909 --> 00:26:54,620
transitions per each branch

608
00:26:54,620 --> 00:26:57,320
so it makes a little bit easier so now

609
00:26:57,320 --> 00:26:58,850
the question is if you read cheat code

610
00:26:58,850 --> 00:27:00,350
that's good about how good is it

611
00:27:00,350 --> 00:27:01,970
actually interpreting JavaScript engine

612
00:27:01,970 --> 00:27:03,890
so I talked to Tom Shuster who's on the

613
00:27:03,890 --> 00:27:05,450
spider monkey team for Firefox about

614
00:27:05,450 --> 00:27:10,070
this and he basically put this in a

615
00:27:10,070 --> 00:27:11,900
while loop and hit it against Iron

616
00:27:11,900 --> 00:27:14,330
Monkey and see how good it is and yeah

617
00:27:14,330 --> 00:27:15,590
so this is like the internal

618
00:27:15,590 --> 00:27:17,210
representation and what he said well

619
00:27:17,210 --> 00:27:18,830
this is a little bit branchy it's not

620
00:27:18,830 --> 00:27:23,240
good so we yeah maybe we're meeting up

621
00:27:23,240 --> 00:27:24,770
in Brussels and work on this and

622
00:27:24,770 --> 00:27:26,750
hopefully we get something that's not

623
00:27:26,750 --> 00:27:28,670
that branching that's actually really

624
00:27:28,670 --> 00:27:30,110
tight loops and then get better

625
00:27:30,110 --> 00:27:32,390
performance but as said it's it's really

626
00:27:32,390 --> 00:27:35,750
under construction so closing up now and

627
00:27:35,750 --> 00:27:38,720
what are what is there to do em so they

628
00:27:38,720 --> 00:27:42,140
need some code cleanup to be done the

629
00:27:42,140 --> 00:27:43,840
cheese is still under construction and

630
00:27:43,840 --> 00:27:47,150
also once you have like the same parser

631
00:27:47,150 --> 00:27:49,040
and traversal API like in this primer

632
00:27:49,040 --> 00:27:51,230
that people can deal with regular

633
00:27:51,230 --> 00:27:55,370
expressions easily so status of project

634
00:27:55,370 --> 00:27:57,200
the matter works against all tests is

635
00:27:57,200 --> 00:28:00,170
around 780 tests and most of them from

636
00:28:00,170 --> 00:28:02,990
the ACMA official test shoot em but I

637
00:28:02,990 --> 00:28:04,370
couldn't need some help for example

638
00:28:04,370 --> 00:28:06,230
project page is basically just what you

639
00:28:06,230 --> 00:28:08,780
saw before with this tracer and you have

640
00:28:08,780 --> 00:28:10,850
hours so that would be awesome someone

641
00:28:10,850 --> 00:28:13,540
could I out there bug fixes and also am

642
00:28:13,540 --> 00:28:16,040
testers if you figure out there's a

643
00:28:16,040 --> 00:28:17,750
wreck is not working just tell me I'll

644
00:28:17,750 --> 00:28:21,590
try to fix it so but what's made more

645
00:28:21,590 --> 00:28:23,120
important for this project is to come up

646
00:28:23,120 --> 00:28:24,559
with some cool ideas where he could use

647
00:28:24,559 --> 00:28:27,290
this for basically I would like to see

648
00:28:27,290 --> 00:28:29,510
that like as primers for analyzing trial

649
00:28:29,510 --> 00:28:32,150
script code that this could be some kind

650
00:28:32,150 --> 00:28:33,710
of foundation finalizing a regular

651
00:28:33,710 --> 00:28:36,620
expressions and for example implementing

652
00:28:36,620 --> 00:28:39,559
a recce up slender way so while you're

653
00:28:39,559 --> 00:28:42,200
not allowed to do arbitrary many matches

654
00:28:42,200 --> 00:28:44,960
or something and also that you could use

655
00:28:44,960 --> 00:28:47,179
this in your maybe it's a development

656
00:28:47,179 --> 00:28:49,250
environment to record how often our

657
00:28:49,250 --> 00:28:51,140
record are you a regular expression

658
00:28:51,140 --> 00:28:55,309
executed and then maybe debug that you

659
00:28:55,309 --> 00:28:57,350
should optimize some regular expressions

660
00:28:57,350 --> 00:29:00,410
or do something else to to increase your

661
00:29:00,410 --> 00:29:03,560
performance so with that that's it thank

