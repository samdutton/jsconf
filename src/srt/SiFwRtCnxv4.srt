1
00:00:02,880 --> 00:00:15,920

[Music]

2
00:00:15,930 --> 00:00:30,470


3
00:00:30,480 --> 00:00:37,629
[Music]

4
00:00:37,629 --> 00:00:41,090
hi so my talk is called immutability or

5
00:00:41,090 --> 00:00:42,859
putting the dream machine to work so

6
00:00:42,859 --> 00:00:44,480
I've been a front-end developer for

7
00:00:44,480 --> 00:00:46,129
eight years now I was at the New York

8
00:00:46,129 --> 00:00:48,829
Times for four I recently left to join

9
00:00:48,829 --> 00:00:50,480
up with a company called cognate echt

10
00:00:50,480 --> 00:00:53,390
their consultancy and they also have a

11
00:00:53,390 --> 00:00:56,449
database and a cognate act I think we

12
00:00:56,449 --> 00:00:59,989
believe that a lot of software is far

13
00:00:59,989 --> 00:01:01,609
too complex and there's ways to achieve

14
00:01:01,609 --> 00:01:04,010
a lot more simplicity in the type of

15
00:01:04,010 --> 00:01:05,840
systems that we write one way to achieve

16
00:01:05,840 --> 00:01:08,270
simplicity is through immutability

17
00:01:08,270 --> 00:01:10,820
by embracing immutability so cognitive

18
00:01:10,820 --> 00:01:13,160
stewards closure and closure script I'm

19
00:01:13,160 --> 00:01:14,510
the lead maintainer of clojurescript

20
00:01:14,510 --> 00:01:16,850
those languages emphasize immutability

21
00:01:16,850 --> 00:01:19,340
we also have a database product called

22
00:01:19,340 --> 00:01:21,530
de Tomic which is a immutable relational

23
00:01:21,530 --> 00:01:24,050
database I'm not actually going to talk

24
00:01:24,050 --> 00:01:25,880
about any of those things today or only

25
00:01:25,880 --> 00:01:27,530
we'll only talk about them a little bit

26
00:01:27,530 --> 00:01:29,090
the thing that I really want to talk

27
00:01:29,090 --> 00:01:31,490
about today is the dream machine so if

28
00:01:31,490 --> 00:01:33,020
you have not seen this book or

29
00:01:33,020 --> 00:01:34,610
encountered this book this should be

30
00:01:34,610 --> 00:01:36,560
number one on your reading list if you

31
00:01:36,560 --> 00:01:38,150
are involved in interactive computing in

32
00:01:38,150 --> 00:01:40,550
any way shape or form this was

33
00:01:40,550 --> 00:01:43,190
recommended to were recommended by Alan

34
00:01:43,190 --> 00:01:46,310
Kay as one of the best histories of how

35
00:01:46,310 --> 00:01:48,590
interactive computing came to be it will

36
00:01:48,590 --> 00:01:50,240
make you laugh it will make you cry and

37
00:01:50,240 --> 00:01:51,650
if you have anything with you eyes it

38
00:01:51,650 --> 00:01:53,480
will fill you with a sense of wonder

39
00:01:53,480 --> 00:01:57,800
so JCR Licklider was a psychologist who

40
00:01:57,800 --> 00:02:00,950
at the time realized that there was not

41
00:02:00,950 --> 00:02:03,530
a serious enough perspective on the role

42
00:02:03,530 --> 00:02:06,260
of human psychology and human factors in

43
00:02:06,260 --> 00:02:09,019
computing systems also a lot of people

44
00:02:09,019 --> 00:02:10,520
didn't believe interactive computing

45
00:02:10,520 --> 00:02:12,140
systems would be of any utility

46
00:02:12,140 --> 00:02:14,900
whatsoever and he really paved the way

47
00:02:14,900 --> 00:02:15,939
through

48
00:02:15,939 --> 00:02:17,879
to make sure that research institutions

49
00:02:17,879 --> 00:02:20,109
were you know putting the time and

50
00:02:20,109 --> 00:02:23,469
effort into discovering the results of

51
00:02:23,469 --> 00:02:27,310
you know interactive computing so he is

52
00:02:27,310 --> 00:02:30,549
most famous for two essays one of the

53
00:02:30,549 --> 00:02:32,439
famous ones is called the man computer

54
00:02:32,439 --> 00:02:33,219
symbiosis

55
00:02:33,219 --> 00:02:37,359
so Licklider basically predicted my talk

56
00:02:37,359 --> 00:02:39,430
fifty-four years ago I was going through

57
00:02:39,430 --> 00:02:40,629
this paper for the actually the first

58
00:02:40,629 --> 00:02:43,450
time two days ago and he says something

59
00:02:43,450 --> 00:02:45,430
very specific which I'm going to talk

60
00:02:45,430 --> 00:02:47,620
about quite a bit today this talk is a

61
00:02:47,620 --> 00:02:49,299
bit of a little bit of history a little

62
00:02:49,299 --> 00:02:51,129
bit of data structures and a little bit

63
00:02:51,129 --> 00:02:53,980
of examples so in this paper he he sort

64
00:02:53,980 --> 00:02:56,290
of lays out what are the types of

65
00:02:56,290 --> 00:02:58,900
hardware and software things that are

66
00:02:58,900 --> 00:03:02,169
going to pave the way for interactive

67
00:03:02,169 --> 00:03:04,120
systems he saw computing as a way to

68
00:03:04,120 --> 00:03:07,450
augment the human intellect so he says

69
00:03:07,450 --> 00:03:09,579
in this paper the tree memory scheme is

70
00:03:09,579 --> 00:03:11,049
inefficient for small memories but it

71
00:03:11,049 --> 00:03:13,030
becomes increasingly efficient and using

72
00:03:13,030 --> 00:03:15,189
available storage space as memory size

73
00:03:15,189 --> 00:03:17,049
increases the attractive features of the

74
00:03:17,049 --> 00:03:18,760
scheme are these number one the

75
00:03:18,760 --> 00:03:20,560
retrieval process is extremely simple

76
00:03:20,560 --> 00:03:22,449
given the argument entered the standard

77
00:03:22,449 --> 00:03:23,530
initial register with the first

78
00:03:23,530 --> 00:03:25,329
character pick up the address of the

79
00:03:25,329 --> 00:03:27,190
second then go to the second register

80
00:03:27,190 --> 00:03:28,329
and pick up the addresses of the third

81
00:03:28,329 --> 00:03:30,459
if two arguments have initial characters

82
00:03:30,459 --> 00:03:32,409
in common they use the same storage

83
00:03:32,409 --> 00:03:34,269
space for these characters and I'm going

84
00:03:34,269 --> 00:03:36,930
to actually talk about this quite a bit

85
00:03:36,930 --> 00:03:39,579
here we have several people that

86
00:03:39,579 --> 00:03:41,109
benefited from the culture that

87
00:03:41,109 --> 00:03:43,510
Licklider created John McCarthy Rees

88
00:03:43,510 --> 00:03:45,579
received considerable funding he is the

89
00:03:45,579 --> 00:03:47,669
inventor of Lisp artificial intelligence

90
00:03:47,669 --> 00:03:49,810
interpreters functional programming

91
00:03:49,810 --> 00:03:52,150
garbage collection all things that are

92
00:03:52,150 --> 00:03:53,439
critical for doing anything that you

93
00:03:53,439 --> 00:03:55,569
guys are doing today he was a

94
00:03:55,569 --> 00:03:57,400
mathematician at the time using

95
00:03:57,400 --> 00:03:58,959
computers was extremely difficult

96
00:03:58,959 --> 00:04:01,299
he believed that computer actually

97
00:04:01,299 --> 00:04:03,370
programming the computer itself should

98
00:04:03,370 --> 00:04:06,400
be a real-time interactive activity you

99
00:04:06,400 --> 00:04:09,040
can thank him for console the

100
00:04:09,040 --> 00:04:10,840
interactive console that's that's

101
00:04:10,840 --> 00:04:12,849
definitely due to John McCarthy to his

102
00:04:12,849 --> 00:04:17,079
right is Ed fredkin he was a Caltech

103
00:04:17,079 --> 00:04:18,280
dropout at 19

104
00:04:18,280 --> 00:04:20,409
went to the US Air Force was a fighter

105
00:04:20,409 --> 00:04:22,270
pilot and then when he was very young

106
00:04:22,270 --> 00:04:24,820
was pivotal and in hacking these early

107
00:04:24,820 --> 00:04:27,010
computers to do impossible things to

108
00:04:27,010 --> 00:04:29,080
build interactive systems

109
00:04:29,080 --> 00:04:32,169
Ede fred can also invented the tree and

110
00:04:32,169 --> 00:04:34,539
that spelled TR IE and that's what we're

111
00:04:34,539 --> 00:04:37,689
gonna talk a bit about so Alan Kay is

112
00:04:37,689 --> 00:04:39,159
another important figure he also

113
00:04:39,159 --> 00:04:40,300
benefited from the culture that

114
00:04:40,300 --> 00:04:44,500
Lickliter created Alan Kay what well

115
00:04:44,500 --> 00:04:45,400
understood

116
00:04:45,400 --> 00:04:47,800
John McCarthy's ideas he built an

117
00:04:47,800 --> 00:04:50,020
interactive programming language but on

118
00:04:50,020 --> 00:04:51,550
top of that he sort of erected the

119
00:04:51,550 --> 00:04:52,900
edifice that we are all familiar with

120
00:04:52,900 --> 00:04:54,759
today around object-oriented programming

121
00:04:54,759 --> 00:04:58,509
as well as blazing the trail around what

122
00:04:58,509 --> 00:05:00,939
we consider modern user interfaces so

123
00:05:00,939 --> 00:05:02,139
here's an image that I think is very

124
00:05:02,139 --> 00:05:05,110
inspiring a big goal of his was that

125
00:05:05,110 --> 00:05:06,879
computing should be simpler that it

126
00:05:06,879 --> 00:05:08,379
should be available to people at a very

127
00:05:08,379 --> 00:05:08,949
young age

128
00:05:08,949 --> 00:05:11,669
here are some boys and girls and they're

129
00:05:11,669 --> 00:05:13,870
interacting with a live small talk

130
00:05:13,870 --> 00:05:15,280
programming environment and they're

131
00:05:15,280 --> 00:05:16,960
doing things that you know we're I mean

132
00:05:16,960 --> 00:05:18,099
they were very lucky right they were

133
00:05:18,099 --> 00:05:20,889
they were they were experiencing the

134
00:05:20,889 --> 00:05:22,539
future of computing when most people

135
00:05:22,539 --> 00:05:27,250
were still doing basic right there's a

136
00:05:27,250 --> 00:05:28,719
really great article I recommend reading

137
00:05:28,719 --> 00:05:30,939
this is an article that I found on the

138
00:05:30,939 --> 00:05:33,610
Atari archive it's more its Marion gold

139
00:05:33,610 --> 00:05:37,599
Goldeen Marion golden and she was 11

140
00:05:37,599 --> 00:05:39,400
years old and she was lucky enough to

141
00:05:39,400 --> 00:05:41,949
experience a Xerox Paul out Xerox Alto

142
00:05:41,949 --> 00:05:44,979
and small talk and she describes when

143
00:05:44,979 --> 00:05:47,319
she's like 12 years old what it was like

144
00:05:47,319 --> 00:05:49,360
to program one of these machines so she

145
00:05:49,360 --> 00:05:51,849
she but directly benefitted from the

146
00:05:51,849 --> 00:05:53,949
dream machine she's actually has for

147
00:05:53,949 --> 00:05:57,250
years been a UI programmer at Apple and

148
00:05:57,250 --> 00:05:59,110
she went off to do this because of her

149
00:05:59,110 --> 00:06:01,000
experiences with the small talk

150
00:06:01,000 --> 00:06:03,610
environment anyways you can fire up a

151
00:06:03,610 --> 00:06:05,349
small talk environment today there's an

152
00:06:05,349 --> 00:06:06,729
open-source one called squeak it's quite

153
00:06:06,729 --> 00:06:08,440
cool if you open the system browser

154
00:06:08,440 --> 00:06:10,479
which uncovers the entire internals of

155
00:06:10,479 --> 00:06:12,219
that system you will encounter something

156
00:06:12,219 --> 00:06:14,500
which is very familiar to JavaScript

157
00:06:14,500 --> 00:06:18,849
programmers model-view-controller trig

158
00:06:18,849 --> 00:06:20,770
Vereen Skagen adele goldberg and others

159
00:06:20,770 --> 00:06:24,460
at Xerox PARC invented NBC well 35 35

160
00:06:24,460 --> 00:06:25,409
years ago

161
00:06:25,409 --> 00:06:27,520
longshadow people are still talking

162
00:06:27,520 --> 00:06:29,529
about this stuff I would actually argue

163
00:06:29,529 --> 00:06:31,930
we haven't really advanced much beyond

164
00:06:31,930 --> 00:06:34,240
it but that's okay

165
00:06:34,240 --> 00:06:36,969
because at an abstract level NBC is a

166
00:06:36,969 --> 00:06:39,490
sound separation of concerns we want

167
00:06:39,490 --> 00:06:40,750
users to be able to interact with their

168
00:06:40,750 --> 00:06:42,790
domain we want to have intuitive

169
00:06:42,790 --> 00:06:44,590
representations that domain and as

170
00:06:44,590 --> 00:06:46,390
programmers we want to coordinate that

171
00:06:46,390 --> 00:06:48,280
abstract domain and those abstract

172
00:06:48,280 --> 00:06:50,230
visual representations such that the

173
00:06:50,230 --> 00:06:53,320
user has a pleasant experience but I

174
00:06:53,320 --> 00:06:54,760
would argue that implementations leave

175
00:06:54,760 --> 00:06:56,830
much to be desired that's having worked

176
00:06:56,830 --> 00:06:59,140
with a variety of mbc's over the years

177
00:06:59,140 --> 00:07:01,060
and that's because they're erected on

178
00:07:01,060 --> 00:07:02,260
top of stateful objects you have

179
00:07:02,260 --> 00:07:03,580
stateful models you have stateful

180
00:07:03,580 --> 00:07:05,350
controllers and you have stateful views

181
00:07:05,350 --> 00:07:07,420
and so the crazy I'm the idea that I'm

182
00:07:07,420 --> 00:07:08,830
going to throw out as I think that

183
00:07:08,830 --> 00:07:11,110
Licklider was correct if you build your

184
00:07:11,110 --> 00:07:14,170
user interfaces around trees really cool

185
00:07:14,170 --> 00:07:17,980
things happen so trees so this is the

186
00:07:17,980 --> 00:07:21,520
data structure part of the talk I'm just

187
00:07:21,520 --> 00:07:22,900
gonna reuse some slides because these

188
00:07:22,900 --> 00:07:24,310
slides are amazing they were done by

189
00:07:24,310 --> 00:07:26,050
Zach Hollan at hacker school he's a

190
00:07:26,050 --> 00:07:28,150
facilitator there he put these slides

191
00:07:28,150 --> 00:07:30,040
together for Strange Loop and they're

192
00:07:30,040 --> 00:07:31,510
just so good there's absolutely no

193
00:07:31,510 --> 00:07:34,770
reason for me to come up with my own so

194
00:07:34,770 --> 00:07:36,220
regardless of whether you like

195
00:07:36,220 --> 00:07:37,450
functional programming a lot it's not

196
00:07:37,450 --> 00:07:40,390
very important but all these ideas apply

197
00:07:40,390 --> 00:07:42,100
if you like object-oriented programming

198
00:07:42,100 --> 00:07:44,410
but we need to at least understand how

199
00:07:44,410 --> 00:07:46,300
these data structures came to be and why

200
00:07:46,300 --> 00:07:48,010
functional programmers like them in

201
00:07:48,010 --> 00:07:49,720
order to understand how we might use

202
00:07:49,720 --> 00:07:51,790
them if we prefer the object-oriented

203
00:07:51,790 --> 00:07:54,460
approach so functional programmers they

204
00:07:54,460 --> 00:07:55,900
like immutable values they don't like

205
00:07:55,900 --> 00:07:59,170
stateful objects and when you change

206
00:07:59,170 --> 00:08:00,400
something you just return a new value

207
00:08:00,400 --> 00:08:02,050
and as JavaScript programmers you guys

208
00:08:02,050 --> 00:08:03,490
are already well aware of this

209
00:08:03,490 --> 00:08:05,470
you have numbers in JavaScript they are

210
00:08:05,470 --> 00:08:06,700
thank goodness

211
00:08:06,700 --> 00:08:09,340
immutable strings you're lucky not every

212
00:08:09,340 --> 00:08:10,480
dynamic primary language had add

213
00:08:10,480 --> 00:08:12,310
immutable strings you have immutable

214
00:08:12,310 --> 00:08:14,890
strings so what functional programmers

215
00:08:14,890 --> 00:08:16,990
want is that yes we know that if you add

216
00:08:16,990 --> 00:08:18,760
one and one and we get to that doesn't

217
00:08:18,760 --> 00:08:21,450
doesn't change the other ones right so

218
00:08:21,450 --> 00:08:23,410
functional programmers also want this

219
00:08:23,410 --> 00:08:25,270
behavior from collections so if I had a

220
00:08:25,270 --> 00:08:28,360
key value to a map I get a new map and

221
00:08:28,360 --> 00:08:30,880
the old map is not destroyed so as

222
00:08:30,880 --> 00:08:32,260
JavaScript programmers you're extremely

223
00:08:32,260 --> 00:08:34,990
used to destroying data on destroying

224
00:08:34,990 --> 00:08:36,729
the past and we don't have to do that

225
00:08:36,729 --> 00:08:38,200
and I'll demonstrate how this can be

226
00:08:38,200 --> 00:08:39,760
done and so this is where the term

227
00:08:39,760 --> 00:08:41,860
persistent comes from not persistent in

228
00:08:41,860 --> 00:08:43,090
the sense of like you're going to record

229
00:08:43,090 --> 00:08:44,890
it to a database but persistent in the

230
00:08:44,890 --> 00:08:46,330
sense that you're not destroying

231
00:08:46,330 --> 00:08:48,670
previous values and they're very fast

232
00:08:48,670 --> 00:08:51,040
and this is actually relatively a recent

233
00:08:51,040 --> 00:08:54,310
development Okazaki talked about purely

234
00:08:54,310 --> 00:08:55,900
functional data structures but that you

235
00:08:55,900 --> 00:08:56,750
know there

236
00:08:56,750 --> 00:08:58,430
okay and they work they have good paper

237
00:08:58,430 --> 00:09:00,890
complexity bounds a man named Phil

238
00:09:00,890 --> 00:09:03,320
Bagwell who was EPFL where Scala was

239
00:09:03,320 --> 00:09:06,380
invented he did initial research in the

240
00:09:06,380 --> 00:09:07,820
early 2000s and how you could have

241
00:09:07,820 --> 00:09:10,700
really high-performance persistent data

242
00:09:10,700 --> 00:09:12,890
structures and they were further

243
00:09:12,890 --> 00:09:15,380
modified by rich icky and actually it

244
00:09:15,380 --> 00:09:17,180
was really closure that showed that they

245
00:09:17,180 --> 00:09:19,570
could perform well on modern hardware

246
00:09:19,570 --> 00:09:21,680
but they might that might sound really

247
00:09:21,680 --> 00:09:23,720
advanced but I wanted to show you that

248
00:09:23,720 --> 00:09:25,940
it's not scary oh I bet almost everyone

249
00:09:25,940 --> 00:09:27,230
here in this room knows what a linked

250
00:09:27,230 --> 00:09:29,690
list is and linked lists have the same

251
00:09:29,690 --> 00:09:32,450
properties that we like about trees so

252
00:09:32,450 --> 00:09:34,190
in a linked list here's a list with four

253
00:09:34,190 --> 00:09:35,300
things in it and we store it in a

254
00:09:35,300 --> 00:09:39,170
variable X well I can cons some value

255
00:09:39,170 --> 00:09:40,640
onto the head of that and I can store

256
00:09:40,640 --> 00:09:42,590
that in a variable Y and now I have two

257
00:09:42,590 --> 00:09:46,670
values right and they share more than

258
00:09:46,670 --> 00:09:49,430
50% of memory right they represent two

259
00:09:49,430 --> 00:09:51,380
distinct values but they share more than

260
00:09:51,380 --> 00:09:53,510
50% of memory I can take the tail of X

261
00:09:53,510 --> 00:09:56,450
and cons e onto that now I have three

262
00:09:56,450 --> 00:09:58,760
distinct list values and they all share

263
00:09:58,760 --> 00:10:01,790
more than 50% of their memory so this is

264
00:10:01,790 --> 00:10:03,560
a scalable idea this idea is called

265
00:10:03,560 --> 00:10:06,589
structural sharing so sharing structure

266
00:10:06,589 --> 00:10:08,780
gives us space efficiency but less

267
00:10:08,780 --> 00:10:10,070
obvious is that actually gives you

268
00:10:10,070 --> 00:10:12,140
computational efficiency so you if you

269
00:10:12,140 --> 00:10:14,150
use structural sharing you can do these

270
00:10:14,150 --> 00:10:15,800
immutable values and you can update just

271
00:10:15,800 --> 00:10:18,680
a part of it and it will be efficient so

272
00:10:18,680 --> 00:10:21,020
fill bag wall innovated this space again

273
00:10:21,020 --> 00:10:22,400
he came up with this thing called the

274
00:10:22,400 --> 00:10:24,860
arraignment try sort of tree hash array

275
00:10:24,860 --> 00:10:27,320
hash array map tree rich Hickey took

276
00:10:27,320 --> 00:10:29,240
that and modified it quite a bit in a

277
00:10:29,240 --> 00:10:30,860
very clever way and he invented

278
00:10:30,860 --> 00:10:32,420
something called the bitmap vector tree

279
00:10:32,420 --> 00:10:34,220
so I know that everybody here knows what

280
00:10:34,220 --> 00:10:36,380
an array is so a bitmap vector tree is

281
00:10:36,380 --> 00:10:37,940
like an array it's its high-performance

282
00:10:37,940 --> 00:10:40,100
random access and you can append to the

283
00:10:40,100 --> 00:10:44,120
end quickly as well so the way that they

284
00:10:44,120 --> 00:10:45,440
work as data lives in the leaves

285
00:10:45,440 --> 00:10:47,210
it's a prefixed tree and remember

286
00:10:47,210 --> 00:10:49,280
Licklider was talking about this in 1960

287
00:10:49,280 --> 00:10:51,140
it uses a prefect it's a prefixed tree

288
00:10:51,140 --> 00:10:53,720
to find a particular value and it's but

289
00:10:53,720 --> 00:10:56,600
it's done in a bitwise way to make that

290
00:10:56,600 --> 00:11:00,140
more visual so in in the in the tree of

291
00:11:00,140 --> 00:11:01,790
a persistent vector you have an array of

292
00:11:01,790 --> 00:11:03,980
arrays so at the root you have to pick

293
00:11:03,980 --> 00:11:08,000
some fixed size say for and then every

294
00:11:08,000 --> 00:11:10,130
element of that points to an array

295
00:11:10,130 --> 00:11:12,380
which was also the same size and then

296
00:11:12,380 --> 00:11:14,029
those arrays point to more arrays that

297
00:11:14,029 --> 00:11:16,040
are the same size finally you're going

298
00:11:16,040 --> 00:11:17,899
to hit a leaf node where you have actual

299
00:11:17,899 --> 00:11:19,910
values okay this sounds kind of

300
00:11:19,910 --> 00:11:21,860
interesting but how the hell do you look

301
00:11:21,860 --> 00:11:25,970
up anything in this so imagine we wanna

302
00:11:25,970 --> 00:11:28,160
get 100 sixth element so we can do this

303
00:11:28,160 --> 00:11:30,440
really cool trick that represents a

304
00:11:30,440 --> 00:11:33,350
binary number we can use bit masking to

305
00:11:33,350 --> 00:11:35,449
find that thing so we can bit mask off

306
00:11:35,449 --> 00:11:37,459
the first two bits this tells us to look

307
00:11:37,459 --> 00:11:39,800
at look at index 1 we can bit-bit mask

308
00:11:39,800 --> 00:11:41,420
the next two bits that get takes us the

309
00:11:41,420 --> 00:11:44,029
next level look at index 2 bit mask

310
00:11:44,029 --> 00:11:47,029
again finally it says the value you're

311
00:11:47,029 --> 00:11:49,730
looking for is that index 2 and that's

312
00:11:49,730 --> 00:11:51,949
106 so if you know anything about modern

313
00:11:51,949 --> 00:11:54,680
JavaScript engines array axises and bit

314
00:11:54,680 --> 00:11:56,420
shifting is about as fast as you can get

315
00:11:56,420 --> 00:11:58,120
this is going to do this is going to be

316
00:11:58,120 --> 00:12:00,649
the engine optimize this in pretty wild

317
00:12:00,649 --> 00:12:03,380
ways which I will show that - but what

318
00:12:03,380 --> 00:12:05,720
about update so this is where the

319
00:12:05,720 --> 00:12:07,550
structural sharing comes into play if I

320
00:12:07,550 --> 00:12:09,079
want to update for example I want to

321
00:12:09,079 --> 00:12:11,899
replace 106 with the string foo how much

322
00:12:11,899 --> 00:12:14,060
work do we have to do we only have to

323
00:12:14,060 --> 00:12:15,980
clone the arrays on the path that

324
00:12:15,980 --> 00:12:18,199
changed all other paths that weren't

325
00:12:18,199 --> 00:12:20,000
involved in the change don't need to be

326
00:12:20,000 --> 00:12:24,079
updated so that's how much work we have

327
00:12:24,079 --> 00:12:26,779
to do to to update that thing and none

328
00:12:26,779 --> 00:12:28,220
of the other nodes are going to change

329
00:12:28,220 --> 00:12:30,589
they all stay the same so this is where

330
00:12:30,589 --> 00:12:32,029
the the structural sharing we saw with

331
00:12:32,029 --> 00:12:35,000
linked lists happens with trees so

332
00:12:35,000 --> 00:12:37,160
you're probably thinking well the for

333
00:12:37,160 --> 00:12:39,829
this seems like a weird number to pick

334
00:12:39,829 --> 00:12:41,420
for the length and of course after

335
00:12:41,420 --> 00:12:43,639
empirical testing it turns out that 32

336
00:12:43,639 --> 00:12:45,649
is a really good number on modern

337
00:12:45,649 --> 00:12:47,480
hardware you do a bunch of tests and 32

338
00:12:47,480 --> 00:12:49,370
works out the best in terms of how

339
00:12:49,370 --> 00:12:51,290
expensive is it to update versus how

340
00:12:51,290 --> 00:12:53,810
quickly we can look something out ok

341
00:12:53,810 --> 00:12:55,910
just to give you a sense of how good a

342
00:12:55,910 --> 00:12:58,160
such a wide branching factor is 32 to

343
00:12:58,160 --> 00:13:01,069
the seventh power that's 34 billion

344
00:13:01,069 --> 00:13:04,370
elements on a 64-bit OS with a 64-bit VM

345
00:13:04,370 --> 00:13:06,680
where the values are 64-bit if you do

346
00:13:06,680 --> 00:13:08,149
that in a regular JavaScript array

347
00:13:08,149 --> 00:13:11,540
that's 256 gigabytes of RAM I don't

348
00:13:11,540 --> 00:13:13,040
think anybody in this room has a laptop

349
00:13:13,040 --> 00:13:15,230
with that much memory to update

350
00:13:15,230 --> 00:13:16,610
something in this data structure only

351
00:13:16,610 --> 00:13:19,579
requires seven array updates to access

352
00:13:19,579 --> 00:13:21,439
anything at most you need seven array

353
00:13:21,439 --> 00:13:24,560
accesses and in some bit operations

354
00:13:24,560 --> 00:13:28,290
okay so that's a lot of talk let's see

355
00:13:28,290 --> 00:13:31,740
some let's see some numbers so this is a

356
00:13:31,740 --> 00:13:34,860
recent build of v8 I'm I've exported all

357
00:13:34,860 --> 00:13:36,390
the functionality and closure script by

358
00:13:36,390 --> 00:13:37,650
a library called Mori which is available

359
00:13:37,650 --> 00:13:40,260
on NPM as well as for the browser if you

360
00:13:40,260 --> 00:13:42,690
want to do that so what I do is I build

361
00:13:42,690 --> 00:13:44,190
an array and I add one mill I just

362
00:13:44,190 --> 00:13:45,540
pushed one million elements to a

363
00:13:45,540 --> 00:13:47,160
nighttime that and then I do this with a

364
00:13:47,160 --> 00:13:50,010
persistent vector and I just calculate

365
00:13:50,010 --> 00:13:51,540
the average well it looks like eighty

366
00:13:51,540 --> 00:13:52,860
three milliseconds on this particular

367
00:13:52,860 --> 00:13:55,320
machine and then we have an average of

368
00:13:55,320 --> 00:13:58,200
about 288 for persistent vectors so it

369
00:13:58,200 --> 00:13:59,760
should already be shocking because it's

370
00:13:59,760 --> 00:14:01,560
this is not an order of magnitude slower

371
00:14:01,560 --> 00:14:03,960
right this is about a little bit more

372
00:14:03,960 --> 00:14:06,000
than three times slower that's already

373
00:14:06,000 --> 00:14:07,590
cool there are many applications that

374
00:14:07,590 --> 00:14:09,210
could benefit from these data structures

375
00:14:09,210 --> 00:14:12,210
that don't need just the craziest amount

376
00:14:12,210 --> 00:14:14,010
of perf I'm going to show something a

377
00:14:14,010 --> 00:14:21,090
little bit crazier so we've been doing

378
00:14:21,090 --> 00:14:23,310
persistent data structures for seven

379
00:14:23,310 --> 00:14:24,690
years now enclosure and clear scripts

380
00:14:24,690 --> 00:14:26,670
we've gotten more and more clever about

381
00:14:26,670 --> 00:14:28,830
what optimizations you can do so you

382
00:14:28,830 --> 00:14:30,240
guys might be familiar with object

383
00:14:30,240 --> 00:14:33,090
freeze so of course all all of our data

384
00:14:33,090 --> 00:14:34,710
structures are already front effectively

385
00:14:34,710 --> 00:14:36,120
frozen but we have a corresponding

386
00:14:36,120 --> 00:14:38,610
operation called thumb rule it's called

387
00:14:38,610 --> 00:14:40,410
transient but we imagine it's like

388
00:14:40,410 --> 00:14:42,870
object thaw and we can get in oh one

389
00:14:42,870 --> 00:14:45,150
time a mutable version of the persistent

390
00:14:45,150 --> 00:14:46,890
thing and we can also make it persistent

391
00:14:46,890 --> 00:14:49,590
again in one time so how does a

392
00:14:49,590 --> 00:14:52,530
transient vector compared to a immutable

393
00:14:52,530 --> 00:15:00,300
array it's faster to build a persistent

394
00:15:00,300 --> 00:15:02,160
vector than it is to mutate immutable

395
00:15:02,160 --> 00:15:04,470
array so that's pretty crazy to show

396
00:15:04,470 --> 00:15:06,720
that this is true on on engines other or

397
00:15:06,720 --> 00:15:08,850
not faster but the performance is about

398
00:15:08,850 --> 00:15:11,490
the same or not so bad for other

399
00:15:11,490 --> 00:15:13,200
JavaScript engines this is a recent

400
00:15:13,200 --> 00:15:17,970
build of JavaScript core it's not it's

401
00:15:17,970 --> 00:15:20,640
not significantly slower right so we but

402
00:15:20,640 --> 00:15:22,230
we have we have all this all these

403
00:15:22,230 --> 00:15:24,300
magical properties that arrays don't

404
00:15:24,300 --> 00:15:25,950
have and we can achieve their

405
00:15:25,950 --> 00:15:32,190
performance of mutable arrays okay so

406
00:15:32,190 --> 00:15:34,290
that's that's awesome so this is this is

407
00:15:34,290 --> 00:15:35,700
because so many people have been

408
00:15:35,700 --> 00:15:37,200
building the dream machine for us right

409
00:15:37,200 --> 00:15:37,500
just

410
00:15:37,500 --> 00:15:38,400
so much research has gone into

411
00:15:38,400 --> 00:15:41,280
optimizing dynamic programming languages

412
00:15:41,280 --> 00:15:43,050
and I got really excited because

413
00:15:43,050 --> 00:15:45,480
recently WebKit sort of kicked up the

414
00:15:45,480 --> 00:15:47,250
notch again I felt like things were

415
00:15:47,250 --> 00:15:49,650
stagnating a bit with their FTL JIT

416
00:15:49,650 --> 00:15:51,870
which is a fourth tier and that tier is

417
00:15:51,870 --> 00:15:53,850
going to absolutely love the type of

418
00:15:53,850 --> 00:15:56,100
code that's involved in doing these

419
00:15:56,100 --> 00:15:58,980
kinds of data structures so there's more

420
00:15:58,980 --> 00:16:01,590
excitement to come nick bray talked on

421
00:16:01,590 --> 00:16:03,960
thursday about opening up the door to

422
00:16:03,960 --> 00:16:06,870
shared memory parallel ism so closure

423
00:16:06,870 --> 00:16:07,980
skippers already ready for that

424
00:16:07,980 --> 00:16:08,970
clojurescript data structures are

425
00:16:08,970 --> 00:16:10,890
already locked free so you can do

426
00:16:10,890 --> 00:16:12,720
parallel operations on them without

427
00:16:12,720 --> 00:16:16,230
locks okay so hopefully you're excited

428
00:16:16,230 --> 00:16:17,370
about trees and you're convinced that

429
00:16:17,370 --> 00:16:19,680
maybe Licklider had a good idea in 1960

430
00:16:19,680 --> 00:16:22,620
so I want to see well what does this

431
00:16:22,620 --> 00:16:25,590
mean for interactive programs so I built

432
00:16:25,590 --> 00:16:27,200
a library five months ago called ohm

433
00:16:27,200 --> 00:16:30,690
maybe some of you heard of it it it

434
00:16:30,690 --> 00:16:33,240
basically marries are the suite of tree

435
00:16:33,240 --> 00:16:35,040
based data structures with react and it

436
00:16:35,040 --> 00:16:37,500
turns out that these are a really good

437
00:16:37,500 --> 00:16:39,900
pair and let's talk really briefly why

438
00:16:39,900 --> 00:16:42,120
so we can now represent our application

439
00:16:42,120 --> 00:16:44,310
state as one giant immutable value and

440
00:16:44,310 --> 00:16:46,410
then react says oh well you can apply a

441
00:16:46,410 --> 00:16:47,820
function to that and we're going to

442
00:16:47,820 --> 00:16:49,410
compute some virtual Dom which is

443
00:16:49,410 --> 00:16:51,510
another value and now if I update my

444
00:16:51,510 --> 00:16:53,400
immutable app state and I get a new

445
00:16:53,400 --> 00:16:54,900
value I can apply that function again

446
00:16:54,900 --> 00:16:57,030
and react will produce some new virtual

447
00:16:57,030 --> 00:16:59,250
Dom and the way that react works is it

448
00:16:59,250 --> 00:17:00,990
applies a very clever diffing algorithm

449
00:17:00,990 --> 00:17:02,970
on the on these two virtual Dom's

450
00:17:02,970 --> 00:17:04,500
and then that creates a minimal change

451
00:17:04,500 --> 00:17:06,930
set but what's fascinating about this is

452
00:17:06,930 --> 00:17:09,650
that what happens if we flip V 1 and V 0

453
00:17:09,650 --> 00:17:12,720
for free react will give us the reverse

454
00:17:12,720 --> 00:17:16,290
change set right for free so this means

455
00:17:16,290 --> 00:17:18,930
that we can do undo redo trivially you

456
00:17:18,930 --> 00:17:20,819
can you can jump or to an arbitrary

457
00:17:20,819 --> 00:17:23,339
point in time you can also do things it

458
00:17:23,339 --> 00:17:25,410
makes actually computing Delta's faster

459
00:17:25,410 --> 00:17:27,329
you can do it makes that which makes

460
00:17:27,329 --> 00:17:29,610
synchronization simpler for example if

461
00:17:29,610 --> 00:17:30,990
you want to rollback your app state on

462
00:17:30,990 --> 00:17:33,090
an error you can just jump back to the

463
00:17:33,090 --> 00:17:35,190
previous application state the snapshot

464
00:17:35,190 --> 00:17:37,680
you don't have to manually reconstruct

465
00:17:37,680 --> 00:17:39,270
what your app looked like before the

466
00:17:39,270 --> 00:17:41,940
error occurred lots of cool stuff it's

467
00:17:41,940 --> 00:17:43,680
not just about undo and redo which some

468
00:17:43,680 --> 00:17:45,080
people get confused about

469
00:17:45,080 --> 00:17:48,450
okay so let's so I it's it's most fun to

470
00:17:48,450 --> 00:17:49,770
show an example that I did not write so

471
00:17:49,770 --> 00:17:51,360
I said

472
00:17:51,360 --> 00:17:53,700
I did a version up to do NBC with ohm

473
00:17:53,700 --> 00:17:56,489
and I said I think I can do undo pretty

474
00:17:56,489 --> 00:17:57,989
simply and I was able to do it

475
00:17:57,989 --> 00:17:59,639
and non-invasively I did not change any

476
00:17:59,639 --> 00:18:02,249
of my to do MBC code I did in an

477
00:18:02,249 --> 00:18:04,110
external change and it was five lines of

478
00:18:04,110 --> 00:18:07,259
code to add undo over the entire state

479
00:18:07,259 --> 00:18:10,019
of the to-do MVC application so this guy

480
00:18:10,019 --> 00:18:11,909
a table tainha skyjacked Scheidler said

481
00:18:11,909 --> 00:18:14,279
well maybe maybe David know is pulling

482
00:18:14,279 --> 00:18:15,809
my chain here is this this is actually

483
00:18:15,809 --> 00:18:17,580
really work for a less trivial thing

484
00:18:17,580 --> 00:18:19,860
than to do MVC so he decided decided to

485
00:18:19,860 --> 00:18:24,179
build a 64 by 64 pixel editor the pixel

486
00:18:24,179 --> 00:18:26,580
surface the frame is represented as an

487
00:18:26,580 --> 00:18:31,799
immutable vector and that's 4096 values

488
00:18:31,799 --> 00:18:34,080
in there that represent pixels so let's

489
00:18:34,080 --> 00:18:37,710
see this guy in action so I can I can

490
00:18:37,710 --> 00:18:39,389
select the color here and then I can you

491
00:18:39,389 --> 00:18:42,239
know start drawing some things on to you

492
00:18:42,239 --> 00:18:45,450
or let's resize that on the right you

493
00:18:45,450 --> 00:18:50,480
should see the history accumulating I

494
00:18:50,480 --> 00:18:54,320
can go over here and I can click undo

495
00:18:54,320 --> 00:19:00,029
and click redo I can I can scrub and you

496
00:19:00,029 --> 00:19:03,539
see the preview on the left oops

497
00:19:03,539 --> 00:19:07,710
to do that and I can you know I can I

498
00:19:07,710 --> 00:19:09,210
could you do this forever I've done it

499
00:19:09,210 --> 00:19:10,950
you know I've done like 200 levels of

500
00:19:10,950 --> 00:19:13,049
undo and the app is still responsive

501
00:19:13,049 --> 00:19:15,830
good memory usage it doesn't slow down

502
00:19:15,830 --> 00:19:19,590
so that's pretty cool so how complicated

503
00:19:19,590 --> 00:19:21,509
was him was it was it for him to

504
00:19:21,509 --> 00:19:23,179
actually implement that functionality

505
00:19:23,179 --> 00:19:27,139
this is the entire code for undo redo

506
00:19:27,139 --> 00:19:30,570
the preview as well as exporting it as

507
00:19:30,570 --> 00:19:32,909
an animated gif these are very simple

508
00:19:32,909 --> 00:19:34,679
functions it's about 60 lines of code

509
00:19:34,679 --> 00:19:36,840
this is a nightmare to do in a mutable

510
00:19:36,840 --> 00:19:39,149
system if you've ever tried that before

511
00:19:39,149 --> 00:19:41,669
it's not fun and how much memory does it

512
00:19:41,669 --> 00:19:43,619
use so if you took an array and you

513
00:19:43,619 --> 00:19:45,809
cloned it 100 times and you because you

514
00:19:45,809 --> 00:19:47,100
wanted to preserve the state of your app

515
00:19:47,100 --> 00:19:49,409
of your frames and you updated one pixel

516
00:19:49,409 --> 00:19:51,779
it takes about 1.7 megabytes to do this

517
00:19:51,779 --> 00:19:53,190
if you do the same thing with a

518
00:19:53,190 --> 00:19:55,200
persistent vector and you snapshot at

519
00:19:55,200 --> 00:19:57,149
100 times you randomly updated a pixel

520
00:19:57,149 --> 00:19:59,309
each time it takes two tenths of a

521
00:19:59,309 --> 00:20:01,169
megabyte it's almost an order of

522
00:20:01,169 --> 00:20:02,999
magnitude memory savings to use

523
00:20:02,999 --> 00:20:04,660
persistent data structures for this

524
00:20:04,660 --> 00:20:06,790
okay so we're getting we're nearing

525
00:20:06,790 --> 00:20:10,000
towards the end so I I use closure and I

526
00:20:10,000 --> 00:20:11,230
use closure script but I also do a lot

527
00:20:11,230 --> 00:20:12,460
of JavaScript but I understand that a

528
00:20:12,460 --> 00:20:13,600
lot of people don't want to do closure

529
00:20:13,600 --> 00:20:15,430
script Lisp is still too crazy for a lot

530
00:20:15,430 --> 00:20:18,100
of people so I spent some time about two

531
00:20:18,100 --> 00:20:19,900
years ago exporting all of closure

532
00:20:19,900 --> 00:20:21,490
scripts data structures as well as the

533
00:20:21,490 --> 00:20:23,110
entire standard library for interacting

534
00:20:23,110 --> 00:20:25,570
with them in a library called Mori if

535
00:20:25,570 --> 00:20:27,880
you want to experiment with like what

536
00:20:27,880 --> 00:20:29,380
type of user interfaces can we build

537
00:20:29,380 --> 00:20:33,310
given the availability of really fast

538
00:20:33,310 --> 00:20:35,830
really expressive persistent data

539
00:20:35,830 --> 00:20:37,240
structures I highly recommend checking

540
00:20:37,240 --> 00:20:39,220
it out I've tried for the most part to

541
00:20:39,220 --> 00:20:41,200
follow conventions that are exist in

542
00:20:41,200 --> 00:20:43,930
lodash and an underscore or what have

543
00:20:43,930 --> 00:20:46,030
you but it does a lot more I mean there

544
00:20:46,030 --> 00:20:46,930
are a lot of data structures we have

545
00:20:46,930 --> 00:20:50,260
sets hashmaps sorted sets sorted maps

546
00:20:50,260 --> 00:20:52,270
the persistent vectors I talked about

547
00:20:52,270 --> 00:20:56,170
and some other things as well and I

548
00:20:56,170 --> 00:20:58,210
actually there's a lot actually there's

549
00:20:58,210 --> 00:20:59,950
a lot of cool possibilities here around

550
00:20:59,950 --> 00:21:02,740
sweet Jas and Mori people have done some

551
00:21:02,740 --> 00:21:05,290
experiments where by using sweet Jas

552
00:21:05,290 --> 00:21:07,540
macros you can instead of having arrays

553
00:21:07,540 --> 00:21:09,790
becoming arrays you can create

554
00:21:09,790 --> 00:21:11,740
persistent vectors and if you have a

555
00:21:11,740 --> 00:21:13,960
little object literal syntax instead it

556
00:21:13,960 --> 00:21:17,920
will produce a a persistent hash map so

557
00:21:17,920 --> 00:21:19,240
that's it hopefully that didn't take too

558
00:21:19,240 --> 00:21:23,740
much time oh thanks

559
00:21:23,740 --> 00:21:33,190
[Music]

560
00:21:33,200 --> 00:21:47,750


