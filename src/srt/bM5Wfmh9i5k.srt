1
00:00:00,290 --> 00:00:23,960

ah there we go hi jas conf Asia I'm

2
00:00:23,960 --> 00:00:27,710
James Kyle i work at facebook i work on

3
00:00:27,710 --> 00:00:29,000
the flow team where we're trying to make

4
00:00:29,000 --> 00:00:30,410
developers happier and more productive

5
00:00:30,410 --> 00:00:33,290
writing JavaScript so that you can all

6
00:00:33,290 --> 00:00:34,880
go out and write more code that we need

7
00:00:34,880 --> 00:00:37,820
to install I also started this project

8
00:00:37,820 --> 00:00:39,410
called Babel which was designed to

9
00:00:39,410 --> 00:00:41,360
convince people they need to install 400

10
00:00:41,360 --> 00:00:43,580
packages so that just so they have

11
00:00:43,580 --> 00:00:46,730
pretty-looking syntax I also helped

12
00:00:46,730 --> 00:00:48,140
build this project called learner so

13
00:00:48,140 --> 00:00:49,460
that's easier to create a bunch of

14
00:00:49,460 --> 00:00:51,260
packages that need to be installed and

15
00:00:51,260 --> 00:00:53,000
then finally I helped launch this

16
00:00:53,000 --> 00:00:55,040
project called yarn which takes the four

17
00:00:55,040 --> 00:00:56,720
billion packages we just created it

18
00:00:56,720 --> 00:00:58,690
makes it way faster to install them

19
00:00:58,690 --> 00:01:00,739
anyways if you wanna make a bad decision

20
00:01:00,739 --> 00:01:02,360
you can follow me on twitter at the

21
00:01:02,360 --> 00:01:06,500
james Kyle this is my first time in

22
00:01:06,500 --> 00:01:09,080
Singapore and I must say it's really

23
00:01:09,080 --> 00:01:13,370
freaking hot I'm dying out there I'm

24
00:01:13,370 --> 00:01:15,110
from Boston so I'm much more comfortable

25
00:01:15,110 --> 00:01:21,380
in weather like this yeah anyways so I

26
00:01:21,380 --> 00:01:24,740
know what you're probably thinking data

27
00:01:24,740 --> 00:01:27,680
structures are awesome and you're right

28
00:01:27,680 --> 00:01:30,500
because they're very important not just

29
00:01:30,500 --> 00:01:33,200
to pass computer science 101 but in

30
00:01:33,200 --> 00:01:35,299
order to be a better programmer knowing

31
00:01:35,299 --> 00:01:37,610
your data structures can help you manage

32
00:01:37,610 --> 00:01:39,950
complexity and make your programs easier

33
00:01:39,950 --> 00:01:42,860
to follow and build highly performant

34
00:01:42,860 --> 00:01:46,280
memory efficient programs the first of

35
00:01:46,280 --> 00:01:48,350
those is I believe to be more important

36
00:01:48,350 --> 00:01:50,810
using the right data structure can

37
00:01:50,810 --> 00:01:52,070
drastically simplify what would

38
00:01:52,070 --> 00:01:54,130
otherwise be really complicated logic

39
00:01:54,130 --> 00:01:56,659
the second point is important too if

40
00:01:56,659 --> 00:01:58,700
performance our memory matters then

41
00:01:58,700 --> 00:02:00,290
using the right data structure is more

42
00:02:00,290 --> 00:02:03,830
than often essential so what are data

43
00:02:03,830 --> 00:02:07,280
structures essentially they are

44
00:02:07,280 --> 00:02:08,899
different methods of storing and

45
00:02:08,899 --> 00:02:10,669
organizing data that serve a number of

46
00:02:10,669 --> 00:02:13,579
different needs data can always be

47
00:02:13,579 --> 00:02:14,210
represented

48
00:02:14,210 --> 00:02:16,370
many different ways however depending on

49
00:02:16,370 --> 00:02:18,770
what your code or what your data is and

50
00:02:18,770 --> 00:02:20,600
what you need to do with it one

51
00:02:20,600 --> 00:02:22,820
representation will pretty much always

52
00:02:22,820 --> 00:02:24,980
be a better choice than the others to

53
00:02:24,980 --> 00:02:26,510
understand why let's first talk about

54
00:02:26,510 --> 00:02:30,530
algorithms algorithms is just a fancy

55
00:02:30,530 --> 00:02:32,360
name for a step-by-step set of

56
00:02:32,360 --> 00:02:34,880
operations to be performed data

57
00:02:34,880 --> 00:02:36,410
structures are often implemented with

58
00:02:36,410 --> 00:02:38,690
algorithms and algorithms I'm go to data

59
00:02:38,690 --> 00:02:41,210
structures and just data structures and

60
00:02:41,210 --> 00:02:43,250
algorithms all the way down until you

61
00:02:43,250 --> 00:02:45,770
reach the tiny microscopic people with

62
00:02:45,770 --> 00:02:46,790
the punch cards that control the

63
00:02:46,790 --> 00:02:50,450
computer yeah it's not by code it's it's

64
00:02:50,450 --> 00:02:54,080
it's these people any given task can be

65
00:02:54,080 --> 00:02:55,580
implemented an infinite number of ways

66
00:02:55,580 --> 00:02:58,130
so for common tasks are often many

67
00:02:58,130 --> 00:02:59,660
different algorithms people have come up

68
00:02:59,660 --> 00:03:02,600
with for example there is an absurd

69
00:03:02,600 --> 00:03:04,700
number of algorithms for sorting a set

70
00:03:04,700 --> 00:03:07,520
of unordered items there's insertion

71
00:03:07,520 --> 00:03:10,460
short there's selection sort merge sort

72
00:03:10,460 --> 00:03:13,810
bubble sort heap sort quicksort

73
00:03:13,810 --> 00:03:19,640
shellsort Tim sort bucket sort and

74
00:03:19,640 --> 00:03:22,640
there's more but you get the point some

75
00:03:22,640 --> 00:03:24,470
of these are significantly faster than

76
00:03:24,470 --> 00:03:27,170
others some use less memory some are

77
00:03:27,170 --> 00:03:28,940
easy to implement some are based of

78
00:03:28,940 --> 00:03:31,490
assumptions about the data set every

79
00:03:31,490 --> 00:03:32,860
single one of these will be better for

80
00:03:32,860 --> 00:03:35,960
something so you'll need to make a

81
00:03:35,960 --> 00:03:38,090
decision based on what your needs are

82
00:03:38,090 --> 00:03:40,160
and for that you'll need a way of

83
00:03:40,160 --> 00:03:42,760
comparing them a way to measure them

84
00:03:42,760 --> 00:03:44,900
when we compare the performance of

85
00:03:44,900 --> 00:03:46,970
algorithms we use a rough measurement of

86
00:03:46,970 --> 00:03:48,350
their average and worst-case performance

87
00:03:48,350 --> 00:03:51,800
using something called big o big o

88
00:03:51,800 --> 00:03:54,530
notation is a way to roughly measure the

89
00:03:54,530 --> 00:03:56,060
performance of algorithms in order to

90
00:03:56,060 --> 00:03:57,980
compare them against one another when

91
00:03:57,980 --> 00:04:00,650
discussing them Big O is a mathematical

92
00:04:00,650 --> 00:04:02,870
notation that we borrowed in computer

93
00:04:02,870 --> 00:04:06,200
science to classify algorithms by how

94
00:04:06,200 --> 00:04:08,210
they respond to the number of items that

95
00:04:08,210 --> 00:04:11,000
you give them there's two primary things

96
00:04:11,000 --> 00:04:13,340
that you measure what they go there's

97
00:04:13,340 --> 00:04:15,470
time complexity which refers to the

98
00:04:15,470 --> 00:04:17,600
total count of operations and algorithm

99
00:04:17,600 --> 00:04:20,590
will perform for a given set of items

100
00:04:20,590 --> 00:04:23,450
and then there's space complexity which

101
00:04:23,450 --> 00:04:25,160
refers to the total memory and algorithm

102
00:04:25,160 --> 00:04:26,630
will take up when running

103
00:04:26,630 --> 00:04:30,350
on a given set of items we measure these

104
00:04:30,350 --> 00:04:33,380
independently from one another because

105
00:04:33,380 --> 00:04:36,020
while an algorithm may perform less

106
00:04:36,020 --> 00:04:38,420
operations than another it may also take

107
00:04:38,420 --> 00:04:41,210
up way more memory depending on what

108
00:04:41,210 --> 00:04:43,640
your requirements are one may be a

109
00:04:43,640 --> 00:04:46,310
better choice in the other so these are

110
00:04:46,310 --> 00:04:48,440
some of the common big O's we have their

111
00:04:48,440 --> 00:04:52,280
name and their number or notation and

112
00:04:52,280 --> 00:04:54,410
how you feel when they show up at your

113
00:04:54,410 --> 00:05:00,080
party uninvited first you have constant

114
00:05:00,080 --> 00:05:02,690
or 0 1 which means it's always going to

115
00:05:02,690 --> 00:05:04,790
take the same amount of operations and

116
00:05:04,790 --> 00:05:06,620
when you see this friend walk in your

117
00:05:06,620 --> 00:05:10,540
leg we need to take a selfie right now

118
00:05:10,540 --> 00:05:14,270
the next is logarithmic or o log of n

119
00:05:14,270 --> 00:05:16,310
which means the number of operations

120
00:05:16,310 --> 00:05:18,680
increases very slowly as you add more

121
00:05:18,680 --> 00:05:20,780
items and when this friend shows up

122
00:05:20,780 --> 00:05:23,420
your leg hey let me get you a drink

123
00:05:23,420 --> 00:05:27,500
let's do this up next is linear or 0 n

124
00:05:27,500 --> 00:05:29,480
which means the number of operations

125
00:05:29,480 --> 00:05:31,310
increases at the same rate as a number

126
00:05:31,310 --> 00:05:33,590
of items and when this person shows up

127
00:05:33,590 --> 00:05:37,100
you're like oh hey how's it going it's

128
00:05:37,100 --> 00:05:39,920
been a while we should catch up later

129
00:05:39,920 --> 00:05:44,840
when you're done running next is linear

130
00:05:44,840 --> 00:05:49,000
if Mick or a log at our 0 n log of n

131
00:05:49,000 --> 00:05:52,340
where the number of operations increases

132
00:05:52,340 --> 00:05:54,320
a bit faster than the rate that linear

133
00:05:54,320 --> 00:05:56,480
does and when this person shows up

134
00:05:56,480 --> 00:05:59,240
you're like who brought them they smell

135
00:05:59,240 --> 00:06:04,640
like soup next is polynomial or 0 n to

136
00:06:04,640 --> 00:06:07,370
the power of 2 where the number of

137
00:06:07,370 --> 00:06:09,680
operations increases exponentially and

138
00:06:09,680 --> 00:06:13,220
quickly gets to be too many when this

139
00:06:13,220 --> 00:06:15,170
person shows up you get all in their

140
00:06:15,170 --> 00:06:17,360
face like salty you're like I don't

141
00:06:17,360 --> 00:06:20,060
remember inviting you I was like really

142
00:06:20,060 --> 00:06:21,620
drunk the other day so maybe I did

143
00:06:21,620 --> 00:06:24,920
invite you then but didn't want you here

144
00:06:24,920 --> 00:06:29,570
and last is factorial or 0 factorial of

145
00:06:29,570 --> 00:06:32,210
n where the number of operations just

146
00:06:32,210 --> 00:06:34,669
shoots like straight up getting into the

147
00:06:34,669 --> 00:06:36,560
billions and trillions and quadriplegic

148
00:06:36,560 --> 00:06:38,840
aliens really really fast and when this

149
00:06:38,840 --> 00:06:40,400
person shows up and you're like

150
00:06:40,400 --> 00:06:42,350
I invite you for a very specific reason

151
00:06:42,350 --> 00:06:44,870
and that reason is I hate your guts so

152
00:06:44,870 --> 00:06:51,350
bye I'm a very mean party person to give

153
00:06:51,350 --> 00:06:53,030
you an idea of how many operations were

154
00:06:53,030 --> 00:06:55,030
talking about let's look at how these

155
00:06:55,030 --> 00:06:57,620
would equal what what these would equal

156
00:06:57,620 --> 00:07:00,830
for a given set of items with five items

157
00:07:00,830 --> 00:07:04,039
nothing is really that bad small number

158
00:07:04,039 --> 00:07:07,460
and we can do lots of operations so but

159
00:07:07,460 --> 00:07:10,759
by 10 items you're already got a pretty

160
00:07:10,759 --> 00:07:13,100
big difference for polynomial starting

161
00:07:13,100 --> 00:07:15,260
the millions of operations but

162
00:07:15,260 --> 00:07:18,490
everything else is mostly acceptable

163
00:07:18,490 --> 00:07:23,240
next ship 20 and it's getting absurd and

164
00:07:23,240 --> 00:07:25,490
then by 30 polynomial is just just

165
00:07:25,490 --> 00:07:28,880
ridiculous and you can already see how

166
00:07:28,880 --> 00:07:30,410
the other ones of those are already

167
00:07:30,410 --> 00:07:32,720
getting to be pretty large numbers for

168
00:07:32,720 --> 00:07:38,870
what could be like pretty low numbers so

169
00:07:38,870 --> 00:07:41,030
with data structures you have four

170
00:07:41,030 --> 00:07:43,460
primary types of actions that you can

171
00:07:43,460 --> 00:07:47,440
perform in sess search insert or delete

172
00:07:47,440 --> 00:07:49,789
and it's important to note that data

173
00:07:49,789 --> 00:07:51,380
structures may be good at one of these

174
00:07:51,380 --> 00:07:55,550
things and not at another and so here

175
00:07:55,550 --> 00:07:56,960
you can see three common types of

176
00:07:56,960 --> 00:08:00,080
ordered data structures arrays linked

177
00:08:00,080 --> 00:08:02,690
lists in binary search trees and you can

178
00:08:02,690 --> 00:08:04,250
see their average time complexity for

179
00:08:04,250 --> 00:08:07,010
the most common operations and here's

180
00:08:07,010 --> 00:08:09,919
them with our party descriptions even

181
00:08:09,919 --> 00:08:12,050
further some actions will have a

182
00:08:12,050 --> 00:08:14,330
different average performance in a

183
00:08:14,330 --> 00:08:16,580
worst-case performance meaning they

184
00:08:16,580 --> 00:08:18,289
perform very differently depending on

185
00:08:18,289 --> 00:08:20,840
the type of data set and sometimes

186
00:08:20,840 --> 00:08:23,150
random things are thrown in there but

187
00:08:23,150 --> 00:08:25,490
there is no perfect data structure and

188
00:08:25,490 --> 00:08:27,560
you choose one over the other based on

189
00:08:27,560 --> 00:08:29,150
the data that you're working with and

190
00:08:29,150 --> 00:08:30,620
the things that you're going to do with

191
00:08:30,620 --> 00:08:33,169
it this is why it's very important to

192
00:08:33,169 --> 00:08:35,029
know a number of different common data

193
00:08:35,029 --> 00:08:36,770
structures so that you can choose from

194
00:08:36,770 --> 00:08:38,330
them and know what you're getting

195
00:08:38,330 --> 00:08:42,169
yourself into a computer's memory is

196
00:08:42,169 --> 00:08:44,779
pretty boring it's just a bunch of

197
00:08:44,779 --> 00:08:46,160
ordered slots where you can store

198
00:08:46,160 --> 00:08:49,100
information you hold on to memory

199
00:08:49,100 --> 00:08:53,610
addresses in order to find information

200
00:08:53,620 --> 00:08:55,660
let's imagine a chunk of memory like

201
00:08:55,660 --> 00:08:59,050
this if you've ever wondered why things

202
00:08:59,050 --> 00:09:00,940
in programming languages are zero index

203
00:09:00,940 --> 00:09:03,040
sort of works kind of like memory in

204
00:09:03,040 --> 00:09:05,620
terms of like it starts at zero but ends

205
00:09:05,620 --> 00:09:09,510
at one so that's like the first item and

206
00:09:09,510 --> 00:09:12,250
so when we're reading a block of memory

207
00:09:12,250 --> 00:09:15,040
we're reading the space between 0 and 1

208
00:09:15,040 --> 00:09:19,360
or 1 and 2 and so on your computer

209
00:09:19,360 --> 00:09:21,660
obviously has way more memory than this

210
00:09:21,660 --> 00:09:24,670
we have to have some space to store all

211
00:09:24,670 --> 00:09:30,070
that JavaScript cached by code but it's

212
00:09:30,070 --> 00:09:31,750
pretty much a continuation of the

213
00:09:31,750 --> 00:09:34,930
pattern above memory is a bit like the

214
00:09:34,930 --> 00:09:37,420
Wild West every program running on your

215
00:09:37,420 --> 00:09:39,730
machine is stored in this same physical

216
00:09:39,730 --> 00:09:42,130
data structure and without layers of

217
00:09:42,130 --> 00:09:43,779
abstraction over it it can be pretty

218
00:09:43,779 --> 00:09:46,600
difficult to use and these abstractions

219
00:09:46,600 --> 00:09:49,750
serve two additional purposes storing

220
00:09:49,750 --> 00:09:51,670
data in memory in a way that is more

221
00:09:51,670 --> 00:09:53,740
efficient or faster to work with and

222
00:09:53,740 --> 00:09:55,660
storing data in a way that makes it

223
00:09:55,660 --> 00:09:59,950
easier to use so now that we've covered

224
00:09:59,950 --> 00:10:02,170
a lot of the basics I want to dive into

225
00:10:02,170 --> 00:10:04,570
some actual data structures and we're

226
00:10:04,570 --> 00:10:07,029
going to quickly cover lists hash tables

227
00:10:07,029 --> 00:10:10,570
stacks queues graphs linked lists trees

228
00:10:10,570 --> 00:10:14,290
and binary search trees we go through a

229
00:10:14,290 --> 00:10:15,970
lot of stuff and don't worry about

230
00:10:15,970 --> 00:10:18,040
understanding all of this code it's

231
00:10:18,040 --> 00:10:19,959
really only there to act as an aid to

232
00:10:19,959 --> 00:10:22,360
the things that I'm saying they're not

233
00:10:22,360 --> 00:10:23,589
even like really feature complete

234
00:10:23,589 --> 00:10:25,959
implementations so don't really worry

235
00:10:25,959 --> 00:10:29,770
about it but let's get into it so to

236
00:10:29,770 --> 00:10:31,959
demonstrate the raw interaction between

237
00:10:31,959 --> 00:10:33,610
memory and the data structure we're

238
00:10:33,610 --> 00:10:36,459
going to first implement a list list is

239
00:10:36,459 --> 00:10:38,410
a representation of an ordered sequence

240
00:10:38,410 --> 00:10:40,839
of values where the same value may

241
00:10:40,839 --> 00:10:45,130
appear many times because lists have an

242
00:10:45,130 --> 00:10:48,279
order you can insert insert stuff at the

243
00:10:48,279 --> 00:10:51,160
start middle or end of them for our

244
00:10:51,160 --> 00:10:52,839
implementation we're going to focus on

245
00:10:52,839 --> 00:10:54,970
adding and removing values from the

246
00:10:54,970 --> 00:10:56,740
start and end of our list using these

247
00:10:56,740 --> 00:10:59,580
four methods push pop on shift and shift

248
00:10:59,580 --> 00:11:01,839
which you should hope all hopefully be

249
00:11:01,839 --> 00:11:04,060
familiar with because I'm assuming most

250
00:11:04,060 --> 00:11:05,440
of you write JavaScript since you're

251
00:11:05,440 --> 00:11:08,540
here

252
00:11:08,550 --> 00:11:11,410
starting with push we need a way to add

253
00:11:11,410 --> 00:11:16,089
items to the end of our list actually

254
00:11:16,089 --> 00:11:19,710
skipped a bit here let me go back sorry

255
00:11:19,710 --> 00:11:22,690
we're gonna in our list we're going to

256
00:11:22,690 --> 00:11:25,420
start with a empty block of memory which

257
00:11:25,420 --> 00:11:26,560
we're just going to represent with a

258
00:11:26,560 --> 00:11:28,750
JavaScript array and we're also going to

259
00:11:28,750 --> 00:11:32,080
store the length of the list note that

260
00:11:32,080 --> 00:11:33,850
we want to store the length separately

261
00:11:33,850 --> 00:11:35,500
because in real life memory doesn't

262
00:11:35,500 --> 00:11:37,270
really have a length that you can read

263
00:11:37,270 --> 00:11:40,839
from so you want to remember that so

264
00:11:40,839 --> 00:11:42,610
starting with push we need a way to add

265
00:11:42,610 --> 00:11:44,890
items to the end of our list it's as

266
00:11:44,890 --> 00:11:47,050
simple as adding a value to the address

267
00:11:47,050 --> 00:11:49,510
at the end of our list and because we

268
00:11:49,510 --> 00:11:51,040
store it the length it's easy to

269
00:11:51,040 --> 00:11:52,960
calculate we just add the value and

270
00:11:52,960 --> 00:11:56,290
increment our length pushing an item to

271
00:11:56,290 --> 00:12:00,160
the end of the list is constant next we

272
00:12:00,160 --> 00:12:02,140
need to wait to pop items off the end of

273
00:12:02,140 --> 00:12:04,330
our list similar to push all we need is

274
00:12:04,330 --> 00:12:07,029
to remove the value at the address at

275
00:12:07,029 --> 00:12:08,260
the end of our list and then just

276
00:12:08,260 --> 00:12:10,990
decrement the length popping an item

277
00:12:10,990 --> 00:12:13,950
from the end of list is also constant

278
00:12:13,950 --> 00:12:17,170
push in pop both operate on the end of

279
00:12:17,170 --> 00:12:19,209
the list in our overall pretty simple

280
00:12:19,209 --> 00:12:20,800
operations because they don't need to be

281
00:12:20,800 --> 00:12:23,770
concerned with the rest of the list but

282
00:12:23,770 --> 00:12:25,300
let's see what happens when we operate

283
00:12:25,300 --> 00:12:26,589
at the beginning of the list with

284
00:12:26,589 --> 00:12:31,180
unshifted shift in order to add a new

285
00:12:31,180 --> 00:12:32,920
item at the beginning of the list we

286
00:12:32,920 --> 00:12:35,050
need to make room for our value we can't

287
00:12:35,050 --> 00:12:36,670
just keep going past the beginning of

288
00:12:36,670 --> 00:12:40,600
memory so we do this by shifting all of

289
00:12:40,600 --> 00:12:44,500
the items in our lists over by one in

290
00:12:44,500 --> 00:12:47,290
order to slide all of the items over we

291
00:12:47,290 --> 00:12:50,620
need to iterate over each one moving the

292
00:12:50,620 --> 00:12:53,860
previous value over because we have to

293
00:12:53,860 --> 00:12:56,589
over iterate over every single item in

294
00:12:56,589 --> 00:12:58,810
the list on shifting an item from the

295
00:12:58,810 --> 00:13:03,209
start of a list is linear so that o n

296
00:13:03,209 --> 00:13:06,730
first we start with the value at the

297
00:13:06,730 --> 00:13:08,770
beginning the list we iterate through

298
00:13:08,770 --> 00:13:11,709
each item replacing the current value

299
00:13:11,709 --> 00:13:14,530
with the previous value and storing the

300
00:13:14,530 --> 00:13:17,250
current value for the next iteration and

301
00:13:17,250 --> 00:13:20,170
then finally we just add the last item

302
00:13:20,170 --> 00:13:21,940
new position which is the start of our

303
00:13:21,940 --> 00:13:25,720
list and increment length finally when

304
00:13:25,720 --> 00:13:27,250
you write a shift function or to move in

305
00:13:27,250 --> 00:13:29,410
the opposite direction we delete the

306
00:13:29,410 --> 00:13:31,959
first value and then slide through every

307
00:13:31,959 --> 00:13:34,450
single item in a list to move it down

308
00:13:34,450 --> 00:13:39,550
one address shift is pretty much

309
00:13:39,550 --> 00:13:42,790
identical to on shift except backwards

310
00:13:42,790 --> 00:13:45,880
so the code is very similar and again

311
00:13:45,880 --> 00:13:48,010
shifting an item from the start of the

312
00:13:48,010 --> 00:13:53,230
list is linear so lists are great for

313
00:13:53,230 --> 00:13:55,779
fast access and dealing with items at

314
00:13:55,779 --> 00:13:58,360
the end of the list however as we've

315
00:13:58,360 --> 00:13:59,709
seen it's not great at dealing with

316
00:13:59,709 --> 00:14:01,570
items that are not at the end of the

317
00:14:01,570 --> 00:14:03,790
list and we have to manually hold on to

318
00:14:03,790 --> 00:14:07,120
memory addresses so let's take a look at

319
00:14:07,120 --> 00:14:08,920
a different data structure and see how

320
00:14:08,920 --> 00:14:11,199
it deals with adding accessing removing

321
00:14:11,199 --> 00:14:13,089
values without needing to know memory

322
00:14:13,089 --> 00:14:16,779
addresses so we'll talk about hash

323
00:14:16,779 --> 00:14:20,110
tables so hash tables don't have any

324
00:14:20,110 --> 00:14:23,260
order to them instead we have keys and

325
00:14:23,260 --> 00:14:26,490
values or a computed address in memory

326
00:14:26,490 --> 00:14:33,910
is its computed by the using the key so

327
00:14:33,910 --> 00:14:36,070
this is exactly what objects are in

328
00:14:36,070 --> 00:14:39,760
JavaScript the idea is that we have keys

329
00:14:39,760 --> 00:14:42,160
that are hashable which we'll get to in

330
00:14:42,160 --> 00:14:46,209
a second and can be used to add access

331
00:14:46,209 --> 00:14:49,990
and remove data very efficiently again

332
00:14:49,990 --> 00:14:51,190
we're just going to use a plain

333
00:14:51,190 --> 00:14:54,839
JavaScript array to represent our memory

334
00:14:54,839 --> 00:14:57,970
in order to store key value pairs in

335
00:14:57,970 --> 00:14:59,620
memory from our hash table we're going

336
00:14:59,620 --> 00:15:01,360
to need a way to turn them into an

337
00:15:01,360 --> 00:15:03,519
address we do this through an operation

338
00:15:03,519 --> 00:15:08,410
known as hashing all that happens is it

339
00:15:08,410 --> 00:15:10,540
takes a key and serialize it into a

340
00:15:10,540 --> 00:15:13,180
unique number for that key you have to

341
00:15:13,180 --> 00:15:15,459
be careful though if you had a really

342
00:15:15,459 --> 00:15:18,069
big key you don't want to member match

343
00:15:18,069 --> 00:15:19,600
it to a memory address that doesn't

344
00:15:19,600 --> 00:15:22,300
exist so the hashing algorithm needs to

345
00:15:22,300 --> 00:15:24,339
limit the size which means there's a

346
00:15:24,339 --> 00:15:27,399
limited number of addresses for an

347
00:15:27,399 --> 00:15:31,300
unlimited number of key value pairs the

348
00:15:31,300 --> 00:15:32,680
result is that you can end up with

349
00:15:32,680 --> 00:15:33,740
collisions

350
00:15:33,740 --> 00:15:35,660
places where two keys get turned into

351
00:15:35,660 --> 00:15:39,020
the same address any real world hash

352
00:15:39,020 --> 00:15:40,880
table implementation would have to deal

353
00:15:40,880 --> 00:15:42,830
with this however we're just going to

354
00:15:42,830 --> 00:15:44,150
kind of glaze over it and pretend that

355
00:15:44,150 --> 00:15:47,960
doesn't happen so let's set up our hash

356
00:15:47,960 --> 00:15:52,310
key function don't understand don't

357
00:15:52,310 --> 00:15:54,020
worry about understanding the logic of

358
00:15:54,020 --> 00:15:56,210
this function just know that it accepts

359
00:15:56,210 --> 00:15:58,730
a string and outputs a mostly unique

360
00:15:58,730 --> 00:16:01,310
address that we will use in our other

361
00:16:01,310 --> 00:16:07,370
functions next let's define our get

362
00:16:07,370 --> 00:16:08,990
function so that we have a way of

363
00:16:08,990 --> 00:16:12,110
accessing values by their key hash table

364
00:16:12,110 --> 00:16:16,730
access is constant yeah so we turn the

365
00:16:16,730 --> 00:16:18,260
key into an address and then get that

366
00:16:18,260 --> 00:16:22,370
address we also need a way of adding

367
00:16:22,370 --> 00:16:24,830
data before we access it so we create a

368
00:16:24,830 --> 00:16:27,590
set function that inserts value that

369
00:16:27,590 --> 00:16:29,480
does basically the same thing except

370
00:16:29,480 --> 00:16:32,660
setting at this time and setting and a

371
00:16:32,660 --> 00:16:36,170
hash table is constant friendly we need

372
00:16:36,170 --> 00:16:38,420
a way to remove items from our hash

373
00:16:38,420 --> 00:16:42,260
table which is just deleting the value

374
00:16:42,260 --> 00:16:43,640
at the memory address that was

375
00:16:43,640 --> 00:16:46,340
calculated by our hash key function in

376
00:16:46,340 --> 00:16:50,870
this operation is also constant from

377
00:16:50,870 --> 00:16:53,330
this point forward we're going to stop

378
00:16:53,330 --> 00:16:55,670
interacting directly with memory as the

379
00:16:55,670 --> 00:16:57,260
rest of these data structures start to

380
00:16:57,260 --> 00:16:58,910
be implemented with other data

381
00:16:58,910 --> 00:17:01,970
structures these data structures focus

382
00:17:01,970 --> 00:17:04,880
on doing two things organizing data

383
00:17:04,880 --> 00:17:07,580
based on how it's used and abstracting

384
00:17:07,580 --> 00:17:10,850
away implementation details these data

385
00:17:10,850 --> 00:17:12,320
structures focus on creating an

386
00:17:12,320 --> 00:17:14,210
organization which makes sense for

387
00:17:14,210 --> 00:17:16,880
various types of programs they insert a

388
00:17:16,880 --> 00:17:18,800
language that allows you to discuss more

389
00:17:18,800 --> 00:17:20,990
complicated logic all well abstracting

390
00:17:20,990 --> 00:17:23,240
away implementation details so that the

391
00:17:23,240 --> 00:17:25,010
implementation can change to be made

392
00:17:25,010 --> 00:17:30,680
much faster so stacks are similar to

393
00:17:30,680 --> 00:17:33,170
lists in that they have in order but

394
00:17:33,170 --> 00:17:34,850
they limit you to only pushing and

395
00:17:34,850 --> 00:17:36,440
popping values at the end of our list

396
00:17:36,440 --> 00:17:39,530
which as we saw before are very fast

397
00:17:39,530 --> 00:17:41,330
operations when mapping directly to

398
00:17:41,330 --> 00:17:44,780
memory however stacks can also be

399
00:17:44,780 --> 00:17:46,580
implemented with other data structures

400
00:17:46,580 --> 00:17:47,420
in order to add

401
00:17:47,420 --> 00:17:50,000
functionality to them the most common

402
00:17:50,000 --> 00:17:53,240
usage of stacks is places where you have

403
00:17:53,240 --> 00:17:55,940
one process adding items to the stack in

404
00:17:55,940 --> 00:17:57,260
another process removing them from the

405
00:17:57,260 --> 00:17:59,420
end prioritizing the items that were

406
00:17:59,420 --> 00:18:03,080
added most recently we're going to again

407
00:18:03,080 --> 00:18:05,690
be backed by a JavaScript array but this

408
00:18:05,690 --> 00:18:08,060
time it represents a list that we

409
00:18:08,060 --> 00:18:09,740
implemented before and rather than the

410
00:18:09,740 --> 00:18:16,010
memory that we were using often times

411
00:18:16,010 --> 00:18:17,980
people don't implement it with a list

412
00:18:17,980 --> 00:18:20,060
but we're going to you for the sake of

413
00:18:20,060 --> 00:18:24,020
this and we're going to implement the

414
00:18:24,020 --> 00:18:26,690
two functions from lists push and pop

415
00:18:26,690 --> 00:18:28,730
which are going to be identical in terms

416
00:18:28,730 --> 00:18:32,900
of functionality we push items to the

417
00:18:32,900 --> 00:18:36,140
top of the stack and pop items to remove

418
00:18:36,140 --> 00:18:37,610
items from the talk of the top of the

419
00:18:37,610 --> 00:18:40,250
stack we're also going to add a function

420
00:18:40,250 --> 00:18:42,350
just in order to view the item at the

421
00:18:42,350 --> 00:18:43,850
top of the stack without removing it

422
00:18:43,850 --> 00:18:48,290
from the stack next we're going to build

423
00:18:48,290 --> 00:18:50,330
a queue which is sort of complementary

424
00:18:50,330 --> 00:18:54,350
to a stack the difference is that this

425
00:18:54,350 --> 00:18:56,120
time you remove items from the start of

426
00:18:56,120 --> 00:18:59,330
the queue rather than the end removing

427
00:18:59,330 --> 00:19:00,920
the oldest items rather than the most

428
00:19:00,920 --> 00:19:04,400
recent again because this limits the

429
00:19:04,400 --> 00:19:06,140
amount of functionality there are many

430
00:19:06,140 --> 00:19:08,420
different ways of implementing it a good

431
00:19:08,420 --> 00:19:11,480
way might be a good way might to be used

432
00:19:11,480 --> 00:19:14,450
a linked list which will see a little

433
00:19:14,450 --> 00:19:17,570
bit later again our queue is just using

434
00:19:17,570 --> 00:19:19,400
a JavaScript array rather as a list

435
00:19:19,400 --> 00:19:22,310
rather than memory similar to stacks

436
00:19:22,310 --> 00:19:23,930
we're going to find two functions for

437
00:19:23,930 --> 00:19:25,760
adding and removing items from the queue

438
00:19:25,760 --> 00:19:28,700
the first is NQ that will push items to

439
00:19:28,700 --> 00:19:32,450
the end of our list in DQ which instead

440
00:19:32,450 --> 00:19:33,650
of removing them from the Edit list

441
00:19:33,650 --> 00:19:35,020
we're gonna remove them from the start

442
00:19:35,020 --> 00:19:37,970
and you could see we're using the shift

443
00:19:37,970 --> 00:19:39,410
function there which as I mentioned was

444
00:19:39,410 --> 00:19:42,350
not very fast but we're abstracting away

445
00:19:42,350 --> 00:19:45,830
to this functionality so that it could

446
00:19:45,830 --> 00:19:48,470
be implemented in many other ways and

447
00:19:48,470 --> 00:19:49,640
again we're just going to find a peek

448
00:19:49,640 --> 00:19:51,890
function from viewing the next item the

449
00:19:51,890 --> 00:19:55,100
queue the important thing to note here

450
00:19:55,100 --> 00:20:00,560
is again that we use a list of a car q

451
00:20:00,560 --> 00:20:01,240
in

452
00:20:01,240 --> 00:20:05,020
that performance of shift and you can

453
00:20:05,020 --> 00:20:08,110
use a linked list which we'll get to in

454
00:20:08,110 --> 00:20:11,350
a few seconds the next station structure

455
00:20:11,350 --> 00:20:13,570
is graphs note that these are very

456
00:20:13,570 --> 00:20:16,060
different than a visual graph that you

457
00:20:16,060 --> 00:20:19,480
would use to represent data instead

458
00:20:19,480 --> 00:20:22,450
imagine it like this we have a bunch of

459
00:20:22,450 --> 00:20:26,140
nodes ABCD and E that are connected with

460
00:20:26,140 --> 00:20:30,270
lines that sort of point to one another

461
00:20:30,270 --> 00:20:32,530
these nodes are going to look like this

462
00:20:32,530 --> 00:20:35,050
where they have a value and a set of

463
00:20:35,050 --> 00:20:36,910
lines that they're pointing to other

464
00:20:36,910 --> 00:20:40,300
nodes and the entire graph will look

465
00:20:40,300 --> 00:20:41,950
like this and it's going to just have

466
00:20:41,950 --> 00:20:44,890
all the nodes which will contain

467
00:20:44,890 --> 00:20:49,210
references to one another will hold on

468
00:20:49,210 --> 00:20:51,250
to all of our nodes in a regular

469
00:20:51,250 --> 00:20:53,380
JavaScript array not because there's any

470
00:20:53,380 --> 00:20:55,300
particular of order to the nodes but

471
00:20:55,300 --> 00:20:56,830
because we just need a way of storing

472
00:20:56,830 --> 00:21:01,870
them as references for everything we can

473
00:21:01,870 --> 00:21:03,940
start to add values to our graph by

474
00:21:03,940 --> 00:21:09,100
creating nodes without any lines next we

475
00:21:09,100 --> 00:21:10,960
need to be able to look up nodes in the

476
00:21:10,960 --> 00:21:13,090
graph most of the time you'll have a

477
00:21:13,090 --> 00:21:14,920
different data structure on top of the

478
00:21:14,920 --> 00:21:16,690
graph in order to make searching faster

479
00:21:16,690 --> 00:21:18,040
because otherwise you're just searching

480
00:21:18,040 --> 00:21:19,270
through every single node and that's

481
00:21:19,270 --> 00:21:22,090
kind of slow but for our case we're just

482
00:21:22,090 --> 00:21:23,410
simply going to go through every single

483
00:21:23,410 --> 00:21:25,870
node that we have and try matching the

484
00:21:25,870 --> 00:21:30,580
value next we can connect two nodes by

485
00:21:30,580 --> 00:21:33,940
making a line from one another we're

486
00:21:33,940 --> 00:21:35,980
going to find the nodes for each value

487
00:21:35,980 --> 00:21:38,470
that we have and then we're going to

488
00:21:38,470 --> 00:21:39,700
freak out if we don't have one on the

489
00:21:39,700 --> 00:21:43,180
other and finally we're going to add a

490
00:21:43,180 --> 00:21:45,310
reference to the end node from the start

491
00:21:45,310 --> 00:21:50,650
node finally you can use a graph like

492
00:21:50,650 --> 00:21:54,100
this this might seem like a lot of work

493
00:21:54,100 --> 00:21:56,320
to do very little but it's actually

494
00:21:56,320 --> 00:21:58,600
quite powerful pattern especially for

495
00:21:58,600 --> 00:22:00,160
finding sanity and really complex

496
00:22:00,160 --> 00:22:03,460
programs they do this by optima

497
00:22:03,460 --> 00:22:05,200
optimizing for the connections between

498
00:22:05,200 --> 00:22:07,600
data rather than operating on the data

499
00:22:07,600 --> 00:22:10,150
itself once you have a node in the graph

500
00:22:10,150 --> 00:22:12,010
it's really simple to find all the

501
00:22:12,010 --> 00:22:13,990
related items in the graph

502
00:22:13,990 --> 00:22:16,330
tons of things can be you can be

503
00:22:16,330 --> 00:22:19,300
represented this way users with friends

504
00:22:19,300 --> 00:22:21,970
the 800 transitive dependencies we have

505
00:22:21,970 --> 00:22:24,400
in a node modules folder the internet

506
00:22:24,400 --> 00:22:26,500
self is a graph of web pages connected

507
00:22:26,500 --> 00:22:30,700
together by links in next we're going to

508
00:22:30,700 --> 00:22:32,860
see how a graph like data structure can

509
00:22:32,860 --> 00:22:38,110
optimize an ordered list of data linked

510
00:22:38,110 --> 00:22:40,210
lists are a pretty common data structure

511
00:22:40,210 --> 00:22:42,460
it's often used to implement the other

512
00:22:42,460 --> 00:22:43,690
data structures as I mentioned before

513
00:22:43,690 --> 00:22:45,610
because of its ability to efficiently

514
00:22:45,610 --> 00:22:48,280
add items at the start middle or end of

515
00:22:48,280 --> 00:22:51,340
list the basic idea of linked lists is

516
00:22:51,340 --> 00:22:53,800
similar to a graph you have nodes that

517
00:22:53,800 --> 00:22:55,570
point to other nodes that sort of look

518
00:22:55,570 --> 00:23:00,070
like this and visualizing them as a data

519
00:23:00,070 --> 00:23:01,990
structure that looks like this where we

520
00:23:01,990 --> 00:23:03,820
have the value that points the next

521
00:23:03,820 --> 00:23:05,620
value which point to the next value but

522
00:23:05,620 --> 00:23:09,880
what's the next one unlike a graph a

523
00:23:09,880 --> 00:23:11,650
linked list has a single node that

524
00:23:11,650 --> 00:23:13,960
starts off the entire chain this is

525
00:23:13,960 --> 00:23:15,870
known as the head of the linked list

526
00:23:15,870 --> 00:23:18,790
we're also going to drink the track the

527
00:23:18,790 --> 00:23:23,710
length of the list here oops first we

528
00:23:23,710 --> 00:23:26,140
need a way to retrieve a value for in a

529
00:23:26,140 --> 00:23:28,510
given position this works differently

530
00:23:28,510 --> 00:23:31,030
than normal list because we can't just

531
00:23:31,030 --> 00:23:33,520
jump to the correct position instead we

532
00:23:33,520 --> 00:23:34,750
need to move through the individual

533
00:23:34,750 --> 00:23:38,200
nodes will start with the head of our

534
00:23:38,200 --> 00:23:40,420
list and then slide through all of the

535
00:23:40,420 --> 00:23:42,550
items using node next until we've

536
00:23:42,550 --> 00:23:45,640
reached a specified position and then

537
00:23:45,640 --> 00:23:48,900
we'll just return the node that we found

538
00:23:48,900 --> 00:23:51,640
next we need a way to add nodes to a

539
00:23:51,640 --> 00:23:54,309
specified position we're going for a

540
00:23:54,309 --> 00:23:56,530
generic add method that accepts a value

541
00:23:56,530 --> 00:24:00,309
into position first we create a node to

542
00:24:00,309 --> 00:24:03,309
hold our value and then we need to have

543
00:24:03,309 --> 00:24:05,290
a special case for nodes that are being

544
00:24:05,290 --> 00:24:08,800
inserted at the head will set the next

545
00:24:08,800 --> 00:24:10,870
field from the current head and replace

546
00:24:10,870 --> 00:24:15,550
it with our new node otherwise if we're

547
00:24:15,550 --> 00:24:18,160
adding a note in any other position we

548
00:24:18,160 --> 00:24:19,720
need to splice it in between the current

549
00:24:19,720 --> 00:24:22,450
node in the previous node so we just

550
00:24:22,450 --> 00:24:24,760
sort of like split it apart and link it

551
00:24:24,760 --> 00:24:27,490
back together

552
00:24:27,500 --> 00:24:29,940
so we find the previous node in our

553
00:24:29,940 --> 00:24:33,899
current node we insert the new node in

554
00:24:33,899 --> 00:24:36,720
by between them by setting its next

555
00:24:36,720 --> 00:24:38,399
fields the current node and updating the

556
00:24:38,399 --> 00:24:41,000
previous nodes next field to the new one

557
00:24:41,000 --> 00:24:43,470
and then finally we just increment the

558
00:24:43,470 --> 00:24:46,950
length the last method we need is a

559
00:24:46,950 --> 00:24:48,960
remove method we're just going to go

560
00:24:48,960 --> 00:24:52,380
look up a node by its position and

561
00:24:52,380 --> 00:24:55,620
splice it out of the chain again if

562
00:24:55,620 --> 00:24:57,450
we're removing the first node we simply

563
00:24:57,450 --> 00:24:59,250
need to set the head to our new to the

564
00:24:59,250 --> 00:25:03,090
next node in the chain for any other

565
00:25:03,090 --> 00:25:04,679
position we need to look up the previous

566
00:25:04,679 --> 00:25:06,750
node and set it to the node after the

567
00:25:06,750 --> 00:25:09,210
current position and then we're just

568
00:25:09,210 --> 00:25:13,139
going to decrement the length so the

569
00:25:13,139 --> 00:25:14,730
remaining two data structures we're

570
00:25:14,730 --> 00:25:16,500
going to cover are both in the tree

571
00:25:16,500 --> 00:25:20,519
family much in like real life there are

572
00:25:20,519 --> 00:25:24,440
many different types of trees like a lot

573
00:25:24,440 --> 00:25:26,490
little did you know you'd be studying

574
00:25:26,490 --> 00:25:29,309
dendrology today and that's not even all

575
00:25:29,309 --> 00:25:31,470
of them but don't let this scare you

576
00:25:31,470 --> 00:25:34,169
most of those don't matter at all there

577
00:25:34,169 --> 00:25:36,149
was just a lot of computer science PhDs

578
00:25:36,149 --> 00:25:41,399
who had something to prove trees are

579
00:25:41,399 --> 00:25:43,620
much like graphs or linked lists and

580
00:25:43,620 --> 00:25:45,870
that they are you need directional all

581
00:25:45,870 --> 00:25:47,820
this means is that I can't have loops in

582
00:25:47,820 --> 00:25:51,029
their references if you can draw a loop

583
00:25:51,029 --> 00:25:53,730
between connected nodes in a tree well

584
00:25:53,730 --> 00:25:56,029
you don't have a tree you have a graph

585
00:25:56,029 --> 00:25:59,279
trees have many different use cases they

586
00:25:59,279 --> 00:26:01,529
can be used to optimize searching or

587
00:26:01,529 --> 00:26:03,630
sorting they can organize programs

588
00:26:03,630 --> 00:26:04,710
better they can give you a

589
00:26:04,710 --> 00:26:06,179
representation that's easier to work

590
00:26:06,179 --> 00:26:10,139
with we're going to start off with a

591
00:26:10,139 --> 00:26:15,059
extremely simple tree structure it

592
00:26:15,059 --> 00:26:16,710
doesn't have any special rules to it and

593
00:26:16,710 --> 00:26:18,090
it looks something like this where we

594
00:26:18,090 --> 00:26:20,130
have a root and a value with children

595
00:26:20,130 --> 00:26:22,590
with values and more children so when

596
00:26:22,590 --> 00:26:26,639
they keep going that way the tree has to

597
00:26:26,639 --> 00:26:28,679
start with a single parent or the root

598
00:26:28,679 --> 00:26:32,820
of the tree we need a way to reverse our

599
00:26:32,820 --> 00:26:35,190
tree and call a function on each node in

600
00:26:35,190 --> 00:26:38,250
the tree will define a walk function

601
00:26:38,250 --> 00:26:39,690
that will call recursively on

602
00:26:39,690 --> 00:26:42,720
every single node in the tree it'll

603
00:26:42,720 --> 00:26:45,570
first call the callback on the node and

604
00:26:45,570 --> 00:26:47,730
then recursively call the walk function

605
00:26:47,730 --> 00:26:50,190
on all of its children and then we just

606
00:26:50,190 --> 00:26:51,960
kick the traversal process off at the

607
00:26:51,960 --> 00:26:56,039
root next we need a way to add nodes to

608
00:26:56,039 --> 00:26:59,220
our tree first we create the node that

609
00:26:59,220 --> 00:27:02,129
we're going to add if there's no route

610
00:27:02,129 --> 00:27:04,980
we just set it to a new node otherwise

611
00:27:04,980 --> 00:27:07,440
we traverse the entire tree and find a

612
00:27:07,440 --> 00:27:09,840
node with a matching value and add the

613
00:27:09,840 --> 00:27:14,309
new node to its children so this is one

614
00:27:14,309 --> 00:27:15,990
of the most basic trees that you could

615
00:27:15,990 --> 00:27:18,960
possibly have it's probably only useful

616
00:27:18,960 --> 00:27:21,149
if the data you're representing actually

617
00:27:21,149 --> 00:27:24,779
resembles a tree identical to this but

618
00:27:24,779 --> 00:27:26,970
with some extra rules a tree can serve a

619
00:27:26,970 --> 00:27:30,809
lot of different purposes binary search

620
00:27:30,809 --> 00:27:33,450
trees are a fairly common form of tree

621
00:27:33,450 --> 00:27:35,399
for their ability to efficiently access

622
00:27:35,399 --> 00:27:38,220
search insert and delete values all

623
00:27:38,220 --> 00:27:42,100
while keeping them in a sorted order

624
00:27:42,110 --> 00:27:45,919
imagine taking a sequence of numbers and

625
00:27:45,919 --> 00:27:48,179
then just turning them into a tree

626
00:27:48,179 --> 00:27:52,440
starting from the center this is how a

627
00:27:52,440 --> 00:27:55,320
binary tree works each node can have two

628
00:27:55,320 --> 00:27:57,899
children the left which is less than the

629
00:27:57,899 --> 00:27:59,759
parent nodes value and the right which

630
00:27:59,759 --> 00:28:01,909
is greater than the parent nodes value

631
00:28:01,909 --> 00:28:05,370
note that in order to make this work all

632
00:28:05,370 --> 00:28:08,009
values must be unique in the tree you

633
00:28:08,009 --> 00:28:09,629
can't have two fives because they would

634
00:28:09,629 --> 00:28:13,710
fall in the same position this makes

635
00:28:13,710 --> 00:28:16,139
traversal to find a value very efficient

636
00:28:16,139 --> 00:28:18,090
say we're trying to find the number five

637
00:28:18,090 --> 00:28:21,240
in our tree we go start at four and we

638
00:28:21,240 --> 00:28:23,220
say five is greater than four so we move

639
00:28:23,220 --> 00:28:25,860
right five is less than six so we move

640
00:28:25,860 --> 00:28:28,200
less and then boom we reach tree or

641
00:28:28,200 --> 00:28:31,769
reached five notice how we only had to

642
00:28:31,769 --> 00:28:33,379
do three checks to reach the number five

643
00:28:33,379 --> 00:28:36,259
if we were to expand this to a tree of

644
00:28:36,259 --> 00:28:41,789
1,000 items we'd go 500 to 250 to 125 to

645
00:28:41,789 --> 00:28:47,119
62 230 12 15 27 23 24 25 and that's

646
00:28:47,119 --> 00:28:49,049
sound like a lot but it's only ten

647
00:28:49,049 --> 00:28:53,140
checks to go placed in 1,000 items

648
00:28:53,140 --> 00:28:58,300
and while it would have been faster if

649
00:28:58,300 --> 00:29:01,900
we just went 1 2 3 4 5 in general if we

650
00:29:01,900 --> 00:29:05,800
were going to 999 that would have been

651
00:29:05,800 --> 00:29:09,550
909 checks down to 10 that's where 0 and

652
00:29:09,550 --> 00:29:13,420
comes from the other important thing to

653
00:29:13,420 --> 00:29:15,640
note about binary search trees is that

654
00:29:15,640 --> 00:29:17,380
they're very similar to linked lists and

655
00:29:17,380 --> 00:29:19,630
that they in the sense you only need to

656
00:29:19,630 --> 00:29:21,490
update the immediately surrounding items

657
00:29:21,490 --> 00:29:24,010
when removing or adding or removing a

658
00:29:24,010 --> 00:29:29,230
value so same as the previous tree we're

659
00:29:29,230 --> 00:29:30,820
going to have a root of our binary

660
00:29:30,820 --> 00:29:34,870
search tree in order to test if a value

661
00:29:34,870 --> 00:29:37,600
exists in the tree we're going to need

662
00:29:37,600 --> 00:29:41,170
to first search through the tree we

663
00:29:41,170 --> 00:29:43,720
start at the root and then we're going

664
00:29:43,720 --> 00:29:45,550
to keep running as long as we have

665
00:29:45,550 --> 00:29:49,630
another node to visit if we reach a left

666
00:29:49,630 --> 00:29:52,570
or right that is no then this loop ends

667
00:29:52,570 --> 00:29:53,980
and we assume that we did not have

668
00:29:53,980 --> 00:29:57,730
anything in the tree if the value is

669
00:29:57,730 --> 00:30:00,100
greater than the current value we move

670
00:30:00,100 --> 00:30:03,610
to the right if the value is less than

671
00:30:03,610 --> 00:30:05,610
current value we move to the left

672
00:30:05,610 --> 00:30:08,470
otherwise if it's not greater than or

673
00:30:08,470 --> 00:30:11,350
less than it must be equal to and so we

674
00:30:11,350 --> 00:30:15,610
return true if we not have if we haven't

675
00:30:15,610 --> 00:30:17,560
matched anything then we return false

676
00:30:17,560 --> 00:30:21,070
that's how we implement contains in

677
00:30:21,070 --> 00:30:22,840
order to add items for the tree we're

678
00:30:22,840 --> 00:30:24,520
going to do the same sort of traversal

679
00:30:24,520 --> 00:30:26,740
as before bouncing between left and

680
00:30:26,740 --> 00:30:28,690
right nodes depending on them being less

681
00:30:28,690 --> 00:30:30,040
are greater than the value that we're

682
00:30:30,040 --> 00:30:32,560
adding however this time when we reach a

683
00:30:32,560 --> 00:30:35,110
left or right that is null we're going

684
00:30:35,110 --> 00:30:39,610
to add a new node in that position first

685
00:30:39,610 --> 00:30:43,900
let's set up our node well special case

686
00:30:43,900 --> 00:30:46,330
for when there isn't any root node so

687
00:30:46,330 --> 00:30:49,080
that we just add one and return

688
00:30:49,080 --> 00:30:52,510
otherwise we start at the roots and

689
00:30:52,510 --> 00:30:53,950
we're going to loop until we've either

690
00:30:53,950 --> 00:30:55,660
added our item or discovered that it

691
00:30:55,660 --> 00:30:59,290
already exists in our tree if the value

692
00:30:59,290 --> 00:31:00,700
is greater than the current value we

693
00:31:00,700 --> 00:31:03,400
move to the right if the right does not

694
00:31:03,400 --> 00:31:06,040
exist we set it to our node and stop

695
00:31:06,040 --> 00:31:07,190
traverse

696
00:31:07,190 --> 00:31:09,899
otherwise we just continue on to keep

697
00:31:09,899 --> 00:31:12,840
searching the right node if the value is

698
00:31:12,840 --> 00:31:14,759
less than the current value we move to

699
00:31:14,759 --> 00:31:16,649
the left now we do the same thing where

700
00:31:16,649 --> 00:31:19,169
we check if it does not exist we set it

701
00:31:19,169 --> 00:31:21,019
to our node and stop traversing

702
00:31:21,019 --> 00:31:23,340
otherwise we just move on to the left

703
00:31:23,340 --> 00:31:26,519
node if the number isn't less than or

704
00:31:26,519 --> 00:31:28,679
greater to then it must be the same and

705
00:31:28,679 --> 00:31:30,269
so we don't do anything we just break

706
00:31:30,269 --> 00:31:32,249
and stop and the note isn't added

707
00:31:32,249 --> 00:31:36,029
because it's already exists and that's

708
00:31:36,029 --> 00:31:40,789
all all the different data structures if

709
00:31:40,789 --> 00:31:44,070
you want to read this code and review it

710
00:31:44,070 --> 00:31:46,799
again you can go to this URL I have a

711
00:31:46,799 --> 00:31:49,470
whole guide on it contains mostly same

712
00:31:49,470 --> 00:31:52,590
content you can also check out some of

713
00:31:52,590 --> 00:31:55,440
my other works I wrote about a compiler

714
00:31:55,440 --> 00:31:57,450
a super tiny compiler that you can go

715
00:31:57,450 --> 00:32:00,269
see here because of my work on babble I

716
00:32:00,269 --> 00:32:01,950
also wrote a Babel handbook that you can

717
00:32:01,950 --> 00:32:04,349
also check out anyways now we're

718
00:32:04,349 --> 00:32:06,720
actually done I'm James Kyle follow me

