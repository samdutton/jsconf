1
00:00:01,040 --> 00:00:04,040
Thank you.

2
00:00:04,040 --> 00:00:05,210
Is this on?

3
00:00:05,210 --> 00:00:07,359
Can you all hear me?

4
00:00:07,359 --> 00:00:10,440
All right.

5
00:00:10,440 --> 00:00:11,440
There we go!

6
00:00:11,440 --> 00:00:12,640
All right.

7
00:00:12,640 --> 00:00:13,990
So, yeah.

8
00:00:13,990 --> 00:00:21,200
My talk is simplifying, though I would have
liked to see a talk titled simplifying complex

9
00:00:21,200 --> 00:00:24,930
talk titles with fewer words.

10
00:00:24,930 --> 00:00:28,020
I know what you might be thinking right now.

11
00:00:28,020 --> 00:00:31,869
The react API, a little scary?

12
00:00:31,869 --> 00:00:40,180
There's a good book in order to understand
how to best work with it, and it's doing whatever

13
00:00:40,180 --> 00:00:46,320
Danny says to do.

14
00:00:46,320 --> 00:00:52,170
The second half of this talk is exactly what
I'm talking about today, except in the more

15
00:00:52,170 --> 00:00:55,940
general sense.

16
00:00:55,940 --> 00:00:58,150
I want to talk about it, though.

17
00:00:58,150 --> 00:01:04,330
Not in the context of React or you or angular
or any of the last frameworks that came out

18
00:01:04,330 --> 00:01:05,330
last week.

19
00:01:05,330 --> 00:01:09,860
But I want to talk about it in a frameworkless
context.

20
00:01:09,860 --> 00:01:14,920
This is an idea that doesn't just apply to
any framework or no framework in general,

21
00:01:14,920 --> 00:01:17,720
but really any programming language as well.

22
00:01:17,720 --> 00:01:21,960
We can see how it could help us simplify our
UIs.

23
00:01:21,960 --> 00:01:27,159
So I'm a pianist, and I have been playing
for about 20 years.

24
00:01:27,159 --> 00:01:34,890
This is the approach that I take to software
development.

25
00:01:34,890 --> 00:01:40,920
I made the analogy that if software is music,
then developers are composers.

26
00:01:40,920 --> 00:01:48,210
We're taking that music, and we're composing
it in a way that is applicable to any language

27
00:01:48,210 --> 00:01:49,440
or any platform.

28
00:01:49,440 --> 00:01:52,549
And we do so in a variety of ways.

29
00:01:52,549 --> 00:01:57,049
However, music's interesting, because with
music, you have music notation, which you

30
00:01:57,049 --> 00:01:58,049
just saw there.

31
00:01:58,049 --> 00:02:00,370
Let's go back and see it.

32
00:02:00,370 --> 00:02:02,640
So this stuff right here.

33
00:02:02,640 --> 00:02:06,140
This music notation is hundreds and hundreds
of years old.

34
00:02:06,140 --> 00:02:13,189
However, the exact same notation is used today
to represent music from classical, romantic,

35
00:02:13,189 --> 00:02:15,590
whatever the hellï¿½Bjork is.

36
00:02:15,590 --> 00:02:25,680
You can give a musician who understands how
to read sheet music, and they will be able

37
00:02:25,680 --> 00:02:27,060
to play it.

38
00:02:27,060 --> 00:02:32,090
And this works for all instruments, and you
know, all musicians of all levels.

39
00:02:32,090 --> 00:02:41,980
So I was wondering, what is the music notation
of user interfaces?

40
00:02:41,980 --> 00:02:49,389
What do all user interfaces have in common,
and how can we represent that declaratively?

41
00:02:49,389 --> 00:02:53,969
So when we're working with software, we usually
deal with APIs.

42
00:02:53,969 --> 00:02:58,730
Good APIs have three main qualities.

43
00:02:58,730 --> 00:03:00,159
They're well documented.

44
00:03:00,159 --> 00:03:04,159
You can read the documentation and understand
exactly what's happening with the API.

45
00:03:04,159 --> 00:03:06,110
They are very predictable.

46
00:03:06,110 --> 00:03:11,189
The API is going to work the exact same way
every time.

47
00:03:11,189 --> 00:03:12,870
And they're also testable.

48
00:03:12,870 --> 00:03:14,909
You can test against an API.

49
00:03:14,909 --> 00:03:20,999
They provide mocks for you or have a test
database or something like that.

50
00:03:20,999 --> 00:03:24,819
So user interfaces, though?

51
00:03:24,819 --> 00:03:27,239
User interfaces are really complex.

52
00:03:27,239 --> 00:03:33,309
I mean, does anyone find developing user interfaces
easy?

53
00:03:33,309 --> 00:03:37,120
Those of you watching online, no one raised
their hand, which is good, because I would

54
00:03:37,120 --> 00:03:39,989
have called them out if they did.

55
00:03:39,989 --> 00:03:43,989
We have to deal with something called a human
API.

56
00:03:43,989 --> 00:03:47,260
That's all of you, all of our clients, everyone
we work with.

57
00:03:47,260 --> 00:03:52,719
Human API is undocumented or unpredictable,
and we're untestable.

58
00:03:52,719 --> 00:03:55,720
And we're also extremely buggy.

59
00:03:55,720 --> 00:04:02,290
If you don't believe me, turn on an American
news network, and you'll see proof of that.

60
00:04:02,290 --> 00:04:03,290
So I work for Microsoft.

61
00:04:03,290 --> 00:04:09,590
By the way, I'm not relating Microsoft to
any of this terrible API stuff, I promise.

62
00:04:09,590 --> 00:04:16,940
And at Microsoft, we have more than 50,000
software engineers throughout the world, and

63
00:04:16,940 --> 00:04:19,900
at least 7 designers, I'm sure.

64
00:04:19,900 --> 00:04:24,720
[ Laughter ]
And we also serve one and a half billion customers.

65
00:04:24,720 --> 00:04:26,300
I think this is just for windows.

66
00:04:26,300 --> 00:04:29,620
It might be more than that.

67
00:04:29,620 --> 00:04:35,560
When we're developing user interfaces for
1.5 billion people, we have to imagine all

68
00:04:35,560 --> 00:04:38,590
the different ways a user could use the user
interface.

69
00:04:38,590 --> 00:04:42,210
And you know, this is different cultures and
languages.

70
00:04:42,210 --> 00:04:45,440
You wonder why diversity is so important in
tech?

71
00:04:45,440 --> 00:04:49,290
We have to reach the 1.5 billion people.

72
00:04:49,290 --> 00:04:52,450
So we don't develop software for just one
person.

73
00:04:52,450 --> 00:04:58,980
However, when we're developing software with
just the happy path in mind, that's essentially

74
00:04:58,980 --> 00:05:00,440
what we're doing.

75
00:05:00,440 --> 00:05:06,000
We're assuming that there's this ideal user
who's using our applications in the exact

76
00:05:06,000 --> 00:05:07,700
way that we want them to.

77
00:05:07,700 --> 00:05:10,100
But this never happens.

78
00:05:10,100 --> 00:05:14,160
We're going to take a look at the code example,
but I don't want you to read too deeply into

79
00:05:14,160 --> 00:05:15,160
the code.

80
00:05:15,160 --> 00:05:19,060
I just want to see if you relate to this.

81
00:05:19,060 --> 00:05:26,730
We're going to create a sample F where we
query the flickr API and then the results.

82
00:05:26,730 --> 00:05:32,310
Similar to what Dan was doing with movies
in his last talk.

83
00:05:32,310 --> 00:05:34,460
So it's pretty simple right?

84
00:05:34,460 --> 00:05:35,590
We do a fetch.

85
00:05:35,590 --> 00:05:40,500
Then when we get the data, we show it.

86
00:05:40,500 --> 00:05:41,650
Are there any bugs here?

87
00:05:41,650 --> 00:05:43,740
Are we done?

88
00:05:43,740 --> 00:05:44,740
Well...

89
00:05:44,740 --> 00:05:46,590
Let's say the data takes a long time to load.

90
00:05:46,590 --> 00:05:47,590
Okay.

91
00:05:47,590 --> 00:05:51,000
So now we have to set this loading flag, loading
is true.

92
00:05:51,000 --> 00:05:55,750
And once we finish loading data, then we have
to set loading to false.

93
00:05:55,750 --> 00:05:57,630
Are we done?

94
00:05:57,630 --> 00:05:58,630
No.

95
00:05:58,630 --> 00:06:00,650
What if we have an error.

96
00:06:00,650 --> 00:06:05,750
Well, we have to hide the loading screen,
show the error, right?

97
00:06:05,750 --> 00:06:08,010
But, are we home free yet?

98
00:06:08,010 --> 00:06:09,010
No.

99
00:06:09,010 --> 00:06:16,280
Because, we also have to make sure that we
clear the error once we try to search again.

100
00:06:16,280 --> 00:06:19,300
As you can see, the complexity is getting
bigger and bigger.

101
00:06:19,300 --> 00:06:22,600
Now my onserve to vent handler is getting
extremely huge.

102
00:06:22,600 --> 00:06:26,430
I'm sure many of you can relate to this code.

103
00:06:26,430 --> 00:06:30,640
Many of you will say yeah, some of my code
looks like that.

104
00:06:30,640 --> 00:06:31,800
Sure.

105
00:06:31,800 --> 00:06:38,440
What if your boss comes to you and says we
want the use tore be able to cancel the search,

106
00:06:38,440 --> 00:06:40,950
because, you know, sometimes it takes too
long.

107
00:06:40,950 --> 00:06:43,670
Sometimes they want to search for something
else.

108
00:06:43,670 --> 00:06:46,780
That logic gets crazier.

109
00:06:46,780 --> 00:06:48,220
I don't know if you can read that.

110
00:06:48,220 --> 00:06:50,120
I'll zoom in for you.

111
00:06:50,120 --> 00:06:57,580
But there's a lot of complexity in just one
event handler.

112
00:06:57,580 --> 00:07:02,160
You might know this as spaghetti code, where
our code quickly gets unmanageable.

113
00:07:02,160 --> 00:07:07,200
Some of you might see your engineers and think
I don't do spaghetti code.

114
00:07:07,200 --> 00:07:13,150
All of my code is modular and layered and
separation of concerns.

115
00:07:13,150 --> 00:07:17,420
You might not write spaghetti code, but you
might write lasagne code, which is spaghetti

116
00:07:17,420 --> 00:07:20,460
code in layers.

117
00:07:20,460 --> 00:07:22,630
This is called the bottomup approach.

118
00:07:22,630 --> 00:07:30,889
That approach is whenever you have an event
like onclick or on change, you do all of the

119
00:07:30,889 --> 00:07:32,260
logic in that event.

120
00:07:32,260 --> 00:07:38,180
And that can refer to so many different actions,
and some of those actions might change the

121
00:07:38,180 --> 00:07:39,180
states.

122
00:07:39,180 --> 00:07:45,240
But you have to choose which actions are executed,
otherwise you might edit the state in a wrong

123
00:07:45,240 --> 00:07:53,800
way, and you have to ad if statements.

124
00:07:53,800 --> 00:07:56,240
There's a lot of downsides to this.

125
00:07:56,240 --> 00:07:59,360
This bottomup code is difficult to test.

126
00:07:59,360 --> 00:08:01,740
All the application logic lives in your mind.

127
00:08:01,740 --> 00:08:06,550
So when you're writing your tests, you have
to output it from the developer's mind on

128
00:08:06,550 --> 00:08:07,550
to the tests.

129
00:08:07,550 --> 00:08:10,780
And it makes it really hard to work with other
developers.

130
00:08:10,780 --> 00:08:12,860
The code is difficult to understand.

131
00:08:12,860 --> 00:08:17,200
The code that I just showed you for showing
and hiding the gallery, if you were to try

132
00:08:17,200 --> 00:08:22,520
to parse that as a brandnew developer working
on the project, you would find it really difficult

133
00:08:22,520 --> 00:08:24,389
to do so.

134
00:08:24,389 --> 00:08:28,650
The code will contain bugs, for sure, because
there's going to be edge cases that you might

135
00:08:28,650 --> 00:08:30,040
not have considered.

136
00:08:30,040 --> 00:08:33,909
It will also be difficult to enhance, just
like we've seen with cancellation.

137
00:08:33,909 --> 00:08:38,749
And features, such as cancellation, make the
code work.

138
00:08:38,749 --> 00:08:45,810
They explode the potential possible states
and actions that could happen in your application.

139
00:08:45,810 --> 00:08:50,600
Here's an intuition for moving forward.

140
00:08:50,600 --> 00:08:54,300
We have a realization that UI components are
not independent.

141
00:08:54,300 --> 00:08:59,889
We have frameworks that they isolate components
and say these components fit in their nice

142
00:08:59,889 --> 00:09:09,820
little box, and we can stick them in the page
anywhere.

143
00:09:09,820 --> 00:09:15,050
Everything they see on the screen is in the
exact same context, and we have to coordinate

144
00:09:15,050 --> 00:09:17,740
from components to component.

145
00:09:17,740 --> 00:09:22,601
So another realization is that actions, which
is what happens when you do an event, are

146
00:09:22,601 --> 00:09:30,610
based both on the events executed, and the
current state of the context.

147
00:09:30,610 --> 00:09:38,860
And it's also that this event action paradigm
is too simple to represent all the possible

148
00:09:38,860 --> 00:09:40,071
states our app can be in.

149
00:09:40,071 --> 00:09:45,210
So, what's the solution?

150
00:09:45,210 --> 00:09:47,790
Standard statecharts.

151
00:09:47,790 --> 00:09:55,040
I know a lot of you may have heard these before
or studied them in school.

152
00:09:55,040 --> 00:10:00,009
Even though you might know what these are,
you probably haven't applied them to user

153
00:10:00,009 --> 00:10:03,529
interfaces and actual software.

154
00:10:03,529 --> 00:10:07,040
So, looking up material for this could be
a little complicated.

155
00:10:07,040 --> 00:10:16,579
I'm a visual person, and I'm going to do it
in a very visual way.

156
00:10:16,579 --> 00:10:20,300
First you have an initial state.

157
00:10:20,300 --> 00:10:27,309
Then you have a finite number of states, which
represents the states that the app could be

158
00:10:27,309 --> 00:10:28,309
in.

159
00:10:28,309 --> 00:10:32,930
When an app is in one state, it can't be in
the other state at the same time.

160
00:10:32,930 --> 00:10:39,259
You have a finite number of events, such as
fetching, resolving, or rejecting a promise.

161
00:10:39,259 --> 00:10:44,180
You have a mapping from state to state based
on these events.

162
00:10:44,180 --> 00:10:48,800
So for example, when you're fetching a promise
and it resolves, you go to the fulfilled state.

163
00:10:48,800 --> 00:10:52,360
And same way with reject and rejected state.

164
00:10:52,360 --> 00:10:57,470
And you have a finite number of final states.

165
00:10:57,470 --> 00:11:00,259
User interfaces can be continuous.

166
00:11:00,259 --> 00:11:02,360
We could keep using them.

167
00:11:02,360 --> 00:11:08,730
It doesn't say we're done, so go uninstall
Instagram because you're not going to need

168
00:11:08,730 --> 00:11:09,730
it.

169
00:11:09,730 --> 00:11:16,439
If you go to this site, it's going to say
promises are just a state machine.

170
00:11:16,439 --> 00:11:19,889
That should give you a big clue with what
we're working with here.

171
00:11:19,889 --> 00:11:24,939
So the original app that I showed you, the
gallery app can be modelled as the state machine

172
00:11:24,939 --> 00:11:26,129
right here.

173
00:11:26,129 --> 00:11:29,420
So we start in the idle state, and then we
go to search.

174
00:11:29,420 --> 00:11:30,980
Then we're in the searching state.

175
00:11:30,980 --> 00:11:34,170
If we try to search again, it loops back.

176
00:11:34,170 --> 00:11:35,300
It's like hold on.

177
00:11:35,300 --> 00:11:36,800
We're already searching.

178
00:11:36,800 --> 00:11:42,220
We can either resolve or reject the search
results.

179
00:11:42,220 --> 00:11:46,800
And from those two states, we could search
again.

180
00:11:46,800 --> 00:11:53,939
This is clearly seen by the arrows going from
success or failure back to searching again.

181
00:11:53,939 --> 00:12:02,040
So, the machine thatï¿½ the state machine
that I envision looks sort of like this.

182
00:12:02,040 --> 00:12:03,399
It's a JSON object.

183
00:12:03,399 --> 00:12:09,490
I like JSON better than blackbox functions
because you can enumerate all the possible

184
00:12:09,490 --> 00:12:15,670
states and actions and be able to transition
from one to the other with nice, simple function

185
00:12:15,670 --> 00:12:16,700
right here.

186
00:12:16,700 --> 00:12:23,800
For example, if we're in the searching state,
and I get a resolve, then I just look it up

187
00:12:23,800 --> 00:12:25,679
in this JSON object.

188
00:12:25,679 --> 00:12:29,329
This searching, on resolve, success.

189
00:12:29,329 --> 00:12:34,519
In type script, it's a record.

190
00:12:34,519 --> 00:12:41,069
I guess it's the same in C#.

191
00:12:41,069 --> 00:12:44,079
In PHP, they call for help.

192
00:12:44,079 --> 00:12:46,190
I don't know.

193
00:12:46,190 --> 00:12:51,350
So here's an example of what I just showed
you.

194
00:12:51,350 --> 00:12:56,459
If I were to search for icelandï¿½ let's search
for goats first.

195
00:12:56,459 --> 00:12:57,550
Let's say I don't want to search for goats.

196
00:12:57,550 --> 00:13:00,249
I'll just cancel that.

197
00:13:00,249 --> 00:13:10,790
Let's search for Iceland instead.

198
00:13:10,790 --> 00:13:16,249
When we do the event of selecting a photo,
we have a state transition that goes from

199
00:13:16,249 --> 00:13:19,569
gallery to photo.

200
00:13:19,569 --> 00:13:24,529
We can exit that, search again, cancel, search.

201
00:13:24,529 --> 00:13:27,940
Let's cancel that.

202
00:13:27,940 --> 00:13:29,079
Iceland.

203
00:13:29,079 --> 00:13:32,889
And so you see it goes from state to state,
and no matter how many times I try to break

204
00:13:32,889 --> 00:13:38,740
this app, it's not going to deviate from this
state machine that I have here.

205
00:13:38,740 --> 00:13:43,059
And you see there was a few extra things such
as actions over here.

206
00:13:43,059 --> 00:13:46,199
When I'm done searching, update the items?

207
00:13:46,199 --> 00:13:50,370
We're going to discuss that in a little further
detail.

208
00:13:50,370 --> 00:13:55,079
And also this is part of an article that I
wrote which gives an introduction to finite

209
00:13:55,079 --> 00:13:58,209
state machines.

210
00:13:58,209 --> 00:14:02,040
So I use visual studio share.

211
00:14:02,040 --> 00:14:04,160
I work on it and I also have to use it.

212
00:14:04,160 --> 00:14:07,300
It's called dog fooding.

213
00:14:07,300 --> 00:14:12,019
Anyway... and this is sort of what it looks
like.

214
00:14:12,019 --> 00:14:16,709
And so, I don't know if we have Sarah and
Burke in here.

215
00:14:16,709 --> 00:14:20,489
Here's Burke right now.

216
00:14:20,489 --> 00:14:24,369
You can think of it as Google docs for collaborative
coding.

217
00:14:24,369 --> 00:14:27,380
It's in preview in Microsoft.

218
00:14:27,380 --> 00:14:32,170
And I have no control over what they're typing,
and they're typing this in realtime.

219
00:14:32,170 --> 00:14:37,470
With this live share, we can collaboratively
code in the exact same document at the same

220
00:14:37,470 --> 00:14:38,639
time.

221
00:14:38,639 --> 00:14:44,119
These are a complex series of events that
are happening at the same time, and so we

222
00:14:44,119 --> 00:14:49,290
have to manage all of these possible events
and all the possible states that this could

223
00:14:49,290 --> 00:14:53,119
be in.

224
00:14:53,119 --> 00:14:54,470
I have no idea...

225
00:14:54,470 --> 00:14:55,470
Oh God.

226
00:14:55,470 --> 00:14:57,699
Good luck breaking the demo.

227
00:14:57,699 --> 00:14:59,110
It probably will, though.

228
00:14:59,110 --> 00:15:00,110
Ha ha.

229
00:15:00,110 --> 00:15:01,110
Anyway!

230
00:15:01,110 --> 00:15:09,389
I'm going to end this before it gets too crazy...

231
00:15:09,389 --> 00:15:14,720
One of the big things I have to work on in
liveshare is this whole signin flow.

232
00:15:14,720 --> 00:15:20,089
You would think that signing in is easy and,
you know, signing in, signing out, all of

233
00:15:20,089 --> 00:15:21,790
that.

234
00:15:21,790 --> 00:15:23,100
But it's actually not.

235
00:15:23,100 --> 00:15:26,649
Once you start drawing it out, it becomes
a lot more complex.

236
00:15:26,649 --> 00:15:29,009
So for example, there could be a signin failure.

237
00:15:29,009 --> 00:15:31,459
You know, especially from Iceland.

238
00:15:31,459 --> 00:15:33,600
I'm so glad that worked in Iceland.

239
00:15:33,600 --> 00:15:36,939
All of our servers are based in the United
States.

240
00:15:36,939 --> 00:15:41,689
So when you have a signin success, then you
go to the signin state.

241
00:15:41,689 --> 00:15:43,910
From there you could go do two things.

242
00:15:43,910 --> 00:15:47,769
You could either share a session or join a
session.

243
00:15:47,769 --> 00:15:53,869
So what I did was a couple months back, I
refactored this part of the app so that it

244
00:15:53,869 --> 00:15:57,339
uses an explicit state machine just like this.

245
00:15:57,339 --> 00:15:58,889
We were getting a lot of bugs.

246
00:15:58,889 --> 00:16:04,320
We were saying what if we're in the middle
of sharing and the user signs out?

247
00:16:04,320 --> 00:16:09,339
What if we join the session, and then we decide
to share a session at the same time?

248
00:16:09,339 --> 00:16:11,559
That shouldn't be allowed.

249
00:16:11,559 --> 00:16:18,529
We had all of these if/else and switch statements,
so I decided there has to be a better way.

250
00:16:18,529 --> 00:16:23,790
I did the simple JSON object approach.

251
00:16:23,790 --> 00:16:28,850
The state machine that I set up?

252
00:16:28,850 --> 00:16:31,769
It was very easy to add telemetry to it.

253
00:16:31,769 --> 00:16:38,369
I added telemetry, and I get this nice visual
showing exactly the frequency of how users

254
00:16:38,369 --> 00:16:40,079
go from state to state.

255
00:16:40,079 --> 00:16:45,059
So you could see obviously, most of the users
go through this initializing and then signing

256
00:16:45,059 --> 00:16:49,769
in state, and then you could either externally
sign in, or you could sign out.

257
00:16:49,769 --> 00:16:57,639
And then you could see that users tend to
go to either joining or sharing, you know?

258
00:16:57,639 --> 00:16:59,959
At about the same frequency.

259
00:16:59,959 --> 00:17:01,360
And yeah.

260
00:17:01,360 --> 00:17:07,610
So it clearly shows, too, how many users go
to the error state and how many users go to

261
00:17:07,610 --> 00:17:10,520
the success state for each of these states
as well.

262
00:17:10,520 --> 00:17:12,740
Now, these are very powerful insights.

263
00:17:12,740 --> 00:17:17,520
Because while telemetry will only tell you
an atomic bit of data, here is telemetry that

264
00:17:17,520 --> 00:17:21,500
tells you the entire user flow of what's happening.

265
00:17:21,500 --> 00:17:26,310
We could limit this to user and be able to
see a nice path of what the user actually

266
00:17:26,310 --> 00:17:27,810
did in the app.

267
00:17:27,810 --> 00:17:35,840
So it's sort of like, you know, like the funnel
diagrams, except even crazier.

268
00:17:35,840 --> 00:17:38,940
We could also use state machines for integration
testing.

269
00:17:38,940 --> 00:17:43,470
And so this gets a little bit into graph theory,
so bear with me a little bit.

270
00:17:43,470 --> 00:17:50,240
Here we would be using a shortest path algorithm.

271
00:17:50,240 --> 00:17:55,580
You could choose your favorite one.

272
00:17:55,580 --> 00:18:03,350
It sounds like an Icelandic name.

273
00:18:03,350 --> 00:18:06,780
Any of these formulas for finding the shortest
path.

274
00:18:06,780 --> 00:18:11,370
And so, for those who don't know, the shortest
path is just going from one state to the other

275
00:18:11,370 --> 00:18:13,280
with the minimal cost.

276
00:18:13,280 --> 00:18:17,680
So you could imagine each of these arrows
have a wait.

277
00:18:17,680 --> 00:18:22,490
And so you just want to minimize, you know,
how long it takes to get from one path to

278
00:18:22,490 --> 00:18:23,490
the other.

279
00:18:23,490 --> 00:18:28,430
Sort of like in Google maps, finding the shortest
ETA from one point to the other.

280
00:18:28,430 --> 00:18:30,340
So analytics would provide these waits.

281
00:18:30,340 --> 00:18:35,280
And this represents all the happy paths a
user could take.

282
00:18:35,280 --> 00:18:41,870
If we want a user to, let's say, share a session,
and get to the shared state, we would imagine

283
00:18:41,870 --> 00:18:45,960
the user going from signed in to sharing to
shared.

284
00:18:45,960 --> 00:18:47,430
Just that simple.

285
00:18:47,430 --> 00:18:54,660
These could be automatically generated from
the JSON structure just like this.

286
00:18:54,660 --> 00:18:58,280
But, remember, we're not just dealing with
the happy paths.

287
00:18:58,280 --> 00:19:06,360
So, we would do a death first search algorithm
to find all the other paths a user could take.

288
00:19:06,360 --> 00:19:11,300
Some of you might be thinking these algorithm
things, I didn't think I would need them.

289
00:19:11,300 --> 00:19:14,850
You sort of do; they're really helpful.

290
00:19:14,850 --> 00:19:20,690
And so, these represent all the possible user
flows.

291
00:19:20,690 --> 00:19:28,280
You can imagine a user getting from state
A to state C might not take the easiest route.

292
00:19:28,280 --> 00:19:34,680
They might take a longer route to get all
the way to C. And it reveals all the edge

293
00:19:34,680 --> 00:19:36,010
cases.

294
00:19:36,010 --> 00:19:40,290
When you model every single possible state
with every single possible action, and you

295
00:19:40,290 --> 00:19:47,610
get all of these flows, you're going to basically
have 100,000% test coverage for anything that

296
00:19:47,610 --> 00:19:49,340
could possibly happen in your app.

297
00:19:49,340 --> 00:19:52,300
And of course these could all be automatically
generated.

298
00:19:52,300 --> 00:19:57,910
I caution against this, because you would
be generating integration testsï¿½ it would

299
00:19:57,910 --> 00:20:02,300
generate a lot of integration tests, which
isn't necessarily a bad thing, but when you're

300
00:20:02,300 --> 00:20:07,760
doing continuous integration, you don't want
your tests to take four hours long.

301
00:20:07,760 --> 00:20:12,880
It makes software bugs visually clear by drawing
a map and putting them on the diagram.

302
00:20:12,880 --> 00:20:17,280
You can see when I do this event, I'm going
to the wrong state.

303
00:20:17,280 --> 00:20:21,210
Or maybe I have an unhandled event, which
does nothing.

304
00:20:21,210 --> 00:20:25,190
Or maybe I have a missing transition.

305
00:20:25,190 --> 00:20:26,190
That's shown here, too.

306
00:20:26,190 --> 00:20:32,320
For example, Dan was showing the example where
when you click a movie, it just waits and

307
00:20:32,320 --> 00:20:37,130
waits, and then you get the next movie, and
there's no loading state.

308
00:20:37,130 --> 00:20:40,490
You can clearly see that in the state transition
diagram.

309
00:20:40,490 --> 00:20:43,860
And also, my favorite, race conditions.

310
00:20:43,860 --> 00:20:50,290
These are just made completely nil and void
with state machines, because you explicitly

311
00:20:50,290 --> 00:20:54,180
say, when I get this event, I go to this state.

312
00:20:54,180 --> 00:20:59,080
If I get another event after that that I don't
care about, it's not going to cause a race

313
00:20:59,080 --> 00:21:01,860
condition, because I will ignore that event.

314
00:21:01,860 --> 00:21:04,150
And that's what state machines can help with.

315
00:21:04,150 --> 00:21:08,550
Now I want to talk about Harold statecharts.

316
00:21:08,550 --> 00:21:12,960
This could go on for hours and hours, because
there's so much information here.

317
00:21:12,960 --> 00:21:18,150
I'm going to give an overview of what these
are and how these extend state machines in

318
00:21:18,150 --> 00:21:22,110
order to improve the way we look at user interfaces.

319
00:21:22,110 --> 00:21:26,730
Because, user interfaces can get complex,
and finite state machines might not solve

320
00:21:26,730 --> 00:21:28,880
everything.

321
00:21:28,880 --> 00:21:32,890
So with statecharts, they are similar to state
machines.

322
00:21:32,890 --> 00:21:35,420
They are an extension of it.

323
00:21:35,420 --> 00:21:38,400
Except we can have actions with Harel statecharts,
too.

324
00:21:38,400 --> 00:21:42,880
They actually do things to the state and the
app.

325
00:21:42,880 --> 00:21:50,850
We can have guards which prevent states from
going from one to the other if something doesn't

326
00:21:50,850 --> 00:21:52,180
match the condition.

327
00:21:52,180 --> 00:21:57,880
If I'm trying to search for something, and
the user didn't give me a search query, then

328
00:21:57,880 --> 00:22:01,090
I'm not going to transition to the next state.

329
00:22:01,090 --> 00:22:03,660
That could be declaratively modelled as well.

330
00:22:03,660 --> 00:22:09,580
There's the idea of nested states.

331
00:22:09,580 --> 00:22:10,780
This is parallel states.

332
00:22:10,780 --> 00:22:18,190
It is not concurrent states where an app can
be in two states at the same time.

333
00:22:18,190 --> 00:22:22,830
It's more a way of simplifying the number
of states you have so your state machine doesn't

334
00:22:22,830 --> 00:22:24,370
look all crazy.

335
00:22:24,370 --> 00:22:31,250
And also, history, which is a very common
feature that many users would want in order

336
00:22:31,250 --> 00:22:34,770
to go back to their safe state.

337
00:22:34,770 --> 00:22:43,470
So I created this library called X states
which models finite state machines and statecharts

338
00:22:43,470 --> 00:22:48,940
in a declarative way, so that all you would
have to do is use this JSON structure to model

339
00:22:48,940 --> 00:22:54,730
your state machine, and then you would get
the next state by calling transition on the

340
00:22:54,730 --> 00:22:57,460
current state and the action.

341
00:22:57,460 --> 00:23:03,310
It's functional, and it's going to work in
any framework or no framework at all.

342
00:23:03,310 --> 00:23:08,790
It also has the notion of actions, so it will
return you an object telling you, these are

343
00:23:08,790 --> 00:23:13,910
the next actions that you're going to take
once you transition to a state.

344
00:23:13,910 --> 00:23:18,850
It also has guards, so you could pass in some
external state, and it will validate against

345
00:23:18,850 --> 00:23:22,780
that external state and say, Okay, this condition
is met.

346
00:23:22,780 --> 00:23:25,120
So you go on to the next state.

347
00:23:25,120 --> 00:23:31,090
It also has hierarchy so you can represent
and compose machines easily.

348
00:23:31,090 --> 00:23:38,120
It has orthogonality so you can represent
parallel states and also represent remembered

349
00:23:38,120 --> 00:23:39,130
states.

350
00:23:39,130 --> 00:23:45,560
If you're doing a payment flow and you're
asking for cash or card, the user can switch

351
00:23:45,560 --> 00:23:48,630
between them, and the user gets to the review
page.

352
00:23:48,630 --> 00:23:52,080
You want to remember if the user chose cash
or card.

353
00:23:52,080 --> 00:23:56,630
So you go to method.history, and it would
remember that.

354
00:23:56,630 --> 00:24:02,440
And this is a purely functional, no side effect
type of thing.

355
00:24:02,440 --> 00:24:06,680
And so you can imagine the applications of
where you could apply this.

356
00:24:06,680 --> 00:24:13,020
One example of where you would use orthoganal
states is this example.

357
00:24:13,020 --> 00:24:15,740
Say you have bold, italic, or underline.

358
00:24:15,740 --> 00:24:24,940
A user can use all or none of them, and it's
represented by all of these eight states.

359
00:24:24,940 --> 00:24:32,300
And you can imagine if we add more options
such as align left, align center, justify,

360
00:24:32,300 --> 00:24:35,990
it's going to explode into even more states.

361
00:24:35,990 --> 00:24:44,870
With orthogonal statecharts, we just have
this succinct representation of these possible

362
00:24:44,870 --> 00:24:50,841
states, so that we know we can go from bold
on to after, italics on to off, and same way

363
00:24:50,841 --> 00:24:55,050
with underline, and we can represent all of
those at the same time.

364
00:24:55,050 --> 00:25:02,160
And also, hierarchy helps to reduce the number
of arrows that you have in your finite state

365
00:25:02,160 --> 00:25:03,160
machine.

366
00:25:03,160 --> 00:25:07,570
So for example, both the success and failure
states, we could search again and go back

367
00:25:07,570 --> 00:25:09,290
to the searching state.

368
00:25:09,290 --> 00:25:15,240
We could simplify this by just nesting them
in a single state, the search state.

369
00:25:15,240 --> 00:25:19,690
This is fully supported by X state, and yeah.

370
00:25:19,690 --> 00:25:26,660
So, you could imagine how this would simplify
just really complex state machines.

371
00:25:26,660 --> 00:25:36,020
So, I released X state about six months ago
at React rally, and since then, there has

372
00:25:36,020 --> 00:25:41,940
been a lot of development and a lot of people
actually using it to make projects such as

373
00:25:41,940 --> 00:25:45,170
React automa and others.

374
00:25:45,170 --> 00:25:50,020
And pretty soon, I'm going to be releasing
another version, minor version.

375
00:25:50,020 --> 00:25:54,680
Don't worry; nothing crazy, of Xstate where
we improved the user ergonomics.

376
00:25:54,680 --> 00:25:59,650
It's full SCXML.

377
00:25:59,650 --> 00:26:01,100
It's not sexy.

378
00:26:01,100 --> 00:26:05,950
Code is not sexy at all.

379
00:26:05,950 --> 00:26:13,480
A Reactive interpreter, visualization interpreter,
and a lot more examples.

380
00:26:13,480 --> 00:26:21,230
In order to show you what I'm talking about,
here is an example of a visualization tool.

381
00:26:21,230 --> 00:26:26,900
That same JSON object that you passed into
xstate and the same one I used for my gallery

382
00:26:26,900 --> 00:26:38,500
app, this is one example of where you would
use this.

383
00:26:38,500 --> 00:26:45,280
My initial state is start, and I can hover
over this search action, and go to this state.

384
00:26:45,280 --> 00:26:50,570
Then I could see the possible different actionsï¿½
sorry, events that I could take from this

385
00:26:50,570 --> 00:26:51,570
state.

386
00:26:51,570 --> 00:26:54,110
So let's say I have a search success.

387
00:26:54,110 --> 00:26:56,770
And so, I go into the gallery view.

388
00:26:56,770 --> 00:27:03,860
And then I choose to search again, or I could
select a photo.

389
00:27:03,860 --> 00:27:13,630
So, I can visually see what's happening in
my state machine by pasting in that JSON object.

390
00:27:13,630 --> 00:27:18,200
That's hard to do with just a function, so
that's why I decided to do it in a more declarative

391
00:27:18,200 --> 00:27:20,310
way.

392
00:27:20,310 --> 00:27:22,380
I'm going to be releasing this soon.

393
00:27:22,380 --> 00:27:27,810
I want you all to enjoy the rest of the conference
before I release it, so you can have time

394
00:27:27,810 --> 00:27:28,970
to play with it afterwards.

395
00:27:28,970 --> 00:27:32,250
That's my excuse, at least.

396
00:27:32,250 --> 00:27:38,680
It's not out yet.

397
00:27:38,680 --> 00:27:46,220
Now, it would be, you know, sort of remiss
of me to not talk about sort of the downsides

398
00:27:46,220 --> 00:27:53,190
of state machines and statecharts, but the
truth is that you all are already creating

399
00:27:53,190 --> 00:27:57,580
finite state machines and statecharts in your
app already, and you don't even know it.

400
00:27:57,580 --> 00:28:00,770
However, the ones that you're creating are
implicit.

401
00:28:00,770 --> 00:28:03,030
They're full of bugs.

402
00:28:03,030 --> 00:28:05,030
They're incomplete.

403
00:28:05,030 --> 00:28:10,250
And that's just the nature of how we code.

404
00:28:10,250 --> 00:28:16,630
So the advantage of finite state machines
and modeling them in a very explicit way is

405
00:28:16,630 --> 00:28:23,490
that you reduce a lot of complexity up front
just by getting rid of your if/else statements

406
00:28:23,490 --> 00:28:27,600
and getting rid of your switch statements
and having a direct mapping.

407
00:28:27,600 --> 00:28:31,430
However, that quickly explodes into many,
many different states.

408
00:28:31,430 --> 00:28:37,150
So statecharts help manage that with a little
higher complexity cost up front.

409
00:28:37,150 --> 00:28:43,620
But in the long run, you will see it will
be very easy to add features, remove features,

410
00:28:43,620 --> 00:28:49,740
and handle different actions and different
possible modes of your application.

411
00:28:49,740 --> 00:28:55,630
So, of course, there's a lot of advantages
to using statecharts, and the ones I am going

412
00:28:55,630 --> 00:28:59,270
to quote are not actually from me.

413
00:28:59,270 --> 00:29:01,240
They're from NASA.

414
00:29:01,240 --> 00:29:08,110
A few years ago, NASA had to send this little
vehicle right here all the way to Mars.

415
00:29:08,110 --> 00:29:11,240
And they did so using statecharts.

416
00:29:11,240 --> 00:29:16,270
So the advantages that they said was, first
of all, there's visualized modeling.

417
00:29:16,270 --> 00:29:23,650
So you could both model and examine the model
of a state chart using visual tools.

418
00:29:23,650 --> 00:29:29,310
You get these precise diagrams that tell you
exactly what's going to happen when certain

419
00:29:29,310 --> 00:29:33,400
conditions are met, when you're in a certain
state, and this event happens.

420
00:29:33,400 --> 00:29:38,080
When you're sending something to Mars, you
can't exactly just send it there and hope

421
00:29:38,080 --> 00:29:39,650
that it works, right?

422
00:29:39,650 --> 00:29:45,800
You have to be absolutely sure that your billion
dollar project is going to handle every single

423
00:29:45,800 --> 00:29:48,240
possible state.

424
00:29:48,240 --> 00:29:51,790
And so they also use state charts for automatic
code generation.

425
00:29:51,790 --> 00:29:56,930
I'm not a fan, but you could see how it could
be beneficial.

426
00:29:56,930 --> 00:29:59,970
Also, comprehensive test coverage.

427
00:29:59,970 --> 00:30:06,470
By using state charts, they were able to generate
just all of these integration tests where

428
00:30:06,470 --> 00:30:11,870
they could test each and every one, and ensure
that every single state was being hit, and

429
00:30:11,870 --> 00:30:15,510
every single possible action or event was
being handled.

430
00:30:15,510 --> 00:30:22,610
Also, you know, being on a big project, you
have a lot of requirement changes.

431
00:30:22,610 --> 00:30:24,870
We want to add this to the rover.

432
00:30:24,870 --> 00:30:27,220
We want to remove this functionality.

433
00:30:27,220 --> 00:30:29,470
We want to change the way this works.

434
00:30:29,470 --> 00:30:34,630
And when you're working on a big project,
and you have these late breaking requirement

435
00:30:34,630 --> 00:30:38,080
changes, then things can get really stressful.

436
00:30:38,080 --> 00:30:43,070
With state charts, since you could clearly
see the full flow of your application, you

437
00:30:43,070 --> 00:30:48,670
could easily add and remove features without
worrying what's going to break, what's going

438
00:30:48,670 --> 00:30:53,250
to change, what's going to be affected.

439
00:30:53,250 --> 00:30:55,760
So there are some disadvantages as well.

440
00:30:55,760 --> 00:31:00,529
And the disadvantage is that my screen just
went black.

441
00:31:00,529 --> 00:31:03,980
I guess that means there are no disadvantages.

442
00:31:03,980 --> 00:31:05,630
Ha ha.

443
00:31:05,630 --> 00:31:06,630
Anyway...

444
00:31:06,630 --> 00:31:11,610
Since the rest of my slides are forked, I
want to show you this real quick.

445
00:31:11,610 --> 00:31:16,580
I gave a talk about one and a half years ago.

446
00:31:16,580 --> 00:31:20,340
It was at JSConf Iceland.

447
00:31:20,340 --> 00:31:25,130
This is where I saw the primary use case for
using state machines and statecharts.

448
00:31:25,130 --> 00:31:34,530
There was this really complex UI design that
I really wanted to model, and I found it pretty

449
00:31:34,530 --> 00:31:39,160
difficult without using an explicit state
machine or state chart.

450
00:31:39,160 --> 00:31:44,250
So what I'm doing here, there's three different
states.

451
00:31:44,250 --> 00:31:45,809
This one.

452
00:31:45,809 --> 00:31:46,809


453
00:31:46,809 --> 00:31:48,620
And there's different actions as well.

454
00:31:48,620 --> 00:31:54,080
So the user could pan right, but just a little
bit.

455
00:31:54,080 --> 00:32:01,080
So I handle that as a transition from going
to state A, back to state A if they didn't

456
00:32:01,080 --> 00:32:02,240
move far enough.

457
00:32:02,240 --> 00:32:08,940
Of course, if they move far enough, it goes
to the next state successfully.

458
00:32:08,940 --> 00:32:14,130
And also, it handles, like, if I'm going up,
and I decide to go left and right, it's not

459
00:32:14,130 --> 00:32:18,809
going to do anything, because we're already
going up and down.

460
00:32:18,809 --> 00:32:23,990
So it knows when this event happens, don't
try to go to a different state, because we're

461
00:32:23,990 --> 00:32:32,570
already transitioning to one state.

462
00:32:32,570 --> 00:32:36,630
I also wanted to mention two very good resources.

463
00:32:36,630 --> 00:32:44,600
The first one is on spectrum.oi/statecharts.

464
00:32:44,600 --> 00:32:49,650
This is a community where we talk about statecharts,
their possible applications, and how they're

465
00:32:49,650 --> 00:32:51,770
used everywhere.

466
00:32:51,770 --> 00:32:54,800
Statecharts are nothing new.

467
00:32:54,800 --> 00:32:58,550
They're invented by David Harel in 1987, which
is what?

468
00:32:58,550 --> 00:33:01,000
30 years ago?

469
00:33:01,000 --> 00:33:03,020
This is not cuttingedge stuff.

470
00:33:03,020 --> 00:33:07,680
If people are asking why aren't we using statecharts
everywhere now?

471
00:33:07,680 --> 00:33:13,970
Well, the thing is, they are in embedded systems
or systems programming.

472
00:33:13,970 --> 00:33:17,670
People do use statecharts in order to model
their applications.

473
00:33:17,670 --> 00:33:22,330
We don't, quite yet, but I think it's about
time that we catch up to it.

474
00:33:22,330 --> 00:33:32,600
And so, Eric Mogansen made a wonderful resource
called the unfinished world of statecharts.

475
00:33:32,600 --> 00:33:46,400
Over here, if you want to learn more information,
there's a well wealth of information here.

476
00:33:46,400 --> 00:33:54,140
I really want to encourage you to revisit
your application and the way you think about

477
00:33:54,140 --> 00:33:57,510
things, and actually try to visualize things.

478
00:33:57,510 --> 00:34:03,490
You will see that by visualizing your application,
all of its possible states, all the events

479
00:34:03,490 --> 00:34:11,360
that could happen, that you're going to have
a clearer representation of the possible bugs,

480
00:34:11,360 --> 00:34:16,389
the possible features that you might have,
the user improvements, and everything else.

481
00:34:16,389 --> 00:34:18,720
So I want to thank you all for having me.

482
00:34:18,720 --> 00:34:22,230
Unfortunately, I can't show you my last slide,
because it's not working, but thank you.

