1
00:00:08,809 --> 00:00:20,350

thank you I'm sure it's fine

2
00:00:20,350 --> 00:00:24,790
I like to start off with a question is

3
00:00:24,790 --> 00:00:27,670
does anyone have a favorite utility

4
00:00:27,670 --> 00:00:30,340
library like low dash or jQuery or

5
00:00:30,340 --> 00:00:36,030
something like that we use this lodash

6
00:00:36,030 --> 00:00:44,890
underscore knockout that's cool is it

7
00:00:44,890 --> 00:00:46,480
great that we have this community that

8
00:00:46,480 --> 00:00:48,129
we can use all these different features

9
00:00:48,129 --> 00:00:50,290
and different libraries we want to and

10
00:00:50,290 --> 00:00:52,239
nobody can tell us that we can't do it

11
00:00:52,239 --> 00:00:54,760
and there's like no single company that

12
00:00:54,760 --> 00:00:58,720
controls our community except do we

13
00:00:58,720 --> 00:01:01,150
really need this many ways to iterate

14
00:01:01,150 --> 00:01:04,510
over an ordinary do you even know all

15
00:01:04,510 --> 00:01:05,950
the ways to filter in the array and

16
00:01:05,950 --> 00:01:09,010
underscore is it the same exact version

17
00:01:09,010 --> 00:01:10,810
in lodash or is it I think it's slightly

18
00:01:10,810 --> 00:01:11,830
different depending on which version

19
00:01:11,830 --> 00:01:15,600
you're using do you even know all the

20
00:01:15,600 --> 00:01:18,270
JavaScript standard library functions

21
00:01:18,270 --> 00:01:22,540
what about the ones in he is six I don't

22
00:01:22,540 --> 00:01:23,860
think Brendan even knows all that wants

23
00:01:23,860 --> 00:01:27,100
to make six pretty sure let alone all

24
00:01:27,100 --> 00:01:30,070
the libraries on top of it it's not that

25
00:01:30,070 --> 00:01:33,340
a library is too big it's pretty cool

26
00:01:33,340 --> 00:01:36,009
every library is pretty cool it is it

27
00:01:36,009 --> 00:01:38,590
has a nice feature size extensions the

28
00:01:38,590 --> 00:01:39,939
problem is that we have a lot of them

29
00:01:39,939 --> 00:01:42,039
and each one has a lot of different

30
00:01:42,039 --> 00:01:44,619
functions and a total amount of AP is

31
00:01:44,619 --> 00:01:46,539
that you have to learn to be productive

32
00:01:46,539 --> 00:01:49,270
in this industry is huge it's way too

33
00:01:49,270 --> 00:01:52,030
much to learn so what happens when you

34
00:01:52,030 --> 00:01:54,070
get a new team member coming out to your

35
00:01:54,070 --> 00:01:57,039
team how many special utility calls to

36
00:01:57,039 --> 00:01:59,100
be able to find in your code base and

37
00:01:59,100 --> 00:02:01,899
how much ramp up time didn't need to

38
00:02:01,899 --> 00:02:03,429
figure out what's actually going on

39
00:02:03,429 --> 00:02:08,320
there so why do we actually use

40
00:02:08,320 --> 00:02:10,929
javascript to begin with it's not the

41
00:02:10,929 --> 00:02:13,980
best language in the world there's

42
00:02:13,980 --> 00:02:16,030
regardless of what style you prefer

43
00:02:16,030 --> 00:02:18,130
there's at least one language that's

44
00:02:18,130 --> 00:02:20,790
better that can compile to JavaScript

45
00:02:20,790 --> 00:02:26,500
except javascript is everywhere this is

46
00:02:26,500 --> 00:02:28,960
why we're using it it's at least

47
00:02:28,960 --> 00:02:30,340
something that a lot of people could

48
00:02:30,340 --> 00:02:31,560
agree on

49
00:02:31,560 --> 00:02:33,810
an art industry needs a baseline to

50
00:02:33,810 --> 00:02:37,470
build on top so javascript is one of

51
00:02:37,470 --> 00:02:38,940
those bass lines so we can build on top

52
00:02:38,940 --> 00:02:41,910
of and using a standard comes with a lot

53
00:02:41,910 --> 00:02:43,860
of benefits the right information is

54
00:02:43,860 --> 00:02:46,890
accessible tooling people to hire and so

55
00:02:46,890 --> 00:02:50,940
on so by introducing divergence in the

56
00:02:50,940 --> 00:02:52,800
library community we're actually

57
00:02:52,800 --> 00:02:55,670
undermining what makes JavaScript great

58
00:02:55,670 --> 00:02:58,170
we're already created in environments

59
00:02:58,170 --> 00:03:00,390
where you can't hire a JavaScript

60
00:03:00,390 --> 00:03:02,400
generalist anymore you have to hire a

61
00:03:02,400 --> 00:03:04,680
JavaScript specialist and a specific

62
00:03:04,680 --> 00:03:08,670
library at Facebook we have a very

63
00:03:08,670 --> 00:03:12,750
simple story we use JavaScript standard

64
00:03:12,750 --> 00:03:14,819
library there's one way to do things and

65
00:03:14,819 --> 00:03:17,430
it's the standard way they don't have an

66
00:03:17,430 --> 00:03:19,380
underscore we don't have utility

67
00:03:19,380 --> 00:03:21,540
libraries and avoids a very simple

68
00:03:21,540 --> 00:03:24,390
problem bike shedding it's the biggest

69
00:03:24,390 --> 00:03:27,180
waste of time of all we still have to do

70
00:03:27,180 --> 00:03:28,650
that but we keep that to the standards

71
00:03:28,650 --> 00:03:30,480
mailing lists and most of it is

72
00:03:30,480 --> 00:03:31,860
arbitrary anyways it doesn't really

73
00:03:31,860 --> 00:03:34,440
matter that much so why is the industry

74
00:03:34,440 --> 00:03:37,250
still using so many JavaScript libraries

75
00:03:37,250 --> 00:03:40,650
well this standard library is pretty

76
00:03:40,650 --> 00:03:42,750
small and it doesn't have all the

77
00:03:42,750 --> 00:03:46,079
features that you may want but many

78
00:03:46,079 --> 00:03:48,720
times the answer is just write a little

79
00:03:48,720 --> 00:03:51,900
bit more boilerplate code it takes you a

80
00:03:51,900 --> 00:03:53,850
few seconds longer you don't take on a

81
00:03:53,850 --> 00:03:56,459
dependency the person coming to fix your

82
00:03:56,459 --> 00:03:59,370
code later after your left or if they're

83
00:03:59,370 --> 00:04:01,829
busy in a meeting they don't have to

84
00:04:01,829 --> 00:04:03,810
learn some obscure functions or twenty

85
00:04:03,810 --> 00:04:05,430
other versions of the same functions

86
00:04:05,430 --> 00:04:07,470
that someone else bought was slightly

87
00:04:07,470 --> 00:04:11,480
better than this one one of the best

88
00:04:11,480 --> 00:04:14,010
lessons that I've learned that Facebook

89
00:04:14,010 --> 00:04:16,410
is that no abstraction can actually be

90
00:04:16,410 --> 00:04:19,459
better than a prong extraction and

91
00:04:19,459 --> 00:04:21,600
especially since abstractions build on

92
00:04:21,600 --> 00:04:23,039
top of each other they're difficult to

93
00:04:23,039 --> 00:04:28,610
unwind so proving that a general

94
00:04:28,610 --> 00:04:32,340
abstraction is worthwhile can actually

95
00:04:32,340 --> 00:04:34,260
be quite difficult and teaching it to in

96
00:04:34,260 --> 00:04:36,270
our entire industry is even more

97
00:04:36,270 --> 00:04:39,810
difficult it takes time and this is

98
00:04:39,810 --> 00:04:41,729
where the reason why standards are slow

99
00:04:41,729 --> 00:04:44,400
you may want JavaScript to copy feature

100
00:04:44,400 --> 00:04:45,280
from

101
00:04:45,280 --> 00:04:47,380
language but once you look at a lot of

102
00:04:47,380 --> 00:04:49,090
different languages is not really clear

103
00:04:49,090 --> 00:04:51,250
which one is the best one now you have

104
00:04:51,250 --> 00:04:52,810
to figure out which one is the best one

105
00:04:52,810 --> 00:04:55,540
because picking the wrong one is highly

106
00:04:55,540 --> 00:04:57,370
risky because our entire industry will

107
00:04:57,370 --> 00:05:02,200
have to figure that out but there are

108
00:05:02,200 --> 00:05:04,990
some features to a language that are

109
00:05:04,990 --> 00:05:06,580
really powerful and we really need them

110
00:05:06,580 --> 00:05:08,530
and we really need them as soon as

111
00:05:08,530 --> 00:05:12,639
possible the problem is that even after

112
00:05:12,639 --> 00:05:15,010
there's agreement on the value of this

113
00:05:15,010 --> 00:05:17,530
specific feature there's still a long

114
00:05:17,530 --> 00:05:19,690
process before it's actually implemented

115
00:05:19,690 --> 00:05:22,090
in browsers so this is proposal their

116
00:05:22,090 --> 00:05:24,780
standardization initial implementation

117
00:05:24,780 --> 00:05:27,070
mainstream browser support and then the

118
00:05:27,070 --> 00:05:32,080
long tail of browsers right and once the

119
00:05:32,080 --> 00:05:34,360
browser implements it it's too late to

120
00:05:34,360 --> 00:05:36,729
take it back so engines actually

121
00:05:36,729 --> 00:05:38,020
optimize for correctness and

122
00:05:38,020 --> 00:05:40,510
compatibility before speed performance

123
00:05:40,510 --> 00:05:44,110
or early implementations that's why the

124
00:05:44,110 --> 00:05:46,120
employability looks like this because

125
00:05:46,120 --> 00:05:49,060
for browsers is way too risky to

126
00:05:49,060 --> 00:05:52,780
implement something way too early but

127
00:05:52,780 --> 00:05:54,310
that's not really what adoption curve

128
00:05:54,310 --> 00:05:57,280
looks like because third party libraries

129
00:05:57,280 --> 00:06:01,539
don't have this restriction they get

130
00:06:01,539 --> 00:06:03,010
adopted before the standards in the

131
00:06:03,010 --> 00:06:05,860
provoke post the industry has already

132
00:06:05,860 --> 00:06:07,450
learned them by the time there is a

133
00:06:07,450 --> 00:06:12,430
standard and at the end of the curve we

134
00:06:12,430 --> 00:06:16,710
have support for new language features

135
00:06:16,710 --> 00:06:20,050
but by the time the new language feature

136
00:06:20,050 --> 00:06:23,410
occurs and it's available there's

137
00:06:23,410 --> 00:06:25,180
already ten libraries that have the same

138
00:06:25,180 --> 00:06:26,560
feature and now you have to learn to

139
00:06:26,560 --> 00:06:29,110
those ten libraries plus another

140
00:06:29,110 --> 00:06:31,330
language feature this is the point when

141
00:06:31,330 --> 00:06:32,590
people are starting to have a strong

142
00:06:32,590 --> 00:06:34,780
reaction against standards because they

143
00:06:34,780 --> 00:06:36,160
already have the feature they already

144
00:06:36,160 --> 00:06:39,190
have the possibility to do this and I

145
00:06:39,190 --> 00:06:42,340
don't want to learn at one more thing at

146
00:06:42,340 --> 00:06:45,190
Facebook it looks something like this we

147
00:06:45,190 --> 00:06:48,070
use small experimental libraries we roll

148
00:06:48,070 --> 00:06:50,050
it up slowly unless you really need it

149
00:06:50,050 --> 00:06:53,470
you're not going to use it too much and

150
00:06:53,470 --> 00:06:55,960
when there's a standard proposal we

151
00:06:55,960 --> 00:06:57,950
quickly roll off our

152
00:06:57,950 --> 00:07:00,810
experimental libraries and use polyfills

153
00:07:00,810 --> 00:07:03,060
instead even before the standard is

154
00:07:03,060 --> 00:07:07,110
filing so most developers won't actually

155
00:07:07,110 --> 00:07:09,540
see these ten different things of doing

156
00:07:09,540 --> 00:07:11,790
things they will jump straight on to the

157
00:07:11,790 --> 00:07:15,720
standards version and I'd like to see

158
00:07:15,720 --> 00:07:17,160
this happening more in our industry as a

159
00:07:17,160 --> 00:07:20,670
whole so why aren't you all using just

160
00:07:20,670 --> 00:07:23,820
poly feels so it's not that easy

161
00:07:23,820 --> 00:07:26,360
actually there's a few problems with it

162
00:07:26,360 --> 00:07:29,070
the primary problem of adopting too

163
00:07:29,070 --> 00:07:30,540
early is that the standards actually

164
00:07:30,540 --> 00:07:34,320
change a lot during the process and poly

165
00:07:34,320 --> 00:07:36,870
fills was differed slightly in various

166
00:07:36,870 --> 00:07:40,830
ways libraries have these problems as

167
00:07:40,830 --> 00:07:42,540
well within consistencies between

168
00:07:42,540 --> 00:07:45,780
versions so often you'll never never

169
00:07:45,780 --> 00:07:49,320
actually noticed this but it does become

170
00:07:49,320 --> 00:07:51,480
a problem when you have a third party

171
00:07:51,480 --> 00:07:54,840
code that depend on the changing

172
00:07:54,840 --> 00:07:56,790
standard and the various versions of

173
00:07:56,790 --> 00:08:00,780
polyfills and one of the reasons this is

174
00:08:00,780 --> 00:08:03,420
a problem is because most built-ins are

175
00:08:03,420 --> 00:08:05,340
only global object or in the prototype

176
00:08:05,340 --> 00:08:08,160
you can only have really realistically

177
00:08:08,160 --> 00:08:09,690
you can only really have one version at

178
00:08:09,690 --> 00:08:12,330
a time and different libraries may

179
00:08:12,330 --> 00:08:13,890
depend on different edge cases that

180
00:08:13,890 --> 00:08:16,710
can't be used together so if they go

181
00:08:16,710 --> 00:08:18,420
unfixed for a long time which they

182
00:08:18,420 --> 00:08:19,920
actually do unfortunately a lot of

183
00:08:19,920 --> 00:08:22,590
polyfills more and more code starts

184
00:08:22,590 --> 00:08:25,260
relying on a particular version of a

185
00:08:25,260 --> 00:08:28,710
polyfill so it's very important for its

186
00:08:28,710 --> 00:08:30,300
Paula feels to stay up to date but also

187
00:08:30,300 --> 00:08:31,920
the code that uses them to stay up to

188
00:08:31,920 --> 00:08:34,260
date but you can package multiple

189
00:08:34,260 --> 00:08:35,670
versions the Varden scores with your

190
00:08:35,670 --> 00:08:38,130
apps it's not ideal but you can it's

191
00:08:38,130 --> 00:08:40,490
much more difficult with a polyfill

192
00:08:40,490 --> 00:08:44,130
another issue which is similar to the

193
00:08:44,130 --> 00:08:48,320
one which brought up earlier is that

194
00:08:48,320 --> 00:08:50,670
some people like to discourage polyfills

195
00:08:50,670 --> 00:08:52,200
because they might actually break the

196
00:08:52,200 --> 00:08:56,430
spec and i'll explain what happened with

197
00:08:56,430 --> 00:09:00,960
string contains so this was another era

198
00:09:00,960 --> 00:09:03,450
long before es5 in the new wave of

199
00:09:03,450 --> 00:09:07,650
standards it was before Guillermo had

200
00:09:07,650 --> 00:09:08,700
facial hair

201
00:09:08,700 --> 00:09:11,940
where are you so gear when I was working

202
00:09:11,940 --> 00:09:14,850
on a framework called mootools at the

203
00:09:14,850 --> 00:09:17,700
time so muches was extending the

204
00:09:17,700 --> 00:09:19,650
building prototypes with some extra

205
00:09:19,650 --> 00:09:23,570
helper functions and we did it this way

206
00:09:23,570 --> 00:09:26,790
we checked if there was at existing

207
00:09:26,790 --> 00:09:28,710
function and if there wasn't we

208
00:09:28,710 --> 00:09:31,860
introduced our own one so what happens

209
00:09:31,860 --> 00:09:34,110
when the browser's try to implement this

210
00:09:34,110 --> 00:09:39,390
feature the new version comes in and it

211
00:09:39,390 --> 00:09:42,570
replaces the Muto's version which means

212
00:09:42,570 --> 00:09:44,580
that the website that relies on the

213
00:09:44,580 --> 00:09:49,260
Muto's behavior breaks so luckily we're

214
00:09:49,260 --> 00:09:52,740
learned our lesson with mootools 1.3 so

215
00:09:52,740 --> 00:09:56,460
instead of overriding them conditionally

216
00:09:56,460 --> 00:09:58,770
we unconditionally override any built-in

217
00:09:58,770 --> 00:10:04,260
version except the built-in version has

218
00:10:04,260 --> 00:10:07,290
a new mobility flag set to false which

219
00:10:07,290 --> 00:10:08,880
means that you can't loop over the

220
00:10:08,880 --> 00:10:12,510
property to find it so what happens with

221
00:10:12,510 --> 00:10:16,190
a second statement it no longer copies

222
00:10:16,190 --> 00:10:18,660
the object if the browser ever

223
00:10:18,660 --> 00:10:21,060
implements this feature so this is

224
00:10:21,060 --> 00:10:24,570
actually the reason why the browsers

225
00:10:24,570 --> 00:10:28,050
refuse to implement this so they're both

226
00:10:28,050 --> 00:10:31,890
fixed in newer versions of mootools but

227
00:10:31,890 --> 00:10:33,690
mucosal is a popular library back then

228
00:10:33,690 --> 00:10:36,150
and a lot of websites have deployed this

229
00:10:36,150 --> 00:10:39,090
version so we I guess we could just

230
00:10:39,090 --> 00:10:42,660
break them except nobody is working on

231
00:10:42,660 --> 00:10:44,070
them anymore there's no consultants

232
00:10:44,070 --> 00:10:46,470
working on these websites so if a

233
00:10:46,470 --> 00:10:49,440
browser introduces this feature it will

234
00:10:49,440 --> 00:10:53,070
break the website and people will start

235
00:10:53,070 --> 00:10:55,740
using another browser so whoever browser

236
00:10:55,740 --> 00:10:58,020
is the first one it's going to lose out

237
00:10:58,020 --> 00:11:00,540
and this is the classic browser game

238
00:11:00,540 --> 00:11:02,430
theory problem no browser wants to be

239
00:11:02,430 --> 00:11:04,020
the first one because they will lose

240
00:11:04,020 --> 00:11:09,930
customers so this is why a bad polyfill

241
00:11:09,930 --> 00:11:12,990
could potentially risk breaking the web

242
00:11:12,990 --> 00:11:15,690
and actually breaking the future

243
00:11:15,690 --> 00:11:20,420
standards that are trying to polyfill

244
00:11:20,430 --> 00:11:23,199
however this is not just a problem with

245
00:11:23,199 --> 00:11:27,430
coded mutates the prototype I've found

246
00:11:27,430 --> 00:11:30,430
this this we can react we actually check

247
00:11:30,430 --> 00:11:33,519
that the string object doesn't have a

248
00:11:33,519 --> 00:11:38,170
key property so if a browser ever

249
00:11:38,170 --> 00:11:39,699
implements the key property on the

250
00:11:39,699 --> 00:11:42,189
string they might break old versions of

251
00:11:42,189 --> 00:11:47,339
react and I picked two examples from

252
00:11:47,339 --> 00:11:49,149
libraries that I've been involved with

253
00:11:49,149 --> 00:11:51,550
but I'm not the only one doing this only

254
00:11:51,550 --> 00:11:53,499
one screwing up this is pretty easy

255
00:11:53,499 --> 00:11:56,589
mistakes to make but as you can see it's

256
00:11:56,589 --> 00:11:58,990
not just if you try to change prototypes

257
00:11:58,990 --> 00:12:02,379
it happens in libraries all the time and

258
00:12:02,379 --> 00:12:04,749
we just renamed pertains to includes

259
00:12:04,749 --> 00:12:07,059
it's not a big deal our suspects will

260
00:12:07,059 --> 00:12:08,790
have to find a way to work around this

261
00:12:08,790 --> 00:12:12,399
it's not a reason to not to you to avoid

262
00:12:12,399 --> 00:12:18,999
using polyfills there's a common

263
00:12:18,999 --> 00:12:20,589
misunderstanding that native functions

264
00:12:20,589 --> 00:12:23,170
are always faster than the polyfills or

265
00:12:23,170 --> 00:12:25,740
library features that's not true so

266
00:12:25,740 --> 00:12:30,220
naive polyfills tend to use the native

267
00:12:30,220 --> 00:12:33,399
implementation if it's available but

268
00:12:33,399 --> 00:12:34,750
then you can end up with the same

269
00:12:34,750 --> 00:12:37,240
problem that Muto's did right if the

270
00:12:37,240 --> 00:12:42,459
spec actually changes then people using

271
00:12:42,459 --> 00:12:44,769
your polyfill might actually break this

272
00:12:44,769 --> 00:12:49,689
back and additionally early

273
00:12:49,689 --> 00:12:51,250
implementations are often really very

274
00:12:51,250 --> 00:12:53,649
slow they're not optimized for speed yet

275
00:12:53,649 --> 00:12:55,120
they're optimized for correctness

276
00:12:55,120 --> 00:12:57,129
because it's high risk for a browser to

277
00:12:57,129 --> 00:12:59,110
introducing a feature so you have to

278
00:12:59,110 --> 00:13:04,959
make it correct so the solution is to

279
00:13:04,959 --> 00:13:06,970
simply just always override the native

280
00:13:06,970 --> 00:13:10,179
implementation until way into the long

281
00:13:10,179 --> 00:13:19,070
tail of browser support

282
00:13:19,080 --> 00:13:23,050
so for new syntax is general solution is

283
00:13:23,050 --> 00:13:26,050
to compile your modern code down to an

284
00:13:26,050 --> 00:13:28,660
older version you're not modifying the

285
00:13:28,660 --> 00:13:31,000
runtime so you don't really suffer from

286
00:13:31,000 --> 00:13:34,270
the same versioning problem and you can

287
00:13:34,270 --> 00:13:37,120
ship different versions of pre compiled

288
00:13:37,120 --> 00:13:42,370
code however transpiring tools I mean

289
00:13:42,370 --> 00:13:44,770
they're great they're they're efficient

290
00:13:44,770 --> 00:13:46,470
than the this setup is fairly easy

291
00:13:46,470 --> 00:13:49,660
however people have a very strong

292
00:13:49,660 --> 00:13:52,090
reaction to that extra compilation step

293
00:13:52,090 --> 00:13:55,960
people don't like compilation for

294
00:13:55,960 --> 00:13:57,100
production it doesn't really matter that

295
00:13:57,100 --> 00:13:59,080
much to be honest like you have a mini

296
00:13:59,080 --> 00:14:01,750
fire in packager anyway so plugging in a

297
00:14:01,750 --> 00:14:04,780
compiler in your pipeline isn't that big

298
00:14:04,780 --> 00:14:06,340
of deal if it's fast enough and the

299
00:14:06,340 --> 00:14:07,690
Facebook we're working very hard on

300
00:14:07,690 --> 00:14:10,840
making these tools fast enough however

301
00:14:10,840 --> 00:14:12,550
looking at the long tail of the jse

302
00:14:12,550 --> 00:14:14,680
ecosystem support for new language

303
00:14:14,680 --> 00:14:17,650
features is actually pretty bad but this

304
00:14:17,650 --> 00:14:19,270
is strictly a tooling problem that we

305
00:14:19,270 --> 00:14:21,730
can solve if you use the well supported

306
00:14:21,730 --> 00:14:23,380
and frequently updated parser than

307
00:14:23,380 --> 00:14:25,990
linters will work with that and what

308
00:14:25,990 --> 00:14:29,350
happens is that these tools tend to die

309
00:14:29,350 --> 00:14:32,290
off when they don't support the new

310
00:14:32,290 --> 00:14:34,150
features they get replaced by other ones

311
00:14:34,150 --> 00:14:41,350
anyway and compilation isn't really an

312
00:14:41,350 --> 00:14:44,170
inherence problem to to this transpire

313
00:14:44,170 --> 00:14:48,940
situation browsers could have

314
00:14:48,940 --> 00:14:51,430
first-class support for trailers or you

315
00:14:51,430 --> 00:14:53,080
can make it browser extension to do it

316
00:14:53,080 --> 00:14:55,660
or you can make a operating system

317
00:14:55,660 --> 00:14:57,160
extension that makes it easy to just

318
00:14:57,160 --> 00:15:01,220
open any file and have a chance pilot

319
00:15:01,230 --> 00:15:03,280
completion happens anyway in the browser

320
00:15:03,280 --> 00:15:06,550
it it happens within the runtime on the

321
00:15:06,550 --> 00:15:09,700
fly so why shouldn't be able to do that

322
00:15:09,700 --> 00:15:12,640
on the fly with a client side to a

323
00:15:12,640 --> 00:15:16,180
spider as well one problem with the

324
00:15:16,180 --> 00:15:18,040
currents which is that there's way too

325
00:15:18,040 --> 00:15:20,200
many options out there having too many

326
00:15:20,200 --> 00:15:22,260
options can actually be a bad thing

327
00:15:22,260 --> 00:15:24,550
getting the polo fields right it's very

328
00:15:24,550 --> 00:15:26,830
difficult and various polyfills depend

329
00:15:26,830 --> 00:15:28,630
on each other's and when they overlap

330
00:15:28,630 --> 00:15:31,180
they might not be compatible with it

331
00:15:31,180 --> 00:15:33,700
other in slightly different ways so I

332
00:15:33,700 --> 00:15:35,290
would recommend using like a full

333
00:15:35,290 --> 00:15:42,970
end-to-end solution and it's not having

334
00:15:42,970 --> 00:15:44,830
too many choices not actually a good

335
00:15:44,830 --> 00:15:47,200
thing in this regard because people

336
00:15:47,200 --> 00:15:50,320
avoid using polyfills because is so

337
00:15:50,320 --> 00:15:52,990
difficult to set up so you actually want

338
00:15:52,990 --> 00:15:54,730
something that is easy and we're just

339
00:15:54,730 --> 00:15:58,120
works out of the box policy tools as a

340
00:15:58,120 --> 00:16:00,220
service is one of these new easy

341
00:16:00,220 --> 00:16:03,310
phenomenons it only really works on

342
00:16:03,310 --> 00:16:06,130
runtime follicles it's pretty easy good

343
00:16:06,130 --> 00:16:08,500
to get started there's still kind of a

344
00:16:08,500 --> 00:16:13,390
lot of configuration options but there's

345
00:16:13,390 --> 00:16:16,330
also a single point of failure which

346
00:16:16,330 --> 00:16:20,560
means that if the CDN updates or goes

347
00:16:20,560 --> 00:16:23,970
down in the future in the long term then

348
00:16:23,970 --> 00:16:28,200
you might break the website and that's

349
00:16:28,200 --> 00:16:32,110
that may seem like a bad thing and for

350
00:16:32,110 --> 00:16:33,820
your clients this probably is but for

351
00:16:33,820 --> 00:16:34,900
the rest of us is actually a good thing

352
00:16:34,900 --> 00:16:37,450
because you can't accidentally break the

353
00:16:37,450 --> 00:16:42,070
future of the web it's the right spirit

354
00:16:42,070 --> 00:16:43,870
that like I've enumerated a lot of

355
00:16:43,870 --> 00:16:46,180
problems here and there all solvable we

356
00:16:46,180 --> 00:16:47,710
just need to start building a cohesive

357
00:16:47,710 --> 00:16:49,930
story around public wheels and buy into

358
00:16:49,930 --> 00:16:53,530
it from the end-to-end stack some people

359
00:16:53,530 --> 00:16:55,090
think the polyfills is a temporary hack

360
00:16:55,090 --> 00:16:56,740
that we don't really have to focus on

361
00:16:56,740 --> 00:17:00,520
it's something that we use now to to get

362
00:17:00,520 --> 00:17:05,530
rid of older browsers eventually but we

363
00:17:05,530 --> 00:17:09,370
won't as long as the web is evolving

364
00:17:09,370 --> 00:17:11,770
it's not an ad hoc hack it needs to be a

365
00:17:11,770 --> 00:17:13,930
natural part of all of our tools chain

366
00:17:13,930 --> 00:17:16,300
and if your tool chain doesn't support

367
00:17:16,300 --> 00:17:18,340
the bleeding edge polyfills entrance

368
00:17:18,340 --> 00:17:21,000
filers it might actually be left behind

369
00:17:21,000 --> 00:17:23,980
so all the major UI frameworks have

370
00:17:23,980 --> 00:17:26,410
announced intentions to design their new

371
00:17:26,410 --> 00:17:29,830
versions or new features with es7 in

372
00:17:29,830 --> 00:17:35,440
mind naughty s6 s7 and this is because

373
00:17:35,440 --> 00:17:37,900
all the new frameworks buy into this

374
00:17:37,900 --> 00:17:39,880
story of having polyfills and and

375
00:17:39,880 --> 00:17:44,450
adopting new standards very early

376
00:17:44,460 --> 00:17:46,690
another faint is showing up there's all

377
00:17:46,690 --> 00:17:49,120
these new type systems making the right

378
00:17:49,120 --> 00:17:51,460
into JavaScript they all have special

379
00:17:51,460 --> 00:17:53,650
annotations and if you want to use the

380
00:17:53,650 --> 00:17:55,750
type annotations you still need some

381
00:17:55,750 --> 00:17:57,850
kind of compile step to strip them out

382
00:17:57,850 --> 00:18:00,160
because they will realistically not be

383
00:18:00,160 --> 00:18:01,960
standardized anytime soon it will take a

384
00:18:01,960 --> 00:18:03,640
long time to standardize these type

385
00:18:03,640 --> 00:18:07,420
systems because this the tc39 doesn't

386
00:18:07,420 --> 00:18:09,549
want to standardize an incomplete type

387
00:18:09,549 --> 00:18:10,870
system they want a complete solution

388
00:18:10,870 --> 00:18:16,360
standardized which means that these

389
00:18:16,360 --> 00:18:18,070
limitations will live on for a long time

390
00:18:18,070 --> 00:18:22,630
without supporting the browser's ideally

391
00:18:22,630 --> 00:18:23,590
we don't want to end up in this

392
00:18:23,590 --> 00:18:25,900
situation where every framework has its

393
00:18:25,900 --> 00:18:28,030
own language and depends on a certain

394
00:18:28,030 --> 00:18:31,390
segment of transpires and polyfills it's

395
00:18:31,390 --> 00:18:32,890
natural that every framework cares

396
00:18:32,890 --> 00:18:34,780
little bit more about certain features

397
00:18:34,780 --> 00:18:37,690
than other features so they will try to

398
00:18:37,690 --> 00:18:39,520
jump on a particular transpiler

399
00:18:39,520 --> 00:18:42,730
particular polyfill but this is a

400
00:18:42,730 --> 00:18:45,160
configuration problem that doesn't

401
00:18:45,160 --> 00:18:47,320
affect most developers then in their

402
00:18:47,320 --> 00:18:50,320
day-to-day life but it's everyone's

403
00:18:50,320 --> 00:18:52,059
responsibility to sort of cooperate and

404
00:18:52,059 --> 00:18:54,370
try to move towards a unified JavaScript

405
00:18:54,370 --> 00:18:57,280
so we avoid the situation with the

406
00:18:57,280 --> 00:19:03,340
virgin libraries but using just

407
00:19:03,340 --> 00:19:05,290
JavaScript doesn't matter necessarily

408
00:19:05,290 --> 00:19:07,780
mean that you have to use all of it so

409
00:19:07,780 --> 00:19:09,490
JavaScript already has a very large

410
00:19:09,490 --> 00:19:11,980
surface area and if we want to add more

411
00:19:11,980 --> 00:19:14,020
features to it we need to remove

412
00:19:14,020 --> 00:19:16,120
something so that we can learn any

413
00:19:16,120 --> 00:19:18,280
features and the new people coming into

414
00:19:18,280 --> 00:19:19,990
our industry doesn't have to learn all

415
00:19:19,990 --> 00:19:22,500
the legacy that comes with along with it

416
00:19:22,500 --> 00:19:26,820
so linters strictmode vm optimizations

417
00:19:26,820 --> 00:19:29,590
they all discourage certain behavior

418
00:19:29,590 --> 00:19:31,570
certain JavaScript features they can

419
00:19:31,570 --> 00:19:34,240
never be removed and unsupported but

420
00:19:34,240 --> 00:19:36,250
they can be removed from our industry's

421
00:19:36,250 --> 00:19:38,169
mental surface area in the sense that

422
00:19:38,169 --> 00:19:39,700
you don't really have to know them to be

423
00:19:39,700 --> 00:19:42,549
productive in our industry so don't use

424
00:19:42,549 --> 00:19:44,290
the crazy parts of JavaScript just

425
00:19:44,290 --> 00:19:48,040
because we can and hopefully we can get

426
00:19:48,040 --> 00:19:50,620
to a adoption rate that looks something

