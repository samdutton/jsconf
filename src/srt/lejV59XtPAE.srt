1
00:00:08,330 --> 00:00:13,139

thank you hello jazz conf Asia I'm Isaac

2
00:00:13,139 --> 00:00:15,780
you can find me on twitter and github at

3
00:00:15,780 --> 00:00:23,430
superstructure I live around here you

4
00:00:23,430 --> 00:00:25,019
might recognize this as a scene from

5
00:00:25,019 --> 00:00:28,140
Middle Earth and a lot of the Rings more

6
00:00:28,140 --> 00:00:29,880
realistically known as in New Zealand

7
00:00:29,880 --> 00:00:31,920
it's a beautiful country so if you have

8
00:00:31,920 --> 00:00:33,840
the opportunity i highly recommend a

9
00:00:33,840 --> 00:00:40,770
visit most of my recent commercial work

10
00:00:40,770 --> 00:00:42,899
has been on a cloud security platform

11
00:00:42,899 --> 00:00:46,649
called SMX the main product is cloud

12
00:00:46,649 --> 00:00:48,450
email security used by the New Zealand

13
00:00:48,450 --> 00:00:50,670
government the Defence Force in most

14
00:00:50,670 --> 00:00:53,250
businesses so we have JavaScript engines

15
00:00:53,250 --> 00:00:55,289
running inside our mail servers that

16
00:00:55,289 --> 00:00:57,000
handle the majority of mail flow in the

17
00:00:57,000 --> 00:00:59,820
whole country that's always so used by

18
00:00:59,820 --> 00:01:02,280
other countries such as Australia Japan

19
00:01:02,280 --> 00:01:10,170
India the average juggler can juggle

20
00:01:10,170 --> 00:01:15,390
about three things at a time like in

21
00:01:15,390 --> 00:01:19,110
this example but then he still manages

22
00:01:19,110 --> 00:01:29,880
to set himself on fire

23
00:01:29,890 --> 00:01:32,750
the most amazing juggler in the world as

24
00:01:32,750 --> 00:01:35,480
a world record can joke about 13 things

25
00:01:35,480 --> 00:01:37,460
at a time so it's not really a lot more

26
00:01:37,460 --> 00:01:39,710
in the context of things if you think

27
00:01:39,710 --> 00:01:42,070
about fifty or one hundred or a thousand

28
00:01:42,070 --> 00:01:44,980
so if we think about this as an analogy

29
00:01:44,980 --> 00:01:47,600
before our mental capability as

30
00:01:47,600 --> 00:01:49,880
JavaScript programmers how many things

31
00:01:49,880 --> 00:01:51,860
about your program can you think about

32
00:01:51,860 --> 00:01:55,160
at any one time how many parts of your

33
00:01:55,160 --> 00:01:58,640
program can you juggle most people can

34
00:01:58,640 --> 00:02:00,200
think about around seven things at a

35
00:02:00,200 --> 00:02:02,330
time or if you're a complete genius

36
00:02:02,330 --> 00:02:05,900
maybe 14 but no one can think about 50

37
00:02:05,900 --> 00:02:13,430
or 100 so the basic premise of this talk

38
00:02:13,430 --> 00:02:15,740
is that compared to the programs we

39
00:02:15,740 --> 00:02:18,860
create we're all extremely limited and

40
00:02:18,860 --> 00:02:21,050
our ability to understand and reason

41
00:02:21,050 --> 00:02:23,600
about the software how can we get to the

42
00:02:23,600 --> 00:02:25,880
next level of software creation without

43
00:02:25,880 --> 00:02:32,420
exceeding our mental capacities and this

44
00:02:32,420 --> 00:02:34,690
talk will look at what reliability

45
00:02:34,690 --> 00:02:38,090
simplicity and easiness means how these

46
00:02:38,090 --> 00:02:39,500
things are related to solving the

47
00:02:39,500 --> 00:02:43,209
problems on limits our mental capacity

48
00:02:43,209 --> 00:02:45,500
then go through some code examples in

49
00:02:45,500 --> 00:02:47,720
JavaScript to help mitigate these

50
00:02:47,720 --> 00:02:50,900
problems in practice this is a technical

51
00:02:50,900 --> 00:02:53,000
talk if your JavaScript programmer that

52
00:02:53,000 --> 00:02:55,780
is based on concepts you already know

53
00:02:55,780 --> 00:02:58,700
unfortunately there's no music robots or

54
00:02:58,700 --> 00:03:00,830
live demonstrations it's a practical

55
00:03:00,830 --> 00:03:04,010
talk on everyday JavaScript I'm not

56
00:03:04,010 --> 00:03:05,390
going to assume you know any of this

57
00:03:05,390 --> 00:03:07,160
already so if you do functional

58
00:03:07,160 --> 00:03:08,750
programming which is going to be

59
00:03:08,750 --> 00:03:11,000
discussed and haskell or closure or

60
00:03:11,000 --> 00:03:13,489
something similar this will be quite

61
00:03:13,489 --> 00:03:16,640
slow we might have time for questions at

62
00:03:16,640 --> 00:03:19,070
the end but we'll see how it goes let's

63
00:03:19,070 --> 00:03:21,440
talk is not original work that's

64
00:03:21,440 --> 00:03:23,660
borrowing a lot from other languages and

65
00:03:23,660 --> 00:03:26,840
it's based on a 75 year history of work

66
00:03:26,840 --> 00:03:29,180
by other people just reapplying it in

67
00:03:29,180 --> 00:03:31,910
the context of JavaScript especially

68
00:03:31,910 --> 00:03:33,830
want to create rich Hickey they created

69
00:03:33,830 --> 00:03:35,840
the closure programming language for as

70
00:03:35,840 --> 00:03:37,850
explanation of simplicity versus

71
00:03:37,850 --> 00:03:39,650
easiness which I'll summarize in this

72
00:03:39,650 --> 00:03:42,250
talk as I assume some people might not

73
00:03:42,250 --> 00:03:44,530
those definitions that he's talked about

74
00:03:44,530 --> 00:03:47,560
I recommend you look up all of Ricky's

75
00:03:47,560 --> 00:03:48,910
talks on YouTube even though they're not

76
00:03:48,910 --> 00:03:50,830
about JavaScript they will help you

77
00:03:50,830 --> 00:03:55,480
become a better programmer so first

78
00:03:55,480 --> 00:03:57,280
let's establish some common terminology

79
00:03:57,280 --> 00:04:01,510
of some important terms words mean

80
00:04:01,510 --> 00:04:02,950
different things to different people and

81
00:04:02,950 --> 00:04:04,450
there are a few words you'll need to

82
00:04:04,450 --> 00:04:10,209
understand so I do email email happens

83
00:04:10,209 --> 00:04:12,610
to be something users just expect to

84
00:04:12,610 --> 00:04:15,390
work so the project I'm working on

85
00:04:15,390 --> 00:04:18,100
reliability means that email is actually

86
00:04:18,100 --> 00:04:20,470
delivered that is delivered quickly and

87
00:04:20,470 --> 00:04:23,020
is accurate so for me it's primarily

88
00:04:23,020 --> 00:04:26,350
about quality and correctness for you

89
00:04:26,350 --> 00:04:28,150
reliability may have different meanings

90
00:04:28,150 --> 00:04:30,550
such as software being delivered on time

91
00:04:30,550 --> 00:04:35,110
or controlling the cost of building and

92
00:04:35,110 --> 00:04:37,240
maintaining the software or being able

93
00:04:37,240 --> 00:04:38,800
to confidently change the software and

94
00:04:38,800 --> 00:04:41,950
the sense almost all of us here probably

95
00:04:41,950 --> 00:04:43,030
care in one way or another about

96
00:04:43,030 --> 00:04:45,940
reliability and that our software can be

97
00:04:45,940 --> 00:04:48,040
trusted in one way or another if you

98
00:04:48,040 --> 00:04:53,860
don't why not can you imagine a better

99
00:04:53,860 --> 00:04:55,810
word start the sentence then simplicity

100
00:04:55,810 --> 00:05:00,580
I can't we need to build simple systems

101
00:05:00,580 --> 00:05:05,740
if we want to build reliable systems so

102
00:05:05,740 --> 00:05:08,740
what does simple actually mean the root

103
00:05:08,740 --> 00:05:11,460
of the word simple are some and flex

104
00:05:11,460 --> 00:05:14,850
that means one fold or braids or twists

105
00:05:14,850 --> 00:05:19,240
or untwisted what does one braid look

106
00:05:19,240 --> 00:05:21,840
like it looks like no braids the

107
00:05:21,840 --> 00:05:24,970
opposite word is complex that means

108
00:05:24,970 --> 00:05:27,910
braided together or folded like twisted

109
00:05:27,910 --> 00:05:30,760
together so we need to be able to think

110
00:05:30,760 --> 00:05:32,440
about our software in terms of whether

111
00:05:32,440 --> 00:05:35,710
it is folded together or not simple

112
00:05:35,710 --> 00:05:37,690
things might have one dimension one

113
00:05:37,690 --> 00:05:40,900
focus or one objective the important

114
00:05:40,900 --> 00:05:42,520
word here is the braiding and the

115
00:05:42,520 --> 00:05:45,640
interleaving not the word one simple is

116
00:05:45,640 --> 00:05:47,560
not about only having one operation or

117
00:05:47,560 --> 00:05:50,050
one instance of something simple is

118
00:05:50,050 --> 00:05:52,990
about that there's no interleaving so

119
00:05:52,990 --> 00:05:55,280
you can think about things in isolation

120
00:05:55,280 --> 00:05:57,410
you can see on the left and right there

121
00:05:57,410 --> 00:05:59,270
are the same number of strands it's four

122
00:05:59,270 --> 00:06:02,150
strands on the left it is not braided

123
00:06:02,150 --> 00:06:03,980
and the right it is so simply has

124
00:06:03,980 --> 00:06:06,280
nothing to do with cardinality

125
00:06:06,280 --> 00:06:08,840
simplicity is kind of objective you can

126
00:06:08,840 --> 00:06:11,090
actually look at something and see if

127
00:06:11,090 --> 00:06:19,770
it's connected to something else or not

128
00:06:19,780 --> 00:06:22,250
so the bad thing about complexity is

129
00:06:22,250 --> 00:06:24,320
though if you want to think about a

130
00:06:24,320 --> 00:06:26,150
piece of your software and it's braided

131
00:06:26,150 --> 00:06:28,550
together with something else then you

132
00:06:28,550 --> 00:06:29,960
also have to think about that other part

133
00:06:29,960 --> 00:06:31,610
and if it's braided to give this with

134
00:06:31,610 --> 00:06:32,870
something else you start pulling all

135
00:06:32,870 --> 00:06:34,610
these parts of your software in just to

136
00:06:34,610 --> 00:06:37,460
solve a single problem you can't think

137
00:06:37,460 --> 00:06:39,410
about just one concept or dimension and

138
00:06:39,410 --> 00:06:45,260
isolation another word we frequently

139
00:06:45,260 --> 00:06:48,560
confused with simple is easy which in

140
00:06:48,560 --> 00:06:50,180
this derivation is from the leading word

141
00:06:50,180 --> 00:06:53,240
adjacent which means to line Nia and be

142
00:06:53,240 --> 00:06:56,060
nearby so there are several meanings

143
00:06:56,060 --> 00:06:58,550
that you can take from this there's the

144
00:06:58,550 --> 00:07:00,710
physical meaning of being near like it's

145
00:07:00,710 --> 00:07:02,840
something right here by right beside me

146
00:07:02,840 --> 00:07:05,479
is it in my toolkit or is it installed

147
00:07:05,479 --> 00:07:08,570
on my computer there's also is it near

148
00:07:08,570 --> 00:07:10,310
to our understanding or is it in our

149
00:07:10,310 --> 00:07:12,860
current skill set the word in this case

150
00:07:12,860 --> 00:07:15,340
is about being a familiar concept as

151
00:07:15,340 --> 00:07:17,900
programmers we're so tremendously self

152
00:07:17,900 --> 00:07:19,450
involved in these two meanings of easy

153
00:07:19,450 --> 00:07:21,770
and we think about this far more than we

154
00:07:21,770 --> 00:07:23,450
should and instead of thinking about

155
00:07:23,450 --> 00:07:25,880
what is simple simplicity is not the

156
00:07:25,880 --> 00:07:28,039
same as easy simplicity is not about

157
00:07:28,039 --> 00:07:29,419
your personal abilities that's not about

158
00:07:29,419 --> 00:07:30,800
your convenience and it's not about your

159
00:07:30,800 --> 00:07:36,410
tastes so the first meaning of easy is

160
00:07:36,410 --> 00:07:38,350
this notion of being physically nearby

161
00:07:38,350 --> 00:07:41,479
we care so much about we can npm install

162
00:07:41,479 --> 00:07:43,070
something and get it working in a few

163
00:07:43,070 --> 00:07:45,320
seconds often we don't think about if

164
00:07:45,320 --> 00:07:47,120
the thing we installing is a giant ball

165
00:07:47,120 --> 00:07:49,280
of complexity just that we can get it

166
00:07:49,280 --> 00:07:52,220
right now this is really easy but is it

167
00:07:52,220 --> 00:07:53,660
good for the reliability of your

168
00:07:53,660 --> 00:07:57,620
software conversely if something is

169
00:07:57,620 --> 00:08:01,970
simple but it is not easy then because

170
00:08:01,970 --> 00:08:04,070
it is not nearby then it is within your

171
00:08:04,070 --> 00:08:06,710
control to bring it nearby by making it

172
00:08:06,710 --> 00:08:08,480
part of your talk or installing it

173
00:08:08,480 --> 00:08:14,270
I can't read this because i can't read

174
00:08:14,270 --> 00:08:17,210
chinese we don't learn Chinese and New

175
00:08:17,210 --> 00:08:19,340
Zealand school unfortunately does that

176
00:08:19,340 --> 00:08:22,640
make Chinese unreadable there's Chinese

177
00:08:22,640 --> 00:08:25,790
unreadable no I just don't know Chinese

178
00:08:25,790 --> 00:08:28,820
so as programmers we're too fixated on

179
00:08:28,820 --> 00:08:30,590
this notion of easy related to

180
00:08:30,590 --> 00:08:35,150
familiarity like I can't read that for

181
00:08:35,150 --> 00:08:36,830
this meaning I don't mean in regards to

182
00:08:36,830 --> 00:08:39,500
our limits or mental capacity as I was

183
00:08:39,500 --> 00:08:40,880
talking about earlier I just literally

184
00:08:40,880 --> 00:08:43,330
mean is it near something I already know

185
00:08:43,330 --> 00:08:45,770
if you want everything to be easy and

186
00:08:45,770 --> 00:08:47,800
familiar you'll never learn anything new

187
00:08:47,800 --> 00:08:50,090
because it cannot be significantly

188
00:08:50,090 --> 00:08:52,400
different from what you already know we

189
00:08:52,400 --> 00:08:54,080
also confuse this notion of easy with

190
00:08:54,080 --> 00:08:56,180
simple all the time by saying that I

191
00:08:56,180 --> 00:08:57,920
like to use some piece of technology in

192
00:08:57,920 --> 00:09:00,230
my stack because it is simple when I

193
00:09:00,230 --> 00:09:03,110
actually mean it it is easy excuse me

194
00:09:03,110 --> 00:09:10,040
I'll just quit that and when I mean it

195
00:09:10,040 --> 00:09:12,830
is easy I mean it is similar to

196
00:09:12,830 --> 00:09:16,130
something I already know conversely to

197
00:09:16,130 --> 00:09:17,900
make something you don't know which is

198
00:09:17,900 --> 00:09:19,700
simple familiar all you need to do is

199
00:09:19,700 --> 00:09:21,590
learn it that's totally within your

200
00:09:21,590 --> 00:09:27,200
control to make it easy then there's the

201
00:09:27,200 --> 00:09:28,910
third notion of being easy which is the

202
00:09:28,910 --> 00:09:31,010
most interesting which is being near to

203
00:09:31,010 --> 00:09:32,810
our mental capacity to understand

204
00:09:32,810 --> 00:09:34,610
something because then this were all

205
00:09:34,610 --> 00:09:37,700
very similar how many conceptual balls

206
00:09:37,700 --> 00:09:40,580
can you juggle this makes developers

207
00:09:40,580 --> 00:09:43,130
uncomfortable because we're in the field

208
00:09:43,130 --> 00:09:47,450
of working and conceptual work so if we

209
00:09:47,450 --> 00:09:48,890
talk about something being outside a

210
00:09:48,890 --> 00:09:52,370
mental capacity it hurts our egos we all

211
00:09:52,370 --> 00:09:54,500
have very similar limitations relative

212
00:09:54,500 --> 00:09:56,120
to the complexity of the software we can

213
00:09:56,120 --> 00:09:59,300
create so it's not so embarrassing after

214
00:09:59,300 --> 00:10:02,600
all we all can't juggle like a hundred

215
00:10:02,600 --> 00:10:05,390
balls this is the notion of easy you can

216
00:10:05,390 --> 00:10:07,250
actually control to great benefit in

217
00:10:07,250 --> 00:10:09,110
your software if you're willing to learn

218
00:10:09,110 --> 00:10:11,090
some onion familiar ways to write

219
00:10:11,090 --> 00:10:13,550
JavaScript you can drastically simplify

220
00:10:13,550 --> 00:10:15,590
your software making it easier to

221
00:10:15,590 --> 00:10:20,300
understand and ultimately more reliable

222
00:10:20,310 --> 00:10:22,240
we're in the business of producing

223
00:10:22,240 --> 00:10:24,850
artifacts for users but we think so much

224
00:10:24,850 --> 00:10:28,060
about the constructs does a user look at

225
00:10:28,060 --> 00:10:29,589
our source code and say oh that's so

226
00:10:29,589 --> 00:10:32,260
nice that javascript is just so amazing

227
00:10:32,260 --> 00:10:36,970
Wow no users don't care about that that

228
00:10:36,970 --> 00:10:40,019
users care about usability correctness

229
00:10:40,019 --> 00:10:42,790
performance and the ability to change

230
00:10:42,790 --> 00:10:45,820
the software these are all attributes of

231
00:10:45,820 --> 00:10:48,420
the artifact not the construct

232
00:10:48,420 --> 00:10:51,190
complexity is endemic and software

233
00:10:51,190 --> 00:10:53,230
because as developers were too often

234
00:10:53,230 --> 00:10:55,149
thinking I like this because it's good

235
00:10:55,149 --> 00:10:58,120
for me personally right now so we need

236
00:10:58,120 --> 00:10:58,930
to start thinking about building

237
00:10:58,930 --> 00:11:00,370
software in terms of the complexity of

238
00:11:00,370 --> 00:11:02,860
the artifact we produce and give to

239
00:11:02,860 --> 00:11:05,230
users not in terms of the easiness of

240
00:11:05,230 --> 00:11:10,029
the construct so Ricky revived this

241
00:11:10,029 --> 00:11:11,560
archaic word to describe creating

242
00:11:11,560 --> 00:11:14,230
complexity and it means to enter leave

243
00:11:14,230 --> 00:11:16,930
or into wine or two braids so when I say

244
00:11:16,930 --> 00:11:19,300
something is conflicting or as complex I

245
00:11:19,300 --> 00:11:20,980
mean it as breeding things together

246
00:11:20,980 --> 00:11:23,730
whereas the act of creating complexity

247
00:11:23,730 --> 00:11:26,050
complexity is bad so obviously

248
00:11:26,050 --> 00:11:32,199
completing is bad just don't do it I'm

249
00:11:32,199 --> 00:11:34,180
proposing that some concepts from

250
00:11:34,180 --> 00:11:36,430
functional programming drastically

251
00:11:36,430 --> 00:11:39,029
simplify the artifacts we produce

252
00:11:39,029 --> 00:11:41,110
functional programming covers a wide

253
00:11:41,110 --> 00:11:43,690
spectrum of languages there is no clear

254
00:11:43,690 --> 00:11:45,970
widely accepted definition of functional

255
00:11:45,970 --> 00:11:48,070
programming it's a collection of related

256
00:11:48,070 --> 00:11:50,440
features that which work together to

257
00:11:50,440 --> 00:11:53,529
form a very useful style using some

258
00:11:53,529 --> 00:11:55,899
features from functional programming can

259
00:11:55,899 --> 00:11:58,089
reduce braiding or complexity thus

260
00:11:58,089 --> 00:11:59,740
making a program easier to understand

261
00:11:59,740 --> 00:12:02,260
and increasing reliability some features

262
00:12:02,260 --> 00:12:04,000
are already widely used in JavaScript

263
00:12:04,000 --> 00:12:06,579
others require libraries and some are

264
00:12:06,579 --> 00:12:09,220
just not possible due to language

265
00:12:09,220 --> 00:12:14,709
constraints so different model

266
00:12:14,709 --> 00:12:16,300
programming is object orientated

267
00:12:16,300 --> 00:12:18,699
programming and this emphasizes the

268
00:12:18,699 --> 00:12:20,740
encapsulation of learning moving parts

269
00:12:20,740 --> 00:12:23,550
within classes and object instances and

270
00:12:23,550 --> 00:12:26,410
oh you bundle up data with methods that

271
00:12:26,410 --> 00:12:28,660
operate on the data whereas in

272
00:12:28,660 --> 00:12:31,149
functional programming emphasizes the

273
00:12:31,149 --> 00:12:32,800
use of functions to minimize the number

274
00:12:32,800 --> 00:12:33,329
of movie

275
00:12:33,329 --> 00:12:35,660
parts instead of encapsulating them and

276
00:12:35,660 --> 00:12:37,889
functional programming you have

277
00:12:37,889 --> 00:12:39,749
behaviorist functions that operate on

278
00:12:39,749 --> 00:12:41,459
the data as arguments and return values

279
00:12:41,459 --> 00:12:43,980
so on oh the central activity is around

280
00:12:43,980 --> 00:12:46,559
classes objects methods whereas in

281
00:12:46,559 --> 00:12:47,879
functional programming the central

282
00:12:47,879 --> 00:12:52,499
activity is all around functions so it's

283
00:12:52,499 --> 00:12:56,999
finally getting to some code this is

284
00:12:56,999 --> 00:13:00,290
valid JavaScript code albeit not useful

285
00:13:00,290 --> 00:13:03,600
both 42 and the string hello our values

286
00:13:03,600 --> 00:13:06,720
I think everyone can see that values

287
00:13:06,720 --> 00:13:10,589
don't change 42 is always 42 hello as

288
00:13:10,589 --> 00:13:13,379
always hello values are also not braided

289
00:13:13,379 --> 00:13:15,899
together with anything so they are

290
00:13:15,899 --> 00:13:21,629
simple and JavaScript for the primitive

291
00:13:21,629 --> 00:13:23,339
types such as if you add two numbers

292
00:13:23,339 --> 00:13:25,860
together or concatenate strings you

293
00:13:25,860 --> 00:13:28,139
always get a new value it does not

294
00:13:28,139 --> 00:13:30,959
modify the original number 40 so 40 plus

295
00:13:30,959 --> 00:13:33,899
2 creates 42 in addition to 40 and too

296
00:13:33,899 --> 00:13:36,929
or at the original string hello so this

297
00:13:36,929 --> 00:13:42,689
is all so simple if we bind the result

298
00:13:42,689 --> 00:13:45,290
of an expression like 40 plus 22 I

299
00:13:45,290 --> 00:13:47,850
identifier we get an identity

300
00:13:47,850 --> 00:13:50,759
referencing a value so meaning of life

301
00:13:50,759 --> 00:13:55,230
is an identity for the value 42 this is

302
00:13:55,230 --> 00:13:59,889
all so simple there's no braiding here

303
00:13:59,899 --> 00:14:02,639
now we have a problem the meaning of

304
00:14:02,639 --> 00:14:05,759
life has changed because of the

305
00:14:05,759 --> 00:14:07,949
different values of the time the program

306
00:14:07,949 --> 00:14:10,649
has been executed the state of the

307
00:14:10,649 --> 00:14:12,749
identifier referencing the value has

308
00:14:12,749 --> 00:14:14,459
changed or mutated into something else

309
00:14:14,459 --> 00:14:17,369
so we say the identify now is state and

310
00:14:17,369 --> 00:14:20,730
that the program is stateful how would

311
00:14:20,730 --> 00:14:22,410
you test this unless you step through it

312
00:14:22,410 --> 00:14:24,239
in a debugger you cannot inspect the

313
00:14:24,239 --> 00:14:25,679
runtime state or the identifier before

314
00:14:25,679 --> 00:14:27,689
has changed you can only test the most

315
00:14:27,689 --> 00:14:31,199
recent state state complex values with

316
00:14:31,199 --> 00:14:33,419
time you don't have the ability to get a

317
00:14:33,419 --> 00:14:36,089
value independent of time but this is so

318
00:14:36,089 --> 00:14:38,429
easy and familiar and so many of our

319
00:14:38,429 --> 00:14:39,989
programming languages and used by

320
00:14:39,989 --> 00:14:43,350
default in JavaScript a lot of people

321
00:14:43,350 --> 00:14:45,149
say state is bad because when threading

322
00:14:45,149 --> 00:14:45,779
and multi-core

323
00:14:45,779 --> 00:14:47,759
chips concurrency means you need to use

324
00:14:47,759 --> 00:14:50,009
locks but in this case it has nothing to

325
00:14:50,009 --> 00:14:52,259
do with concurrency state is complex

326
00:14:52,259 --> 00:14:54,029
because it is completing the software at

327
00:14:54,029 --> 00:14:56,189
a fundamental level the data is what

328
00:14:56,189 --> 00:15:03,160
you're operating on to produce a result

329
00:15:03,170 --> 00:15:06,149
Const creates a read-only reference to a

330
00:15:06,149 --> 00:15:07,829
value it does not mean the value of

331
00:15:07,829 --> 00:15:09,420
holds cannot change just that the

332
00:15:09,420 --> 00:15:11,100
identifier referencing value cannot be

333
00:15:11,100 --> 00:15:13,319
reassigned to a different value so this

334
00:15:13,319 --> 00:15:15,329
is better for primitive types like

335
00:15:15,329 --> 00:15:17,999
numbers and strings this effectively

336
00:15:17,999 --> 00:15:19,980
does provide immutability because you

337
00:15:19,980 --> 00:15:23,220
cannot modify those types anyway this is

338
00:15:23,220 --> 00:15:24,899
simple because we're not conflicting

339
00:15:24,899 --> 00:15:36,700
values in time

340
00:15:36,710 --> 00:15:40,100
to represent some information using

341
00:15:40,100 --> 00:15:42,110
objects as maps for key value records

342
00:15:42,110 --> 00:15:44,810
for values as simple because data is

343
00:15:44,810 --> 00:15:47,420
just data this is not braided together

344
00:15:47,420 --> 00:15:54,560
with anything but despite using const

345
00:15:54,560 --> 00:15:56,030
for a read-only reference to this map

346
00:15:56,030 --> 00:15:58,730
object objects as values are mutable and

347
00:15:58,730 --> 00:16:00,980
JavaScript this introduces a change of

348
00:16:00,980 --> 00:16:03,380
state by setting a new field so again

349
00:16:03,380 --> 00:16:05,900
this is conflicting time with values and

350
00:16:05,900 --> 00:16:12,860
it is complex a way to give around us in

351
00:16:12,860 --> 00:16:15,380
javascript is by using a library you can

352
00:16:15,380 --> 00:16:16,880
get immutable data structures and

353
00:16:16,880 --> 00:16:22,550
JavaScript this way with an immutable

354
00:16:22,550 --> 00:16:24,920
collection modifying the collection in

355
00:16:24,920 --> 00:16:28,220
any way returns a new value so after the

356
00:16:28,220 --> 00:16:30,800
last line here of confidence it both

357
00:16:30,800 --> 00:16:33,110
values persist as separate and isolated

358
00:16:33,110 --> 00:16:37,610
values the set call does not modify the

359
00:16:37,610 --> 00:16:39,370
value assigned to the comp reference

360
00:16:39,370 --> 00:16:41,660
immutable collections are simple because

361
00:16:41,660 --> 00:16:43,220
there are no conflicting of values in

362
00:16:43,220 --> 00:16:46,430
time immutable collections can also be

363
00:16:46,430 --> 00:16:47,840
used to do interesting things like time

364
00:16:47,840 --> 00:16:49,880
traveling debuggers which can show the

365
00:16:49,880 --> 00:16:50,990
state of values over the entire

366
00:16:50,990 --> 00:16:52,460
execution of the program because you

367
00:16:52,460 --> 00:16:56,510
never lose any changes this example is

368
00:16:56,510 --> 00:16:58,190
using a library called immutable from

369
00:16:58,190 --> 00:17:00,770
Facebook there is also a library called

370
00:17:00,770 --> 00:17:02,360
Morey from the closure community which

371
00:17:02,360 --> 00:17:04,880
is faster but immutable was used here as

372
00:17:04,880 --> 00:17:06,890
it has more support within JavaScript

373
00:17:06,890 --> 00:17:15,589
ecosystem so why immutability what do

374
00:17:15,589 --> 00:17:16,700
you have to do if you want to reproduce

375
00:17:16,700 --> 00:17:21,640
a bug in production or write a new test

376
00:17:21,640 --> 00:17:23,630
recreate the state of the program at

377
00:17:23,630 --> 00:17:26,959
that point in time because our software

378
00:17:26,959 --> 00:17:28,580
is operating a data there's a huge

379
00:17:28,580 --> 00:17:31,160
amount of state in our programs state is

380
00:17:31,160 --> 00:17:33,340
the source of the majority of complexity

381
00:17:33,340 --> 00:17:35,870
so using a mutable references and

382
00:17:35,870 --> 00:17:38,060
immutable collections can resolve a

383
00:17:38,060 --> 00:17:39,590
massive amount of the complexity in your

384
00:17:39,590 --> 00:17:41,810
software not only does it make your

385
00:17:41,810 --> 00:17:44,030
software easier to understand for some

386
00:17:44,030 --> 00:17:45,590
optimizations that are possible with

387
00:17:45,590 --> 00:17:47,540
frameworks like react it can be

388
00:17:47,540 --> 00:17:49,370
something like 50 times faster because

389
00:17:49,370 --> 00:17:49,640
of

390
00:17:49,640 --> 00:18:01,610
cheap chicks 24 changes to the data

391
00:18:01,620 --> 00:18:03,630
but what about memory usage if we keep

392
00:18:03,630 --> 00:18:06,830
all these versions of the data around

393
00:18:06,830 --> 00:18:09,630
modern mutable immutable collections

394
00:18:09,630 --> 00:18:11,640
like the immutable library is the

395
00:18:11,640 --> 00:18:14,760
feature called structural sharing for

396
00:18:14,760 --> 00:18:16,230
example this means that when you add an

397
00:18:16,230 --> 00:18:18,840
item to a collection the original is has

398
00:18:18,840 --> 00:18:21,090
not been changed but a new value is

399
00:18:21,090 --> 00:18:23,430
created with a reference to the original

400
00:18:23,430 --> 00:18:25,830
value and only the new item that has

401
00:18:25,830 --> 00:18:28,770
been added as stored in memory behind

402
00:18:28,770 --> 00:18:31,290
the scenes the data structures share

403
00:18:31,290 --> 00:18:33,809
common data between multiple values so

404
00:18:33,809 --> 00:18:35,130
you don't need to worry that this is

405
00:18:35,130 --> 00:18:36,929
costing a lot of memory or a lot of

406
00:18:36,929 --> 00:18:38,730
inefficiency in copying copying data

407
00:18:38,730 --> 00:18:44,250
around and memory does anyone know what

408
00:18:44,250 --> 00:18:48,809
this is no it's magnetic core memory

409
00:18:48,809 --> 00:18:52,980
that was used from 1955 until 1975 if

410
00:18:52,980 --> 00:18:55,320
you ever wondered with the term core

411
00:18:55,320 --> 00:18:57,630
dump for writing memory to a file came

412
00:18:57,630 --> 00:18:59,700
from it was originally used with core

413
00:18:59,700 --> 00:19:02,520
memory every ring you see is one bit of

414
00:19:02,520 --> 00:19:04,559
memory made from iron that had to be

415
00:19:04,559 --> 00:19:06,890
placed in that network of wires by hand

416
00:19:06,890 --> 00:19:10,470
but by bet it was woven on a loom each

417
00:19:10,470 --> 00:19:13,530
vet costs as much one as one dollar so

418
00:19:13,530 --> 00:19:15,270
by that measure my iphone has eight

419
00:19:15,270 --> 00:19:18,450
billion dollars of memory functional

420
00:19:18,450 --> 00:19:20,970
programming was invented in 1956 when

421
00:19:20,970 --> 00:19:23,160
this memory was on use so that time it

422
00:19:23,160 --> 00:19:25,800
was just too expensive the only reason

423
00:19:25,800 --> 00:19:27,210
we change locations in memory with

424
00:19:27,210 --> 00:19:28,380
mutable references and mutable

425
00:19:28,380 --> 00:19:30,660
collections is that we literally had to

426
00:19:30,660 --> 00:19:32,670
think about where and memory we would

427
00:19:32,670 --> 00:19:34,290
put something and then replace it when

428
00:19:34,290 --> 00:19:36,150
we didn't need it anymore because we

429
00:19:36,150 --> 00:19:37,890
didn't have enough available memory to

430
00:19:37,890 --> 00:19:41,400
use a new place and memory we don't have

431
00:19:41,400 --> 00:19:43,160
anything like these limitations anymore

432
00:19:43,160 --> 00:19:46,290
memory is plentiful cheap and fast so

433
00:19:46,290 --> 00:19:47,970
why we're using language decisions made

434
00:19:47,970 --> 00:19:53,580
for obsolete hardware let's look at an

435
00:19:53,580 --> 00:19:55,380
example that's a bit less trivial than

436
00:19:55,380 --> 00:19:57,540
storing simple values this is a

437
00:19:57,540 --> 00:19:59,610
sunflower a sub flowerheads follow the

438
00:19:59,610 --> 00:20:01,380
foot Bonacci sequence of numbers which

439
00:20:01,380 --> 00:20:06,130
is closely related to the golden ratio

440
00:20:06,140 --> 00:20:09,330
to get a Fibonacci number we start with

441
00:20:09,330 --> 00:20:11,610
two numbers one and one then each

442
00:20:11,610 --> 00:20:13,860
subsequent number as the previous two

443
00:20:13,860 --> 00:20:15,049
numbers added together

444
00:20:15,049 --> 00:20:17,210
so the first number is one the second

445
00:20:17,210 --> 00:20:19,669
number is 1 then 1 plus 1 is 2 for the

446
00:20:19,669 --> 00:20:21,320
third number and one plus two is three

447
00:20:21,320 --> 00:20:26,749
for the fourth number and so on this is

448
00:20:26,749 --> 00:20:28,070
a function that will get the info

449
00:20:28,070 --> 00:20:30,710
Bonacci number so if we want the fifth

450
00:20:30,710 --> 00:20:32,509
number would pacify them as the in

451
00:20:32,509 --> 00:20:35,269
argument not only is the state full as

452
00:20:35,269 --> 00:20:37,610
variables a changing state but loops

453
00:20:37,610 --> 00:20:40,190
also complex what you're doing with how

454
00:20:40,190 --> 00:20:43,070
to do it and the four definition it's

455
00:20:43,070 --> 00:20:44,809
checking if I is listening in on each

456
00:20:44,809 --> 00:20:47,149
step and incrementing I which is the

457
00:20:47,149 --> 00:20:49,759
iteration part and then inside the for

458
00:20:49,759 --> 00:20:51,679
loop the step part is calculating the

459
00:20:51,679 --> 00:20:55,190
value so loop represents conflicting

460
00:20:55,190 --> 00:20:56,629
different concerns and as a source of

461
00:20:56,629 --> 00:20:58,909
complexity could this be written so that

462
00:20:58,909 --> 00:21:06,830
is stateless and not using a loop it can

463
00:21:06,830 --> 00:21:09,489
be written this way it's not very useful

464
00:21:09,489 --> 00:21:12,590
to write it like this but no variables

465
00:21:12,590 --> 00:21:15,159
changing state and there is no looping

466
00:21:15,159 --> 00:21:17,809
also despite having no state branching

467
00:21:17,809 --> 00:21:19,820
complex with structure and organization

468
00:21:19,820 --> 00:21:21,980
in the program so branching is not

469
00:21:21,980 --> 00:21:28,080
actually simple there is a better way

470
00:21:28,090 --> 00:21:31,580
this is a recursive algorithm where thug

471
00:21:31,580 --> 00:21:33,919
calls itself until in as less than or

472
00:21:33,919 --> 00:21:37,100
equal to 2 then it will return one and

473
00:21:37,100 --> 00:21:39,919
stop calling itself no references change

474
00:21:39,919 --> 00:21:42,259
state new references are introduced with

475
00:21:42,259 --> 00:21:44,570
const but these are recreated every time

476
00:21:44,570 --> 00:21:46,669
functions called so if you call this

477
00:21:46,669 --> 00:21:49,369
function with 5 as the in value the

478
00:21:49,369 --> 00:21:50,600
lines at the bottom are the calls it

479
00:21:50,600 --> 00:21:52,039
will go through until is just adding

480
00:21:52,039 --> 00:21:54,889
ones together you can test the state of

481
00:21:54,889 --> 00:21:56,869
this function at any point simply by

482
00:21:56,869 --> 00:21:58,970
calling it with the right value for the

483
00:21:58,970 --> 00:22:04,039
in argument unfortunately until recently

484
00:22:04,039 --> 00:22:06,859
JavaScript recursion does not perform as

485
00:22:06,859 --> 00:22:08,720
well as there is overhead of creating

486
00:22:08,720 --> 00:22:11,629
stacks new stack context for erie

487
00:22:11,629 --> 00:22:16,789
function call in es2015 it is tail call

488
00:22:16,789 --> 00:22:18,669
optimization which will make this fast a

489
00:22:18,669 --> 00:22:21,529
tail call is when the very last thing

490
00:22:21,529 --> 00:22:24,679
the function does before returning as a

491
00:22:24,679 --> 00:22:27,350
recursive call to itself so this verb

492
00:22:27,350 --> 00:22:27,879
function

493
00:22:27,879 --> 00:22:30,190
is not optimized herbal because after

494
00:22:30,190 --> 00:22:32,949
calling itself it calls itself again so

495
00:22:32,949 --> 00:22:34,659
it's doing something else after it calls

496
00:22:34,659 --> 00:22:36,039
itself the first time in the return

497
00:22:36,039 --> 00:22:42,069
statement so let's rewrite the recursive

498
00:22:42,069 --> 00:22:44,469
function slightly so that there is just

499
00:22:44,469 --> 00:22:47,199
one recursive call and the return

500
00:22:47,199 --> 00:22:51,789
statement this is now a tail call the

501
00:22:51,789 --> 00:22:54,609
very last thing in the function is doing

502
00:22:54,609 --> 00:22:56,669
before returning is calling itself at

503
00:22:56,669 --> 00:22:58,929
this point why do we need to allocate

504
00:22:58,929 --> 00:23:01,539
more stack space the current invocation

505
00:23:01,539 --> 00:23:04,389
of the function will never need the spec

506
00:23:04,389 --> 00:23:06,819
space again as soon as it receives a

507
00:23:06,819 --> 00:23:08,829
value from the recursive call it will

508
00:23:08,829 --> 00:23:11,559
return to the caller so instead of

509
00:23:11,559 --> 00:23:13,809
allocating stack space we could simply

510
00:23:13,809 --> 00:23:15,759
reuse the stake space used by the

511
00:23:15,759 --> 00:23:17,919
current function invocation and inherit

512
00:23:17,919 --> 00:23:20,139
the return address which will return the

513
00:23:20,139 --> 00:23:22,299
Fibonacci number in the latest

514
00:23:22,299 --> 00:23:24,719
JavaScript engines putting ears 2015

515
00:23:24,719 --> 00:23:27,759
telco optimizations will make this fast

516
00:23:27,759 --> 00:23:35,110
and efficient

517
00:23:35,120 --> 00:23:38,070
so functions have a concept of purity

518
00:23:38,070 --> 00:23:39,840
and functional programming we say a

519
00:23:39,840 --> 00:23:42,540
function is impure if it causes state to

520
00:23:42,540 --> 00:23:45,090
change outside of the scope of itself

521
00:23:45,090 --> 00:23:47,460
this is also referred to as side effects

522
00:23:47,460 --> 00:23:49,650
because there is an effect outside of

523
00:23:49,650 --> 00:23:52,110
the scope of the function and pure

524
00:23:52,110 --> 00:23:54,030
functions are complex because yet again

525
00:23:54,030 --> 00:23:56,460
there's conflicting values in time over

526
00:23:56,460 --> 00:23:59,100
your program but you see the style of

527
00:23:59,100 --> 00:24:00,720
mutating outer scope variables all the

528
00:24:00,720 --> 00:24:09,200
time in JavaScript

529
00:24:09,210 --> 00:24:12,450
conversely a pure function only takes

530
00:24:12,450 --> 00:24:15,929
arguments and returns values it does not

531
00:24:15,929 --> 00:24:18,480
modify any other script state pure

532
00:24:18,480 --> 00:24:20,340
functions are easy to test in isolation

533
00:24:20,340 --> 00:24:22,230
because you only need to provide

534
00:24:22,230 --> 00:24:24,299
arguments to test the result there's not

535
00:24:24,299 --> 00:24:26,669
some otoscope state to set up and check

536
00:24:26,669 --> 00:24:29,580
and obviously pure functions don't

537
00:24:29,580 --> 00:24:36,220
complete time with values so simple so

538
00:24:36,230 --> 00:24:39,510
without loops and modifying values how

539
00:24:39,510 --> 00:24:41,070
do you convert one collection of values

540
00:24:41,070 --> 00:24:43,980
into another collection of values one of

541
00:24:43,980 --> 00:24:45,510
the most fundamental functions and

542
00:24:45,510 --> 00:24:48,240
functional programming is map which is

543
00:24:48,240 --> 00:24:50,190
used to convert one collection and to a

544
00:24:50,190 --> 00:24:52,260
related one by running the same function

545
00:24:52,260 --> 00:24:54,860
against each member of the collection

546
00:24:54,860 --> 00:24:57,510
any function that takes a function as an

547
00:24:57,510 --> 00:24:59,669
argument or returns a function as a

548
00:24:59,669 --> 00:25:01,860
return value as known as a higher-order

549
00:25:01,860 --> 00:25:05,390
function in general so in this example

550
00:25:05,390 --> 00:25:07,799
double is a function that is passed to

551
00:25:07,799 --> 00:25:09,330
the map function to run against each

552
00:25:09,330 --> 00:25:12,570
number this is simpler than loops

553
00:25:12,570 --> 00:25:15,419
because it does not conflict what you

554
00:25:15,419 --> 00:25:19,919
are doing with how to do it I put

555
00:25:19,919 --> 00:25:21,899
simpler with an R here because it's not

556
00:25:21,899 --> 00:25:25,350
as simple as it could be first I could

557
00:25:25,350 --> 00:25:27,029
be using immutable collections instead

558
00:25:27,029 --> 00:25:29,210
of the JavaScript mutable arrays in maps

559
00:25:29,210 --> 00:25:32,070
second I'll talk later about how common

560
00:25:32,070 --> 00:25:34,679
collection functions like map complete

561
00:25:34,679 --> 00:25:36,210
to the inputs and the outputs of the

562
00:25:36,210 --> 00:25:38,429
data with the steps or transformations

563
00:25:38,429 --> 00:25:44,610
you're performing on the data produce is

564
00:25:44,610 --> 00:25:46,500
a more general higher-order function for

565
00:25:46,500 --> 00:25:48,870
collections then map allows you to

566
00:25:48,870 --> 00:25:51,830
produce any new value from a collection

567
00:25:51,830 --> 00:25:54,450
so each invocation of the add function

568
00:25:54,450 --> 00:25:58,110
receives the value so far and returns

569
00:25:58,110 --> 00:26:00,059
the new value that would be passed into

570
00:26:00,059 --> 00:26:02,130
the next invocation of the add function

571
00:26:02,130 --> 00:26:04,649
in this way a value is built up over

572
00:26:04,649 --> 00:26:12,750
each member of the collection

573
00:26:12,760 --> 00:26:15,320
filter is another example of a common

574
00:26:15,320 --> 00:26:16,670
higher-order function for collections

575
00:26:16,670 --> 00:26:18,830
they will produce a new collection with

576
00:26:18,830 --> 00:26:20,990
any items that do not pass a truth test

577
00:26:20,990 --> 00:26:23,930
removed that as even function will be

578
00:26:23,930 --> 00:26:25,400
invoked for each member of the

579
00:26:25,400 --> 00:26:28,220
collection and if it returns false the

580
00:26:28,220 --> 00:26:29,390
member will be removed from the

581
00:26:29,390 --> 00:26:31,070
collection returned by the filter

582
00:26:31,070 --> 00:26:41,520
function

583
00:26:41,530 --> 00:26:43,720
I want to make special mention of for

584
00:26:43,720 --> 00:26:46,180
each here which is technically a higher

585
00:26:46,180 --> 00:26:49,090
order function for collections because

586
00:26:49,090 --> 00:26:50,920
it takes a step function as an argument

587
00:26:50,920 --> 00:26:53,650
for each is basically a loop with a step

588
00:26:53,650 --> 00:26:55,450
defined as a function because there's no

589
00:26:55,450 --> 00:26:58,300
output value because there's no output

590
00:26:58,300 --> 00:27:00,700
value the only user can have as an

591
00:27:00,700 --> 00:27:02,830
impure step function that changes state

592
00:27:02,830 --> 00:27:05,980
or has side effects so the only possible

593
00:27:05,980 --> 00:27:07,540
valid use of this is pressed with

594
00:27:07,540 --> 00:27:09,580
debugging or intentional side effects if

595
00:27:09,580 --> 00:27:11,830
you can't do it another way and it's

596
00:27:11,830 --> 00:27:13,780
definitely simpler to use reduce fill to

597
00:27:13,780 --> 00:27:16,090
a map or some of the functions for

598
00:27:16,090 --> 00:27:20,230
working with transforming collections so

599
00:27:20,230 --> 00:27:27,820
this is complex methods actually like

600
00:27:27,820 --> 00:27:30,730
stateful functions most of the time but

601
00:27:30,730 --> 00:27:33,760
even if methods on classes and instances

602
00:27:33,760 --> 00:27:35,610
do not mutate any state object

603
00:27:35,610 --> 00:27:38,050
orientation complex a lot of things a

604
00:27:38,050 --> 00:27:41,650
complex state identity values methods

605
00:27:41,650 --> 00:27:43,780
complete functions state and namespaces

606
00:27:43,780 --> 00:27:46,180
this is claimed to be required to

607
00:27:46,180 --> 00:27:47,800
encapsulate the data with its

608
00:27:47,800 --> 00:27:50,050
implementation but latitude and

609
00:27:50,050 --> 00:27:52,060
longitude here in this example are just

610
00:27:52,060 --> 00:27:54,070
data what implementation do they

611
00:27:54,070 --> 00:27:56,740
actually have and reality this is

612
00:27:56,740 --> 00:27:58,240
braiding together the operations on the

613
00:27:58,240 --> 00:28:01,600
data with the data itself object

614
00:28:01,600 --> 00:28:03,850
orientation in general is very complex I

615
00:28:03,850 --> 00:28:06,640
agree with GK leave earlier who said

616
00:28:06,640 --> 00:28:08,560
their classes are not necessarily always

617
00:28:08,560 --> 00:28:11,500
bad that's how you use them it's just

618
00:28:11,500 --> 00:28:13,090
the most common use of classes for

619
00:28:13,090 --> 00:28:15,340
encapsulating data has promoted as good

620
00:28:15,340 --> 00:28:17,590
practice as part of object orientated

621
00:28:17,590 --> 00:28:19,780
programming but I think this is obsolete

622
00:28:19,780 --> 00:28:27,440
and complex

623
00:28:27,450 --> 00:28:30,169
why not just use data as values and

624
00:28:30,169 --> 00:28:32,789
namespaces of pure functions this is

625
00:28:32,789 --> 00:28:34,559
easier to test and easier to reason

626
00:28:34,559 --> 00:28:36,690
about this is simple because there's no

627
00:28:36,690 --> 00:28:38,730
conflicting of state identity values and

628
00:28:38,730 --> 00:28:54,460
namespaces lock with object orientation

629
00:28:54,470 --> 00:28:56,909
there's also feature and functional

630
00:28:56,909 --> 00:28:59,640
programming called Korean unfortunately

631
00:28:59,640 --> 00:29:02,130
it's not as yummy as curry in real life

632
00:29:02,130 --> 00:29:05,789
but it was very useful it's named after

633
00:29:05,789 --> 00:29:08,220
the person who created it from a

634
00:29:08,220 --> 00:29:10,289
different programming language so the

635
00:29:10,289 --> 00:29:11,789
naming has no relation whatsoever to

636
00:29:11,789 --> 00:29:18,179
what it actually does carrying is the

637
00:29:18,179 --> 00:29:20,340
process of converting functions that

638
00:29:20,340 --> 00:29:22,710
take more than one argument and two ones

639
00:29:22,710 --> 00:29:24,570
that when supplied with fewer the

640
00:29:24,570 --> 00:29:26,820
arguments then they require will return

641
00:29:26,820 --> 00:29:29,159
new functions that accept the remaining

642
00:29:29,159 --> 00:29:32,399
arguments so in this example if is a

643
00:29:32,399 --> 00:29:37,710
function that is already has a set a to

644
00:29:37,710 --> 00:29:42,120
1 so that when we call F with 2 we get

645
00:29:42,120 --> 00:29:45,179
the result of 1 plus 2 carrying is

646
00:29:45,179 --> 00:29:47,159
simple because it enables us to untwist

647
00:29:47,159 --> 00:29:49,860
or unbraid applying arguments from

648
00:29:49,860 --> 00:29:51,510
function and vacation so you can do

649
00:29:51,510 --> 00:29:53,580
these two things separately whereas with

650
00:29:53,580 --> 00:29:55,169
normal function invocation you have to

651
00:29:55,169 --> 00:29:57,200
provide all the arguments that cool time

652
00:29:57,200 --> 00:29:59,220
different versions of currying work

653
00:29:59,220 --> 00:30:01,200
slightly differently but in the ram

654
00:30:01,200 --> 00:30:02,760
dealer library implementation you can

655
00:30:02,760 --> 00:30:04,590
pass any number of arguments at any time

656
00:30:04,590 --> 00:30:07,710
to the curried function when the total

657
00:30:07,710 --> 00:30:09,149
arguments past have not reached the

658
00:30:09,149 --> 00:30:10,529
required number you'll get back a new

659
00:30:10,529 --> 00:30:12,899
function if you reach or exceed the

660
00:30:12,899 --> 00:30:14,399
number of arguments you'll get back the

661
00:30:14,399 --> 00:30:18,179
final result users of more advanced

662
00:30:18,179 --> 00:30:19,889
functional languages will insist this is

663
00:30:19,889 --> 00:30:21,570
not carrying but something called

664
00:30:21,570 --> 00:30:23,730
partial application that is partially

665
00:30:23,730 --> 00:30:25,559
applying function arguments to the

666
00:30:25,559 --> 00:30:27,840
function but for us i think that serves

667
00:30:27,840 --> 00:30:36,169
the role of carrying just fine

668
00:30:36,179 --> 00:30:39,549
compose as a function that can join

669
00:30:39,549 --> 00:30:41,129
functions together into a new function

670
00:30:41,129 --> 00:30:43,960
so in this example calling if is the

671
00:30:43,960 --> 00:30:46,419
same as calling power then the gate and

672
00:30:46,419 --> 00:30:50,230
then increment on the values composed as

673
00:30:50,230 --> 00:30:52,779
simple because enable us enables us to

674
00:30:52,779 --> 00:30:54,340
remove braiding between using the

675
00:30:54,340 --> 00:30:56,710
behavior of multiple functions together

676
00:30:56,710 --> 00:30:58,869
as a named reference from the actual

677
00:30:58,869 --> 00:31:01,960
function invocation so we can join these

678
00:31:01,960 --> 00:31:03,159
functions together and give it a

679
00:31:03,159 --> 00:31:14,750
reference and then call it later

680
00:31:14,760 --> 00:31:17,770
this is commonly done in web browsers in

681
00:31:17,770 --> 00:31:20,140
JavaScript it past callbacks to event

682
00:31:20,140 --> 00:31:24,850
handlers to do something in relation to

683
00:31:24,850 --> 00:31:26,980
the mouse moving or someone clicking a

684
00:31:26,980 --> 00:31:29,649
button passing callbacks event handlers

685
00:31:29,649 --> 00:31:31,929
as completing the producer and the

686
00:31:31,929 --> 00:31:34,270
consumer of events as the producer is

687
00:31:34,270 --> 00:31:38,440
the document that's firing the mouse

688
00:31:38,440 --> 00:31:42,450
move in and the consumer is the callback

689
00:31:42,450 --> 00:31:45,070
so there's this massive web of direct

690
00:31:45,070 --> 00:31:47,230
relationships between the things that

691
00:31:47,230 --> 00:31:49,779
produce events and the listeners it

692
00:31:49,779 --> 00:31:51,429
creates fragmented logic there's

693
00:31:51,429 --> 00:31:53,289
difficult to reason about or control the

694
00:31:53,289 --> 00:31:55,570
flow of it's also conflicting the

695
00:31:55,570 --> 00:31:57,429
asynchronous or synchronous nature of

696
00:31:57,429 --> 00:31:59,770
the event source with the consumer logic

697
00:31:59,770 --> 00:32:02,559
the consumer logic is directly bound to

698
00:32:02,559 --> 00:32:07,450
the asynchronous asing recently so this

699
00:32:07,450 --> 00:32:14,610
is complex

700
00:32:14,620 --> 00:32:17,630
communicating sequential processes or

701
00:32:17,630 --> 00:32:20,150
CSP for short as a model that D braids

702
00:32:20,150 --> 00:32:23,049
event producers from event consumers and

703
00:32:23,049 --> 00:32:25,760
allows intermediary transformations as

704
00:32:25,760 --> 00:32:28,340
functions it was originally introduced

705
00:32:28,340 --> 00:32:30,289
in the go language then put it to

706
00:32:30,289 --> 00:32:32,240
closure and then put it to JavaScript

707
00:32:32,240 --> 00:32:34,760
this allows you not to be concerned

708
00:32:34,760 --> 00:32:36,650
about the source of data or for as

709
00:32:36,650 --> 00:32:39,530
asynchronous or synchronous these are

710
00:32:39,530 --> 00:32:41,450
basically multi reader multi writer

711
00:32:41,450 --> 00:32:43,850
message queues so you can pass the

712
00:32:43,850 --> 00:32:47,809
endpoints around as values put events on

713
00:32:47,809 --> 00:32:51,650
to the endpoints the inputs do some

714
00:32:51,650 --> 00:32:53,600
logical transformations in between and

715
00:32:53,600 --> 00:32:58,549
take events out I'm not going to go

716
00:32:58,549 --> 00:33:00,980
through CSP and detail as that would be

717
00:33:00,980 --> 00:33:02,600
a whole talk in itself but I will

718
00:33:02,600 --> 00:33:08,480
provide a short example this function

719
00:33:08,480 --> 00:33:11,720
given a Dom element a name of an event

720
00:33:11,720 --> 00:33:14,900
type and a CSP channel will put the Dom

721
00:33:14,900 --> 00:33:18,860
events on to the CSP channel so this is

722
00:33:18,860 --> 00:33:29,160
an event producer

723
00:33:29,170 --> 00:33:31,270
so for this example I'm going to use

724
00:33:31,270 --> 00:33:34,150
mouse events so we can filter to only

725
00:33:34,150 --> 00:33:36,730
consume Mouse events that are on even

726
00:33:36,730 --> 00:33:39,280
pixels on the page and I don't want to

727
00:33:39,280 --> 00:33:41,620
deal with this complex event object are

728
00:33:41,620 --> 00:33:43,540
just like a simple vector of the x and y

729
00:33:43,540 --> 00:33:45,460
coordinates so we can use a mapping

730
00:33:45,460 --> 00:33:47,410
function to transform each event and to

731
00:33:47,410 --> 00:34:03,490
array

732
00:34:03,500 --> 00:34:06,590
finally I can use a recursive loop to

733
00:34:06,590 --> 00:34:09,440
take events from the cs p-channel so

734
00:34:09,440 --> 00:34:11,990
this is an event consumer and print them

735
00:34:11,990 --> 00:34:14,990
to the JavaScript console so you can see

736
00:34:14,990 --> 00:34:16,639
that as a mouse would be moving around

737
00:34:16,639 --> 00:34:18,950
on the screen each filtered and

738
00:34:18,950 --> 00:34:20,450
transformed event would be printed to

739
00:34:20,450 --> 00:34:23,360
the console this is probably more lines

740
00:34:23,360 --> 00:34:25,639
of code than the event Kovac example but

741
00:34:25,639 --> 00:34:27,370
it's about the lack of interleaving

742
00:34:27,370 --> 00:34:29,780
being able to understand and test these

743
00:34:29,780 --> 00:34:31,520
things in isolation not the number of

744
00:34:31,520 --> 00:34:40,690
lines of code

745
00:34:40,700 --> 00:34:42,919
in real life if we want to take some

746
00:34:42,919 --> 00:34:44,800
luggage there's going on or off a plane

747
00:34:44,800 --> 00:34:46,940
remove the bags that contain bombs

748
00:34:46,940 --> 00:34:49,220
because bombs are not cool then label

749
00:34:49,220 --> 00:34:51,679
the bags with a barcode removing bombs

750
00:34:51,679 --> 00:34:54,500
is like a filter function and applying

751
00:34:54,500 --> 00:34:56,960
labels as like the mapping function it

752
00:34:56,960 --> 00:34:58,670
transforming the bag by putting a label

753
00:34:58,670 --> 00:35:01,339
on it in real life the instructions for

754
00:35:01,339 --> 00:35:05,060
removing bombs contain or bomb

755
00:35:05,060 --> 00:35:07,490
containing bags and labeling bags with

756
00:35:07,490 --> 00:35:09,890
barcodes don't care about if the bags

757
00:35:09,890 --> 00:35:13,099
come from a conveyor belt or trailer the

758
00:35:13,099 --> 00:35:15,079
bomb dog doesn't say oh man that bag

759
00:35:15,079 --> 00:35:16,700
came from a trailer and I'm only used to

760
00:35:16,700 --> 00:35:18,260
conveyor belts I just don't want to do

761
00:35:18,260 --> 00:35:21,260
with that the collection functions like

762
00:35:21,260 --> 00:35:23,930
Map Reduce and filter that I showed

763
00:35:23,930 --> 00:35:25,369
earlier actually have some remaining

764
00:35:25,369 --> 00:35:27,230
complexity and that they're tightly

765
00:35:27,230 --> 00:35:29,119
interleaved with the type of input and

766
00:35:29,119 --> 00:35:32,210
outputs for example I might expect to

767
00:35:32,210 --> 00:35:34,339
get data synchronously from an array and

768
00:35:34,339 --> 00:35:38,960
provide results as an array you know but

769
00:35:38,960 --> 00:35:40,180
what if i want to get data

770
00:35:40,180 --> 00:35:43,190
asynchronously from a CSP channel and

771
00:35:43,190 --> 00:35:46,579
provide results as an array you know i

772
00:35:46,579 --> 00:35:47,930
have to rewrite all my code again

773
00:35:47,930 --> 00:35:50,630
because the input has changed and then

774
00:35:50,630 --> 00:35:52,460
again for every possible combination of

775
00:35:52,460 --> 00:35:56,180
inputs and outputs so there are these

776
00:35:56,180 --> 00:35:57,920
things invented by rich ricci enclosure

777
00:35:57,920 --> 00:35:59,720
that were subsequently ported to

778
00:35:59,720 --> 00:36:02,829
javascript called transducers a

779
00:36:02,829 --> 00:36:05,420
transducer is a function that can

780
00:36:05,420 --> 00:36:08,500
operate on data collections or streams

781
00:36:08,500 --> 00:36:10,700
independent of the types of the sources

782
00:36:10,700 --> 00:36:14,780
and outputs they specify only the

783
00:36:14,780 --> 00:36:16,760
transformation in terms of a single

784
00:36:16,760 --> 00:36:19,280
element they don't care where it comes

785
00:36:19,280 --> 00:36:22,069
from or where it goes I'll show some

786
00:36:22,069 --> 00:36:24,319
examples but again I can't go into them

787
00:36:24,319 --> 00:36:25,640
in detail as that would be an entire

788
00:36:25,640 --> 00:36:30,890
talk so you can use transducers with

789
00:36:30,890 --> 00:36:32,510
immutable collections from the immutable

790
00:36:32,510 --> 00:36:35,900
library that I showed earlier and much

791
00:36:35,900 --> 00:36:38,060
like their original higher-order

792
00:36:38,060 --> 00:36:40,339
functions I showed earlier apply some

793
00:36:40,339 --> 00:36:43,250
map and filter transformations so in

794
00:36:43,250 --> 00:36:44,900
this example map and filter are

795
00:36:44,900 --> 00:36:47,930
transducers that are composable with the

796
00:36:47,930 --> 00:36:49,430
function composition

797
00:36:49,430 --> 00:36:51,770
that I also showed earlier and the

798
00:36:51,770 --> 00:36:53,540
resulting function can be used with any

799
00:36:53,540 --> 00:36:56,440
type of inputs and any type of outputs

800
00:36:56,440 --> 00:36:58,970
so you can even reference the exact same

801
00:36:58,970 --> 00:37:00,980
code you don't need to copy and paste or

802
00:37:00,980 --> 00:37:04,160
rewrite it in any way a relevant of

803
00:37:04,160 --> 00:37:06,920
where we are using it this is quite a

804
00:37:06,920 --> 00:37:08,510
high level of abstraction so it can be

805
00:37:08,510 --> 00:37:10,490
difficult to understand at first but it

806
00:37:10,490 --> 00:37:12,890
is extremely simple we've got into the

807
00:37:12,890 --> 00:37:14,660
essence of map and filter which is to

808
00:37:14,660 --> 00:37:27,569
apply a step to transform an item

809
00:37:27,579 --> 00:37:29,859
so yeah the interesting part is you can

810
00:37:29,859 --> 00:37:32,019
use those exact functions that were just

811
00:37:32,019 --> 00:37:34,029
used with immutable collection even

812
00:37:34,029 --> 00:37:35,739
direct references to the same code to

813
00:37:35,739 --> 00:37:37,779
transform an asynchronous CSP channel as

814
00:37:37,779 --> 00:37:40,900
well it doesn't matter that it's a

815
00:37:40,900 --> 00:37:42,430
synchronous it doesn't matter with

816
00:37:42,430 --> 00:37:51,450
different data source

817
00:37:51,460 --> 00:37:53,440
so I certainly didn't cover everything

818
00:37:53,440 --> 00:37:55,660
all the possible techniques or concepts

819
00:37:55,660 --> 00:37:58,150
within the subject I hope it has been

820
00:37:58,150 --> 00:37:59,920
demonstrated that if you look at

821
00:37:59,920 --> 00:38:02,380
javascript code objectively there are

822
00:38:02,380 --> 00:38:04,960
simple ways to write things that are not

823
00:38:04,960 --> 00:38:07,210
interleaved and there are complex ways

824
00:38:07,210 --> 00:38:08,620
to write things that are braided

825
00:38:08,620 --> 00:38:11,830
together functional programming features

826
00:38:11,830 --> 00:38:14,590
can achieve code more closely tied to

827
00:38:14,590 --> 00:38:16,510
the actual problem domain with

828
00:38:16,510 --> 00:38:18,280
straightforward unit testing and easier

829
00:38:18,280 --> 00:38:21,550
debugging do you want to build a lego

830
00:38:21,550 --> 00:38:24,070
castle as on the left or a knitted

831
00:38:24,070 --> 00:38:26,860
castle like on the right ask yourself

832
00:38:26,860 --> 00:38:28,900
which way is going to help you impact

833
00:38:28,900 --> 00:38:30,240
the most positive change in the world

834
00:38:30,240 --> 00:38:41,080
Thank you Thank You Rosie thank you I

835
00:38:41,080 --> 00:38:44,260
just want to ask Allah someone has been

836
00:38:44,260 --> 00:38:48,880
asked about I stairs or CSP which one is

837
00:38:48,880 --> 00:38:52,000
better since they are all tagged to

838
00:38:52,000 --> 00:38:56,110
manually to the event stream so i have a

839
00:38:56,110 --> 00:38:58,390
herd of a surgical chair also my

840
00:38:58,390 --> 00:39:02,080
question too so that's a really good

841
00:39:02,080 --> 00:39:04,060
question the question is what's the

842
00:39:04,060 --> 00:39:05,980
difference between eric's jayus like

843
00:39:05,980 --> 00:39:08,680
assume bacon juice in the libraries and

844
00:39:08,680 --> 00:39:13,000
CSP a tough question answer in a short

845
00:39:13,000 --> 00:39:16,660
time but there are known cases where r x

846
00:39:16,660 --> 00:39:20,830
JS doesn't cover things well that you

847
00:39:20,830 --> 00:39:23,650
can do in CSP i'll have to show some

848
00:39:23,650 --> 00:39:25,450
code examples to be more clear but i'm

849
00:39:25,450 --> 00:39:30,270
happy to put those up with my slides

