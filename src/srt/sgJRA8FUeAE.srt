1
00:00:07,700 --> 00:00:09,870

all right my name is thomas yang shook

2
00:00:09,870 --> 00:00:13,290
i'm working for microsoft i'm currently

3
00:00:13,290 --> 00:00:16,020
focusing on making sure that windows is

4
00:00:16,020 --> 00:00:18,420
a great hosting platform for know Jas so

5
00:00:18,420 --> 00:00:19,650
I'm working on a couple of projects

6
00:00:19,650 --> 00:00:24,750
related to know Jas and windows if you

7
00:00:24,750 --> 00:00:26,220
are interested about that topic i will

8
00:00:26,220 --> 00:00:28,410
be available after this talk to to talk

9
00:00:28,410 --> 00:00:31,949
about it so feel free to get me and we

10
00:00:31,949 --> 00:00:33,840
can go there please talk about is about

11
00:00:33,840 --> 00:00:36,570
something entirely different this is

12
00:00:36,570 --> 00:00:38,850
about high density several side

13
00:00:38,850 --> 00:00:42,180
JavaScript which is pretty much about

14
00:00:42,180 --> 00:00:45,239
how to do more with less so let's get

15
00:00:45,239 --> 00:00:49,860
started so let's say you have just

16
00:00:49,860 --> 00:00:51,420
developed a web application something

17
00:00:51,420 --> 00:00:53,370
that most likely has happened to most of

18
00:00:53,370 --> 00:00:56,670
us oh and let's have a look at that

19
00:00:56,670 --> 00:01:02,000
application actually

20
00:01:02,010 --> 00:01:05,700
so this is a application written in

21
00:01:05,700 --> 00:01:11,399
server side JavaScript and it's a simple

22
00:01:11,399 --> 00:01:37,270
web chat up

23
00:01:37,280 --> 00:01:39,799
so nothing unusual basically you can hit

24
00:01:39,799 --> 00:01:42,830
an HTTP endpoint that endpoint will

25
00:01:42,830 --> 00:01:46,070
serve you an HTML page with a bunch of

26
00:01:46,070 --> 00:01:48,770
client-side JavaScript the does HTTP

27
00:01:48,770 --> 00:01:51,530
long polling against rest endpoints

28
00:01:51,530 --> 00:01:55,070
exposed by the same backend posted in

29
00:01:55,070 --> 00:01:59,940
that server side JavaScript application

30
00:01:59,950 --> 00:02:02,360
the one interesting thing about that app

31
00:02:02,360 --> 00:02:05,149
is that it falls into a category of what

32
00:02:05,149 --> 00:02:13,340
I call a lightweight web application and

33
00:02:13,340 --> 00:02:15,890
what I mean by that there is a class of

34
00:02:15,890 --> 00:02:18,739
applications that are using very few

35
00:02:18,739 --> 00:02:21,370
resources both in terms of CPU memory

36
00:02:21,370 --> 00:02:27,319
networking and possibly disk usage so

37
00:02:27,319 --> 00:02:29,060
the next question you are facing after

38
00:02:29,060 --> 00:02:30,700
we have developed such an application is

39
00:02:30,700 --> 00:02:33,980
what I hosted and there is a number of

40
00:02:33,980 --> 00:02:37,760
choices today on the marketplace varying

41
00:02:37,760 --> 00:02:41,200
in the level of functionality and price

42
00:02:41,200 --> 00:02:44,000
but bottom line what what it boils down

43
00:02:44,000 --> 00:02:46,910
to and don't hold me to that number but

44
00:02:46,910 --> 00:02:48,980
you know 5 euro will probably buy you a

45
00:02:48,980 --> 00:02:51,140
reasonably decent shirt hosting plan

46
00:02:51,140 --> 00:02:55,070
today my claim is that five euro is way

47
00:02:55,070 --> 00:02:57,620
too much to ask in terms of hosting a

48
00:02:57,620 --> 00:03:00,410
lightweight web application hosting such

49
00:03:00,410 --> 00:03:03,610
apps such should be much less expensive

50
00:03:03,610 --> 00:03:06,680
so the question is is there anything we

51
00:03:06,680 --> 00:03:09,620
can do about it to make them less

52
00:03:09,620 --> 00:03:12,980
expensive to run and I during this talk

53
00:03:12,980 --> 00:03:15,260
I'd like to have a look at ways we can

54
00:03:15,260 --> 00:03:17,780
help hosting companies lower their costs

55
00:03:17,780 --> 00:03:19,880
of running such apps and therefore

56
00:03:19,880 --> 00:03:22,579
potentially provide them with an

57
00:03:22,579 --> 00:03:26,299
incentive to reduce the pricing of the

58
00:03:26,299 --> 00:03:29,680
shirt hosting plans

59
00:03:29,690 --> 00:03:33,330
so after you deploy your application to

60
00:03:33,330 --> 00:03:37,380
the any of the onion of the shirt

61
00:03:37,380 --> 00:03:39,000
hosting providers will probably end up

62
00:03:39,000 --> 00:03:41,640
running a place like this so there is a

63
00:03:41,640 --> 00:03:43,980
data center with a large number of

64
00:03:43,980 --> 00:03:46,890
machines your app is running on one of

65
00:03:46,890 --> 00:03:49,140
them probably alongside a number of

66
00:03:49,140 --> 00:03:51,630
other applications possibly applications

67
00:03:51,630 --> 00:03:54,090
written by our competitors and this is

68
00:03:54,090 --> 00:03:55,410
pretty much what you are paying the five

69
00:03:55,410 --> 00:03:58,410
euro for the breakdown of the cost of

70
00:03:58,410 --> 00:04:01,920
operating a data center it falls into

71
00:04:01,920 --> 00:04:04,049
three categories there is this cost of

72
00:04:04,049 --> 00:04:06,840
buying the hardware there is a cost of

73
00:04:06,840 --> 00:04:09,480
electricity and maintenance and there is

74
00:04:09,480 --> 00:04:12,090
the cost of electricity is most actually

75
00:04:12,090 --> 00:04:14,610
cooling the data center and there is a

76
00:04:14,610 --> 00:04:16,200
cost of maintenance and these categories

77
00:04:16,200 --> 00:04:20,669
are roughly thirty three percent each so

78
00:04:20,669 --> 00:04:22,530
the key takeaway from this is if we can

79
00:04:22,530 --> 00:04:24,419
reduce the number of machines that are

80
00:04:24,419 --> 00:04:26,700
necessary to run a certain number of web

81
00:04:26,700 --> 00:04:29,780
applications we can pretty much

82
00:04:29,780 --> 00:04:31,620
proportionally reduce the overall cost

83
00:04:31,620 --> 00:04:34,080
of running a datacenter and therefore

84
00:04:34,080 --> 00:04:36,180
provide an incentive to hosting

85
00:04:36,180 --> 00:04:39,590
companies to reduce the pricing of the

86
00:04:39,590 --> 00:04:45,390
short hosting plan so the typical

87
00:04:45,390 --> 00:04:49,260
breakdown of the plans that the short

88
00:04:49,260 --> 00:04:51,720
hosting companies offer falls into three

89
00:04:51,720 --> 00:04:53,820
categories you can go and get yourself a

90
00:04:53,820 --> 00:04:56,130
dedicated piece of hardware that will

91
00:04:56,130 --> 00:04:59,090
cost you most let's say 200 your mouth

92
00:04:59,090 --> 00:05:02,070
then you can go and get a virtual

93
00:05:02,070 --> 00:05:03,990
machine running on a piece of hardware

94
00:05:03,990 --> 00:05:05,520
that virtual machine running alongside

95
00:05:05,520 --> 00:05:09,500
virtual machines owned by others who

96
00:05:09,500 --> 00:05:11,370
purchased computing power from that

97
00:05:11,370 --> 00:05:14,820
hosting company virtual machine provides

98
00:05:14,820 --> 00:05:18,180
a good level of isolation between these

99
00:05:18,180 --> 00:05:21,660
execution environments typically these

100
00:05:21,660 --> 00:05:24,660
hosting plans are manifest themselves as

101
00:05:24,660 --> 00:05:27,000
the so-called root access to the system

102
00:05:27,000 --> 00:05:28,530
because effectively you're an

103
00:05:28,530 --> 00:05:30,690
administrator of the virtual machine but

104
00:05:30,690 --> 00:05:32,780
it is still not a physical box is just a

105
00:05:32,780 --> 00:05:36,600
slice of the physical box in the last

106
00:05:36,600 --> 00:05:38,430
class of

107
00:05:38,430 --> 00:05:42,120
short hosting plans offer today revolves

108
00:05:42,120 --> 00:05:45,060
around process level isolation so

109
00:05:45,060 --> 00:05:47,100
typically you'll basically have a

110
00:05:47,100 --> 00:05:49,830
username created on a system and you'll

111
00:05:49,830 --> 00:05:51,750
be able to host your application as part

112
00:05:51,750 --> 00:05:55,860
of that username so operate most

113
00:05:55,860 --> 00:05:57,750
operating system modern operating system

114
00:05:57,750 --> 00:06:01,740
offer a kind of user level isolation

115
00:06:01,740 --> 00:06:03,000
within the operating system where you

116
00:06:03,000 --> 00:06:05,700
can control access to resources meter

117
00:06:05,700 --> 00:06:09,710
access to resources at the level of

118
00:06:09,710 --> 00:06:12,390
process that there is running within the

119
00:06:12,390 --> 00:06:13,770
credentials of a particular user

120
00:06:13,770 --> 00:06:15,750
registered with that system and this is

121
00:06:15,750 --> 00:06:18,240
perhaps the densest you can get in terms

122
00:06:18,240 --> 00:06:21,930
of application density in case of the

123
00:06:21,930 --> 00:06:25,650
most moisture hosting plans today so

124
00:06:25,650 --> 00:06:27,690
this is what you're paying the five euro

125
00:06:27,690 --> 00:06:33,390
for a monthly basis there are two things

126
00:06:33,390 --> 00:06:35,460
you really care about when you choose

127
00:06:35,460 --> 00:06:38,330
your show hosting provider one is

128
00:06:38,330 --> 00:06:40,560
isolation of your application you really

129
00:06:40,560 --> 00:06:42,750
want to make sure that your app when it

130
00:06:42,750 --> 00:06:47,610
is deployed to the data center is not

131
00:06:47,610 --> 00:06:50,910
affected by what other applications are

132
00:06:50,910 --> 00:06:53,040
doing you don't want other applications

133
00:06:53,040 --> 00:06:54,630
running on the same physical machine as

134
00:06:54,630 --> 00:06:58,820
yours for example take away all cpu

135
00:06:58,820 --> 00:07:01,710
capacity from your application or affect

136
00:07:01,710 --> 00:07:05,790
how much networking you can do the

137
00:07:05,790 --> 00:07:07,920
second aspect also isolation is one the

138
00:07:07,920 --> 00:07:10,560
second aspect is resource consumption

139
00:07:10,560 --> 00:07:12,450
you really want to make sure that what

140
00:07:12,450 --> 00:07:14,940
you're paying for really guarantee see a

141
00:07:14,940 --> 00:07:17,340
certain level of access to memory CPU

142
00:07:17,340 --> 00:07:20,490
networking and days can you really want

143
00:07:20,490 --> 00:07:21,450
to make sure that you're paying your

144
00:07:21,450 --> 00:07:24,720
fair share of the resources it kind of

145
00:07:24,720 --> 00:07:26,460
in proportion to what the applications

146
00:07:26,460 --> 00:07:28,170
from all the applications are consuming

147
00:07:28,170 --> 00:07:32,430
on that box so in case of the class of

148
00:07:32,430 --> 00:07:34,080
applications i'm talking about here the

149
00:07:34,080 --> 00:07:36,570
lightweight web applications as i said

150
00:07:36,570 --> 00:07:40,140
before cpu usage networking and disk is

151
00:07:40,140 --> 00:07:45,029
probably not the

152
00:07:45,039 --> 00:07:47,599
factor that bounds the number of

153
00:07:47,599 --> 00:07:49,039
applications that can be running in one

154
00:07:49,039 --> 00:07:51,409
box I think in this in case of these

155
00:07:51,409 --> 00:07:54,409
apps today it will be the memory simply

156
00:07:54,409 --> 00:07:56,300
because of the process level isolation a

157
00:07:56,300 --> 00:07:57,680
single process has a certain weight

158
00:07:57,680 --> 00:08:00,080
behind it and you can only run a certain

159
00:08:00,080 --> 00:08:01,550
number of processes on a single physical

160
00:08:01,550 --> 00:08:03,379
machine and regardless of the operating

161
00:08:03,379 --> 00:08:06,919
system you are using so let's have a

162
00:08:06,919 --> 00:08:09,830
look at what exactly does it mean to run

163
00:08:09,830 --> 00:08:12,680
I the process scope let's come back to

164
00:08:12,680 --> 00:08:18,050
our shut up I'll just stop an instance

165
00:08:18,050 --> 00:08:39,140
again let's just make sure it is running

166
00:08:39,150 --> 00:08:42,090
yep so now as you let's have a look at

167
00:08:42,090 --> 00:08:43,670
the resource consumption of the process

168
00:08:43,670 --> 00:08:47,190
so first of all you're not is that cpu

169
00:08:47,190 --> 00:08:49,320
usage is pretty much negligible all cpu

170
00:08:49,320 --> 00:08:50,520
usage is actually coming from other

171
00:08:50,520 --> 00:08:53,340
processes running on the machine the my

172
00:08:53,340 --> 00:08:55,110
light weight of obligations are sitting

173
00:08:55,110 --> 00:08:57,030
there no doing nothing waiting for a

174
00:08:57,030 --> 00:08:58,980
message from the client so this is to be

175
00:08:58,980 --> 00:09:02,880
expected let's have a look at the memory

176
00:09:02,880 --> 00:09:08,610
consumption so this is my process there

177
00:09:08,610 --> 00:09:10,440
are many ways you can measure memory

178
00:09:10,440 --> 00:09:11,880
consumption of a process there are many

179
00:09:11,880 --> 00:09:13,860
different metrics that the one that is

180
00:09:13,860 --> 00:09:16,980
most relevant in the context of this

181
00:09:16,980 --> 00:09:19,110
discussion I think is what on Windows is

182
00:09:19,110 --> 00:09:21,930
called private working set so this is

183
00:09:21,930 --> 00:09:25,880
the number of bytes that that is

184
00:09:25,880 --> 00:09:28,470
dedicated to the exclusive use of that

185
00:09:28,470 --> 00:09:30,060
process so it is not shirt between

186
00:09:30,060 --> 00:09:31,470
processes that for example doesn't

187
00:09:31,470 --> 00:09:34,290
belong to any shirt library that is

188
00:09:34,290 --> 00:09:38,850
ridiculous processes and a subset of

189
00:09:38,850 --> 00:09:40,980
those buys that actually resides in

190
00:09:40,980 --> 00:09:43,350
physical memory at the time so this is

191
00:09:43,350 --> 00:09:46,830
not something that is paged out to or

192
00:09:46,830 --> 00:09:48,690
swapped out today's it is something that

193
00:09:48,690 --> 00:09:50,790
has to reside in physical memory for in

194
00:09:50,790 --> 00:09:52,320
order for that application to function

195
00:09:52,320 --> 00:09:57,500
correctly so that number would represent

196
00:09:57,500 --> 00:10:00,690
what chunk of the physical memory

197
00:10:00,690 --> 00:10:02,640
resource is that particular process

198
00:10:02,640 --> 00:10:04,830
using and therefore how many of these

199
00:10:04,830 --> 00:10:06,660
processes could you run at maximum on

200
00:10:06,660 --> 00:10:08,640
the honor system with a given amount of

201
00:10:08,640 --> 00:10:10,740
physical memory so in case of the

202
00:10:10,740 --> 00:10:14,580
process we are running here this is 2.6

203
00:10:14,580 --> 00:10:18,150
megabytes right now so i'll just take

204
00:10:18,150 --> 00:10:20,190
note of that number and you'll use it in

205
00:10:20,190 --> 00:10:26,150
a moment so process level isolation

206
00:10:26,150 --> 00:10:31,199
memory

207
00:10:31,209 --> 00:10:33,740
and what you're paying for that level of

208
00:10:33,740 --> 00:10:44,779
isolation is 5 euro so naturally the

209
00:10:44,779 --> 00:10:48,019
question is can we do better and given

210
00:10:48,019 --> 00:10:49,339
that I'm only ten minutes into this

211
00:10:49,339 --> 00:10:50,720
presentation you can expect that the

212
00:10:50,720 --> 00:10:55,250
answer is I hope so so how about trying

213
00:10:55,250 --> 00:10:58,100
to use threads in order to isolate

214
00:10:58,100 --> 00:11:04,880
applications most modern operating

215
00:11:04,880 --> 00:11:09,589
system provides primitives that helped

216
00:11:09,589 --> 00:11:12,139
write applications that are isolated at

217
00:11:12,139 --> 00:11:14,930
the process scope you can for example

218
00:11:14,930 --> 00:11:17,569
put limits on the number of handles the

219
00:11:17,569 --> 00:11:19,819
process can create you can put limits on

220
00:11:19,819 --> 00:11:22,899
the amount of memory process can consume

221
00:11:22,899 --> 00:11:26,269
at the thread level the number of

222
00:11:26,269 --> 00:11:28,940
resources you can constrain or control

223
00:11:28,940 --> 00:11:30,860
at the level of the operating system

224
00:11:30,860 --> 00:11:32,449
from the outside of the process is very

225
00:11:32,449 --> 00:11:36,439
limited for example threads are free to

226
00:11:36,439 --> 00:11:39,139
access memory within that process there

227
00:11:39,139 --> 00:11:41,120
is no makin no native mechanism within

228
00:11:41,120 --> 00:11:42,620
any of the operating system that would

229
00:11:42,620 --> 00:11:46,569
prevent one thread from accessing memory

230
00:11:46,569 --> 00:11:49,189
that another thread has allocated within

231
00:11:49,189 --> 00:11:52,519
the same process and this is what the

232
00:11:52,519 --> 00:11:55,189
difference between native applications

233
00:11:55,189 --> 00:11:58,399
and managed applications becomes

234
00:11:58,399 --> 00:12:00,829
important so whenever you are writing an

235
00:12:00,829 --> 00:12:06,259
application that you really don't know

236
00:12:06,259 --> 00:12:08,480
anything about it could be written in C

237
00:12:08,480 --> 00:12:10,930
C++ and use the full functionality

238
00:12:10,930 --> 00:12:13,970
offered by an operating system there is

239
00:12:13,970 --> 00:12:16,069
really no way to reason about resource

240
00:12:16,069 --> 00:12:17,990
consumption at the SAP process level

241
00:12:17,990 --> 00:12:20,120
there is no way to constrain resources

242
00:12:20,120 --> 00:12:23,509
on a per thread level when the threads

243
00:12:23,509 --> 00:12:26,720
running within that app well managed

244
00:12:26,720 --> 00:12:28,550
execution environments like server-side

245
00:12:28,550 --> 00:12:32,420
JavaScript provide us is a layer that

246
00:12:32,420 --> 00:12:34,399
separates the operating system from the

247
00:12:34,399 --> 00:12:36,620
application called a hosting layer in

248
00:12:36,620 --> 00:12:38,930
case of nodejs it is actually the node

249
00:12:38,930 --> 00:12:44,079
code which consists of the v8 JavaScript

250
00:12:44,079 --> 00:12:47,600
engine plus the node specific

251
00:12:47,600 --> 00:12:49,490
functionality the event loop and all the

252
00:12:49,490 --> 00:12:54,740
native modules so it is up to that layer

253
00:12:54,740 --> 00:12:56,630
to expose certain primitives to the

254
00:12:56,630 --> 00:12:58,760
application to use if the layer chooses

255
00:12:58,760 --> 00:13:00,620
to allow the application to spawn new

256
00:13:00,620 --> 00:13:03,800
processes it's a certain decision that

257
00:13:03,800 --> 00:13:05,240
is made at the hosting layer know the

258
00:13:05,240 --> 00:13:07,459
operating system layer so that layer

259
00:13:07,459 --> 00:13:10,490
could effectively provide a constraint

260
00:13:10,490 --> 00:13:12,380
set of primitives to the application

261
00:13:12,380 --> 00:13:19,130
such that it is easy and actually

262
00:13:19,130 --> 00:13:22,069
possible to control resource consumption

263
00:13:22,069 --> 00:13:25,449
and limit resource consumption a

264
00:13:25,449 --> 00:13:28,670
finer-grained in the process so in

265
00:13:28,670 --> 00:13:29,899
theory you could run multiple

266
00:13:29,899 --> 00:13:31,850
applications within a single process and

267
00:13:31,850 --> 00:13:33,980
use the hosting layer to provide both

268
00:13:33,980 --> 00:13:36,800
isolation and resource metering between

269
00:13:36,800 --> 00:13:43,779
these applications so a solution that

270
00:13:43,779 --> 00:13:47,389
uses hosting layer around a javascript

271
00:13:47,389 --> 00:13:52,490
v8 engine could look like like this we

272
00:13:52,490 --> 00:13:54,050
will have one process there is running

273
00:13:54,050 --> 00:13:56,000
multiple threads each thread will be

274
00:13:56,000 --> 00:13:58,850
running a different application a

275
00:13:58,850 --> 00:14:00,709
JavaScript application these

276
00:14:00,709 --> 00:14:03,259
applications theoretically can compete

277
00:14:03,259 --> 00:14:06,380
for access to operating system resources

278
00:14:06,380 --> 00:14:09,139
and it is up to the hosting layer to

279
00:14:09,139 --> 00:14:11,540
ensure fair access to resources as well

280
00:14:11,540 --> 00:14:15,199
as isolation between these context so

281
00:14:15,199 --> 00:14:21,160
JavaScript the v8 engine provides a few

282
00:14:21,160 --> 00:14:24,910
key concepts that help realize that

283
00:14:24,910 --> 00:14:27,680
possibility so first of all there is a

284
00:14:27,680 --> 00:14:30,709
concept of a v8 isolate an isolette

285
00:14:30,709 --> 00:14:33,829
allows you to create a standalone

286
00:14:33,829 --> 00:14:36,259
instance of a JavaScript engine within a

287
00:14:36,259 --> 00:14:37,610
process and you can have multiple of

288
00:14:37,610 --> 00:14:39,740
those what standalone means in this case

289
00:14:39,740 --> 00:14:41,899
is that each instance is completely

290
00:14:41,899 --> 00:14:43,790
isolated from each other in terms of the

291
00:14:43,790 --> 00:14:47,059
resources then the memory resources it

292
00:14:47,059 --> 00:14:49,250
uses because its own he passes on

293
00:14:49,250 --> 00:14:52,010
garbage collector if you dispose of a

294
00:14:52,010 --> 00:14:54,589
sea of one v8 isolate within the process

295
00:14:54,589 --> 00:14:59,540
it doesn't affect the other isolates so

296
00:14:59,540 --> 00:15:02,149
as far as I understand v8 isolates have

297
00:15:02,149 --> 00:15:06,439
been meant to support concurrent

298
00:15:06,439 --> 00:15:07,939
execution of multiple JavaScript

299
00:15:07,939 --> 00:15:09,439
programs within a single process and

300
00:15:09,439 --> 00:15:12,199
different threads a second concert that

301
00:15:12,199 --> 00:15:13,760
is not shown here and I'll go into that

302
00:15:13,760 --> 00:15:17,689
later is a Viet context VidCon text

303
00:15:17,689 --> 00:15:20,000
provides the in that kind of data

304
00:15:20,000 --> 00:15:22,220
environment within which JavaScript

305
00:15:22,220 --> 00:15:25,040
application execute specifically in case

306
00:15:25,040 --> 00:15:27,380
of JavaScript it controls the global

307
00:15:27,380 --> 00:15:30,799
object that is available to the

308
00:15:30,799 --> 00:15:33,319
application code when it runs so you can

309
00:15:33,319 --> 00:15:35,089
have multiple

310
00:15:35,089 --> 00:15:38,329
v8 context and multiple isolates when

311
00:15:38,329 --> 00:15:40,249
you run JavaScript code you have to

312
00:15:40,249 --> 00:15:43,970
choose one isolate and one v8 context

313
00:15:43,970 --> 00:15:45,439
the data application will be running in

314
00:15:45,439 --> 00:15:47,600
in this case the reason I didn't show a

315
00:15:47,600 --> 00:15:50,990
context is because there is kind of one

316
00:15:50,990 --> 00:15:53,180
to one relationship between isolate any

317
00:15:53,180 --> 00:15:54,949
context so for each isolate I create I

318
00:15:54,949 --> 00:15:57,559
get only one context and execute the the

319
00:15:57,559 --> 00:15:58,939
JavaScript application within that

320
00:15:58,939 --> 00:16:03,470
context so let's have a look at how that

321
00:16:03,470 --> 00:16:13,070
looks like

322
00:16:13,080 --> 00:16:15,900
so the tensile prototype which is that

323
00:16:15,900 --> 00:16:17,310
little hosting lane that I've created

324
00:16:17,310 --> 00:16:19,980
for the purpose of this demo allows you

325
00:16:19,980 --> 00:16:22,260
to actually start multiple apps inside

326
00:16:22,260 --> 00:16:25,830
of a single process so i can three start

327
00:16:25,830 --> 00:16:28,380
three web chat applications in this case

328
00:16:28,380 --> 00:16:32,070
and each of these apps is again running

329
00:16:32,070 --> 00:16:37,260
on its own thread and using its own v8

330
00:16:37,260 --> 00:16:39,030
isolate so the data of these apps is

331
00:16:39,030 --> 00:16:41,970
completely isolated in key in terms of

332
00:16:41,970 --> 00:16:44,580
access to the cpu it is actually the

333
00:16:44,580 --> 00:16:46,200
operating system that ensures fair

334
00:16:46,200 --> 00:16:48,390
access to the severe because thread

335
00:16:48,390 --> 00:16:49,770
scheduling happens in the operating

336
00:16:49,770 --> 00:16:53,820
system level so let's not just test the

337
00:16:53,820 --> 00:16:55,620
hypothesis that these apps are actually

338
00:16:55,620 --> 00:17:09,949
isolated I'll pick the first one

339
00:17:09,959 --> 00:17:14,520
so this is strut one and I'll take the

340
00:17:14,520 --> 00:17:30,620
second one

341
00:17:30,630 --> 00:17:33,300
and this is the chapter so you can you

342
00:17:33,300 --> 00:17:36,090
can do chatting in this window it

343
00:17:36,090 --> 00:17:37,410
doesn't affect the chat in the other

344
00:17:37,410 --> 00:17:39,570
window so the level of the day doubt

345
00:17:39,570 --> 00:17:41,940
that these chat rooms exchange they are

346
00:17:41,940 --> 00:17:44,220
isolated now in terms of resource

347
00:17:44,220 --> 00:17:47,610
consumption one thing that the hosting

348
00:17:47,610 --> 00:17:49,650
layer that I've implemented here does is

349
00:17:49,650 --> 00:17:52,530
also provide metering of resource

350
00:17:52,530 --> 00:18:02,190
consumption on a per program basis so

351
00:18:02,190 --> 00:18:04,860
what it does it basically shows you cpu

352
00:18:04,860 --> 00:18:08,040
usage network usage and memory usage on

353
00:18:08,040 --> 00:18:11,520
a per program basis so you notice that

354
00:18:11,520 --> 00:18:13,200
you know this particular web chat

355
00:18:13,200 --> 00:18:15,720
instance has used that many cpu cycles

356
00:18:15,720 --> 00:18:18,630
so far the exchange a certain number of

357
00:18:18,630 --> 00:18:22,260
bytes and that number will increase as

358
00:18:22,260 --> 00:18:27,480
you type something number of HTTP

359
00:18:27,480 --> 00:18:29,790
requests and also memory usage so memory

360
00:18:29,790 --> 00:18:33,360
usage refers to the name of our

361
00:18:33,360 --> 00:18:36,690
locations within the heap maintained by

362
00:18:36,690 --> 00:18:38,790
the v8 isolated applications running in

363
00:18:38,790 --> 00:18:42,360
one thing to notice is that these

364
00:18:42,360 --> 00:18:44,280
numbers and are different from the

365
00:18:44,280 --> 00:18:50,950
second web shot that I have running here

366
00:18:50,960 --> 00:18:54,170
so this is let's say thirty four

367
00:18:54,170 --> 00:18:57,330
kilobytes exchange this is 3 80

368
00:18:57,330 --> 00:18:58,860
kilobytes exchange so you've got

369
00:18:58,860 --> 00:19:01,410
metering and resource control the

370
00:19:01,410 --> 00:19:03,030
program level and these programs are

371
00:19:03,030 --> 00:19:04,290
running within the same process on

372
00:19:04,290 --> 00:19:08,970
different threats so this is greatest

373
00:19:08,970 --> 00:19:10,680
demonstrates that at that level we can

374
00:19:10,680 --> 00:19:15,240
actually measure resources and isolate

375
00:19:15,240 --> 00:19:17,670
applications of the subprocess level now

376
00:19:17,670 --> 00:19:20,250
let's see how heavy weight it is to run

377
00:19:20,250 --> 00:19:33,170
many of those applications

378
00:19:33,180 --> 00:19:37,370
so right 50 of them in a single process

379
00:19:37,370 --> 00:19:39,450
now let's have a look at the memory

380
00:19:39,450 --> 00:19:45,870
footprint of this 70 megabytes so go

381
00:19:45,870 --> 00:19:56,250
back to excel thread 70 megabytes by 50

382
00:19:56,250 --> 00:20:00,000
in programs so it is 1.4 megabyte per

383
00:20:00,000 --> 00:20:04,530
program now if you if you assume that

384
00:20:04,530 --> 00:20:08,100
the short hosting plan will will be

385
00:20:08,100 --> 00:20:09,870
proportional to the memory consumption

386
00:20:09,870 --> 00:20:12,060
of that application that shirt hosting

387
00:20:12,060 --> 00:20:26,880
plan would cost less than 3 Europe

388
00:20:26,890 --> 00:20:31,580
so basically what i have shown right now

389
00:20:31,580 --> 00:20:33,380
is that from the perspective of the data

390
00:20:33,380 --> 00:20:36,740
center the the hosting provider can now

391
00:20:36,740 --> 00:20:39,520
run the same number of applications on

392
00:20:39,520 --> 00:20:42,320
less hardware so this is a great out

393
00:20:42,320 --> 00:20:43,820
section of the hardware at the end of

394
00:20:43,820 --> 00:20:48,140
the rackspace they're giving there are

395
00:20:48,140 --> 00:20:50,080
fewer machines used to run the same

396
00:20:50,080 --> 00:20:54,140
number of apps theoretically the cost of

397
00:20:54,140 --> 00:20:57,020
the shell toasting goes down and it can

398
00:20:57,020 --> 00:20:58,280
be reflected in the price of the

399
00:20:58,280 --> 00:21:01,450
hosting plan which is now around 3 euro

400
00:21:01,450 --> 00:21:04,640
can you do better than that is there any

401
00:21:04,640 --> 00:21:09,960
way we can reduce the price even further

402
00:21:09,970 --> 00:21:12,350
so let's see there is a way we can

403
00:21:12,350 --> 00:21:14,870
actually share a single thread among

404
00:21:14,870 --> 00:21:17,300
several applications running on the

405
00:21:17,300 --> 00:21:19,790
system in a way that still provides the

406
00:21:19,790 --> 00:21:22,040
guarantees that we can isolate data

407
00:21:22,040 --> 00:21:25,730
between the applications and control

408
00:21:25,730 --> 00:21:26,960
resource consumption for each

409
00:21:26,960 --> 00:21:33,380
application and this is what the v8

410
00:21:33,380 --> 00:21:39,950
context comes in in this solution I'm

411
00:21:39,950 --> 00:21:42,650
going to use a single thread in the

412
00:21:42,650 --> 00:21:45,320
process a single d8 isolate which means

413
00:21:45,320 --> 00:21:46,910
that all the applications running within

414
00:21:46,910 --> 00:21:49,430
that process will use the same keep the

415
00:21:49,430 --> 00:21:51,820
same gap in the same garbage collector

416
00:21:51,820 --> 00:21:54,170
however I will use a different v8

417
00:21:54,170 --> 00:21:56,930
context for each of these apps this is

418
00:21:56,930 --> 00:21:59,120
actually the model that no Jas is using

419
00:21:59,120 --> 00:22:03,830
today however to my knowledge node has

420
00:22:03,830 --> 00:22:05,840
not been started off with intent to

421
00:22:05,840 --> 00:22:09,590
actually provide the level of isolation

422
00:22:09,590 --> 00:22:10,790
that allows you to run competing

423
00:22:10,790 --> 00:22:13,190
applications within the same process you

424
00:22:13,190 --> 00:22:16,210
can spawn multiple contexts inside of

425
00:22:16,210 --> 00:22:20,360
node using the vm module but

426
00:22:20,360 --> 00:22:22,730
the code executing in this context is

427
00:22:22,730 --> 00:22:25,429
kind of by default as soon to execute

428
00:22:25,429 --> 00:22:28,070
within the same kind of trust boundary

429
00:22:28,070 --> 00:22:33,799
you can belong to the same tenant of in

430
00:22:33,799 --> 00:22:38,240
the in the context of short hosting so

431
00:22:38,240 --> 00:22:39,860
why is that there are actually two

432
00:22:39,860 --> 00:22:44,900
challenges with this model one is the

433
00:22:44,900 --> 00:22:47,120
the most evil program you can write as

434
00:22:47,120 --> 00:22:49,549
this basically while true this this

435
00:22:49,549 --> 00:22:54,380
program will take the CPU and prevent

436
00:22:54,380 --> 00:22:56,960
other programs that attempts to run on

437
00:22:56,960 --> 00:23:00,110
the same thread from executing at the

438
00:23:00,110 --> 00:23:01,669
operating system level that the

439
00:23:01,669 --> 00:23:04,100
operating system will when at season

440
00:23:04,100 --> 00:23:05,809
infinite loop like that it'll actually

441
00:23:05,809 --> 00:23:07,970
at some point preempted up thread and

442
00:23:07,970 --> 00:23:11,150
give the cpu to another thread that is

443
00:23:11,150 --> 00:23:13,160
open on that system but remember that in

444
00:23:13,160 --> 00:23:15,200
this particular case we are running

445
00:23:15,200 --> 00:23:17,480
multiple JavaScript applications that

446
00:23:17,480 --> 00:23:19,160
potentially compete with each other on a

447
00:23:19,160 --> 00:23:21,290
single thread so if one of those

448
00:23:21,290 --> 00:23:23,870
applications has called like that it

449
00:23:23,870 --> 00:23:26,919
will basically hold up to the CPU

450
00:23:26,919 --> 00:23:28,820
infinitely from the perspective of

451
00:23:28,820 --> 00:23:31,640
sharing it with other JavaScript

452
00:23:31,640 --> 00:23:36,860
applications so this is not to say it is

453
00:23:36,860 --> 00:23:39,110
not impossible to prevent this from

454
00:23:39,110 --> 00:23:40,549
happening remember the name on your arm

455
00:23:40,549 --> 00:23:42,500
code like this in JavaScript what

456
00:23:42,500 --> 00:23:44,960
happens at the JavaScript engine layer

457
00:23:44,960 --> 00:23:49,220
that code gets compile into some form of

458
00:23:49,220 --> 00:23:52,740
assembly code and it is not

459
00:23:52,740 --> 00:23:55,630
theoretically not impossible to inject

460
00:23:55,630 --> 00:23:59,050
checks into the generated code that will

461
00:23:59,050 --> 00:24:02,260
prevent runaway programs from executing

462
00:24:02,260 --> 00:24:04,540
however such mechanism that does not

463
00:24:04,540 --> 00:24:07,270
exist today in any of the JavaScript

464
00:24:07,270 --> 00:24:11,380
engines that I know of another problem

465
00:24:11,380 --> 00:24:14,100
with the context based approach is

466
00:24:14,100 --> 00:24:19,020
limiting memory consumption so running

467
00:24:19,020 --> 00:24:21,580
several applications using different

468
00:24:21,580 --> 00:24:24,490
contexts on the same v8 as I slit

469
00:24:24,490 --> 00:24:27,580
implies that all these apps are

470
00:24:27,580 --> 00:24:29,350
allocating memory from the same heap

471
00:24:29,350 --> 00:24:30,970
managed by a single instance of the

472
00:24:30,970 --> 00:24:33,760
JavaScript engine so a program like that

473
00:24:33,760 --> 00:24:38,590
will effectively result in every

474
00:24:38,590 --> 00:24:42,490
increasing memory allocation and there

475
00:24:42,490 --> 00:24:46,660
is no mechanism in the VA JavaScript

476
00:24:46,660 --> 00:24:49,540
engine today that kind of native

477
00:24:49,540 --> 00:24:51,910
mechanism that allows you to control

478
00:24:51,910 --> 00:24:54,490
memory consumption repair context level

479
00:24:54,490 --> 00:24:56,620
such functionally can be built in on top

480
00:24:56,620 --> 00:24:59,020
of the primitives provided by the v8 but

481
00:24:59,020 --> 00:25:01,270
this is not something that my hosting

482
00:25:01,270 --> 00:25:04,090
layer currently has so again these are

483
00:25:04,090 --> 00:25:08,140
two challenges with this approach none

484
00:25:08,140 --> 00:25:10,870
of which is kind of a smoking gun reason

485
00:25:10,870 --> 00:25:12,990
not to do it I think there are ways to

486
00:25:12,990 --> 00:25:15,760
to address that problem however it is

487
00:25:15,760 --> 00:25:19,270
not immediately available in either the

488
00:25:19,270 --> 00:25:21,700
hosting layer that I've done all the v8

489
00:25:21,700 --> 00:25:25,300
engine so nevertheless let's have a look

490
00:25:25,300 --> 00:25:28,780
at what's the density that running

491
00:25:28,780 --> 00:25:30,760
JavaScript applications or the sub

492
00:25:30,760 --> 00:25:40,899
thread level using v8 context gives us

493
00:25:40,909 --> 00:25:47,599
so I'm now going to run dancer using

494
00:25:47,599 --> 00:25:49,519
context as the isolation boundary

495
00:25:49,519 --> 00:25:54,859
between applications and this time I'm

496
00:25:54,859 --> 00:25:57,859
going to rise the ball and around 1,000

497
00:25:57,859 --> 00:26:19,230
of them

498
00:26:19,240 --> 00:26:28,130
you

499
00:26:28,140 --> 00:26:33,710
here

500
00:26:33,720 --> 00:26:36,030
alright so you have 1000 web chat

501
00:26:36,030 --> 00:26:39,540
applications running within a single OS

502
00:26:39,540 --> 00:26:43,500
process using a single thread and

503
00:26:43,500 --> 00:26:46,320
different v8 context for that provide

504
00:26:46,320 --> 00:26:47,820
isolation of data between these

505
00:26:47,820 --> 00:26:50,430
applications so there's a large number

506
00:26:50,430 --> 00:26:52,500
so let's just make sure that it is still

507
00:26:52,500 --> 00:27:05,120
running indeed

508
00:27:05,130 --> 00:27:09,250
you go um so let's have a look at the

509
00:27:09,250 --> 00:27:14,169
resource consumption again cpu is pretty

510
00:27:14,169 --> 00:27:16,090
much still dormant remember these are

511
00:27:16,090 --> 00:27:17,440
lightweight with obligations that are

512
00:27:17,440 --> 00:27:19,090
not using cpu they're just sitting there

513
00:27:19,090 --> 00:27:21,309
and maintaining a state of readiness to

514
00:27:21,309 --> 00:27:23,289
accept user messages so from that

515
00:27:23,289 --> 00:27:26,320
perspective you are fine if you look at

516
00:27:26,320 --> 00:27:30,400
the process memory consumption 150

517
00:27:30,400 --> 00:27:39,960
megabytes

518
00:27:39,970 --> 00:27:42,430
one thousand roses no thousand

519
00:27:42,430 --> 00:27:50,620
applications oops so that's 150

520
00:27:50,620 --> 00:27:53,260
kilobytes per application so this is

521
00:27:53,260 --> 00:27:54,640
actually pretty good let's see how a

522
00:27:54,640 --> 00:27:56,980
short hosting plan like that would cost

523
00:27:56,980 --> 00:27:59,650
if it was to be priced and in proportion

524
00:27:59,650 --> 00:28:07,060
to memory consumption 30 cents so that's

525
00:28:07,060 --> 00:28:13,690
better than five Bureau so with that I'm

526
00:28:13,690 --> 00:28:15,730
actually going to start a little social

527
00:28:15,730 --> 00:28:49,120
experiment

528
00:28:49,130 --> 00:28:51,490
so if you have any questions about

529
00:28:51,490 --> 00:28:57,290
fighting city server-side JavaScript why

530
00:28:57,290 --> 00:28:59,420
don't you look up Twitter go to this URL

531
00:28:59,420 --> 00:29:01,820
and ask it and let's see what

532
00:29:01,820 --> 00:29:16,680
unmonitored web chat results with

533
00:29:16,690 --> 00:29:20,780
so again if you look at the data center

534
00:29:20,780 --> 00:29:25,400
we started off with we allow the hosting

535
00:29:25,400 --> 00:29:27,650
company to share a bunch of extra

536
00:29:27,650 --> 00:29:31,760
machines by going subprocess level the

537
00:29:31,760 --> 00:29:33,560
end result is if you turn these cost

538
00:29:33,560 --> 00:29:37,190
savings into the reduction of the shot

539
00:29:37,190 --> 00:29:39,470
hosting plan price with around 3 euro

540
00:29:39,470 --> 00:29:42,440
cents which is a reasonable price to pay

541
00:29:42,440 --> 00:29:43,520
anything for my little web chat

542
00:29:43,520 --> 00:29:46,820
application so basically we started off

543
00:29:46,820 --> 00:29:48,680
with the notion that five euros too much

544
00:29:48,680 --> 00:29:51,590
to pay for for hosting very simple web

545
00:29:51,590 --> 00:29:56,330
applications like that we have shown and

546
00:29:56,330 --> 00:29:58,310
demonstrate mechanisms that can be used

547
00:29:58,310 --> 00:30:01,780
to lower the price quite dramatically

548
00:30:01,780 --> 00:30:07,810
over 10 x and if you are interested in

549
00:30:07,810 --> 00:30:10,820
looking at the source code of the denser

550
00:30:10,820 --> 00:30:12,890
cost which is really a very thin wrapper

551
00:30:12,890 --> 00:30:16,490
around the javascript v8 engine it is

552
00:30:16,490 --> 00:30:19,880
available on github on the same account

553
00:30:19,880 --> 00:30:22,220
there is also a project called is know

554
00:30:22,220 --> 00:30:24,020
that i'm working on kind of during the

555
00:30:24,020 --> 00:30:28,690
day at microsoft that that is used to

556
00:30:28,690 --> 00:30:33,100
help hosting no J's applications in IAS

557
00:30:33,100 --> 00:30:35,360
if you have any questions there is most

558
00:30:35,360 --> 00:30:38,150
little pieces my contact and with that

559
00:30:38,150 --> 00:30:57,049
let's go back to the questions

560
00:30:57,059 --> 00:30:59,860
hi great presentation so I have a

561
00:30:59,860 --> 00:31:03,580
question about the overhead so how does

562
00:31:03,580 --> 00:31:06,820
the the overhead plays into to this how

563
00:31:06,820 --> 00:31:11,100
much does the context switching of v8

564
00:31:11,100 --> 00:31:14,380
coast in terms of CPU and memory usage

565
00:31:14,380 --> 00:31:17,200
in this because we saw all dormant

566
00:31:17,200 --> 00:31:20,380
processes and DD applications were

567
00:31:20,380 --> 00:31:23,799
enthused intensively so did you just put

568
00:31:23,799 --> 00:31:26,169
this into under stress into to verify

569
00:31:26,169 --> 00:31:31,090
how it relate how it compares with a

570
00:31:31,090 --> 00:31:33,370
traditional approach with process

571
00:31:33,370 --> 00:31:36,280
isolation yeah so effectively what this

572
00:31:36,280 --> 00:31:37,750
approach is showing that there are

573
00:31:37,750 --> 00:31:41,590
certain constant cost of creating a

574
00:31:41,590 --> 00:31:43,929
process on an operating system as well

575
00:31:43,929 --> 00:31:45,820
as certain constant cost of creating a

576
00:31:45,820 --> 00:31:49,000
thread in an operating system that if

577
00:31:49,000 --> 00:31:50,590
you take that cost and you actually

578
00:31:50,590 --> 00:31:53,140
average it out across a large number of

579
00:31:53,140 --> 00:31:54,580
applications that becomes manageable

580
00:31:54,580 --> 00:31:59,140
small so in case of of a process it is

581
00:31:59,140 --> 00:32:01,000
basically all the static like libraries

582
00:32:01,000 --> 00:32:03,010
that you have to load up in order for a

583
00:32:03,010 --> 00:32:04,990
process to function once you spin

584
00:32:04,990 --> 00:32:06,669
multiple threads within the process that

585
00:32:06,669 --> 00:32:09,549
actually show the static libraries not

586
00:32:09,549 --> 00:32:12,610
cost averages out nicely at a threat

587
00:32:12,610 --> 00:32:15,010
level once you create an additional

588
00:32:15,010 --> 00:32:18,669
thread you have to allocate a stack size

589
00:32:18,669 --> 00:32:21,760
for each thread which again you can

590
00:32:21,760 --> 00:32:25,299
average out the cost of that memory

591
00:32:25,299 --> 00:32:26,980
allocation when when you're running

592
00:32:26,980 --> 00:32:29,890
multiple apps on a single thread on top

593
00:32:29,890 --> 00:32:31,840
of that there is the cost of running a

594
00:32:31,840 --> 00:32:34,360
single JavaScript engine which basically

595
00:32:34,360 --> 00:32:37,270
allocates its own heap memory to manage

596
00:32:37,270 --> 00:32:39,160
memory locations of the JavaScript

597
00:32:39,160 --> 00:32:43,960
program so whenever you can show the key

598
00:32:43,960 --> 00:32:47,020
across many apps you can also reduce the

599
00:32:47,020 --> 00:32:48,200
average

600
00:32:48,200 --> 00:32:59,620
memory consumption will be dubs

601
00:32:59,630 --> 00:33:06,070
by the way is Andrea here

602
00:33:06,080 --> 00:33:13,820
get yourself a mic up there hi em

603
00:33:13,820 --> 00:33:16,070
question how is Mary using your online

604
00:33:16,070 --> 00:33:19,309
news is the same like we saw on your

605
00:33:19,309 --> 00:33:22,490
winners or because I would imagine a lot

606
00:33:22,490 --> 00:33:26,720
of hosting platforms would use lonex I'm

607
00:33:26,720 --> 00:33:29,330
sorry can you repeat I yo this is tested

608
00:33:29,330 --> 00:33:31,399
on Windows I guess have you measured how

609
00:33:31,399 --> 00:33:34,460
many usages and liners is the same I've

610
00:33:34,460 --> 00:33:38,059
done similar experiments on Linux using

611
00:33:38,059 --> 00:33:41,120
node with a second approach the the one

612
00:33:41,120 --> 00:33:45,919
in which you run multiple JavaScript

613
00:33:45,919 --> 00:33:48,019
applications using context level

614
00:33:48,019 --> 00:33:50,419
isolation and there is also very very

615
00:33:50,419 --> 00:33:53,149
comparable you know the difference is

616
00:33:53,149 --> 00:33:55,549
you could point out between Windows and

617
00:33:55,549 --> 00:33:58,130
Linux in this case would really probably

618
00:33:58,130 --> 00:34:01,639
revolve around possibly around memory

619
00:34:01,639 --> 00:34:03,289
allocations of the process and Fred

620
00:34:03,289 --> 00:34:05,179
scope whenever you are running

621
00:34:05,179 --> 00:34:09,889
applications in that quantity and you

622
00:34:09,889 --> 00:34:11,929
average out the memory allocations they

623
00:34:11,929 --> 00:34:14,899
really become irrelevant these

624
00:34:14,899 --> 00:34:22,040
differences become really leery minor so

625
00:34:22,040 --> 00:34:25,520
there is also a third model in which you

626
00:34:25,520 --> 00:34:28,849
will have a application well thread per

627
00:34:28,849 --> 00:34:31,940
application but to make the threads

628
00:34:31,940 --> 00:34:34,429
share the same v8 instance so it has

629
00:34:34,429 --> 00:34:37,010
something called the preemption which

630
00:34:37,010 --> 00:34:41,000
allows you to basically say 28 please

631
00:34:41,000 --> 00:34:44,899
switch between these threats every two

632
00:34:44,899 --> 00:34:48,290
milliseconds or something and this will

633
00:34:48,290 --> 00:34:52,099
first give you a lower memory usage like

634
00:34:52,099 --> 00:34:55,559
in your second model and

635
00:34:55,559 --> 00:34:57,569
in the same time you will be protected

636
00:34:57,569 --> 00:35:00,150
from the wild true loops because we it

637
00:35:00,150 --> 00:35:02,249
will just trimmed between the thread

638
00:35:02,249 --> 00:35:05,729
skewing each thread a fair amount of via

639
00:35:05,729 --> 00:35:08,999
rock yes I agree there are many many

640
00:35:08,999 --> 00:35:11,160
models I haven't experimented with that

641
00:35:11,160 --> 00:35:13,739
are perfectly legitimate these are just

642
00:35:13,739 --> 00:35:16,499
to kind of reference points in the

643
00:35:16,499 --> 00:35:19,140
entire space of possible solutions so

644
00:35:19,140 --> 00:35:30,430
definitely as you're right

