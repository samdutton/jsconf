1
00:00:37,650 --> 00:00:40,510

in 1995 JavaScript was created by

2
00:00:40,510 --> 00:00:44,290
Brendan Eich in 1997 ACMA produced the

3
00:00:44,290 --> 00:00:46,690
first standards document under the name

4
00:00:46,690 --> 00:00:48,850
Atma scripts this wasn't much like the

5
00:00:48,850 --> 00:00:50,310
JavaScript that we know of today

6
00:00:50,310 --> 00:00:53,590
it did have prototypical inheritance and

7
00:00:53,590 --> 00:00:56,079
that's probably about the the main cool

8
00:00:56,079 --> 00:00:56,980
thing about it at that point

9
00:00:56,980 --> 00:00:59,320
unfortunately we were already stuck with

10
00:00:59,320 --> 00:01:00,910
a lot of the bad stuff that we know of

11
00:01:00,910 --> 00:01:01,450
today

12
00:01:01,450 --> 00:01:05,320
it's just with it automatic semicolon

13
00:01:05,320 --> 00:01:08,950
insertion and double eagles oh well in

14
00:01:08,950 --> 00:01:10,990
1990 a Tekamah script - was released

15
00:01:10,990 --> 00:01:13,960
just a minor revision in Equus script 3

16
00:01:13,960 --> 00:01:17,409
was released in 1999 this one was a big

17
00:01:17,409 --> 00:01:19,299
release this came with the triple equals

18
00:01:19,299 --> 00:01:21,429
operator exceptions at the error object

19
00:01:21,429 --> 00:01:24,299
and a whole lot of stuff most notably

20
00:01:24,299 --> 00:01:27,069
functional or function expressions so

21
00:01:27,069 --> 00:01:29,200
you have closures so Java scripting have

22
00:01:29,200 --> 00:01:32,229
closures for four years it's crazy

23
00:01:32,229 --> 00:01:35,380
in 2001 script for started the effort

24
00:01:35,380 --> 00:01:36,909
for it started unfortunately it was just

25
00:01:36,909 --> 00:01:39,880
too big in too little time and it failed

26
00:01:39,880 --> 00:01:41,350
it promised a lot of cool stuff though

27
00:01:41,350 --> 00:01:44,170
like type annotations variable D

28
00:01:44,170 --> 00:01:45,939
structuring classes and logical stuff

29
00:01:45,939 --> 00:01:49,149
according to the ECMO archives ECMO

30
00:01:49,149 --> 00:01:51,630
script for just never happened

31
00:01:51,630 --> 00:01:54,779
i consecrate v was released in 2008 I

32
00:01:54,779 --> 00:01:56,979
came a lot of cool features such as a

33
00:01:56,979 --> 00:01:59,289
prettier spud page so we're we have

34
00:01:59,289 --> 00:02:01,359
colors now we're not in the 90s anymore

35
00:02:01,359 --> 00:02:03,219
it did have a bunch of cool stuff like

36
00:02:03,219 --> 00:02:08,200
use strict and a lot of things like

37
00:02:08,200 --> 00:02:10,450
getters and setters and JSON parsing but

38
00:02:10,450 --> 00:02:11,500
it's really just an incremental

39
00:02:11,500 --> 00:02:12,880
improvement it was it was to set the

40
00:02:12,880 --> 00:02:14,480
stage for bigger things to

41
00:02:14,480 --> 00:02:16,580
and that's where we are right now we

42
00:02:16,580 --> 00:02:17,750
almost have the finalized version of

43
00:02:17,750 --> 00:02:20,239
Ekman script 6 and this brings back a

44
00:02:20,239 --> 00:02:22,730
lot of what we lost in es for things

45
00:02:22,730 --> 00:02:24,140
like generators and classes and

46
00:02:24,140 --> 00:02:25,970
variability structuring a lot of really

47
00:02:25,970 --> 00:02:29,780
cool stuff the problem is that web

48
00:02:29,780 --> 00:02:31,910
developers can't use these features yet

49
00:02:31,910 --> 00:02:34,010
because we have to wait for all of the

50
00:02:34,010 --> 00:02:35,900
browser's to implement them several

51
00:02:35,900 --> 00:02:37,310
versions back it has to have the

52
00:02:37,310 --> 00:02:39,020
majority of the market share for a

53
00:02:39,020 --> 00:02:41,300
normal web developer to use these maybe

54
00:02:41,300 --> 00:02:43,370
you're lucky and that you can only

55
00:02:43,370 --> 00:02:45,080
target the latest version of chrome of

56
00:02:45,080 --> 00:02:46,970
Chrome and Firefox but most web

57
00:02:46,970 --> 00:02:48,620
developers have to wait a long time for

58
00:02:48,620 --> 00:02:52,610
these things to be implemented so a

59
00:02:52,610 --> 00:02:54,170
quick poll how many of you all use

60
00:02:54,170 --> 00:02:55,489
variable D structuring in your

61
00:02:55,489 --> 00:02:57,519
JavaScript today

62
00:02:57,519 --> 00:03:02,870
yeah like 2% of people so 14 years later

63
00:03:02,870 --> 00:03:05,720
after we wanted this we still don't have

64
00:03:05,720 --> 00:03:08,360
it I mean I understand why I don't blame

65
00:03:08,360 --> 00:03:09,920
anybody it's it's a hard process

66
00:03:09,920 --> 00:03:11,810
especially JavaScript because there's so

67
00:03:11,810 --> 00:03:15,920
many really advanced implementations and

68
00:03:15,920 --> 00:03:18,290
engines but this is a simple feature

69
00:03:18,290 --> 00:03:20,810
that could let that could make your

70
00:03:20,810 --> 00:03:22,640
codebase looks so much cleaner it's

71
00:03:22,640 --> 00:03:25,370
crazy so what can we do well we can

72
00:03:25,370 --> 00:03:26,989
write you has six code and compile it to

73
00:03:26,989 --> 00:03:29,570
es five projects like tracer enable this

74
00:03:29,570 --> 00:03:32,120
and this is really cool this is a great

75
00:03:32,120 --> 00:03:35,269
idea tracer implements a host of es6

76
00:03:35,269 --> 00:03:37,940
features I think pretty much most of

77
00:03:37,940 --> 00:03:39,140
them I think there are a few things that

78
00:03:39,140 --> 00:03:41,780
depend on the additions to the virtual

79
00:03:41,780 --> 00:03:43,640
machine that we just can't compile to

80
00:03:43,640 --> 00:03:45,739
what tracer does most most everything

81
00:03:45,739 --> 00:03:47,810
else and this is awesome this is really

82
00:03:47,810 --> 00:03:49,310
helped with early adoption of es6

83
00:03:49,310 --> 00:03:53,150
features and that's great but it's an

84
00:03:53,150 --> 00:03:55,400
all-or-nothing proposition there's

85
00:03:55,400 --> 00:03:56,510
something technically wrong with it but

86
00:03:56,510 --> 00:03:58,220
I think a better culture comes when you

87
00:03:58,220 --> 00:03:59,660
enable smaller and more independent

88
00:03:59,660 --> 00:04:02,269
modules so if if tracer is missing a

89
00:04:02,269 --> 00:04:04,190
feature like variable D structuring

90
00:04:04,190 --> 00:04:06,739
which it's not but if it's missing a

91
00:04:06,739 --> 00:04:07,790
feature you just have to wait for that

92
00:04:07,790 --> 00:04:08,900
feature to be implemented there's no

93
00:04:08,900 --> 00:04:11,109
there's no it's it's hard for the

94
00:04:11,109 --> 00:04:14,329
community to take to participate and

95
00:04:14,329 --> 00:04:16,400
fill in the gaps we all know that

96
00:04:16,400 --> 00:04:18,079
smaller independent modules are a better

97
00:04:18,079 --> 00:04:19,820
way of doing things where JavaScript

98
00:04:19,820 --> 00:04:22,970
folks we live and die by our modules so

99
00:04:22,970 --> 00:04:24,349
the question is is it possible to have

100
00:04:24,349 --> 00:04:26,750
language features a smaller more

101
00:04:26,750 --> 00:04:30,440
modules so as with anything in computer

102
00:04:30,440 --> 00:04:32,690
science this was solved in the 60s and

103
00:04:32,690 --> 00:04:35,540
the 70s this is a hard problem so it's

104
00:04:35,540 --> 00:04:37,130
probably completely solved but I think

105
00:04:37,130 --> 00:04:40,490
that it was pioneered way back when I'm

106
00:04:40,490 --> 00:04:43,060
James long and I work on Firefox

107
00:04:43,060 --> 00:04:45,890
developer tools for Mozilla and I'm

108
00:04:45,890 --> 00:04:47,410
gonna show you how how this could work

109
00:04:47,410 --> 00:04:49,610
so to show you how how we can do this we

110
00:04:49,610 --> 00:04:51,590
need to take a quick look at Lisp

111
00:04:51,590 --> 00:04:54,140
Lisp has deep roots and simplicity it

112
00:04:54,140 --> 00:04:56,030
started out as a small but a powerful

113
00:04:56,030 --> 00:05:00,110
language with a simple syntax in 1963

114
00:05:00,110 --> 00:05:02,060
Timothy Hart was a way to keep the

115
00:05:02,060 --> 00:05:04,370
language small but users add their own

116
00:05:04,370 --> 00:05:06,200
forms and extend the language you could

117
00:05:06,200 --> 00:05:07,580
do this with a new special form called

118
00:05:07,580 --> 00:05:10,900
macro macro later called

119
00:05:10,900 --> 00:05:13,669
def macro allowed the community to

120
00:05:13,669 --> 00:05:15,950
evolve Lisp just like adding new AP eyes

121
00:05:15,950 --> 00:05:18,740
they could add new semantics the Common

122
00:05:18,740 --> 00:05:20,960
Lisp object system see loss which was

123
00:05:20,960 --> 00:05:24,080
the object system specified with Common

124
00:05:24,080 --> 00:05:27,050
Lisp was inspired by two other systems

125
00:05:27,050 --> 00:05:29,150
that had already been widely used common

126
00:05:29,150 --> 00:05:30,950
loops and flavours these were systems

127
00:05:30,950 --> 00:05:32,630
way back in the I think the seventies

128
00:05:32,630 --> 00:05:34,550
maybe the sixties that had been

129
00:05:34,550 --> 00:05:36,440
implemented as libraries so users could

130
00:05:36,440 --> 00:05:37,880
just download these things add them to

131
00:05:37,880 --> 00:05:39,620
their project and use it and they added

132
00:05:39,620 --> 00:05:42,050
new special forms to define objects who

133
00:05:42,050 --> 00:05:44,600
defined methods on these objects these

134
00:05:44,600 --> 00:05:46,669
these libraries had already fleshed out

135
00:05:46,669 --> 00:05:48,620
these these ideas for they cut these

136
00:05:48,620 --> 00:05:50,960
ideas for the OP these object systems

137
00:05:50,960 --> 00:05:54,260
and it it was a highly influential in

138
00:05:54,260 --> 00:05:57,229
the design of C loss which was the later

139
00:05:57,229 --> 00:05:58,940
the object system which was included in

140
00:05:58,940 --> 00:06:01,250
the specification which is pretty cool

141
00:06:01,250 --> 00:06:02,780
that you can use them in the real world

142
00:06:02,780 --> 00:06:05,210
before they're actually specified so

143
00:06:05,210 --> 00:06:06,470
here's how you define a method with

144
00:06:06,470 --> 00:06:08,450
flavors you'll probably recognize a

145
00:06:08,450 --> 00:06:10,310
little bit more in JavaScript so

146
00:06:10,310 --> 00:06:11,930
obviously this is not valid JavaScript

147
00:06:11,930 --> 00:06:14,960
method is a special form it's somewhat

148
00:06:14,960 --> 00:06:16,100
similar to function but a little bit

149
00:06:16,100 --> 00:06:17,780
more specialized it takes the type that

150
00:06:17,780 --> 00:06:19,130
you're adding the method to takes the

151
00:06:19,130 --> 00:06:20,479
name of the method and the arguments in

152
00:06:20,479 --> 00:06:24,110
the code so current currently there's no

153
00:06:24,110 --> 00:06:26,630
way to add this special form method you

154
00:06:26,630 --> 00:06:28,100
have to write your own compiler to do it

155
00:06:28,100 --> 00:06:29,690
but if you do that you can't use any

156
00:06:29,690 --> 00:06:31,370
other language extensions that anybody

157
00:06:31,370 --> 00:06:34,370
else writes and don't don't focus too

158
00:06:34,370 --> 00:06:36,440
much on the actual feature don't cringe

159
00:06:36,440 --> 00:06:38,479
at the actual method this is probably a

160
00:06:38,479 --> 00:06:40,070
terrible way to do methods

161
00:06:40,070 --> 00:06:42,230
but it's just an example of a new

162
00:06:42,230 --> 00:06:44,630
special form so sweet GS is a new

163
00:06:44,630 --> 00:06:47,360
powerful macro system from Java or for

164
00:06:47,360 --> 00:06:50,420
JavaScript from Mozilla now these aren't

165
00:06:50,420 --> 00:06:52,220
your run-of-the-mill C macros sweet just

166
00:06:52,220 --> 00:06:53,780
provides a powerful pattern matching

167
00:06:53,780 --> 00:06:56,600
language for matching on code and

168
00:06:56,600 --> 00:06:58,520
sophisticated mechanisms for expanding

169
00:06:58,520 --> 00:07:00,890
into new code it'd be trivial to

170
00:07:00,890 --> 00:07:03,710
implement that method new special form

171
00:07:03,710 --> 00:07:05,830
and really easy for you just to use it

172
00:07:05,830 --> 00:07:08,210
you just add it to your project and it's

173
00:07:08,210 --> 00:07:09,710
available the great thing is they can

174
00:07:09,710 --> 00:07:11,840
add any number of modules that have

175
00:07:11,840 --> 00:07:14,270
macros and users macros alongside of the

176
00:07:14,270 --> 00:07:16,130
method macro you're not binding yourself

177
00:07:16,130 --> 00:07:19,040
down to one compiler so if you formalize

178
00:07:19,040 --> 00:07:20,990
a way to add new semantics just like you

179
00:07:20,990 --> 00:07:22,340
add new features it makes it really easy

180
00:07:22,340 --> 00:07:24,830
to extend the language and really easy

181
00:07:24,830 --> 00:07:27,290
to make the community participate in the

182
00:07:27,290 --> 00:07:30,290
language evolution so I have a new

183
00:07:30,290 --> 00:07:31,790
language that I want to announce called

184
00:07:31,790 --> 00:07:34,070
emoji scripts this is an example for you

185
00:07:34,070 --> 00:07:37,490
guys the emoji script features emotion

186
00:07:37,490 --> 00:07:39,950
as a value so currently in JavaScript

187
00:07:39,950 --> 00:07:41,960
you can't actually use emoji which is a

188
00:07:41,960 --> 00:07:44,210
real shame you have to quote it but then

189
00:07:44,210 --> 00:07:45,770
you deal with strings and it's really

190
00:07:45,770 --> 00:07:48,680
just a second class citizen but you

191
00:07:48,680 --> 00:07:50,150
moved your script lets you embed emoji

192
00:07:50,150 --> 00:07:52,220
in into JavaScript so you can actually

193
00:07:52,220 --> 00:07:53,840
assign it to a variable and you can use

194
00:07:53,840 --> 00:07:58,220
it so emotion literals are cool so now

195
00:07:58,220 --> 00:07:59,930
with a swift Google search for emoji

196
00:07:59,930 --> 00:08:01,610
finding what you want and then copy and

197
00:08:01,610 --> 00:08:03,500
pasting in that single emoji into your

198
00:08:03,500 --> 00:08:05,030
code you can do things like emotional

199
00:08:05,030 --> 00:08:08,930
algebra there's a having person plus

200
00:08:08,930 --> 00:08:11,470
fire equals a person's scream in fear

201
00:08:11,470 --> 00:08:14,480
and a happy person plus a punch in the

202
00:08:14,480 --> 00:08:17,570
face equals a crying person a happy

203
00:08:17,570 --> 00:08:20,540
person plus a drop of water equals a

204
00:08:20,540 --> 00:08:21,830
happy person with a different foot water

205
00:08:21,830 --> 00:08:24,440
I'm not really sure what that one is you

206
00:08:24,440 --> 00:08:26,810
can compare emotions so happiness things

207
00:08:26,810 --> 00:08:30,200
better than sadness emoji script

208
00:08:30,200 --> 00:08:33,290
enforces good practices it actually this

209
00:08:33,290 --> 00:08:35,330
allows the use of the double equals

210
00:08:35,330 --> 00:08:37,340
operator now maybe you just really

211
00:08:37,340 --> 00:08:38,750
needed to use it maybe you just loved it

212
00:08:38,750 --> 00:08:41,270
too much and you can use it any motor

213
00:08:41,270 --> 00:08:43,550
script so if you want to use it you have

214
00:08:43,550 --> 00:08:46,850
to use the poop operator

215
00:08:46,850 --> 00:08:50,060
they this has the exact same semantics

216
00:08:50,060 --> 00:08:53,930
as double equals except it's poop so

217
00:08:53,930 --> 00:08:55,430
there's also a better way to a more

218
00:08:55,430 --> 00:08:57,199
tourist way to throw errors instead of

219
00:08:57,199 --> 00:08:59,600
having to type out throw new error you

220
00:08:59,600 --> 00:09:02,149
can just use the angry face and that

221
00:09:02,149 --> 00:09:04,130
throws the error with that message

222
00:09:04,130 --> 00:09:06,290
there's also features automatic cat

223
00:09:06,290 --> 00:09:08,089
insertion so why would you terminate

224
00:09:08,089 --> 00:09:09,500
your statements with semicolons when you

225
00:09:09,500 --> 00:09:11,060
could terminate your statements with

226
00:09:11,060 --> 00:09:14,180
cats so now now you now you get this

227
00:09:14,180 --> 00:09:16,160
better expressive language where you can

228
00:09:16,160 --> 00:09:18,259
do things like if the user is not happy

229
00:09:18,259 --> 00:09:20,569
then you can yell at them to be happy

230
00:09:20,569 --> 00:09:22,100
there's not really a way to make him

231
00:09:22,100 --> 00:09:25,279
happy with software so if you want to

232
00:09:25,279 --> 00:09:27,259
use emoji script you just npm install it

233
00:09:27,259 --> 00:09:29,209
this actually works you could do this

234
00:09:29,209 --> 00:09:31,730
right now and you use the script emo to

235
00:09:31,730 --> 00:09:36,350
compile your file so a MIDI script is

236
00:09:36,350 --> 00:09:38,569
actually just a set of macros each of

237
00:09:38,569 --> 00:09:39,769
those individual features were

238
00:09:39,769 --> 00:09:41,480
implemented is just separate J's files

239
00:09:41,480 --> 00:09:43,579
you can see there's the algebra there's

240
00:09:43,579 --> 00:09:46,490
the poop macro I never thought I'd be

241
00:09:46,490 --> 00:09:47,839
talking about poop when my first J's

242
00:09:47,839 --> 00:09:51,170
comp talked but so as a disclosure I did

243
00:09:51,170 --> 00:09:53,180
have to patch sweet GS to support emoji

244
00:09:53,180 --> 00:09:55,160
which is unfortunate but let's just for

245
00:09:55,160 --> 00:09:57,170
an example so you can pick out

246
00:09:57,170 --> 00:09:58,870
individual features that you want to use

247
00:09:58,870 --> 00:10:03,139
this command uses the the standard sweet

248
00:10:03,139 --> 00:10:05,720
J's compiler which is SJS and it uses

249
00:10:05,720 --> 00:10:08,000
the - M argument which means you you can

250
00:10:08,000 --> 00:10:10,160
pass a module to sweet GS to load macros

251
00:10:10,160 --> 00:10:11,720
from and it will use those macros to

252
00:10:11,720 --> 00:10:14,269
expand your file so this just uses the

253
00:10:14,269 --> 00:10:17,959
poop feature now I knew the irony of me

254
00:10:17,959 --> 00:10:19,610
telling you not to use compilers and

255
00:10:19,610 --> 00:10:21,230
then telling you to go download this

256
00:10:21,230 --> 00:10:24,019
week is compiler technically technically

257
00:10:24,019 --> 00:10:26,180
yes it's a compiler but it's really an

258
00:10:26,180 --> 00:10:29,120
expander a macro system as a new phase

259
00:10:29,120 --> 00:10:30,410
for the parse compile and execute

260
00:10:30,410 --> 00:10:33,259
pipeline of a program the expand phase

261
00:10:33,259 --> 00:10:34,910
and it happens before anyone before

262
00:10:34,910 --> 00:10:36,350
anything else it's really just

263
00:10:36,350 --> 00:10:38,990
formalizing this the way that we want to

264
00:10:38,990 --> 00:10:41,300
extend the language and now that since

265
00:10:41,300 --> 00:10:42,860
we formalized it we just have one

266
00:10:42,860 --> 00:10:46,790
compiler and everything else just works

267
00:10:46,790 --> 00:10:48,560
together really well and you get a lot

268
00:10:48,560 --> 00:10:50,209
of good things like automatic source

269
00:10:50,209 --> 00:10:52,490
Maps so all of the macros automatically

270
00:10:52,490 --> 00:10:54,860
are automatically generated source maps

271
00:10:54,860 --> 00:10:57,079
for free sweet J's compiler it takes

272
00:10:57,079 --> 00:10:58,399
care of that if you're writing a macro

273
00:10:58,399 --> 00:10:59,510
you don't have to worry about it at all

274
00:10:59,510 --> 00:11:00,320
if you're using

275
00:11:00,320 --> 00:11:01,730
macros you know it you're going to get

276
00:11:01,730 --> 00:11:03,320
accurate source maps which I think

277
00:11:03,320 --> 00:11:05,630
that's I think that's a pretty awesome a

278
00:11:05,630 --> 00:11:09,620
pretty awesome thing so here's here's a

279
00:11:09,620 --> 00:11:10,970
more realistic example I have a project

280
00:11:10,970 --> 00:11:14,150
called es6 macros it implements

281
00:11:14,150 --> 00:11:17,180
individual es6 features as macros you

282
00:11:17,180 --> 00:11:18,650
can pick up the whole bundle or you can

283
00:11:18,650 --> 00:11:19,940
just choose one or two features that you

284
00:11:19,940 --> 00:11:22,280
want from it and of course you can use

285
00:11:22,280 --> 00:11:24,140
any other macros there's some really

286
00:11:24,140 --> 00:11:25,340
cool stuff that some people are doing

287
00:11:25,340 --> 00:11:26,840
like pattern matching and things like

288
00:11:26,840 --> 00:11:30,140
this so this is an example of the fat

289
00:11:30,140 --> 00:11:32,600
arrow module if you use the fat arrow

290
00:11:32,600 --> 00:11:35,900
module you can use es6 headers and which

291
00:11:35,900 --> 00:11:37,220
are really cool because they keep the

292
00:11:37,220 --> 00:11:39,920
outer this context so what my macro does

293
00:11:39,920 --> 00:11:41,660
is it just expands it into a function

294
00:11:41,660 --> 00:11:43,970
expression but it calls dot bind with

295
00:11:43,970 --> 00:11:47,180
this on it so you get that with just a

296
00:11:47,180 --> 00:11:49,580
pretty small macro there's also ad

297
00:11:49,580 --> 00:11:52,340
structuring module where if you include

298
00:11:52,340 --> 00:11:53,690
this you can use variable structuring

299
00:11:53,690 --> 00:11:57,290
which I still don't understand like why

300
00:11:57,290 --> 00:12:00,140
people don't use this more or like at

301
00:12:00,140 --> 00:12:01,760
least use tracer to compile this because

302
00:12:01,760 --> 00:12:04,430
it makes your code so much cleaner this

303
00:12:04,430 --> 00:12:05,750
is the class module so you can actually

304
00:12:05,750 --> 00:12:08,570
CSS classes my module supports the

305
00:12:08,570 --> 00:12:10,970
constructor and as well as super as well

306
00:12:10,970 --> 00:12:13,070
which is not in the example but if you

307
00:12:13,070 --> 00:12:14,900
call super within move it'll actually

308
00:12:14,900 --> 00:12:16,430
walk up the prototype chain and called

309
00:12:16,430 --> 00:12:19,340
and move that's your parent so this

310
00:12:19,340 --> 00:12:21,500
expands out to this which is kind of the

311
00:12:21,500 --> 00:12:25,240
familiar class and takes the class

312
00:12:25,240 --> 00:12:30,440
function that you're used to so here's

313
00:12:30,440 --> 00:12:32,870
here's an example of interoperable

314
00:12:32,870 --> 00:12:36,320
features if you just wanted the the poop

315
00:12:36,320 --> 00:12:38,990
operator and the fat arrow operator you

316
00:12:38,990 --> 00:12:40,790
could just npm install both of those

317
00:12:40,790 --> 00:12:43,820
projects but just pass the poop and the

318
00:12:43,820 --> 00:12:46,670
federal module to SJS and it'll expand

319
00:12:46,670 --> 00:12:48,710
your file just with those operators it

320
00:12:48,710 --> 00:12:53,990
it interoperates just fine so ready

321
00:12:53,990 --> 00:12:55,580
macros is far easier than writing

322
00:12:55,580 --> 00:12:58,130
compilers have fun experiment and play

323
00:12:58,130 --> 00:12:59,450
with things that javascript might might

324
00:12:59,450 --> 00:13:01,010
want to do in the future things that we

325
00:13:01,010 --> 00:13:03,320
don't even know about this is more than

326
00:13:03,320 --> 00:13:06,790
just a better way to adopt es6 features

327
00:13:06,790 --> 00:13:09,470
es7 is coming as well and javascript

328
00:13:09,470 --> 00:13:11,390
will always be evolving we should make

329
00:13:11,390 --> 00:13:13,400
it easy to experiment in to try new

330
00:13:13,400 --> 00:13:14,150
features

331
00:13:14,150 --> 00:13:15,380
and they're all small independent

332
00:13:15,380 --> 00:13:17,240
modules that are easy to write and to

333
00:13:17,240 --> 00:13:22,760
use together so currently this is the

334
00:13:22,760 --> 00:13:24,050
abstract process of adding the feature

335
00:13:24,050 --> 00:13:26,950
to JavaScript there's proposal to tc39

336
00:13:26,950 --> 00:13:29,290
there's discussion there's my

337
00:13:29,290 --> 00:13:31,790
finalization there's implementation and

338
00:13:31,790 --> 00:13:33,830
there's maturation the maturation phase

339
00:13:33,830 --> 00:13:35,720
is basically its existed out there long

340
00:13:35,720 --> 00:13:38,300
enough to where it's taken over enough

341
00:13:38,300 --> 00:13:40,339
browser market share so it's existed in

342
00:13:40,339 --> 00:13:42,890
browsers several versions back because

343
00:13:42,890 --> 00:13:44,960
most web devs as you know have to

344
00:13:44,960 --> 00:13:48,980
support you know 96% of the of the

345
00:13:48,980 --> 00:13:50,839
browser market share so this takes

346
00:13:50,839 --> 00:13:52,700
forever even if we can speed up the

347
00:13:52,700 --> 00:13:54,920
discussion and finalization pieces this

348
00:13:54,920 --> 00:13:56,089
creates a gap between the Ekman

349
00:13:56,089 --> 00:13:58,820
committee named tc39 and the community

350
00:13:58,820 --> 00:14:00,710
actually building stuff because it's six

351
00:14:00,710 --> 00:14:04,460
years maybe even decades no I I think we

352
00:14:04,460 --> 00:14:07,670
got stuck on es6 on es6 because this is

353
00:14:07,670 --> 00:14:10,370
so large and I know tc39 is working on a

354
00:14:10,370 --> 00:14:11,980
ways to push through features faster

355
00:14:11,980 --> 00:14:15,770
more frequent smaller respects but the

356
00:14:15,770 --> 00:14:17,210
implementation the maturation phases are

357
00:14:17,210 --> 00:14:19,730
always going to take a long time so I

358
00:14:19,730 --> 00:14:21,350
think one way to help with this is to

359
00:14:21,350 --> 00:14:23,630
let the tc39 give the community features

360
00:14:23,630 --> 00:14:25,880
early on as well as making it easy for

361
00:14:25,880 --> 00:14:28,760
the community to create features imagine

362
00:14:28,760 --> 00:14:31,610
if every TC tc39 proposal came with a

363
00:14:31,610 --> 00:14:34,250
working macro anyone of you excited

364
00:14:34,250 --> 00:14:35,690
about this in the community could go and

365
00:14:35,690 --> 00:14:38,120
just use that right now and test it and

366
00:14:38,120 --> 00:14:39,560
flush it out and see see how it actually

367
00:14:39,560 --> 00:14:42,740
feels in real-world code yes you can do

368
00:14:42,740 --> 00:14:45,080
this with compilers but what I'm saying

369
00:14:45,080 --> 00:14:47,089
is it's really only scalable it's only

370
00:14:47,089 --> 00:14:48,620
really a good solution if you if you

371
00:14:48,620 --> 00:14:50,120
could do it as independent modules is

372
00:14:50,120 --> 00:14:52,370
every feature posted to the mailing list

373
00:14:52,370 --> 00:14:53,990
has an attachment that's a macro to make

374
00:14:53,990 --> 00:14:59,570
it work and even better if the everyone

375
00:14:59,570 --> 00:15:02,089
in the community who is excited about an

376
00:15:02,089 --> 00:15:03,709
idea could actually try it out they

377
00:15:03,709 --> 00:15:05,570
could actually write a macro to extend a

378
00:15:05,570 --> 00:15:08,060
language and see how it works and so the

379
00:15:08,060 --> 00:15:10,130
community has a greater participation so

380
00:15:10,130 --> 00:15:11,570
I think I think it helps close the gap

381
00:15:11,570 --> 00:15:13,910
between the community and committees

382
00:15:13,910 --> 00:15:17,570
like tc39 of course not everything has

383
00:15:17,570 --> 00:15:19,250
to be standardised in fact I think it's

384
00:15:19,250 --> 00:15:20,540
better if we keep JavaScript from

385
00:15:20,540 --> 00:15:22,400
getting bloated by standardizing all the

386
00:15:22,400 --> 00:15:24,589
things there are huge advantages to

387
00:15:24,589 --> 00:15:26,540
simply using libraries instead of

388
00:15:26,540 --> 00:15:27,830
depending on platform feature

389
00:15:27,830 --> 00:15:30,080
it works because it works the same

390
00:15:30,080 --> 00:15:32,630
everywhere instantly I mean there might

391
00:15:32,630 --> 00:15:33,680
be a possibility that you're depending

392
00:15:33,680 --> 00:15:36,740
on a runtime API that's only available

393
00:15:36,740 --> 00:15:38,810
in a specific version but when you when

394
00:15:38,810 --> 00:15:41,060
you release a library anyone you don't

395
00:15:41,060 --> 00:15:42,140
have to worry if they're working in

396
00:15:42,140 --> 00:15:45,230
Firefox or Chrome or anything like that

397
00:15:45,230 --> 00:15:46,339
it's just a library that you just

398
00:15:46,339 --> 00:15:49,220
download and use the main advantage to I

399
00:15:49,220 --> 00:15:50,360
think is that you don't have to worry

400
00:15:50,360 --> 00:15:52,250
about backwards compatibility so any

401
00:15:52,250 --> 00:15:53,589
feature that goes into a browser

402
00:15:53,589 --> 00:15:55,700
requires a lot of thought because

403
00:15:55,700 --> 00:15:57,890
they're thinking up mmm this doesn't

404
00:15:57,890 --> 00:15:59,450
break any existing feature right this

405
00:15:59,450 --> 00:16:00,980
doesn't break any existing syntax in

406
00:16:00,980 --> 00:16:04,220
addition to that this isn't going to tie

407
00:16:04,220 --> 00:16:05,899
us down into one thing in the far future

408
00:16:05,899 --> 00:16:07,790
because the browser is always completely

409
00:16:07,790 --> 00:16:09,380
backwards compatible which i think is

410
00:16:09,380 --> 00:16:11,480
awesome but it kind of constrains the

411
00:16:11,480 --> 00:16:13,850
language in some ways if a breaking

412
00:16:13,850 --> 00:16:16,579
change if you if you if you release a

413
00:16:16,579 --> 00:16:18,170
feature as a macro and you need it a

414
00:16:18,170 --> 00:16:19,399
breaking change you could just either

415
00:16:19,399 --> 00:16:20,959
fork the library or do like a major

416
00:16:20,959 --> 00:16:22,459
version bump and maintain two different

417
00:16:22,459 --> 00:16:24,140
libraries because it's a library it's

418
00:16:24,140 --> 00:16:26,600
not hooked down to the jeaious engine so

419
00:16:26,600 --> 00:16:28,190
they give a formalized way to treat new

420
00:16:28,190 --> 00:16:29,510
language features of libraries and a lot

421
00:16:29,510 --> 00:16:31,640
of community to experiment and use

422
00:16:31,640 --> 00:16:33,260
things that will probably never be other

423
00:16:33,260 --> 00:16:36,079
dogs have standard or will the widget

424
00:16:36,079 --> 00:16:37,910
script be ever beyond the standard it

425
00:16:37,910 --> 00:16:42,079
might be but in all seriousness changing

426
00:16:42,079 --> 00:16:44,089
language semantics should should not be

427
00:16:44,089 --> 00:16:44,750
taken lightly

428
00:16:44,750 --> 00:16:47,589
don't use macros just for inlining code

429
00:16:47,589 --> 00:16:50,360
don't use macros just to remove curly

430
00:16:50,360 --> 00:16:52,520
braces honestly if you're thinking of

431
00:16:52,520 --> 00:16:54,350
writing the macro right now you probably

432
00:16:54,350 --> 00:16:57,800
shouldn't I mean how how can I say this

433
00:16:57,800 --> 00:16:59,540
after everything I just said I think

434
00:16:59,540 --> 00:17:01,010
it's because we need to be grounded

435
00:17:01,010 --> 00:17:03,410
don't don't experiment on your company's

436
00:17:03,410 --> 00:17:05,780
codebase don't cut off the community by

437
00:17:05,780 --> 00:17:08,300
using weird features only write a macro

438
00:17:08,300 --> 00:17:10,610
if the feature is unique enough and you

439
00:17:10,610 --> 00:17:12,199
have time to invest in teaching people

440
00:17:12,199 --> 00:17:16,069
why it's useful Common Lisp in my

441
00:17:16,069 --> 00:17:17,720
opinion kind of felt fell prey to this

442
00:17:17,720 --> 00:17:19,850
it's just way too common to write macros

443
00:17:19,850 --> 00:17:21,800
if you're working on your web app you

444
00:17:21,800 --> 00:17:23,630
probably will write some macros to do

445
00:17:23,630 --> 00:17:26,240
something this just creates too much

446
00:17:26,240 --> 00:17:28,669
confusion too much divisive nough speak

447
00:17:28,669 --> 00:17:30,470
of the semantics are changing just too

448
00:17:30,470 --> 00:17:33,050
much my opinion closure did it right

449
00:17:33,050 --> 00:17:34,400
they have just enough built in

450
00:17:34,400 --> 00:17:36,290
functionality so you don't always have

451
00:17:36,290 --> 00:17:38,450
to be writing macros and the culture

452
00:17:38,450 --> 00:17:40,280
actually discourages macros in fact

453
00:17:40,280 --> 00:17:41,100
which i think is what

454
00:17:41,100 --> 00:17:43,770
need to do as well but we can't simply

455
00:17:43,770 --> 00:17:45,660
discount macros completely don't be

456
00:17:45,660 --> 00:17:46,380
afraid

457
00:17:46,380 --> 00:17:48,240
closure was able to release a library

458
00:17:48,240 --> 00:17:50,130
called core async which has is somewhat

459
00:17:50,130 --> 00:17:51,960
similar to generators they're different

460
00:17:51,960 --> 00:17:54,179
in many ways but the core functionality

461
00:17:54,179 --> 00:17:56,160
is that they can pause and suspend

462
00:17:56,160 --> 00:17:58,169
execution of a function they were able

463
00:17:58,169 --> 00:17:59,580
to do this as a library because they

464
00:17:59,580 --> 00:18:02,400
implemented a go block which is a new

465
00:18:02,400 --> 00:18:04,200
special form and it compiles the code

466
00:18:04,200 --> 00:18:06,270
inside the go block into a state machine

467
00:18:06,270 --> 00:18:08,160
that they can control it's all just a

468
00:18:08,160 --> 00:18:09,720
library when they release it everyone

469
00:18:09,720 --> 00:18:10,980
can download it and just immediately

470
00:18:10,980 --> 00:18:12,330
begin using it they don't have to wait

471
00:18:12,330 --> 00:18:14,010
for a whole standardization process and

472
00:18:14,010 --> 00:18:16,559
ten years from now might be able to use

473
00:18:16,559 --> 00:18:18,900
it so I think this is especially

474
00:18:18,900 --> 00:18:20,970
important for JavaScript the language is

475
00:18:20,970 --> 00:18:23,370
the language evolution is already

476
00:18:23,370 --> 00:18:25,169
happening I mean looking angular they're

477
00:18:25,169 --> 00:18:27,390
talking about this extension to es6 to

478
00:18:27,390 --> 00:18:29,010
make es6 plus where they have this

479
00:18:29,010 --> 00:18:32,580
dependency injection weird stuff and you

480
00:18:32,580 --> 00:18:34,020
know i think this is fine i think it's

481
00:18:34,020 --> 00:18:35,429
so good to think of ways that we can

482
00:18:35,429 --> 00:18:37,500
improve our code but i think they're

483
00:18:37,500 --> 00:18:39,390
planning on 14 tracer i could be wrong

484
00:18:39,390 --> 00:18:41,130
with that or they're playing around

485
00:18:41,130 --> 00:18:42,750
forking a compiler and adding some

486
00:18:42,750 --> 00:18:44,460
extensions the more and more you do that

487
00:18:44,460 --> 00:18:46,320
the more and more you're styling

488
00:18:46,320 --> 00:18:47,640
yourself away from the JavaScript

489
00:18:47,640 --> 00:18:50,220
community I think javascript needs

490
00:18:50,220 --> 00:18:52,049
release valves because it's just such a

491
00:18:52,049 --> 00:18:56,130
massive language it's used everywhere so

492
00:18:56,130 --> 00:18:57,450
macros can be useful even if you don't

493
00:18:57,450 --> 00:19:00,690
change semantics the emoji script poop

494
00:19:00,690 --> 00:19:03,419
feature disables double equals and this

495
00:19:03,419 --> 00:19:04,350
is how that works

496
00:19:04,350 --> 00:19:06,480
I'm not going to go into the details but

497
00:19:06,480 --> 00:19:09,090
I'm able to throw a syntaxerror within

498
00:19:09,090 --> 00:19:11,850
my macro so whenever the double equals

499
00:19:11,850 --> 00:19:13,530
operator is invoked my macro is invoked

500
00:19:13,530 --> 00:19:15,659
and my macro throws a syntax error so at

501
00:19:15,659 --> 00:19:17,460
expand time it's just throws a syntax

502
00:19:17,460 --> 00:19:19,320
error and says that's not allowed so

503
00:19:19,320 --> 00:19:21,179
this is an interesting way to not only

504
00:19:21,179 --> 00:19:22,470
expand the language but kind of

505
00:19:22,470 --> 00:19:26,250
restricted as well in fact if you wanted

506
00:19:26,250 --> 00:19:28,530
to use macros but you didn't want

507
00:19:28,530 --> 00:19:29,970
anybody on the team especially that

508
00:19:29,970 --> 00:19:32,100
overeager college grad that you just

509
00:19:32,100 --> 00:19:34,080
hired to create macros and go crazy and

510
00:19:34,080 --> 00:19:35,700
change things out from under you you can

511
00:19:35,700 --> 00:19:37,260
just disable macros entirely across your

512
00:19:37,260 --> 00:19:38,880
projects just create a macro called

513
00:19:38,880 --> 00:19:40,470
macro and throw the syntax here and say

514
00:19:40,470 --> 00:19:44,789
you know aloud so here's another example

515
00:19:44,789 --> 00:19:46,620
of macros that don't introduce new new

516
00:19:46,620 --> 00:19:49,710
semantics macros allow certain forms of

517
00:19:49,710 --> 00:19:52,049
aspect or unit programming which means

518
00:19:52,049 --> 00:19:54,419
you can change behavior or add behavior

519
00:19:54,419 --> 00:19:54,780
too so

520
00:19:54,780 --> 00:19:56,430
parts your code without actually

521
00:19:56,430 --> 00:19:59,460
changing it I kind of just made that up

522
00:19:59,460 --> 00:20:01,200
I don't really know what aspect-oriented

523
00:20:01,200 --> 00:20:03,060
programming is technically but look at

524
00:20:03,060 --> 00:20:05,430
the wiki page I mean a macro that traces

525
00:20:05,430 --> 00:20:07,830
all function calls it overrides the

526
00:20:07,830 --> 00:20:10,350
function keyword and injects a console

527
00:20:10,350 --> 00:20:12,870
that log at the beginning calls the

528
00:20:12,870 --> 00:20:14,010
function immediately and gets the return

529
00:20:14,010 --> 00:20:16,350
value and then adds another console dot

530
00:20:16,350 --> 00:20:18,120
log of the return when the return is

531
00:20:18,120 --> 00:20:21,330
happening and I'm able to pick off the

532
00:20:21,330 --> 00:20:22,920
name of the function this is actually

533
00:20:22,920 --> 00:20:25,050
just one part of the macro that the real

534
00:20:25,050 --> 00:20:26,160
macro that it wrote is a little bit more

535
00:20:26,160 --> 00:20:27,630
sophisticated it's able to pick off the

536
00:20:27,630 --> 00:20:29,130
name of the function even if it's like a

537
00:20:29,130 --> 00:20:34,110
an object property you know so I took

538
00:20:34,110 --> 00:20:36,720
this macro and I ran it through and I

539
00:20:36,720 --> 00:20:39,540
ran and I ran jQuery with it so it

540
00:20:39,540 --> 00:20:41,850
expanded jquery with this and so with

541
00:20:41,850 --> 00:20:42,900
this it's really interesting i was able

542
00:20:42,900 --> 00:20:45,090
to run this jQuery code and say with it

543
00:20:45,090 --> 00:20:46,950
what does the execution look like within

544
00:20:46,950 --> 00:20:51,360
jQuery so I can grab an element with the

545
00:20:51,360 --> 00:20:54,000
idea of app and I can set the HTML of it

546
00:20:54,000 --> 00:20:55,980
with of it with to the div with a class

547
00:20:55,980 --> 00:20:58,260
box and I can kind of see the shape of

548
00:20:58,260 --> 00:21:00,030
what's going on within jQuery so if I

549
00:21:00,030 --> 00:21:01,530
wanted to learn what jQuery was doing

550
00:21:01,530 --> 00:21:02,730
maybe I wanted to start working on

551
00:21:02,730 --> 00:21:05,400
jQuery I just immediately see this

552
00:21:05,400 --> 00:21:07,890
interesting functionality now a certain

553
00:21:07,890 --> 00:21:09,030
dev tools I think are starting to

554
00:21:09,030 --> 00:21:11,550
implement things like tracers but youyou

555
00:21:11,550 --> 00:21:14,190
wrote this for your app for your code

556
00:21:14,190 --> 00:21:15,690
and project and you know what you're

557
00:21:15,690 --> 00:21:17,640
wanting to look for so you could do all

558
00:21:17,640 --> 00:21:19,710
sorts of things with macros that are

559
00:21:19,710 --> 00:21:21,180
specific to your app for debugging your

560
00:21:21,180 --> 00:21:22,710
app and logging your app and doing all

561
00:21:22,710 --> 00:21:24,270
sorts of interesting things but don't

562
00:21:24,270 --> 00:21:25,830
actually change semantics right there

563
00:21:25,830 --> 00:21:27,150
just adding interesting logging

564
00:21:27,150 --> 00:21:29,940
capabilities so nobody else on the team

565
00:21:29,940 --> 00:21:31,140
doesn't even have to worry about what's

566
00:21:31,140 --> 00:21:34,530
going on so here's something a little

567
00:21:34,530 --> 00:21:36,960
crazier this does this does add new

568
00:21:36,960 --> 00:21:39,180
semantics can we implement a simplistic

569
00:21:39,180 --> 00:21:43,320
stack allocated type system so we can

570
00:21:43,320 --> 00:21:45,380
get bit something basic working I think

571
00:21:45,380 --> 00:21:47,790
first let's allocate one big typed array

572
00:21:47,790 --> 00:21:50,250
our stock and create various type two

573
00:21:50,250 --> 00:21:53,790
views into it and my stack a located

574
00:21:53,790 --> 00:21:54,840
type system allows you to write code

575
00:21:54,840 --> 00:21:56,850
like this you can define a record type

576
00:21:56,850 --> 00:21:59,250
so you have point which with fields and

577
00:21:59,250 --> 00:22:01,110
they all have types and these types are

578
00:22:01,110 --> 00:22:03,030
just kind of the machine low-level types

579
00:22:03,030 --> 00:22:04,770
like double and float and you went and

580
00:22:04,770 --> 00:22:07,920
int and short

581
00:22:07,920 --> 00:22:09,960
but now now you can accentuate one of

582
00:22:09,960 --> 00:22:12,620
these records and it essentially

583
00:22:12,620 --> 00:22:16,140
allocates it on our set which we is that

584
00:22:16,140 --> 00:22:16,740
big techhdarre

585
00:22:16,740 --> 00:22:19,710
and this sets the X&Y to 180 this

586
00:22:19,710 --> 00:22:22,050
expands all the way down do this so I

587
00:22:22,050 --> 00:22:23,940
grab I grab the current side pointer and

588
00:22:23,940 --> 00:22:25,290
that's essentially my stack allocated

589
00:22:25,290 --> 00:22:27,690
objects it's just a pointer and I move

590
00:22:27,690 --> 00:22:29,780
the stack pointer and then I set the

591
00:22:29,780 --> 00:22:34,080
pieces in my stack to 180 and I'm

592
00:22:34,080 --> 00:22:36,350
accessing it through the float

593
00:22:36,350 --> 00:22:39,330
float64array and you can see the pointer

594
00:22:39,330 --> 00:22:42,240
so the first one is my my cyclic a to

595
00:22:42,240 --> 00:22:44,700
object pointer and the the second value

596
00:22:44,700 --> 00:22:47,130
Y is that plus 8 because it's 8 bytes

597
00:22:47,130 --> 00:22:50,250
wide so we can have typed allocated

598
00:22:50,250 --> 00:22:52,980
structs and compile it down to this this

599
00:22:52,980 --> 00:22:54,060
lets you avoid all those pesky

600
00:22:54,060 --> 00:22:55,860
allocations if you're writing like heavy

601
00:22:55,860 --> 00:22:58,080
graphics code it's a very interesting

602
00:22:58,080 --> 00:22:59,580
way to kind of interleave this this is a

603
00:22:59,580 --> 00:23:00,960
haven't put a whole lot of time you do

604
00:23:00,960 --> 00:23:02,460
this if a new type theory better I'd

605
00:23:02,460 --> 00:23:03,360
probably do something little bit

606
00:23:03,360 --> 00:23:05,850
different if you want it to like return

607
00:23:05,850 --> 00:23:07,650
this you can do that you but you could I

608
00:23:07,650 --> 00:23:09,510
essentially copied it onto the heap if

609
00:23:09,510 --> 00:23:11,010
you wanted to do that but there's a lot

610
00:23:11,010 --> 00:23:12,120
of times when you're writing graphics

611
00:23:12,120 --> 00:23:14,070
code and you just want a bunch of local

612
00:23:14,070 --> 00:23:16,200
vectors to do some computationally heavy

613
00:23:16,200 --> 00:23:18,390
work and always doing the object literal

614
00:23:18,390 --> 00:23:20,130
x and y is just hitting a garbage

615
00:23:20,130 --> 00:23:22,980
collector for no reason so who knows

616
00:23:22,980 --> 00:23:24,330
maybe one of these features does turn

617
00:23:24,330 --> 00:23:25,920
out to be so useful that it does become

618
00:23:25,920 --> 00:23:27,840
standardized something that we wouldn't

619
00:23:27,840 --> 00:23:30,510
have thought to propose at first and now

620
00:23:30,510 --> 00:23:32,100
it will be based on real world usage and

621
00:23:32,100 --> 00:23:33,300
most of the problems with backwards

622
00:23:33,300 --> 00:23:35,100
compatibility will already have been

623
00:23:35,100 --> 00:23:37,380
solved it would be neat if JavaScript

624
00:23:37,380 --> 00:23:39,450
even integrated sweet GS itself natively

625
00:23:39,450 --> 00:23:41,280
but if that does happen that's probably

626
00:23:41,280 --> 00:23:42,450
a long ways off

627
00:23:42,450 --> 00:23:43,680
but I think it could be need to do

628
00:23:43,680 --> 00:23:45,480
something like a browser add-on that in

629
00:23:45,480 --> 00:23:46,980
that integrates it automatically and

630
00:23:46,980 --> 00:23:49,050
then for production you just pre compile

631
00:23:49,050 --> 00:23:51,810
or could of course some levels really do

632
00:23:51,810 --> 00:23:53,270
you require a platform level integration

633
00:23:53,270 --> 00:23:55,920
just things like weak Maps but I think

634
00:23:55,920 --> 00:23:58,920
those are actually relatively rare so

635
00:23:58,920 --> 00:24:01,800
let's let's look at what sweet GS if you

636
00:24:01,800 --> 00:24:03,330
wanted to actually write macros some of

637
00:24:03,330 --> 00:24:05,970
the features that it gives you to to

638
00:24:05,970 --> 00:24:07,200
actually do this because I haven't

639
00:24:07,200 --> 00:24:10,410
showed you any of the actual code so if

640
00:24:10,410 --> 00:24:12,570
features a pattern matching various

641
00:24:12,570 --> 00:24:15,690
expansion strategies and hygiene so

642
00:24:15,690 --> 00:24:17,760
these are fully hygienic macros so if

643
00:24:17,760 --> 00:24:19,020
you're familiar with macros you know

644
00:24:19,020 --> 00:24:20,520
that that's pretty much necessary for a

645
00:24:20,520 --> 00:24:21,090
real world

646
00:24:21,090 --> 00:24:25,770
her system so PI R imagine you've you've

647
00:24:25,770 --> 00:24:28,470
seen this to some extent this is just a

648
00:24:28,470 --> 00:24:30,000
basic pattern matching you have a list

649
00:24:30,000 --> 00:24:32,640
of rules and the sweet jest system will

650
00:24:32,640 --> 00:24:35,850
invoke your macro so it's you have a

651
00:24:35,850 --> 00:24:37,680
macro named bar your macro will be

652
00:24:37,680 --> 00:24:39,240
invoked when it hits the keyword bar in

653
00:24:39,240 --> 00:24:41,280
the code and then it will walk down your

654
00:24:41,280 --> 00:24:43,920
rules top to bottom and see see if it

655
00:24:43,920 --> 00:24:45,120
matches a rule and if it doesn't matter

656
00:24:45,120 --> 00:24:46,950
rule it'll throw in my chair and when it

657
00:24:46,950 --> 00:24:48,870
does the first rule that matches it will

658
00:24:48,870 --> 00:24:50,550
expand into the code that's within that

659
00:24:50,550 --> 00:24:52,920
rule so this is a basic basic variable

660
00:24:52,920 --> 00:24:54,690
destructuring array so you can see that

661
00:24:54,690 --> 00:24:57,270
the first rule has a curly brace and

662
00:24:57,270 --> 00:25:00,240
then a name and then of multiple

663
00:25:00,240 --> 00:25:02,880
repeated names and then equals object so

664
00:25:02,880 --> 00:25:05,130
you can bind current syntactic elements

665
00:25:05,130 --> 00:25:07,470
to pattern variables with the dollar

666
00:25:07,470 --> 00:25:09,450
sign so that basically says whatever is

667
00:25:09,450 --> 00:25:11,700
here just bind it to me and then the the

668
00:25:11,700 --> 00:25:14,930
dot dot means match repeated elements

669
00:25:14,930 --> 00:25:18,510
and just a brief overview so that's

670
00:25:18,510 --> 00:25:20,100
that's the roll macro this is a rule

671
00:25:20,100 --> 00:25:22,220
makkal you just have a list of patterns

672
00:25:22,220 --> 00:25:24,780
there's a a let macro which is

673
00:25:24,780 --> 00:25:26,450
essentially the same as the rule macro

674
00:25:26,450 --> 00:25:29,400
except you define it saying let var

675
00:25:29,400 --> 00:25:32,460
equals macro and what this does is by

676
00:25:32,460 --> 00:25:35,340
default recur macros are recursive so

677
00:25:35,340 --> 00:25:37,770
when a code is expanded it will

678
00:25:37,770 --> 00:25:43,590
reexpansion var keyword you couldn't do

679
00:25:43,590 --> 00:25:46,230
that let macro does not recursively

680
00:25:46,230 --> 00:25:48,450
expand oh I'm sorry it does it but I let

681
00:25:48,450 --> 00:25:50,820
my grow if you the VAR that we've

682
00:25:50,820 --> 00:25:52,890
referenced within the macro doesn't

683
00:25:52,890 --> 00:25:54,450
reference my macro it references what

684
00:25:54,450 --> 00:25:57,300
what it was defined as before my macro

685
00:25:57,300 --> 00:25:59,280
which was the built-in var so this will

686
00:25:59,280 --> 00:26:01,590
not recursively infinitely loop which it

687
00:26:01,590 --> 00:26:04,470
would do with a normal macro there's in

688
00:26:04,470 --> 00:26:07,740
fix macros which let you specify a pipe

689
00:26:07,740 --> 00:26:09,930
or a bar in your pattern and that means

690
00:26:09,930 --> 00:26:11,880
you can look and that that bar indicates

691
00:26:11,880 --> 00:26:13,920
where that macro matched and that means

692
00:26:13,920 --> 00:26:16,020
you can match before the syntactical

693
00:26:16,020 --> 00:26:18,090
element that you've been invoked on so

694
00:26:18,090 --> 00:26:19,860
for the arrow function syntax the FATA

695
00:26:19,860 --> 00:26:22,020
is we need this because we need to look

696
00:26:22,020 --> 00:26:23,940
back and grab the arguments and so

697
00:26:23,940 --> 00:26:26,070
that's this is a basic file

698
00:26:26,070 --> 00:26:28,950
this is actually most where all of the

699
00:26:28,950 --> 00:26:29,660
fat arrow

700
00:26:29,660 --> 00:26:33,540
macro you you get this like you get fed

701
00:26:33,540 --> 00:26:34,899
arose with this macro

702
00:26:34,899 --> 00:26:36,340
I think it's actually missing one rule

703
00:26:36,340 --> 00:26:39,700
for one one style of photos but this is

704
00:26:39,700 --> 00:26:41,019
how tiny it is you don't have to write

705
00:26:41,019 --> 00:26:45,070
compilers this is a little bit more

706
00:26:45,070 --> 00:26:47,169
complex but there's um there's a special

707
00:26:47,169 --> 00:26:49,210
form called operator which defines a new

708
00:26:49,210 --> 00:26:51,940
macro but it's but it's has a little bit

709
00:26:51,940 --> 00:26:54,159
more semantics so this overrides the

710
00:26:54,159 --> 00:26:56,139
plus operator it takes the precedence

711
00:26:56,139 --> 00:26:58,090
and the associativity so 12 is the

712
00:26:58,090 --> 00:26:59,740
president's level so if you think of

713
00:26:59,740 --> 00:27:01,090
operators they all have our precedence

714
00:27:01,090 --> 00:27:02,710
level like where they where they group

715
00:27:02,710 --> 00:27:05,200
together so plus I'm doing it 12 which i

716
00:27:05,200 --> 00:27:06,669
think is what the what the default is

717
00:27:06,669 --> 00:27:09,100
and then a left associativity so you can

718
00:27:09,100 --> 00:27:10,210
see that it expands is you a function

719
00:27:10,210 --> 00:27:12,730
call add so 1 plus 2 Plus 3 plus 4

720
00:27:12,730 --> 00:27:16,149
expands into this and it groups 1 & 2

721
00:27:16,149 --> 00:27:18,490
first if I change the associativity to

722
00:27:18,490 --> 00:27:20,590
right then it's going to group 3 & 4

723
00:27:20,590 --> 00:27:24,730
first and then expand out from there so

724
00:27:24,730 --> 00:27:26,529
this is why you need this special form

725
00:27:26,529 --> 00:27:28,210
operator because it has the precedence

726
00:27:28,210 --> 00:27:29,740
and the associative 'ti and things that

727
00:27:29,740 --> 00:27:32,429
you can do with what the other macros

728
00:27:32,429 --> 00:27:34,720
and this is the last one this is the

729
00:27:34,720 --> 00:27:36,669
most complex one and one that should

730
00:27:36,669 --> 00:27:38,649
rarely be needed really it's case

731
00:27:38,649 --> 00:27:41,379
mappers these macros actually let you

732
00:27:41,379 --> 00:27:43,929
run arbitrary JavaScript within the the

733
00:27:43,929 --> 00:27:47,019
rule so it takes a pattern this is a

734
00:27:47,019 --> 00:27:49,119
little bit different it takes it takes a

735
00:27:49,119 --> 00:27:51,190
syntactic element that it bound on as

736
00:27:51,190 --> 00:27:54,940
the first argument or as the first piece

737
00:27:54,940 --> 00:27:57,340
in your pattern and then you have your

738
00:27:57,340 --> 00:27:59,289
whole pattern but then you can actually

739
00:27:59,289 --> 00:28:01,059
any JavaScript within this expanded code

740
00:28:01,059 --> 00:28:03,369
so I can check if this condition isn't

741
00:28:03,369 --> 00:28:05,679
true then throw a syntax error and this

742
00:28:05,679 --> 00:28:07,360
lets you do things like break hygiene

743
00:28:07,360 --> 00:28:10,840
gum which I'm about to talk about so so

744
00:28:10,840 --> 00:28:12,190
hygiene like I said these are hygienic

745
00:28:12,190 --> 00:28:14,799
Macker this is like crucially important

746
00:28:14,799 --> 00:28:16,809
it's a basic thing that you need for any

747
00:28:16,809 --> 00:28:18,549
macro system that's going to be used as

748
00:28:18,549 --> 00:28:21,519
modules so the problem with macros

749
00:28:21,519 --> 00:28:23,529
typically is we've defined this square

750
00:28:23,529 --> 00:28:26,590
macro if it square X expands out to

751
00:28:26,590 --> 00:28:28,600
these two lines of code which have

752
00:28:28,600 --> 00:28:31,480
another suit var X so if it was just a

753
00:28:31,480 --> 00:28:35,309
naive macro system I would have to two

754
00:28:35,309 --> 00:28:37,570
variable declarations with the name X

755
00:28:37,570 --> 00:28:39,519
and they would collide and they

756
00:28:39,519 --> 00:28:42,279
overwrite and it leads to really strange

757
00:28:42,279 --> 00:28:43,600
bugs and there's just you really need

758
00:28:43,600 --> 00:28:46,450
hygiene to actually have a sound

759
00:28:46,450 --> 00:28:48,399
macro system so a sweet J's says it

760
00:28:48,399 --> 00:28:48,670
actual

761
00:28:48,670 --> 00:28:50,830
renames the variables so the first X is

762
00:28:50,830 --> 00:28:53,020
renamed X dollars 21 and the second one

763
00:28:53,020 --> 00:28:54,640
is rename X are assigned to so it

764
00:28:54,640 --> 00:28:56,050
removes everything to make sure that

765
00:28:56,050 --> 00:28:59,140
it's right so this is the very last

766
00:28:59,140 --> 00:29:01,900
thing I'm going to talk about you might

767
00:29:01,900 --> 00:29:03,100
be sitting there thinking like well this

768
00:29:03,100 --> 00:29:05,080
is totally all cool I would use this

769
00:29:05,080 --> 00:29:06,640
except for one thing and that that's

770
00:29:06,640 --> 00:29:08,170
that it breaks my syntax highlighter in

771
00:29:08,170 --> 00:29:10,960
my editor so I looked at a lot of some

772
00:29:10,960 --> 00:29:11,950
nice highlighters and they're actually

773
00:29:11,950 --> 00:29:14,020
pretty loose most of them are regular

774
00:29:14,020 --> 00:29:16,090
expression based you can do a lot of

775
00:29:16,090 --> 00:29:18,610
weird operators and stuff this is

776
00:29:18,610 --> 00:29:20,140
IntelliJ I just chose it because it's

777
00:29:20,140 --> 00:29:21,430
just a really random one that I thought

778
00:29:21,430 --> 00:29:23,080
would be a little bit more intrusive

779
00:29:23,080 --> 00:29:24,490
about how it's actually parsing the code

780
00:29:24,490 --> 00:29:26,470
but it actually worked fine I didn't

781
00:29:26,470 --> 00:29:29,440
really throw any enters errors most

782
00:29:29,440 --> 00:29:30,910
editors are pretty flexible and they're

783
00:29:30,910 --> 00:29:32,020
just looking for the keywords and

784
00:29:32,020 --> 00:29:32,860
they're just looking for a basic

785
00:29:32,860 --> 00:29:34,780
delimiter is so that it can indent the

786
00:29:34,780 --> 00:29:36,220
code right and it just pretty much

787
00:29:36,220 --> 00:29:38,230
ignores everything else there are a few

788
00:29:38,230 --> 00:29:41,170
exceptions jst mode in Emacs actually

789
00:29:41,170 --> 00:29:43,240
little literally parses the JavaScript

790
00:29:43,240 --> 00:29:45,130
code in your buffer so that it does

791
00:29:45,130 --> 00:29:47,380
break that but honestly the more I think

792
00:29:47,380 --> 00:29:49,000
about it the more I think that some of

793
00:29:49,000 --> 00:29:50,650
those things aren't worth the return

794
00:29:50,650 --> 00:29:53,170
because I really don't use like it tells

795
00:29:53,170 --> 00:29:54,610
me when I'm missing a semicolon and

796
00:29:54,610 --> 00:29:56,500
that's cool but J's hint can tell me

797
00:29:56,500 --> 00:29:57,700
that or it's somewhat somewhat I think

798
00:29:57,700 --> 00:29:59,530
and tell me that some kind of build time

799
00:29:59,530 --> 00:30:01,930
that that's happening I'm starting to

800
00:30:01,930 --> 00:30:03,130
think that something's like that might

801
00:30:03,130 --> 00:30:04,330
actually end up holding back Java

802
00:30:04,330 --> 00:30:05,860
scripts because a lot of people don't

803
00:30:05,860 --> 00:30:08,020
use es6 because not only is ESX not

804
00:30:08,020 --> 00:30:09,760
implemented you could use it with trace

805
00:30:09,760 --> 00:30:11,080
or something but a lot of these other

806
00:30:11,080 --> 00:30:13,090
tools haven't implemented like editors

807
00:30:13,090 --> 00:30:14,920
haven't implemented like the fat arrow

808
00:30:14,920 --> 00:30:17,560
syntax so it the the editor breaks so

809
00:30:17,560 --> 00:30:18,340
I'm actually starting to think that

810
00:30:18,340 --> 00:30:20,050
things like editors the looser the

811
00:30:20,050 --> 00:30:24,130
highlighting is the better so I'm I mean

812
00:30:24,130 --> 00:30:25,420
maybe I'm a little bit biased because I

813
00:30:25,420 --> 00:30:27,820
do like to use macros but I've actually

814
00:30:27,820 --> 00:30:30,090
seen like vim works great with the with

815
00:30:30,090 --> 00:30:32,800
different operators and stuff like that

816
00:30:32,800 --> 00:30:34,840
basically anything on a new line that is

817
00:30:34,840 --> 00:30:36,490
still part of the previous previous

818
00:30:36,490 --> 00:30:38,200
expression is just intended like two or

819
00:30:38,200 --> 00:30:39,490
four spaces and they just kind of

820
00:30:39,490 --> 00:30:43,210
doesn't care what it is so just a quick

821
00:30:43,210 --> 00:30:44,980
recap javascript is under a lot of

822
00:30:44,980 --> 00:30:46,900
pressure to evolve and suite just

823
00:30:46,900 --> 00:30:49,420
provides powerful macros for adding

824
00:30:49,420 --> 00:30:50,980
these features as libraries and we can

825
00:30:50,980 --> 00:30:52,240
test them out early we can try them

826
00:30:52,240 --> 00:30:54,700
early and see if they work compilers

827
00:30:54,700 --> 00:30:56,650
can't work together there they're great

828
00:30:56,650 --> 00:30:58,420
for some things but for specifically

829
00:30:58,420 --> 00:31:01,049
language extensions there

830
00:31:01,049 --> 00:31:03,179
a little bit more they tend to create

831
00:31:03,179 --> 00:31:06,450
silos and we can help tc39 we can help

832
00:31:06,450 --> 00:31:08,730
liberate javascript so we don't have to

833
00:31:08,730 --> 00:31:11,419
wait 14 years for a variable destruction

834
00:31:11,419 --> 00:31:12,749
that's it

