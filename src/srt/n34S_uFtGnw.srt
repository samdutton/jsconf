1
00:00:09,780 --> 00:00:14,049

okay hi yep I said I'm Tim ruffles I'm

2
00:00:14,049 --> 00:00:15,609
currently working on a product called

3
00:00:15,609 --> 00:00:17,619
psychic Jess which is a code quality

4
00:00:17,619 --> 00:00:20,500
tool for JavaScript and today I'm going

5
00:00:20,500 --> 00:00:23,169
to be talking about handling lots and

6
00:00:23,169 --> 00:00:25,300
lots of asynchronous code big

7
00:00:25,300 --> 00:00:27,309
asynchronous processes involving lots

8
00:00:27,309 --> 00:00:29,379
and lots of inputs going lots of

9
00:00:29,379 --> 00:00:36,930
different directions AKA callback hell

10
00:00:36,930 --> 00:00:38,890
but i think we've got cool backhaul

11
00:00:38,890 --> 00:00:40,629
wrong i think all the kind of typical

12
00:00:40,629 --> 00:00:42,190
blog posts you see where people start

13
00:00:42,190 --> 00:00:44,170
going on about callbacks being

14
00:00:44,170 --> 00:00:46,930
JavaScript's go to and how you can try

15
00:00:46,930 --> 00:00:48,520
anything complicated in javascript as

16
00:00:48,520 --> 00:00:50,110
soon as you start using callbacks it all

17
00:00:50,110 --> 00:00:52,060
turns into a big spaghetti code mess I

18
00:00:52,060 --> 00:00:54,489
think they kind of missed the point so

19
00:00:54,489 --> 00:00:55,930
in this I'm going to be talking about

20
00:00:55,930 --> 00:00:58,570
how you can handle most callback stuff

21
00:00:58,570 --> 00:01:00,309
with just the tools you already know a

22
00:01:00,309 --> 00:01:02,230
JavaScript and then we can be looking at

23
00:01:02,230 --> 00:01:03,760
what I think is the real cool back help

24
00:01:03,760 --> 00:01:05,710
the real challenge is of asynchronous

25
00:01:05,710 --> 00:01:08,079
code and looking at some new stuff some

26
00:01:08,079 --> 00:01:09,909
libraries but also some new things in

27
00:01:09,909 --> 00:01:12,130
JavaScript that will help you make a

28
00:01:12,130 --> 00:01:16,119
simple game so pyramids pyramids of doom

29
00:01:16,119 --> 00:01:18,850
do exist I've been looking at a lot of

30
00:01:18,850 --> 00:01:20,590
code for sidekick it's kind of research

31
00:01:20,590 --> 00:01:22,209
for what people are doing in terms of

32
00:01:22,209 --> 00:01:25,090
their code and it's out there like if

33
00:01:25,090 --> 00:01:27,600
you look on github some node code has

34
00:01:27,600 --> 00:01:31,060
inline callbacks five levels deep you

35
00:01:31,060 --> 00:01:32,409
know that there's no way you can reason

36
00:01:32,409 --> 00:01:34,149
about this stuff it's just a nightmare

37
00:01:34,149 --> 00:01:35,799
there's no way you could test this in a

38
00:01:35,799 --> 00:01:39,520
million years there's really no need for

39
00:01:39,520 --> 00:01:42,340
this kind of call back he'll like for

40
00:01:42,340 --> 00:01:44,259
most of the code that I see it for

41
00:01:44,259 --> 00:01:46,029
there's no need for it in the simple

42
00:01:46,029 --> 00:01:48,039
cases like something like this so this

43
00:01:48,039 --> 00:01:50,799
is a just some simple Express jazz

44
00:01:50,799 --> 00:01:53,289
handler we're getting a user we're going

45
00:01:53,289 --> 00:01:54,819
to update their profile we want to check

46
00:01:54,819 --> 00:01:56,169
out you know did have a profile already

47
00:01:56,169 --> 00:01:59,020
or are we creating a new one so just all

48
00:01:59,020 --> 00:02:00,549
very simple stuff if we're writing the

49
00:02:00,549 --> 00:02:03,069
synchronously it will be super simple if

50
00:02:03,069 --> 00:02:05,049
you start just starting out node and you

51
00:02:05,049 --> 00:02:06,039
don't you don't know any other way you

52
00:02:06,039 --> 00:02:07,689
might end up with something like this so

53
00:02:07,689 --> 00:02:09,310
we're handling errors all over the place

54
00:02:09,310 --> 00:02:11,470
we've got quite a kind of deep stack of

55
00:02:11,470 --> 00:02:15,700
nested callbacks we don't wanna do this

56
00:02:15,700 --> 00:02:19,150
for two reasons first off it's

57
00:02:19,150 --> 00:02:20,710
completely untested and I personally

58
00:02:20,710 --> 00:02:21,940
find that

59
00:02:21,940 --> 00:02:23,920
test codes without test is just not code

60
00:02:23,920 --> 00:02:25,900
I don't really count thats code that's

61
00:02:25,900 --> 00:02:27,610
kind of a hack that's like an experiment

62
00:02:27,610 --> 00:02:29,830
without code I just don't trust it and I

63
00:02:29,830 --> 00:02:31,360
wouldn't really trust someone else's

64
00:02:31,360 --> 00:02:33,220
code I certainly don't trust my own code

65
00:02:33,220 --> 00:02:35,710
if it doesn't have tests so how do we

66
00:02:35,710 --> 00:02:38,080
test this code will there be no way we'd

67
00:02:38,080 --> 00:02:40,330
have to dig right in so if you have a

68
00:02:40,330 --> 00:02:41,620
look at the two points I've got these

69
00:02:41,620 --> 00:02:43,240
comments saying we can't test this stuff

70
00:02:43,240 --> 00:02:45,040
there's no way of getting in there it's

71
00:02:45,040 --> 00:02:46,930
inside a closure we'd have to test the

72
00:02:46,930 --> 00:02:48,640
whole lot in one go so all of those

73
00:02:48,640 --> 00:02:50,920
callbacks or nothing so we're either

74
00:02:50,920 --> 00:02:52,720
have to stub out every little bit of our

75
00:02:52,720 --> 00:02:55,030
code there or we're just kind of give up

76
00:02:55,030 --> 00:02:57,250
and not test it it's not cool just don't

77
00:02:57,250 --> 00:02:59,200
it's not it's not doable so we can't do

78
00:02:59,200 --> 00:03:00,730
this so we just can't do this kind of

79
00:03:00,730 --> 00:03:02,500
stuff we have to name all are callbacks

80
00:03:02,500 --> 00:03:04,870
and reveal them so we either reveal them

81
00:03:04,870 --> 00:03:07,840
individually and the kind of no objects

82
00:03:07,840 --> 00:03:09,460
just have loads of blobs of functions

83
00:03:09,460 --> 00:03:10,990
just have a name so we can actually get

84
00:03:10,990 --> 00:03:12,700
at them with our tests or we stick them

85
00:03:12,700 --> 00:03:14,410
in objects and then we can get animo

86
00:03:14,410 --> 00:03:15,970
test again so everything has to have a

87
00:03:15,970 --> 00:03:17,200
name all your callback should have a

88
00:03:17,200 --> 00:03:18,610
name you should be able to get at them

89
00:03:18,610 --> 00:03:20,050
and test them individually and that

90
00:03:20,050 --> 00:03:22,030
let's split up the input-output stuff

91
00:03:22,030 --> 00:03:23,650
which is the complicated stuff the

92
00:03:23,650 --> 00:03:26,200
asynchronous bit with the simple code we

93
00:03:26,200 --> 00:03:28,090
have inside our handlers which say if I

94
00:03:28,090 --> 00:03:29,950
have an error and a user what happens if

95
00:03:29,950 --> 00:03:32,320
I have a no error and a user something

96
00:03:32,320 --> 00:03:33,580
good happens all that kind of stuff it

97
00:03:33,580 --> 00:03:35,080
suddenly becomes easy again as soon as

98
00:03:35,080 --> 00:03:39,100
we do that reason be javascript already

99
00:03:39,100 --> 00:03:40,900
has tools to avoid most of the simple

100
00:03:40,900 --> 00:03:44,920
case kind of causes of complexity so the

101
00:03:44,920 --> 00:03:46,900
named functions obviously but secondly

102
00:03:46,900 --> 00:03:49,270
the function up bind so how many of

103
00:03:49,270 --> 00:03:52,750
these are used function bind cool okay

104
00:03:52,750 --> 00:03:54,370
so most of you well function up bind is

105
00:03:54,370 --> 00:03:56,260
a really really nice little tool that

106
00:03:56,260 --> 00:03:58,870
lets you get a new version of a function

107
00:03:58,870 --> 00:04:01,180
that's kind of partially filled in so

108
00:04:01,180 --> 00:04:03,209
let's say we if we have a look at the

109
00:04:03,209 --> 00:04:06,989
save profile method here it has three

110
00:04:06,989 --> 00:04:09,700
bits of context we're kind of going

111
00:04:09,700 --> 00:04:11,080
halfway through a process so it already

112
00:04:11,080 --> 00:04:13,720
has the user we've already got the user

113
00:04:13,720 --> 00:04:15,340
and we're going to the next one of the

114
00:04:15,340 --> 00:04:16,510
process we either get an error or a

115
00:04:16,510 --> 00:04:18,669
profile so if we were doing this all in

116
00:04:18,669 --> 00:04:20,350
line we'd obviously just reference the

117
00:04:20,350 --> 00:04:22,060
variables in the closure but as I said

118
00:04:22,060 --> 00:04:24,730
can't do that we can't test it how can

119
00:04:24,730 --> 00:04:26,770
we get around that with bind well we can

120
00:04:26,770 --> 00:04:29,050
use bind we pass it this which is the

121
00:04:29,050 --> 00:04:31,870
context of this inside the new bound

122
00:04:31,870 --> 00:04:33,789
function and we pass at some of the

123
00:04:33,789 --> 00:04:35,790
variables which kind of fill it in and

124
00:04:35,790 --> 00:04:37,020
get back what's called a partial

125
00:04:37,020 --> 00:04:39,090
function which is exactly that it's like

126
00:04:39,090 --> 00:04:40,530
a new version of the function where one

127
00:04:40,530 --> 00:04:42,260
of the arguments has already been set

128
00:04:42,260 --> 00:04:44,990
that's what you get so we've avoided

129
00:04:44,990 --> 00:04:47,130
using closures and therefore the

130
00:04:47,130 --> 00:04:48,540
untested bility just with pure

131
00:04:48,540 --> 00:04:51,810
JavaScript so buying kind of fills in

132
00:04:51,810 --> 00:04:53,190
the stuff we get this partially bound

133
00:04:53,190 --> 00:04:55,890
function and we can apply it easily it's

134
00:04:55,890 --> 00:04:59,700
nice and simple it's not ideal if we

135
00:04:59,700 --> 00:05:00,900
have a look we've got our two kind of

136
00:05:00,900 --> 00:05:02,250
solutions to this we got naming so we

137
00:05:02,250 --> 00:05:03,930
can test we got bind so we don't have to

138
00:05:03,930 --> 00:05:05,610
use closures we obviously have to

139
00:05:05,610 --> 00:05:07,410
percolate this context down in our

140
00:05:07,410 --> 00:05:09,450
functions it's a little bit fragile if

141
00:05:09,450 --> 00:05:11,430
we need to change the context we're all

142
00:05:11,430 --> 00:05:15,240
doing it by hand so it's okay but we you

143
00:05:15,240 --> 00:05:16,920
know we've won hyung we we finished cool

144
00:05:16,920 --> 00:05:22,110
back hell not exactly these simple cases

145
00:05:22,110 --> 00:05:23,430
that people in blog posts say are

146
00:05:23,430 --> 00:05:25,140
completely insoluble definitely have

147
00:05:25,140 --> 00:05:28,070
solutions but they're still pay points

148
00:05:28,070 --> 00:05:30,240
so what happens when we have lots and

149
00:05:30,240 --> 00:05:32,070
lots of asynchronous stuff let's say we

150
00:05:32,070 --> 00:05:34,110
have a list of files we need to apply

151
00:05:34,110 --> 00:05:35,430
some transform to all of them

152
00:05:35,430 --> 00:05:38,030
asynchronously or in this case we have

153
00:05:38,030 --> 00:05:40,350
two processes we want to run in parallel

154
00:05:40,350 --> 00:05:43,710
will bind can't help us their naming is

155
00:05:43,710 --> 00:05:45,030
not going to help us there we need to

156
00:05:45,030 --> 00:05:46,530
have some kind of way of saying when

157
00:05:46,530 --> 00:05:48,590
both of these things are done progress

158
00:05:48,590 --> 00:05:52,110
okay javascript doesn't give us any

159
00:05:52,110 --> 00:05:54,390
tools natively to do that we can have to

160
00:05:54,390 --> 00:05:55,680
start writing them ourselves we can have

161
00:05:55,680 --> 00:05:57,150
to start implementing this flow control

162
00:05:57,150 --> 00:05:59,310
our self which is not ideal because

163
00:05:59,310 --> 00:06:01,320
every single time we do something we're

164
00:06:01,320 --> 00:06:02,280
going to have to write some of this kind

165
00:06:02,280 --> 00:06:06,600
of eight ad-hoc code same those sets so

166
00:06:06,600 --> 00:06:08,670
innumerable zor collections of things so

167
00:06:08,670 --> 00:06:10,680
for all the users do this asynchronous

168
00:06:10,680 --> 00:06:12,330
process for all the files do this

169
00:06:12,330 --> 00:06:14,130
asynchronous process again you can see

170
00:06:14,130 --> 00:06:16,230
this is all very ad hoc code you know

171
00:06:16,230 --> 00:06:18,270
I've just got this like done counting

172
00:06:18,270 --> 00:06:20,040
how many of them we finish so far and

173
00:06:20,040 --> 00:06:21,960
then finally it does the callback with

174
00:06:21,960 --> 00:06:24,330
the array of the outputs of this

175
00:06:24,330 --> 00:06:26,820
asynchronous process so it's a bit of a

176
00:06:26,820 --> 00:06:28,920
pain point we're writing code again and

177
00:06:28,920 --> 00:06:30,630
again and again to get round some kind

178
00:06:30,630 --> 00:06:32,100
of problem there's something wrong with

179
00:06:32,100 --> 00:06:34,440
our code that makes us continuous you

180
00:06:34,440 --> 00:06:35,850
have to write this ad hoc code to solve

181
00:06:35,850 --> 00:06:39,390
it well maybe you could just get someone

182
00:06:39,390 --> 00:06:41,550
else to write the code for us you know

183
00:06:41,550 --> 00:06:42,990
we can see these kind of patterns coming

184
00:06:42,990 --> 00:06:44,669
up again and again someone else must

185
00:06:44,669 --> 00:06:46,290
have had this problem and indeed they

186
00:06:46,290 --> 00:06:47,460
have and they came up with something

187
00:06:47,460 --> 00:06:48,960
called async Jess

188
00:06:48,960 --> 00:06:52,080
whoo so aging jess is a nice library for

189
00:06:52,080 --> 00:06:54,180
note all the concepts in it could easily

190
00:06:54,180 --> 00:06:56,100
be applied to any kind of cool back

191
00:06:56,100 --> 00:06:57,990
scheme so when I say note i mean the

192
00:06:57,990 --> 00:07:00,840
node callback scheme in that you have an

193
00:07:00,840 --> 00:07:03,300
error parameter and then result

194
00:07:03,300 --> 00:07:05,370
parameter in your callbacks you could

195
00:07:05,370 --> 00:07:06,780
change it for other ones and basically

196
00:07:06,780 --> 00:07:08,280
it's all the code yet otherwise have to

197
00:07:08,280 --> 00:07:10,830
write if you wanted to solve these kind

198
00:07:10,830 --> 00:07:12,509
of problems so it replaces your ad hoc

199
00:07:12,509 --> 00:07:14,310
code it's a library of code doesn't do

200
00:07:14,310 --> 00:07:15,569
anything special doesn't require any

201
00:07:15,569 --> 00:07:18,599
crazy language extensions and it handles

202
00:07:18,599 --> 00:07:20,130
all the kind of passenger you might see

203
00:07:20,130 --> 00:07:22,229
so a chain of processes where each

204
00:07:22,229 --> 00:07:24,300
functions output goes into the next one

205
00:07:24,300 --> 00:07:26,280
exactly the same as composed with

206
00:07:26,280 --> 00:07:28,949
synchronous code it has a kind of a duel

207
00:07:28,949 --> 00:07:31,560
in asynchronous code so we're water

208
00:07:31,560 --> 00:07:35,039
falling down the coat or we might be

209
00:07:35,039 --> 00:07:37,199
talking about parallel as I saying so

210
00:07:37,199 --> 00:07:38,880
when all of these callbacks are fired

211
00:07:38,880 --> 00:07:40,770
give me this callback and have all the

212
00:07:40,770 --> 00:07:42,570
results in it we might be talking about

213
00:07:42,570 --> 00:07:45,690
enumerations so mapping over file is all

214
00:07:45,690 --> 00:07:49,800
that kind of stuff as I said it relies

215
00:07:49,800 --> 00:07:51,690
on this interface this error result

216
00:07:51,690 --> 00:07:53,729
interface it could rely on another one

217
00:07:53,729 --> 00:07:55,860
if you wanted to rewrite it the kind of

218
00:07:55,860 --> 00:07:57,840
concept is going on is that we can

219
00:07:57,840 --> 00:08:01,590
replace the manual ad hoc code by using

220
00:08:01,590 --> 00:08:02,970
an interface and just running a whole

221
00:08:02,970 --> 00:08:04,560
library around it so it's not going to

222
00:08:04,560 --> 00:08:05,820
do any good for you for like browser

223
00:08:05,820 --> 00:08:07,740
stuff unless you do some adapting work

224
00:08:07,740 --> 00:08:10,440
now the problem for me with async Jas is

225
00:08:10,440 --> 00:08:13,380
it is still an ad hoc solution it's just

226
00:08:13,380 --> 00:08:14,909
someone else has written a bunch of code

227
00:08:14,909 --> 00:08:16,349
using the ad hoc solution it's still a

228
00:08:16,349 --> 00:08:18,719
leaky abstraction what do I mean by that

229
00:08:18,719 --> 00:08:20,729
is if it hasn't had it doesn't have a

230
00:08:20,729 --> 00:08:23,669
helper for your precise situation you're

231
00:08:23,669 --> 00:08:25,050
still going to have to write the ad hoc

232
00:08:25,050 --> 00:08:27,740
code so in that simple example we had a

233
00:08:27,740 --> 00:08:30,930
fetcher user fetch that users profile

234
00:08:30,930 --> 00:08:32,669
and then using both for those bits of

235
00:08:32,669 --> 00:08:35,579
information do something else so the

236
00:08:35,579 --> 00:08:37,050
fetch the user and then fetch that guy's

237
00:08:37,050 --> 00:08:39,719
profile is a is a waterfall it's a chain

238
00:08:39,719 --> 00:08:41,820
but then taking both those bits of

239
00:08:41,820 --> 00:08:43,979
information is a parallel thing we need

240
00:08:43,979 --> 00:08:47,790
both those and if you look at the the

241
00:08:47,790 --> 00:08:49,110
signatures for those functions

242
00:08:49,110 --> 00:08:50,550
unfortunately can't do them both at once

243
00:08:50,550 --> 00:08:52,589
there's no helper that does both at once

244
00:08:52,589 --> 00:08:54,240
in a sink so we're gonna have to go back

245
00:08:54,240 --> 00:08:56,370
to some kind of you know ad hoc co to

246
00:08:56,370 --> 00:08:59,190
solve that problem out and this is to me

247
00:08:59,190 --> 00:09:01,079
this is a classic example of a leaking

248
00:09:01,079 --> 00:09:02,940
abstraction we still haven't solved the

249
00:09:02,940 --> 00:09:04,710
it's root we're still having to write

250
00:09:04,710 --> 00:09:05,850
more and more and more and more and more

251
00:09:05,850 --> 00:09:08,400
code and a sings quite a big library is

252
00:09:08,400 --> 00:09:09,900
not just one simple concept it's

253
00:09:09,900 --> 00:09:12,420
basically a bunch of hairy code covering

254
00:09:12,420 --> 00:09:15,510
all the different edge cases what is the

255
00:09:15,510 --> 00:09:16,830
root problem i'm talking about what what

256
00:09:16,830 --> 00:09:19,200
is causing all this hairy code well i

257
00:09:19,200 --> 00:09:21,390
think it's the fact we don't have values

258
00:09:21,390 --> 00:09:24,540
when we use callbacks so when you call a

259
00:09:24,540 --> 00:09:25,740
normal synchronous function you get

260
00:09:25,740 --> 00:09:27,360
something back night regardless how long

261
00:09:27,360 --> 00:09:29,310
it takes could take 10 minutes it could

262
00:09:29,310 --> 00:09:30,510
be blocking for 10 minutes but you still

263
00:09:30,510 --> 00:09:32,160
get something back before the next line

264
00:09:32,160 --> 00:09:34,470
of code executes and that means we can

265
00:09:34,470 --> 00:09:36,390
do things with that value we can you

266
00:09:36,390 --> 00:09:38,250
know use if statements we can follow

267
00:09:38,250 --> 00:09:40,230
pover it all that kind of stuff but we

268
00:09:40,230 --> 00:09:42,480
can't do anything in our programs with a

269
00:09:42,480 --> 00:09:44,220
value that doesn't exist yet and that's

270
00:09:44,220 --> 00:09:45,720
a problem with callbacks it replaces

271
00:09:45,720 --> 00:09:48,420
values with flow control as in we jump

272
00:09:48,420 --> 00:09:50,790
around the program we don't have a value

273
00:09:50,790 --> 00:09:53,130
that we can kind of use in our programs

274
00:09:53,130 --> 00:09:55,860
it just doesn't exist yet everything's

275
00:09:55,860 --> 00:09:57,210
kind of easier value so this is a

276
00:09:57,210 --> 00:09:59,160
synchronous version of our process you

277
00:09:59,160 --> 00:10:00,840
can see it's just kind of you know

278
00:10:00,840 --> 00:10:03,030
programming 101 stuff it's really really

279
00:10:03,030 --> 00:10:05,010
really simple and that is our process

280
00:10:05,010 --> 00:10:07,560
like the asynchronous honest of it is

281
00:10:07,560 --> 00:10:09,900
not inherent if you say I mean it's just

282
00:10:09,900 --> 00:10:11,790
an implementation detail it could be

283
00:10:11,790 --> 00:10:13,500
this simple if our language was good

284
00:10:13,500 --> 00:10:18,060
enough can we get values with async is

285
00:10:18,060 --> 00:10:22,140
that possible what is there's an

286
00:10:22,140 --> 00:10:25,640
abstraction called promises or futures

287
00:10:25,640 --> 00:10:28,440
which has been around for a while and

288
00:10:28,440 --> 00:10:30,450
the basic concept is rather than a

289
00:10:30,450 --> 00:10:32,130
callback that kind of flies over your

290
00:10:32,130 --> 00:10:33,240
head and you kind of don't know whether

291
00:10:33,240 --> 00:10:36,450
the value is it gives you an IOU and

292
00:10:36,450 --> 00:10:38,490
that's a value get back straight away so

293
00:10:38,490 --> 00:10:39,990
rather than as I say taking a call back

294
00:10:39,990 --> 00:10:41,550
in kind of jumping summer with the value

295
00:10:41,550 --> 00:10:43,230
in a future point it gives you an IE

296
00:10:43,230 --> 00:10:45,630
piece of paper saying I owe you one user

297
00:10:45,630 --> 00:10:47,870
and then you can do stuff on that value

298
00:10:47,870 --> 00:10:50,250
so just like normal normal code you get

299
00:10:50,250 --> 00:10:53,040
your value straight away and the basic

300
00:10:53,040 --> 00:10:56,580
API is it's later fulfilled as in the

301
00:10:56,580 --> 00:10:59,280
user has appeared or rejected as in I

302
00:10:59,280 --> 00:11:00,360
couldn't find the user or there was some

303
00:11:00,360 --> 00:11:03,810
error in the process exactly once and

304
00:11:03,810 --> 00:11:05,070
the other idea is it doesn't matter when

305
00:11:05,070 --> 00:11:07,140
that happens so if it happens

306
00:11:07,140 --> 00:11:11,850
immediately oh and you attach your your

307
00:11:11,850 --> 00:11:13,920
call back later or your call back your

308
00:11:13,920 --> 00:11:15,990
request for the value of the promise it

309
00:11:15,990 --> 00:11:16,390
doesn

310
00:11:16,390 --> 00:11:18,220
difference so it takes time out of the

311
00:11:18,220 --> 00:11:20,470
equation it's a lot more like linking up

312
00:11:20,470 --> 00:11:22,270
cells in a spreadsheet when you're using

313
00:11:22,270 --> 00:11:24,460
promises and then the second really

314
00:11:24,460 --> 00:11:27,130
important idea is that if you apply a

315
00:11:27,130 --> 00:11:30,820
function to a promise you get a new

316
00:11:30,820 --> 00:11:32,980
promise back which is a promise for the

317
00:11:32,980 --> 00:11:36,370
transformed value inside that promise so

318
00:11:36,370 --> 00:11:38,620
they chain so we have a look over here

319
00:11:38,620 --> 00:11:40,180
we've got a promise for a coming back

320
00:11:40,180 --> 00:11:42,760
from our get a function and then we use

321
00:11:42,760 --> 00:11:45,280
the promise for a and we say then some

322
00:11:45,280 --> 00:11:48,610
cool back and that will return a further

323
00:11:48,610 --> 00:11:50,350
promise for value for B and we can see

324
00:11:50,350 --> 00:11:53,530
the comparison with a standard callback

325
00:11:53,530 --> 00:11:57,460
interface below so this is the bit where

326
00:11:57,460 --> 00:11:58,990
it gets really useful so we got get a

327
00:11:58,990 --> 00:12:01,810
then and we've got a function over a and

328
00:12:01,810 --> 00:12:05,020
we're saying return get be so that whole

329
00:12:05,020 --> 00:12:07,360
chain this changed just like jQuery or

330
00:12:07,360 --> 00:12:09,340
lots of other libraries now returns a

331
00:12:09,340 --> 00:12:11,950
promise for B and we can use that in

332
00:12:11,950 --> 00:12:14,650
future bits and pieces the basic API is

333
00:12:14,650 --> 00:12:16,750
just this then so you can see the direct

334
00:12:16,750 --> 00:12:18,820
comparison we've got the promise for a

335
00:12:18,820 --> 00:12:21,370
then call back an arrow back versus the

336
00:12:21,370 --> 00:12:24,870
callback method where we have mm-hmm

337
00:12:24,870 --> 00:12:32,200
thanks useful cool yeah so we and then

338
00:12:32,200 --> 00:12:33,280
the call bad version we have the error

339
00:12:33,280 --> 00:12:35,140
and then the the value so there's a very

340
00:12:35,140 --> 00:12:37,750
kind of tight parallel between this two

341
00:12:37,750 --> 00:12:40,390
AP is so it changed as I say that

342
00:12:40,390 --> 00:12:42,160
promises the core idea one of the two

343
00:12:42,160 --> 00:12:43,630
core ideas I think of promises is that

344
00:12:43,630 --> 00:12:46,150
chains for reasons unknown Jay Curry's

345
00:12:46,150 --> 00:12:48,940
API implementation doesn't chain so it's

346
00:12:48,940 --> 00:12:50,530
not really a good implementation of

347
00:12:50,530 --> 00:12:51,700
promises so I would avoid that like the

348
00:12:51,700 --> 00:12:56,230
plague and yeah they just let make

349
00:12:56,230 --> 00:12:58,060
things really simple again so if we have

350
00:12:58,060 --> 00:12:59,590
a process here while we're trying to

351
00:12:59,590 --> 00:13:02,590
threading through so this is from a

352
00:13:02,590 --> 00:13:04,480
project I did called tweed are there was

353
00:13:04,480 --> 00:13:06,520
like a machine learning Twitter client

354
00:13:06,520 --> 00:13:09,190
and it needs to get a tweet and then it

355
00:13:09,190 --> 00:13:10,870
needs to format the tweet and then it

356
00:13:10,870 --> 00:13:12,310
needs to run a classifier on the tweak

357
00:13:12,310 --> 00:13:13,900
and you can see that process kind of

358
00:13:13,900 --> 00:13:15,640
gets flattened down we don't have any

359
00:13:15,640 --> 00:13:17,440
real complexity there and the whole

360
00:13:17,440 --> 00:13:19,780
process returns a promise for the final

361
00:13:19,780 --> 00:13:22,030
value you seem so we got the Twitter

362
00:13:22,030 --> 00:13:23,530
next week gives us promise for a tweet

363
00:13:23,530 --> 00:13:25,570
then when we get the tweet we put it

364
00:13:25,570 --> 00:13:27,280
through the formatter that's a promise

365
00:13:27,280 --> 00:13:29,110
for a formatted tweet and then we get a

366
00:13:29,110 --> 00:13:29,860
prom

367
00:13:29,860 --> 00:13:33,339
for a classified tweet at the end and

368
00:13:33,339 --> 00:13:34,660
because doesn't it there's no real

369
00:13:34,660 --> 00:13:36,250
reason we can't have multiple consumers

370
00:13:36,250 --> 00:13:37,959
for one promise it's easy to tag on

371
00:13:37,959 --> 00:13:40,149
operations like logging whatever else

372
00:13:40,149 --> 00:13:41,380
you need you can chuck it out and

373
00:13:41,380 --> 00:13:45,370
everyone can get it so if we have a look

374
00:13:45,370 --> 00:13:47,110
at the earlier thing where we're having

375
00:13:47,110 --> 00:13:51,220
multiple dependencies because we don't

376
00:13:51,220 --> 00:13:53,260
worry about time anymore we can just get

377
00:13:53,260 --> 00:13:55,450
the first thing we can before we even

378
00:13:55,450 --> 00:13:57,700
have it we can pass it into the process

379
00:13:57,700 --> 00:13:59,860
that takes the first thing and then we

380
00:13:59,860 --> 00:14:04,060
can use some method like all to pass

381
00:14:04,060 --> 00:14:05,620
both of them onto a third process

382
00:14:05,620 --> 00:14:07,390
without any nesting it's just super-easy

383
00:14:07,390 --> 00:14:10,360
it's completely uncoupled to time we can

384
00:14:10,360 --> 00:14:12,399
already start reasoning about stuff that

385
00:14:12,399 --> 00:14:13,600
hasn't come back yet whereas with

386
00:14:13,600 --> 00:14:14,800
callbacks would have to be doing all

387
00:14:14,800 --> 00:14:17,500
this thudding via flow control a lot

388
00:14:17,500 --> 00:14:21,070
more complicated and manual and

389
00:14:21,070 --> 00:14:23,380
interestingly it works with a lot less

390
00:14:23,380 --> 00:14:25,690
library code so if we just have promises

391
00:14:25,690 --> 00:14:27,370
we don't do any other code at all we

392
00:14:27,370 --> 00:14:29,980
just implement that to function API the

393
00:14:29,980 --> 00:14:32,410
then thing we can starting really

394
00:14:32,410 --> 00:14:35,199
interesting stuff because we can here we

395
00:14:35,199 --> 00:14:37,449
have a map over three files we return a

396
00:14:37,449 --> 00:14:39,310
promise for the contents of the file

397
00:14:39,310 --> 00:14:41,920
each one and we map over the promises so

398
00:14:41,920 --> 00:14:44,019
now have the final function here is a

399
00:14:44,019 --> 00:14:46,540
pretty we get a variable contents that

400
00:14:46,540 --> 00:14:48,160
contains a promise for the contents and

401
00:14:48,160 --> 00:14:50,769
we can return a new promise which is a

402
00:14:50,769 --> 00:14:52,269
promise for the transformation of that

403
00:14:52,269 --> 00:14:54,130
content without any additional library

404
00:14:54,130 --> 00:14:56,350
code because it's a value it works with

405
00:14:56,350 --> 00:14:58,209
stuff like maps it works with every

406
00:14:58,209 --> 00:14:59,740
other possible enumeration function you

407
00:14:59,740 --> 00:15:01,930
could think of it's already there to

408
00:15:01,930 --> 00:15:03,760
play with so we don't need to do

409
00:15:03,760 --> 00:15:05,980
anything in particular we can make it

410
00:15:05,980 --> 00:15:08,260
even better with with libraries but I

411
00:15:08,260 --> 00:15:10,180
think it's a much happier abstraction

412
00:15:10,180 --> 00:15:12,130
for that reason and you'll see

413
00:15:12,130 --> 00:15:13,300
throughout the talk from this point on i

414
00:15:13,300 --> 00:15:15,220
think promises solve that one problem

415
00:15:15,220 --> 00:15:16,959
that you can never get away with if you

416
00:15:16,959 --> 00:15:18,730
don't have a value which is you can't

417
00:15:18,730 --> 00:15:20,410
talk about stuff until it appears with

418
00:15:20,410 --> 00:15:22,829
callbacks where's your camera promises

419
00:15:22,829 --> 00:15:25,540
so who only yet well we seem to be doing

420
00:15:25,540 --> 00:15:27,880
pretty well but i'd say we still haven't

421
00:15:27,880 --> 00:15:29,709
one we saw one core problem with

422
00:15:29,709 --> 00:15:31,360
callbacks but i reckon there's another

423
00:15:31,360 --> 00:15:34,930
one also to kind of pointers with

424
00:15:34,930 --> 00:15:37,540
promises you need to ensure you catch

425
00:15:37,540 --> 00:15:39,970
all the errors so when you do the then

426
00:15:39,970 --> 00:15:41,829
promise doesn't have any idea of if

427
00:15:41,829 --> 00:15:43,240
you're finished yet

428
00:15:43,240 --> 00:15:44,649
and so we'll just soak up all the errors

429
00:15:44,649 --> 00:15:46,540
in the rejection handler unless you say

430
00:15:46,540 --> 00:15:49,750
done in most libraries to say like from

431
00:15:49,750 --> 00:15:51,790
this point on just throw the error if if

432
00:15:51,790 --> 00:15:53,830
it's if it's there and it's not being

433
00:15:53,830 --> 00:15:56,800
handled so do you make sure you do that

434
00:15:56,800 --> 00:16:00,910
and you still have to unwrap them so

435
00:16:00,910 --> 00:16:02,740
JavaScript has all this great stuff like

436
00:16:02,740 --> 00:16:04,990
tries and catches and for loops and

437
00:16:04,990 --> 00:16:06,250
things that we just can't use with

438
00:16:06,250 --> 00:16:07,600
asynchronous values whether their

439
00:16:07,600 --> 00:16:10,630
promises or if their callbacks we can't

440
00:16:10,630 --> 00:16:12,850
use them generically we have to unwrap

441
00:16:12,850 --> 00:16:14,230
them from their process so they either

442
00:16:14,230 --> 00:16:15,850
have to come into the callback and we

443
00:16:15,850 --> 00:16:17,020
get them out of the callback but we have

444
00:16:17,020 --> 00:16:19,060
to unwrap them from the promise and then

445
00:16:19,060 --> 00:16:21,190
use them so we write a lot of additional

446
00:16:21,190 --> 00:16:22,690
croft where are we effectively

447
00:16:22,690 --> 00:16:25,029
unwrapping the async value from the

448
00:16:25,029 --> 00:16:26,890
asynchronous process and then putting it

449
00:16:26,890 --> 00:16:29,620
into our ifs or our fours or whatever if

450
00:16:29,620 --> 00:16:30,850
you're really nice to be able to use

451
00:16:30,850 --> 00:16:32,230
things like tries and catches and if

452
00:16:32,230 --> 00:16:34,029
some else just straight on the results

453
00:16:34,029 --> 00:16:35,740
of asynchronous values as if they were

454
00:16:35,740 --> 00:16:37,630
synchronous that was what a library

455
00:16:37,630 --> 00:16:39,640
asari a language that was designed for

456
00:16:39,640 --> 00:16:41,529
async would look like like why make it

457
00:16:41,529 --> 00:16:44,070
more complicated than it already is and

458
00:16:44,070 --> 00:16:46,420
I think this is the kind of irreducible

459
00:16:46,420 --> 00:16:49,270
hell of callbacks is that we kind of

460
00:16:49,270 --> 00:16:51,940
break JavaScript all the JavaScript we

461
00:16:51,940 --> 00:16:53,500
know and love we can't use with this

462
00:16:53,500 --> 00:16:55,720
stuff we have to unwrap and then we can

463
00:16:55,720 --> 00:16:57,310
finally get to it we can't just use it

464
00:16:57,310 --> 00:17:02,709
natively but but there's a pretty cool

465
00:17:02,709 --> 00:17:06,970
concept called a wait this is some kind

466
00:17:06,970 --> 00:17:09,189
of pseudocode imagine a language it

467
00:17:09,189 --> 00:17:11,140
supports away languages that do support

468
00:17:11,140 --> 00:17:13,329
away at things like C sharp so we have a

469
00:17:13,329 --> 00:17:15,520
trying to catch and we we await the

470
00:17:15,520 --> 00:17:16,959
result of an asynchronous callback a

471
00:17:16,959 --> 00:17:18,819
couple of times here so we can say okay

472
00:17:18,819 --> 00:17:22,510
if a equals await the capital a so we've

473
00:17:22,510 --> 00:17:23,920
got some asynchronous stuff going on and

474
00:17:23,920 --> 00:17:25,030
it's just going to stop at that point

475
00:17:25,030 --> 00:17:26,800
nothing's going to happen and then it'll

476
00:17:26,800 --> 00:17:28,449
come back so we're using asynchronous

477
00:17:28,449 --> 00:17:29,950
code you know it's asynchronous

478
00:17:29,950 --> 00:17:31,750
implementation we can run loads of a

479
00:17:31,750 --> 00:17:33,580
sinker once we still have the the

480
00:17:33,580 --> 00:17:35,500
performance of a sink but we get back a

481
00:17:35,500 --> 00:17:37,540
synchronous looking code which is great

482
00:17:37,540 --> 00:17:39,309
because a language is not as

483
00:17:39,309 --> 00:17:41,500
implementation it doesn't matter if the

484
00:17:41,500 --> 00:17:42,970
language look synchronous as long as the

485
00:17:42,970 --> 00:17:44,590
async IO is still going on the

486
00:17:44,590 --> 00:17:45,910
background so we can support lots and

487
00:17:45,910 --> 00:17:47,350
lots of users and all that kind of good

488
00:17:47,350 --> 00:17:50,710
stuff so could we possibly do this I

489
00:17:50,710 --> 00:17:52,320
mean we can't really do it in in

490
00:17:52,320 --> 00:17:55,090
JavaScript surely surely this is the end

491
00:17:55,090 --> 00:17:56,650
of JavaScript do we have to you

492
00:17:56,650 --> 00:17:58,030
some kind of new crazy language that

493
00:17:58,030 --> 00:18:00,570
compiles to JavaScript or just give up

494
00:18:00,570 --> 00:18:03,910
no javascript has a new trick up our

495
00:18:03,910 --> 00:18:06,040
sleeve coming very soon we had a talk

496
00:18:06,040 --> 00:18:09,970
about es5 today but now we have es6 we

497
00:18:09,970 --> 00:18:13,330
will have seen hopefully so there's a

498
00:18:13,330 --> 00:18:15,340
concept in es6 called generators and

499
00:18:15,340 --> 00:18:17,800
this will let you do i'm sure a load of

500
00:18:17,800 --> 00:18:18,940
really cool stuff that no one even

501
00:18:18,940 --> 00:18:20,410
thought of yet but what are the really

502
00:18:20,410 --> 00:18:22,660
exciting stuff it does is allows you to

503
00:18:22,660 --> 00:18:25,030
write code that looks like synchronous

504
00:18:25,030 --> 00:18:27,910
code so before we go any further I just

505
00:18:27,910 --> 00:18:28,660
going to talk a little bit our

506
00:18:28,660 --> 00:18:31,620
generators they're in the draft es6 back

507
00:18:31,620 --> 00:18:33,880
that's supposedly going to be finalized

508
00:18:33,880 --> 00:18:36,340
december this year the lesson was heard

509
00:18:36,340 --> 00:18:39,880
an update from that it's in the draft so

510
00:18:39,880 --> 00:18:42,550
it's kind of if the spec gets approved

511
00:18:42,550 --> 00:18:44,920
it will be in there and it looks like

512
00:18:44,920 --> 00:18:46,480
this so it has a little star operator

513
00:18:46,480 --> 00:18:47,860
next to the function to say i'm a

514
00:18:47,860 --> 00:18:49,990
generator function or a generator kind

515
00:18:49,990 --> 00:18:52,480
of constructor and it has the yield

516
00:18:52,480 --> 00:18:55,570
keyword now what yield does is at that

517
00:18:55,570 --> 00:18:57,580
point it returns control back to the

518
00:18:57,580 --> 00:18:59,890
calling whatever's calling the generator

519
00:18:59,890 --> 00:19:01,810
so you can kind of think of its kind of

520
00:19:01,810 --> 00:19:03,880
intermediate return and it pauses

521
00:19:03,880 --> 00:19:06,310
execution inside that generator so we

522
00:19:06,310 --> 00:19:07,960
won't go on to the next line of code

523
00:19:07,960 --> 00:19:10,690
until the generator is resumed so we

524
00:19:10,690 --> 00:19:12,790
literally pause at that point so if you

525
00:19:12,790 --> 00:19:14,260
go have a look at this code here we have

526
00:19:14,260 --> 00:19:16,150
a wild tree loop which is never a good

527
00:19:16,150 --> 00:19:18,160
signing code you see a wild tree loop in

528
00:19:18,160 --> 00:19:19,120
your code you're thinking are there's

529
00:19:19,120 --> 00:19:20,980
this a bit of a nightmare but it works

530
00:19:20,980 --> 00:19:22,840
fine with generators because we control

531
00:19:22,840 --> 00:19:24,310
when it's resumed every time it hits

532
00:19:24,310 --> 00:19:26,440
that yield inside the while loop it's

533
00:19:26,440 --> 00:19:29,170
going to return control to the cooling

534
00:19:29,170 --> 00:19:31,030
environment and it's not going to go

535
00:19:31,030 --> 00:19:33,340
around the loop again until we hit next

536
00:19:33,340 --> 00:19:35,230
so it's kind of like we can pause them

537
00:19:35,230 --> 00:19:36,970
and play it again so lets you write

538
00:19:36,970 --> 00:19:38,620
things like I don't know things that

539
00:19:38,620 --> 00:19:40,000
generate long sequences of code

540
00:19:40,000 --> 00:19:41,650
extremely of numbers or something

541
00:19:41,650 --> 00:19:44,740
extremely nice and concisely and you can

542
00:19:44,740 --> 00:19:47,740
see the API here we cool we as I said

543
00:19:47,740 --> 00:19:48,790
it's a it's a kind of generator

544
00:19:48,790 --> 00:19:50,800
constructor when we call it we get back

545
00:19:50,800 --> 00:19:52,480
a generator we get an instance of the

546
00:19:52,480 --> 00:19:54,820
generator so we call it first count now

547
00:19:54,820 --> 00:19:56,650
we have our counter it's the generator

548
00:19:56,650 --> 00:19:58,540
itself and then we call dot next on it

549
00:19:58,540 --> 00:20:00,640
and then we get back a kind of to Polly

550
00:20:00,640 --> 00:20:02,290
thing it so it's an object with two keys

551
00:20:02,290 --> 00:20:04,510
value and result and then we can have a

552
00:20:04,510 --> 00:20:07,750
look at the sorry value and done and we

553
00:20:07,750 --> 00:20:09,220
gonna have a look at the valley see what

554
00:20:09,220 --> 00:20:10,270
we got out and that will be the thing

555
00:20:10,270 --> 00:20:10,659
that's been

556
00:20:10,659 --> 00:20:13,090
yielded so it's kind of like the return

557
00:20:13,090 --> 00:20:14,889
key word in that respect and we also

558
00:20:14,889 --> 00:20:17,169
have a done and we can check if it's

559
00:20:17,169 --> 00:20:18,399
done and basically if it's done it's

560
00:20:18,399 --> 00:20:19,539
fallen off the bottom of the generator

561
00:20:19,539 --> 00:20:22,479
just like normal cool so what does it

562
00:20:22,479 --> 00:20:25,899
look like let's look so here is a thing

563
00:20:25,899 --> 00:20:29,499
called three queries you can see it's

564
00:20:29,499 --> 00:20:30,789
relying on some glue code that we're

565
00:20:30,789 --> 00:20:32,200
going to have a look at in a bit called

566
00:20:32,200 --> 00:20:34,720
away table and we've set up three

567
00:20:34,720 --> 00:20:37,359
queries a B and C we set ourselves a

568
00:20:37,359 --> 00:20:38,889
result array and then we're just using

569
00:20:38,889 --> 00:20:41,619
the standard JavaScript I know not quite

570
00:20:41,619 --> 00:20:43,149
the standard with this is just a

571
00:20:43,149 --> 00:20:45,309
gratuitous es6 demonstration it's using

572
00:20:45,309 --> 00:20:48,389
the four of not fought in so we can just

573
00:20:48,389 --> 00:20:50,679
just go straight over an array without

574
00:20:50,679 --> 00:20:52,599
any indices or anything very cool

575
00:20:52,599 --> 00:20:54,519
feature of es6 so we're going over the

576
00:20:54,519 --> 00:20:57,039
whole array of our promises and we're

577
00:20:57,039 --> 00:20:58,809
just hitting yield and that's going to

578
00:20:58,809 --> 00:21:00,369
block at that point we get out the

579
00:21:00,369 --> 00:21:02,259
generator and then we'll come back when

580
00:21:02,259 --> 00:21:04,570
the promises has been fulfilled so you

581
00:21:04,570 --> 00:21:06,909
can see that this is parallel we've done

582
00:21:06,909 --> 00:21:08,379
all the queries we started off all the

583
00:21:08,379 --> 00:21:10,179
queries on the first three lines so

584
00:21:10,179 --> 00:21:12,460
they're all going in parallel and then

585
00:21:12,460 --> 00:21:13,679
we're going to block on them all until

586
00:21:13,679 --> 00:21:15,999
they're all done and then we're gonna

587
00:21:15,999 --> 00:21:17,950
return the rizal a array so it's very

588
00:21:17,950 --> 00:21:20,139
concise and clear but it's also very

589
00:21:20,139 --> 00:21:22,720
fast because it's parallel async good

590
00:21:22,720 --> 00:21:26,049
combination cool now this is this is the

591
00:21:26,049 --> 00:21:27,549
point I how to like oh can I actually

592
00:21:27,549 --> 00:21:29,169
explain this how does this actually work

593
00:21:29,169 --> 00:21:32,200
well I'm gonna proviso this is a black

594
00:21:32,200 --> 00:21:34,479
box the way you do the the generator

595
00:21:34,479 --> 00:21:37,200
implementation you can kind of ignore it

596
00:21:37,200 --> 00:21:39,070
we can understand it it's not very

597
00:21:39,070 --> 00:21:41,349
difficult you can you can either do this

598
00:21:41,349 --> 00:21:44,229
with promises or with callbacks in the

599
00:21:44,229 --> 00:21:45,519
same way if you have an interface for

600
00:21:45,519 --> 00:21:46,989
your call backs you can do this with

601
00:21:46,989 --> 00:21:49,509
callbacks to I think generators with

602
00:21:49,509 --> 00:21:51,039
promises are a little bit more powerful

603
00:21:51,039 --> 00:21:53,049
for reasons I'll explain in a second but

604
00:21:53,049 --> 00:21:55,450
let's have a look at how this works okay

605
00:21:55,450 --> 00:21:58,059
so we this is the queue door a sinc

606
00:21:58,059 --> 00:22:00,909
function so this is the thing that given

607
00:22:00,909 --> 00:22:03,609
a generator returns a kind of away table

608
00:22:03,609 --> 00:22:05,529
1 so generators as they could be used

609
00:22:05,529 --> 00:22:07,210
for loads of different things not just

610
00:22:07,210 --> 00:22:09,009
this but we're going to use a generator

611
00:22:09,009 --> 00:22:12,399
for this await style keyword so we get

612
00:22:12,399 --> 00:22:13,869
our make generator function and we

613
00:22:13,869 --> 00:22:15,599
return a new function that's the kind of

614
00:22:15,599 --> 00:22:20,289
decorated one now we set up a continuous

615
00:22:20,289 --> 00:22:22,179
function that takes a verb and we're

616
00:22:22,179 --> 00:22:23,499
using bind against its lucky I talks

617
00:22:23,499 --> 00:22:24,370
about that

618
00:22:24,370 --> 00:22:26,110
we make two versions of the continuous

619
00:22:26,110 --> 00:22:28,090
function one that's going to go next on

620
00:22:28,090 --> 00:22:30,640
the generator and one that's going to go

621
00:22:30,640 --> 00:22:32,740
throw on the generator and the next one

622
00:22:32,740 --> 00:22:34,650
just regimes it as we've seen before

623
00:22:34,650 --> 00:22:37,570
okay so we start off just by calling the

624
00:22:37,570 --> 00:22:39,520
callback which is going to go into

625
00:22:39,520 --> 00:22:42,130
continuer the verbs going to be next

626
00:22:42,130 --> 00:22:44,800
it's going to ask for the next result of

627
00:22:44,800 --> 00:22:46,120
the generator so it's going to run until

628
00:22:46,120 --> 00:22:48,010
it hits the first yield and then give us

629
00:22:48,010 --> 00:22:51,670
back the promise if we throw an error at

630
00:22:51,670 --> 00:22:52,840
this point then it's going to return a

631
00:22:52,840 --> 00:22:55,630
rejecter promise it's fine if the

632
00:22:55,630 --> 00:22:57,190
results done we're going to return the

633
00:22:57,190 --> 00:23:00,190
value of that entire process but the

634
00:23:00,190 --> 00:23:01,960
important bit really is if it's not done

635
00:23:01,960 --> 00:23:04,600
we're going to say cue up that promise

636
00:23:04,600 --> 00:23:06,400
because it's yielding promises every

637
00:23:06,400 --> 00:23:08,260
time that's the whole idea cue up that

638
00:23:08,260 --> 00:23:10,780
promise and when it's done if it

639
00:23:10,780 --> 00:23:13,210
succeeds we hit cool back so we loop and

640
00:23:13,210 --> 00:23:15,790
if it fails we hit arrow back so we

641
00:23:15,790 --> 00:23:19,950
throw now throw is really super because

642
00:23:19,950 --> 00:23:22,809
throw I hope have a try-catch example in

643
00:23:22,809 --> 00:23:33,700
here mmm yeah okay not even javascript

644
00:23:33,700 --> 00:23:36,610
is a bit unfortunate but throw will

645
00:23:36,610 --> 00:23:38,679
literally throw an error from that point

646
00:23:38,679 --> 00:23:40,240
inside your generator so suddenly you're

647
00:23:40,240 --> 00:23:42,490
a synchronous processes work with try

648
00:23:42,490 --> 00:23:44,110
and catch which is completely amazing

649
00:23:44,110 --> 00:23:46,690
you can suddenly granularly put a try

650
00:23:46,690 --> 00:23:48,250
and catch around each one of your async

651
00:23:48,250 --> 00:23:50,980
processes that might fail again you can

652
00:23:50,980 --> 00:23:56,620
use try catch is pretty amazing cool and

653
00:23:56,620 --> 00:23:58,210
that's it that's all you need and

654
00:23:58,210 --> 00:24:00,070
there's similar the glue code for using

655
00:24:00,070 --> 00:24:02,290
it with callbacks is even shorter it's

656
00:24:02,290 --> 00:24:03,910
amazing now like I say I mean this is

657
00:24:03,910 --> 00:24:05,710
just one use of generators they're going

658
00:24:05,710 --> 00:24:09,130
to be pretty amazing so having a look at

659
00:24:09,130 --> 00:24:12,570
a dependent process we can just yield a

660
00:24:12,570 --> 00:24:15,640
wait for it to come back and then put

661
00:24:15,640 --> 00:24:17,380
into be it's just like synchronous code

662
00:24:17,380 --> 00:24:21,100
we get the value back parallel processes

663
00:24:21,100 --> 00:24:22,390
as I said a pretty easy we just kick

664
00:24:22,390 --> 00:24:23,740
them off we get the promises from both

665
00:24:23,740 --> 00:24:25,480
and then we can just loop over and block

666
00:24:25,480 --> 00:24:27,340
now the point I was making about cool

667
00:24:27,340 --> 00:24:30,130
boxes you still can't do it like this

668
00:24:30,130 --> 00:24:31,870
with callbacks because we're still going

669
00:24:31,870 --> 00:24:33,429
to have the same problem where we don't

670
00:24:33,429 --> 00:24:35,399
have the value yet to reason about

671
00:24:35,399 --> 00:24:36,960
there's nothing in the machinery that's

672
00:24:36,960 --> 00:24:39,869
going to let us give back something so

673
00:24:39,869 --> 00:24:41,219
we can have to block on the call back

674
00:24:41,219 --> 00:24:42,779
straightaway just one at a time so you

675
00:24:42,779 --> 00:24:46,109
can't do parallel processes with with

676
00:24:46,109 --> 00:24:47,429
just call backs if you can with promises

677
00:24:47,429 --> 00:24:51,269
a new rule is pretty easy just leaping

678
00:24:51,269 --> 00:24:54,149
over arrays and obviously this will

679
00:24:54,149 --> 00:24:56,159
works with async as well if you using

680
00:24:56,159 --> 00:25:01,109
the callback style sweet so seems like

681
00:25:01,109 --> 00:25:03,269
kind of a synchronous code is a solved

682
00:25:03,269 --> 00:25:05,460
problem well the last thing that we

683
00:25:05,460 --> 00:25:06,960
can't do with a sink and I think we're

684
00:25:06,960 --> 00:25:10,889
ever gonna be able to do is to wrap the

685
00:25:10,889 --> 00:25:13,889
async bit of our code and ignore it from

686
00:25:13,889 --> 00:25:14,849
the rest of our code so we have a

687
00:25:14,849 --> 00:25:16,320
synchronous bit of our code and an async

688
00:25:16,320 --> 00:25:18,869
because we can never stop the

689
00:25:18,869 --> 00:25:20,219
asynchronous code kind of leaking out

690
00:25:20,219 --> 00:25:21,450
we're always going to have to deal with

691
00:25:21,450 --> 00:25:22,940
async code everywhere in our code base

692
00:25:22,940 --> 00:25:25,710
and that's simply because jay s is

693
00:25:25,710 --> 00:25:27,419
always going to be single threaded and

694
00:25:27,419 --> 00:25:29,489
there's no way of having what i call a

695
00:25:29,489 --> 00:25:31,080
deep co routine where we block the whole

696
00:25:31,080 --> 00:25:34,109
thread all the generator does is go back

697
00:25:34,109 --> 00:25:35,519
to the calling environment it doesn't

698
00:25:35,519 --> 00:25:37,259
block the entire interpreter and this is

699
00:25:37,259 --> 00:25:39,029
a good thing if we have threads we'd

700
00:25:39,029 --> 00:25:40,109
have all the kind of problems with

701
00:25:40,109 --> 00:25:41,129
reading that we don't have with

702
00:25:41,129 --> 00:25:43,559
JavaScript so it's actually good this is

703
00:25:43,559 --> 00:25:44,609
the kind of level of pain we should

704
00:25:44,609 --> 00:25:47,639
accept in JavaScript we have synchronous

705
00:25:47,639 --> 00:25:50,489
looking code it's pretty easy to reason

706
00:25:50,489 --> 00:25:54,379
about I think we won I think we've won

707
00:25:54,379 --> 00:25:56,929
asynchronous code is kind of easy again

708
00:25:56,929 --> 00:25:59,399
it's pretty exciting so we got

709
00:25:59,399 --> 00:26:01,049
JavaScript back we can use ifs we can

710
00:26:01,049 --> 00:26:02,580
use else's we can use falls and tries

711
00:26:02,580 --> 00:26:05,580
and catches it's all pretty easy we need

712
00:26:05,580 --> 00:26:07,710
to wrap our code with these kind of glue

713
00:26:07,710 --> 00:26:10,080
code things and use generators it still

714
00:26:10,080 --> 00:26:11,639
leaks the async ever in our code but

715
00:26:11,639 --> 00:26:13,259
we're happy with that we avoid threading

716
00:26:13,259 --> 00:26:15,179
hell which I think of on balance is far

717
00:26:15,179 --> 00:26:22,679
worse than callback hell cool so to sum

718
00:26:22,679 --> 00:26:24,419
up don't in line everything it's

719
00:26:24,419 --> 00:26:25,789
terrible you need to write tests

720
00:26:25,789 --> 00:26:27,960
javascript has the tools to solve the

721
00:26:27,960 --> 00:26:30,059
simple cases and when they fall down we

722
00:26:30,059 --> 00:26:31,710
have our kind of trio of tools we can

723
00:26:31,710 --> 00:26:34,320
use async it's pretty good it's not a

724
00:26:34,320 --> 00:26:36,419
great abstraction kind of leaks and when

725
00:26:36,419 --> 00:26:38,929
it leaks we can use promises promises

726
00:26:38,929 --> 00:26:41,460
also solve the whole time issue we

727
00:26:41,460 --> 00:26:42,899
finally have a value of game we can

728
00:26:42,899 --> 00:26:45,059
write code straight away we can kind of

729
00:26:45,059 --> 00:26:47,519
link it all up like a spreadsheet and

730
00:26:47,519 --> 00:26:49,240
then finally if we want

731
00:26:49,240 --> 00:26:51,520
right some really nice-looking code we

732
00:26:51,520 --> 00:26:53,440
can use generators you can generate us

733
00:26:53,440 --> 00:26:54,640
right now by the way in Chrome Canary

734
00:26:54,640 --> 00:26:58,770
and node 0 point 11 with a harmony flag

735
00:26:58,770 --> 00:27:00,970
and they're coming pretty soon there's

736
00:27:00,970 --> 00:27:03,220
also a tracer compiler that compiles

737
00:27:03,220 --> 00:27:05,620
from es5 to es6 includes generators by

738
00:27:05,620 --> 00:27:08,560
some crazy voodoo so you can use it

739
00:27:08,560 --> 00:27:10,780
today and and firefox but is it still

740
00:27:10,780 --> 00:27:13,870
the python generators or yeah i thought

741
00:27:13,870 --> 00:27:18,130
it was sweet okay so firefox soon

742
00:27:18,130 --> 00:27:20,080
firefox currently has an old version

743
00:27:20,080 --> 00:27:21,520
generators but it was seen how the best

744
00:27:21,520 --> 00:27:24,900
version generators thanks a lot cool

745
00:27:24,900 --> 00:27:33,779
that's me come

