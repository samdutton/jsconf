1
00:00:00,320 --> 00:00:02,070

[Music]

2
00:00:02,070 --> 00:00:03,840
[Applause]

3
00:00:03,840 --> 00:00:05,660
[Music]

4
00:00:05,660 --> 00:00:07,410
[Applause]

5
00:00:07,410 --> 00:00:09,280
[Music]

6
00:00:09,280 --> 00:00:11,020
[Applause]

7
00:00:11,020 --> 00:00:12,780
[Music]

8
00:00:12,780 --> 00:00:16,860
[Applause]

9
00:00:16,870 --> 00:00:25,100
[Music]

10
00:00:25,110 --> 00:00:33,190
hi guys all right I'm gonna take a cue

11
00:00:33,190 --> 00:00:36,010
from from Laurie stalk and get a selfie

12
00:00:36,010 --> 00:00:39,149
because pics if it didn't happen

13
00:00:39,149 --> 00:00:41,890
cool all right so let's talk to you a

14
00:00:41,890 --> 00:00:47,440
little bit about es6 in practice but

15
00:00:47,440 --> 00:00:48,930
first a little bit about me

16
00:00:48,930 --> 00:00:51,850
so I am first and foremost a father a

17
00:00:51,850 --> 00:00:53,560
stepfather and a husband

18
00:00:53,560 --> 00:00:56,560
I run Santa Barbara JavaScript which is

19
00:00:56,560 --> 00:00:59,860
our local meetup up in Santa Barbara as

20
00:00:59,860 --> 00:01:01,930
Sonia mentioned I'm an avid scuba diver

21
00:01:01,930 --> 00:01:04,689
and underwater photographer and I'm

22
00:01:04,689 --> 00:01:07,750
president of paradise dive Club I've

23
00:01:07,750 --> 00:01:09,070
been building and shipping software

24
00:01:09,070 --> 00:01:11,229
professionally for a little over two

25
00:01:11,229 --> 00:01:13,180
decades now and I'm currently staff

26
00:01:13,180 --> 00:01:15,040
engineer at pro core technologies

27
00:01:15,040 --> 00:01:16,810
building a software that builds the

28
00:01:16,810 --> 00:01:19,299
world it is I can say hands-down the

29
00:01:19,299 --> 00:01:20,890
best job I've ever had we're always

30
00:01:20,890 --> 00:01:22,479
looking for good people so see me in the

31
00:01:22,479 --> 00:01:23,920
hallway if you're interested we'll talk

32
00:01:23,920 --> 00:01:26,680
more all right so enough about me before

33
00:01:26,680 --> 00:01:28,060
we dig into es6

34
00:01:28,060 --> 00:01:29,409
before we find out what this is all

35
00:01:29,409 --> 00:01:31,390
about let's take a moment for a brief

36
00:01:31,390 --> 00:01:33,640
history of the language so in the

37
00:01:33,640 --> 00:01:37,330
beginning there was mocha and it was

38
00:01:37,330 --> 00:01:39,930
released and they called it live script

39
00:01:39,930 --> 00:01:42,100
but the marketing gods had to be

40
00:01:42,100 --> 00:01:45,400
appeased and recruiters weren't confused

41
00:01:45,400 --> 00:01:46,150
enough already

42
00:01:46,150 --> 00:01:50,290
so they renamed it javascript and they

43
00:01:50,290 --> 00:01:51,869
saw that it was good

44
00:01:51,869 --> 00:01:55,450
so they standardized it but javascript

45
00:01:55,450 --> 00:01:57,759
was a registered trademark of netscape

46
00:01:57,759 --> 00:02:00,900
corporation so how about web script or

47
00:02:00,900 --> 00:02:03,790
maybe browser script or Brendan Eich

48
00:02:03,790 --> 00:02:05,259
site scheme as one of the major

49
00:02:05,259 --> 00:02:07,810
influences on the language well maybe

50
00:02:07,810 --> 00:02:09,549
instead let's call it something really

51
00:02:09,549 --> 00:02:10,060
nasty

52
00:02:10,060 --> 00:02:12,970
sounds like eczema what we ended up with

53
00:02:12,970 --> 00:02:16,360
was ACMA script magma for those who

54
00:02:16,360 --> 00:02:17,739
don't know is the european computer

55
00:02:17,739 --> 00:02:19,270
manufacturers association they're the

56
00:02:19,270 --> 00:02:21,540
standardizing body manages ekam script

57
00:02:21,540 --> 00:02:24,280
so we got actor script one

58
00:02:24,280 --> 00:02:26,770
and then we got version two and then we

59
00:02:26,770 --> 00:02:28,960
got version three and then we got

60
00:02:28,960 --> 00:02:32,560
version four well actually version four

61
00:02:32,560 --> 00:02:35,620
didn't happen the eat the committee the

62
00:02:35,620 --> 00:02:38,170
tc39 committee split into warring

63
00:02:38,170 --> 00:02:39,520
factions and couldn't agree on what

64
00:02:39,520 --> 00:02:41,800
should be in yes four but they

65
00:02:41,800 --> 00:02:44,800
eventually extended an olive branch and

66
00:02:44,800 --> 00:02:46,480
came up with a compromise that ended up

67
00:02:46,480 --> 00:02:48,910
being version five and then we got

68
00:02:48,910 --> 00:02:53,950
version 2015 wait what the actual name

69
00:02:53,950 --> 00:02:56,980
of the language is act math two six two

70
00:02:56,980 --> 00:02:58,930
fifth edition six edition sorry echo

71
00:02:58,930 --> 00:03:00,670
script 2015 it rolls right off the

72
00:03:00,670 --> 00:03:03,040
tongue regardless of what it's called

73
00:03:03,040 --> 00:03:06,130
it made a big splash and people were

74
00:03:06,130 --> 00:03:09,370
really excited about this new spec but

75
00:03:09,370 --> 00:03:13,090
why did I care well I've been using Java

76
00:03:13,090 --> 00:03:14,560
scripts into the first game Allen in

77
00:03:14,560 --> 00:03:17,410
1995 and I've been following the spec

78
00:03:17,410 --> 00:03:19,840
for a while and was really interested in

79
00:03:19,840 --> 00:03:22,180
getting in on this new hotness so I

80
00:03:22,180 --> 00:03:25,209
figured like most things the best way to

81
00:03:25,209 --> 00:03:27,910
learn it was to teach so I went back to

82
00:03:27,910 --> 00:03:29,080
my JavaScript meet up and gave a

83
00:03:29,080 --> 00:03:31,330
three-part series of in-depth talks and

84
00:03:31,330 --> 00:03:33,459
hands-on coding exercises to learn es6

85
00:03:33,459 --> 00:03:35,890
and then with a head full of knowledge I

86
00:03:35,890 --> 00:03:38,650
got the bright idea to introduce the s6

87
00:03:38,650 --> 00:03:41,560
to the enterprise nope not that

88
00:03:41,560 --> 00:03:43,870
enterprise this kind of enterprise and

89
00:03:43,870 --> 00:03:45,790
those of you who have worked in an

90
00:03:45,790 --> 00:03:47,530
enterprise software company know that we

91
00:03:47,530 --> 00:03:50,140
often do things by committee into the

92
00:03:50,140 --> 00:03:51,250
case of my last employer

93
00:03:51,250 --> 00:03:52,630
this meant the enterprise software

94
00:03:52,630 --> 00:03:55,060
architecture committee comprised mostly

95
00:03:55,060 --> 00:03:56,890
of former and current back-end

96
00:03:56,890 --> 00:04:00,160
developers whose default stances Java

97
00:04:00,160 --> 00:04:03,100
Script sucks so needless to say they

98
00:04:03,100 --> 00:04:05,079
were dubious and they asked me lots of

99
00:04:05,079 --> 00:04:06,430
questions like can't we just wait until

100
00:04:06,430 --> 00:04:09,070
the specs fully implemented then I was

101
00:04:09,070 --> 00:04:12,519
like well we could but this is not like

102
00:04:12,519 --> 00:04:14,829
the rollout of es5 for one thing

103
00:04:14,829 --> 00:04:17,140
browsers are evergreen now and we have

104
00:04:17,140 --> 00:04:18,669
amazing tools like Babel that will let

105
00:04:18,669 --> 00:04:20,709
us use the features of tomorrow today

106
00:04:20,709 --> 00:04:22,930
but there was still a lot of fear

107
00:04:22,930 --> 00:04:27,850
uncertainty doubt so I waited and I

108
00:04:27,850 --> 00:04:31,090
evangelized every moment I could and I

109
00:04:31,090 --> 00:04:32,470
waited some more until finally one day

110
00:04:32,470 --> 00:04:34,000
in one of these meetings of the

111
00:04:34,000 --> 00:04:35,200
enterprise software architecture

112
00:04:35,200 --> 00:04:37,650
committee es6 was approved

113
00:04:37,650 --> 00:04:40,360
well at that point I was really

114
00:04:40,360 --> 00:04:42,070
interested in having teams opt in

115
00:04:42,070 --> 00:04:43,870
without worrying about the plumbing and

116
00:04:43,870 --> 00:04:46,750
we were using grunt at the time with

117
00:04:46,750 --> 00:04:48,430
lots of duplicated configs across

118
00:04:48,430 --> 00:04:50,170
applications there was already an effort

119
00:04:50,170 --> 00:04:51,910
underway to consolidate those config so

120
00:04:51,910 --> 00:04:53,860
I piggybacked on that we published an

121
00:04:53,860 --> 00:04:55,750
NPM package the teams could install and

122
00:04:55,750 --> 00:05:01,150
get es6 features for free oh all good

123
00:05:01,150 --> 00:05:03,790
right well that time we were also

124
00:05:03,790 --> 00:05:05,770
weaning ourselves off Bower which was

125
00:05:05,770 --> 00:05:07,870
the dominant package manager for the

126
00:05:07,870 --> 00:05:09,760
client at the time and we decided to

127
00:05:09,760 --> 00:05:12,910
move to JSP m which is a noble that

128
00:05:12,910 --> 00:05:14,740
failed experiment and poly filling

129
00:05:14,740 --> 00:05:16,600
module loading in the browser

130
00:05:16,600 --> 00:05:18,970
the problem with JSP m is that not only

131
00:05:18,970 --> 00:05:20,650
does it want to load modules in the

132
00:05:20,650 --> 00:05:22,210
browser I wants to transpile them there

133
00:05:22,210 --> 00:05:23,560
as well which you might imagine is

134
00:05:23,560 --> 00:05:27,790
really slow but at Build time it uses

135
00:05:27,790 --> 00:05:30,520
node uses babel and it's fast so I just

136
00:05:30,520 --> 00:05:32,230
offset the transpiling

137
00:05:32,230 --> 00:05:33,880
to grunt and I have grunt and Babel for

138
00:05:33,880 --> 00:05:36,310
development and JSP and babble at Build

139
00:05:36,310 --> 00:05:38,080
time so now my developers are pumped

140
00:05:38,080 --> 00:05:39,760
everyone stoked we're ready to conquer

141
00:05:39,760 --> 00:05:42,010
the world but there's still one problem

142
00:05:42,010 --> 00:05:45,130
and that is most of them haven't been

143
00:05:45,130 --> 00:05:47,170
following the spec like I have and some

144
00:05:47,170 --> 00:05:48,700
of them don't even know that es6 is a

145
00:05:48,700 --> 00:05:50,620
thing so I put my teaching hat back on

146
00:05:50,620 --> 00:05:54,100
and I gave a condensed version of es6 in

147
00:05:54,100 --> 00:05:56,590
depth for the enterprise then I used

148
00:05:56,590 --> 00:05:58,300
code reviews as an opportunity to

149
00:05:58,300 --> 00:06:01,000
suggest es6 syntax and features to solve

150
00:06:01,000 --> 00:06:02,280
problems that were already on the table

151
00:06:02,280 --> 00:06:05,140
slowly but surely it started to sink in

152
00:06:05,140 --> 00:06:07,240
until a couple of months later our first

153
00:06:07,240 --> 00:06:10,930
es6 code was deployed to production so

154
00:06:10,930 --> 00:06:12,780
what's the big deal who cares

155
00:06:12,780 --> 00:06:15,660
well we're talking about javascript

156
00:06:15,660 --> 00:06:17,940
javascript is arguably the most

157
00:06:17,940 --> 00:06:20,320
misunderstood language in widespread use

158
00:06:20,320 --> 00:06:23,620
it's also arguably the most important by

159
00:06:23,620 --> 00:06:25,780
virtue of its magnitude of deployment

160
00:06:25,780 --> 00:06:28,600
alone it's not just in browsers anymore

161
00:06:28,600 --> 00:06:30,400
it's been for a while now viable on the

162
00:06:30,400 --> 00:06:32,350
server it's a first-class citizen in

163
00:06:32,350 --> 00:06:34,630
databases automation tools and even

164
00:06:34,630 --> 00:06:36,310
operating systems at this point and it's

165
00:06:36,310 --> 00:06:39,250
the undisputed king of the web and it

166
00:06:39,250 --> 00:06:41,340
continues to eat the rest of the world

167
00:06:41,340 --> 00:06:43,930
so let's talk about what's new what's in

168
00:06:43,930 --> 00:06:46,060
es6 so this was the first major update

169
00:06:46,060 --> 00:06:47,860
in the languages history really since

170
00:06:47,860 --> 00:06:50,170
1995 and you can break down the updates

171
00:06:50,170 --> 00:06:51,430
into three broad categories

172
00:06:51,430 --> 00:06:54,400
the first is syntax so this is new ways

173
00:06:54,400 --> 00:06:56,410
of expressing existing behavior that the

174
00:06:56,410 --> 00:06:58,449
language already has we get things like

175
00:06:58,449 --> 00:07:02,080
rest spread D structuring block scoping

176
00:07:02,080 --> 00:07:05,710
arrow functions and modules the second

177
00:07:05,710 --> 00:07:07,300
broad category of updates are

178
00:07:07,300 --> 00:07:09,490
enhancements so these are ants mints -

179
00:07:09,490 --> 00:07:11,080
built-ins or the standard library in

180
00:07:11,080 --> 00:07:12,520
JavaScript so we get some updates to

181
00:07:12,520 --> 00:07:15,460
strings and arrays and objects amongst

182
00:07:15,460 --> 00:07:17,770
others and then the last broad category

183
00:07:17,770 --> 00:07:19,750
of updates are entirely new features and

184
00:07:19,750 --> 00:07:21,250
I'm going to argue later that this is

185
00:07:21,250 --> 00:07:22,960
where the real meat and potatoes of es6

186
00:07:22,960 --> 00:07:25,199
live these are things like symbols

187
00:07:25,199 --> 00:07:29,320
generators proxies and promises it's big

188
00:07:29,320 --> 00:07:31,449
it's a really large update again this

189
00:07:31,449 --> 00:07:33,370
was the first major update in 20 years

190
00:07:33,370 --> 00:07:35,320
of the language can't possibly cover all

191
00:07:35,320 --> 00:07:36,880
of it today so I'm gonna talk about the

192
00:07:36,880 --> 00:07:38,289
things that I think are kind of

193
00:07:38,289 --> 00:07:38,860
important

194
00:07:38,860 --> 00:07:43,330
starting with syntax so we get a you

195
00:07:43,330 --> 00:07:44,949
know a step forward and what we got in

196
00:07:44,949 --> 00:07:46,960
the s5 with the object literal syntax we

197
00:07:46,960 --> 00:07:48,460
get method and property shorthands

198
00:07:48,460 --> 00:07:50,020
computed properties these are a

199
00:07:50,020 --> 00:07:52,050
no-brainer most teams have adopted these

200
00:07:52,050 --> 00:07:54,639
we get default arguments that let you

201
00:07:54,639 --> 00:07:56,470
provide a default for function arguments

202
00:07:56,470 --> 00:07:58,690
there with me I know most modern

203
00:07:58,690 --> 00:07:59,979
programming languages have default

204
00:07:59,979 --> 00:08:03,340
arguments already but javis could we get

205
00:08:03,340 --> 00:08:04,690
this nice little dot dot dot operator

206
00:08:04,690 --> 00:08:07,000
and this guy has a split personality

207
00:08:07,000 --> 00:08:09,909
its first personality is rest which

208
00:08:09,909 --> 00:08:12,250
means it gathers the rest of a functions

209
00:08:12,250 --> 00:08:14,560
arguments together into a true array and

210
00:08:14,560 --> 00:08:16,930
lets you do real array options or

211
00:08:16,930 --> 00:08:18,550
operations on this without borrowing

212
00:08:18,550 --> 00:08:20,800
from a radar prototype so let you do

213
00:08:20,800 --> 00:08:22,720
things like manipulate an array and then

214
00:08:22,720 --> 00:08:24,909
call a base function right went the

215
00:08:24,909 --> 00:08:26,260
opposite of the default value for

216
00:08:26,260 --> 00:08:29,919
example now it's second personality is

217
00:08:29,919 --> 00:08:31,630
spread which does the opposite it

218
00:08:31,630 --> 00:08:34,779
spreads out elements in a collection if

219
00:08:34,779 --> 00:08:36,880
you will here's an array with the spread

220
00:08:36,880 --> 00:08:38,169
operator being used I haven't actually

221
00:08:38,169 --> 00:08:40,060
seen this a lot in production last three

222
00:08:40,060 --> 00:08:42,159
years now but it can also be used to

223
00:08:42,159 --> 00:08:43,810
spread out the arguments to a function

224
00:08:43,810 --> 00:08:47,050
so we see that same example before if

225
00:08:47,050 --> 00:08:49,690
you don't need to provide the value of

226
00:08:49,690 --> 00:08:51,250
this it's an alternative to apply

227
00:08:51,250 --> 00:08:54,310
function dot apply okay let's talk about

228
00:08:54,310 --> 00:08:57,190
the structuring or more concisely D

229
00:08:57,190 --> 00:08:58,750
structuring assignment this feature was

230
00:08:58,750 --> 00:09:00,640
by kind of widely criticised where all

231
00:09:00,640 --> 00:09:02,170
the spec was being worked on mostly due

232
00:09:02,170 --> 00:09:03,750
to examples like this

233
00:09:03,750 --> 00:09:05,550
don't really give any value and just

234
00:09:05,550 --> 00:09:07,529
make the code even more opaque and hard

235
00:09:07,529 --> 00:09:09,269
to read but I think most people would

236
00:09:09,269 --> 00:09:10,949
agree that this is a really readable

237
00:09:10,949 --> 00:09:13,199
syntax this is widespread D structuring

238
00:09:13,199 --> 00:09:15,389
of the named exports of a module it's

239
00:09:15,389 --> 00:09:17,790
also a common pattern and react to D

240
00:09:17,790 --> 00:09:20,790
structure props and you can actually

241
00:09:20,790 --> 00:09:22,350
combine this with default function

242
00:09:22,350 --> 00:09:25,110
arguments for a really concise and

243
00:09:25,110 --> 00:09:29,730
expressive way to provide sort of you

244
00:09:29,730 --> 00:09:32,160
know a consistent API for functions if

245
00:09:32,160 --> 00:09:33,420
you will Doug Crockford is really big

246
00:09:33,420 --> 00:09:35,699
onto this pattern let's talk about block

247
00:09:35,699 --> 00:09:39,240
scoping so up until 2015 we had exactly

248
00:09:39,240 --> 00:09:41,670
two scopes in JavaScript global scope

249
00:09:41,670 --> 00:09:44,160
and the lexical of function scope so

250
00:09:44,160 --> 00:09:46,410
even though curly brackets like this is

251
00:09:46,410 --> 00:09:48,629
a perfectly valid block in es5 this

252
00:09:48,629 --> 00:09:50,370
doesn't do anything the variable name is

253
00:09:50,370 --> 00:09:51,990
hoisted and just gets reassigned

254
00:09:51,990 --> 00:09:55,439
but in es6 with the let operator we

255
00:09:55,439 --> 00:09:57,180
actually get block scoping it doesn't

256
00:09:57,180 --> 00:09:58,410
look like this would be useful but it

257
00:09:58,410 --> 00:10:00,329
this can actually replace the if e or

258
00:10:00,329 --> 00:10:01,889
immediately vote function expression if

259
00:10:01,889 --> 00:10:03,240
you need to do setup without polluting

260
00:10:03,240 --> 00:10:07,309
the global scope the other block scope

261
00:10:07,309 --> 00:10:10,709
right before we move on to that the

262
00:10:10,709 --> 00:10:12,149
other thing this can solve although I

263
00:10:12,149 --> 00:10:14,550
still don't recommend doing this is the

264
00:10:14,550 --> 00:10:16,410
problem you get with creating functions

265
00:10:16,410 --> 00:10:18,029
in a loop this is the classic closure

266
00:10:18,029 --> 00:10:20,309
problem and this is a question that I've

267
00:10:20,309 --> 00:10:21,750
given in interviews in the past quite a

268
00:10:21,750 --> 00:10:23,129
bit and people have given me about

269
00:10:23,129 --> 00:10:24,959
it because it's a contrived example I'm

270
00:10:24,959 --> 00:10:26,160
never going to see code like this in

271
00:10:26,160 --> 00:10:28,790
production but I got vindicated when a

272
00:10:28,790 --> 00:10:30,809
problem just like this came up in

273
00:10:30,809 --> 00:10:32,550
production and the dev who found it and

274
00:10:32,550 --> 00:10:34,170
the only reason I recognized it so fast

275
00:10:34,170 --> 00:10:35,399
because it's because it looked like

276
00:10:35,399 --> 00:10:36,990
Tim's interview question but those who

277
00:10:36,990 --> 00:10:38,490
don't know this is basically going to

278
00:10:38,490 --> 00:10:40,500
close over the variable I and every

279
00:10:40,500 --> 00:10:42,839
function that gets executed in that

280
00:10:42,839 --> 00:10:44,459
array will be the value of five at the

281
00:10:44,459 --> 00:10:47,639
end which is five the value of I so in

282
00:10:47,639 --> 00:10:50,550
es5 or below the only way to solve this

283
00:10:50,550 --> 00:10:52,559
is to force a valuation of that variable

284
00:10:52,559 --> 00:10:54,779
during the iteration either with an e or

285
00:10:54,779 --> 00:10:58,410
a separate function in es6 block scoping

286
00:10:58,410 --> 00:11:00,000
will create a new instance of that

287
00:11:00,000 --> 00:11:02,069
variable every time again I don't

288
00:11:02,069 --> 00:11:03,930
recommend that you do this but this can

289
00:11:03,930 --> 00:11:05,129
solve the problems worried if you find

290
00:11:05,129 --> 00:11:07,110
yourself in that position the other

291
00:11:07,110 --> 00:11:08,939
block scoped operator would get as Const

292
00:11:08,939 --> 00:11:11,069
which presumably is short for constant

293
00:11:11,069 --> 00:11:14,009
and we would be I think reasonable and

294
00:11:14,009 --> 00:11:16,350
assuming that a constant

295
00:11:16,350 --> 00:11:19,380
mutated but we'd be wrong because const

296
00:11:19,380 --> 00:11:21,210
is not immutable accounts is only a

297
00:11:21,210 --> 00:11:23,160
mutable assignment not a mutable value

298
00:11:23,160 --> 00:11:25,050
right so any of the properties of an

299
00:11:25,050 --> 00:11:27,000
object that are not primitive can be

300
00:11:27,000 --> 00:11:29,220
mutated it's more of a signal of intent

301
00:11:29,220 --> 00:11:32,850
than actual immutability arrow functions

302
00:11:32,850 --> 00:11:34,380
are important not just because they

303
00:11:34,380 --> 00:11:36,090
provide a nice concise syntax there's an

304
00:11:36,090 --> 00:11:37,680
actual use cases for them Brendan Eich

305
00:11:37,680 --> 00:11:38,910
has said that if he could change one

306
00:11:38,910 --> 00:11:40,230
thing about JavaScript when it first

307
00:11:40,230 --> 00:11:41,220
came out it would be the function

308
00:11:41,220 --> 00:11:43,470
keyword because it's servos we've got

309
00:11:43,470 --> 00:11:45,510
various different flavors of them and in

310
00:11:45,510 --> 00:11:47,220
my opinion they're useful in three

311
00:11:47,220 --> 00:11:49,560
different use cases the first is they're

312
00:11:49,560 --> 00:11:51,360
really good for terse callbacks so when

313
00:11:51,360 --> 00:11:52,680
you're doing a rein manipulation or

314
00:11:52,680 --> 00:11:54,090
promise chaining things like that they

315
00:11:54,090 --> 00:11:55,320
really shine make the code a lot more

316
00:11:55,320 --> 00:11:58,650
readable the second is they retain the

317
00:11:58,650 --> 00:12:00,090
value of this from their enclosing

318
00:12:00,090 --> 00:12:01,830
lexical scope so you don't need to do

319
00:12:01,830 --> 00:12:03,660
crazy things like bar that equals this

320
00:12:03,660 --> 00:12:05,370
or function that binds are still valid

321
00:12:05,370 --> 00:12:07,140
use cases for function dot bind and the

322
00:12:07,140 --> 00:12:09,860
third is that it really shines for

323
00:12:09,860 --> 00:12:12,180
currying or partial application this

324
00:12:12,180 --> 00:12:13,650
gives you a really terse and readable

325
00:12:13,650 --> 00:12:16,350
syntax but as tempting as it is to use

326
00:12:16,350 --> 00:12:17,910
error functions everywhere you can use

327
00:12:17,910 --> 00:12:19,350
function declaration there's a reason

328
00:12:19,350 --> 00:12:21,210
why function function declarations are

329
00:12:21,210 --> 00:12:22,800
still around they are not a golden

330
00:12:22,800 --> 00:12:23,660
hammer

331
00:12:23,660 --> 00:12:26,280
first off they can't be hoisted now this

332
00:12:26,280 --> 00:12:28,350
is not as much of an issue now that we

333
00:12:28,350 --> 00:12:30,030
have actual block scoping but if you're

334
00:12:30,030 --> 00:12:31,530
introducing us into a legacy code base

335
00:12:31,530 --> 00:12:33,240
it's it's a foot gun to look out for and

336
00:12:33,240 --> 00:12:35,040
the other thing is they can't be back

337
00:12:35,040 --> 00:12:38,220
bound I mentioned function bind these

338
00:12:38,220 --> 00:12:40,170
are functions they inherit from function

339
00:12:40,170 --> 00:12:41,730
prototype this is a perfectly legal

340
00:12:41,730 --> 00:12:43,590
operation just won't do anything it

341
00:12:43,590 --> 00:12:44,880
won't actually change the value of this

342
00:12:44,880 --> 00:12:46,350
there will always be the value of this

343
00:12:46,350 --> 00:12:49,140
from the closing lexical scope okay

344
00:12:49,140 --> 00:12:50,670
template literals give us a really nice

345
00:12:50,670 --> 00:12:52,170
concise syntax for variable

346
00:12:52,170 --> 00:12:53,790
interpolation we used to do lots of

347
00:12:53,790 --> 00:12:55,470
tricks like this in the s52 tokenize a

348
00:12:55,470 --> 00:12:57,540
string just by borrowing join from array

349
00:12:57,540 --> 00:12:59,850
and passing your token as the argument

350
00:12:59,850 --> 00:13:00,960
to it now we get something that actually

351
00:13:00,960 --> 00:13:02,610
signifies the intent and is a little

352
00:13:02,610 --> 00:13:03,420
easier to read

353
00:13:03,420 --> 00:13:06,360
they also potentially can replace even

354
00:13:06,360 --> 00:13:07,830
the simplest of templating libraries a

355
00:13:07,830 --> 00:13:09,390
lot of people don't even realize that

356
00:13:09,390 --> 00:13:11,670
lodash and its predecessor underscore

357
00:13:11,670 --> 00:13:13,350
actually have a micro templating engine

358
00:13:13,350 --> 00:13:15,180
included it's the one you use when you

359
00:13:15,180 --> 00:13:16,530
don't want to reach for handlebars to

360
00:13:16,530 --> 00:13:18,660
mustache or something heavier weight but

361
00:13:18,660 --> 00:13:20,820
with es6 we can almost entirely drop

362
00:13:20,820 --> 00:13:22,950
this and when you bring in multi-line

363
00:13:22,950 --> 00:13:24,870
string support and tagged template

364
00:13:24,870 --> 00:13:25,950
functions which i'm not going to cover

365
00:13:25,950 --> 00:13:27,480
here but basically it allows you gives

366
00:13:27,480 --> 00:13:29,280
you a way of parsing the strings and

367
00:13:29,280 --> 00:13:30,150
tokens that are passed

368
00:13:30,150 --> 00:13:32,250
into a template you can write your own

369
00:13:32,250 --> 00:13:34,980
templating engine natively and the last

370
00:13:34,980 --> 00:13:36,240
thing that they can do is potentially

371
00:13:36,240 --> 00:13:38,460
solve this double versus single quotes

372
00:13:38,460 --> 00:13:40,200
thing once and for all if you just put

373
00:13:40,200 --> 00:13:41,430
back takes everywhere in your codebase

374
00:13:41,430 --> 00:13:43,020
you get rid of that you also get

375
00:13:43,020 --> 00:13:44,820
character escaping multi-line strings

376
00:13:44,820 --> 00:13:47,910
and all that great stuff for free and

377
00:13:47,910 --> 00:13:49,200
last syntax thing I want to talk about

378
00:13:49,200 --> 00:13:53,490
is modules so JavaScript up until 2015

379
00:13:53,490 --> 00:13:55,590
was basically the only widespread modern

380
00:13:55,590 --> 00:13:57,150
programming language with no concept of

381
00:13:57,150 --> 00:13:59,730
a module system now your modules are a

382
00:13:59,730 --> 00:14:01,050
great best practice they help us

383
00:14:01,050 --> 00:14:02,870
structure our code and have a proper

384
00:14:02,870 --> 00:14:06,720
dependency tree but javascript has had

385
00:14:06,720 --> 00:14:07,980
new modules and its twenty-year history

386
00:14:07,980 --> 00:14:09,390
to this point so the community has been

387
00:14:09,390 --> 00:14:11,220
really creative in stepping in to fill

388
00:14:11,220 --> 00:14:12,870
this gap with things like object name

389
00:14:12,870 --> 00:14:14,970
spacing the immediately invoked function

390
00:14:14,970 --> 00:14:16,800
expression or a variant of that which is

391
00:14:16,800 --> 00:14:18,360
the JavaScript module pattern on the

392
00:14:18,360 --> 00:14:20,640
server we got common Jas and its brother

393
00:14:20,640 --> 00:14:22,620
on the client the asynchronous module

394
00:14:22,620 --> 00:14:24,930
definition as embodied by required Jas

395
00:14:24,930 --> 00:14:26,670
but my personal favorite is script tag

396
00:14:26,670 --> 00:14:29,370
vomit es6

397
00:14:29,370 --> 00:14:31,410
gives us native modules with all of

398
00:14:31,410 --> 00:14:34,140
their glory right and it's awesome right

399
00:14:34,140 --> 00:14:35,670
there's just one problem and that is

400
00:14:35,670 --> 00:14:37,860
that while the syntax made the cut for

401
00:14:37,860 --> 00:14:40,440
the es expect a loader did not so we

402
00:14:40,440 --> 00:14:42,690
have no way until now and I'll touch on

403
00:14:42,690 --> 00:14:44,490
that later to load modules in the

404
00:14:44,490 --> 00:14:46,890
browser so again the community stepped

405
00:14:46,890 --> 00:14:47,880
up to the plate and gave us some

406
00:14:47,880 --> 00:14:50,130
incredible tools to do this right to

407
00:14:50,130 --> 00:14:52,110
parse the dependency tree and turn these

408
00:14:52,110 --> 00:14:53,670
into something that's consumable by a

409
00:14:53,670 --> 00:14:56,430
browser and some of these do additional

410
00:14:56,430 --> 00:14:59,010
things like static analysis and tree

411
00:14:59,010 --> 00:15:04,080
shaking now module loading natively has

412
00:15:04,080 --> 00:15:06,180
just dropped in most major browsers you

413
00:15:06,180 --> 00:15:08,250
can actually load modules without a

414
00:15:08,250 --> 00:15:11,700
polyfill or bundler but traversing a

415
00:15:11,700 --> 00:15:13,590
dependency tree have a large JavaScript

416
00:15:13,590 --> 00:15:15,150
application and actually fetching all

417
00:15:15,150 --> 00:15:17,010
those over HTTP it's prohibitively

418
00:15:17,010 --> 00:15:18,720
expensive so I think you know for the

419
00:15:18,720 --> 00:15:21,930
time being until HTTP 2 and aggressive

420
00:15:21,930 --> 00:15:23,640
module caching or rolled out widely

421
00:15:23,640 --> 00:15:25,320
across the web bundling is probably

422
00:15:25,320 --> 00:15:27,900
still the future ok we've talked about

423
00:15:27,900 --> 00:15:29,130
syntax let's talk about some

424
00:15:29,130 --> 00:15:31,620
enhancements so we got you know a good

425
00:15:31,620 --> 00:15:33,090
set of enhancements to the standard

426
00:15:33,090 --> 00:15:34,620
library of JavaScript what we like to

427
00:15:34,620 --> 00:15:36,960
refer as built-in objects starting with

428
00:15:36,960 --> 00:15:38,940
strings string got a handful most of

429
00:15:38,940 --> 00:15:42,090
these are more about the semantics and

430
00:15:42,090 --> 00:15:43,950
what the expression of intent

431
00:15:43,950 --> 00:15:46,020
any kind of real syntax saving although

432
00:15:46,020 --> 00:15:48,380
stringing out ends red gives you both

433
00:15:48,380 --> 00:15:51,140
array gives us a few additional

434
00:15:51,140 --> 00:15:53,340
enhancements I think the most important

435
00:15:53,340 --> 00:15:55,560
of which are find and find index they

436
00:15:55,560 --> 00:15:57,210
let us kind of reduce our dependency on

437
00:15:57,210 --> 00:15:59,280
libraries like low - an underscore to do

438
00:15:59,280 --> 00:16:00,140
that for us

439
00:16:00,140 --> 00:16:02,550
number got some enhancements and most of

440
00:16:02,550 --> 00:16:05,070
these actually are just moving the local

441
00:16:05,070 --> 00:16:06,780
functions off the window object into a

442
00:16:06,780 --> 00:16:10,110
named module number math got some

443
00:16:10,110 --> 00:16:11,490
significant enhancements and I'm gonna

444
00:16:11,490 --> 00:16:13,920
just put a disclaimer that well some of

445
00:16:13,920 --> 00:16:15,090
you in the room may use these on a

446
00:16:15,090 --> 00:16:17,970
regular basis I don't and impostor

447
00:16:17,970 --> 00:16:19,470
syndrome be damned I'm not afraid to

448
00:16:19,470 --> 00:16:20,520
admit that they're pretty much just

449
00:16:20,520 --> 00:16:23,010
Greek to me all right object got one

450
00:16:23,010 --> 00:16:24,780
functional enhancement but it's an

451
00:16:24,780 --> 00:16:26,340
important one and that's object out of

452
00:16:26,340 --> 00:16:28,110
sign it lets us do mix-ins

453
00:16:28,110 --> 00:16:31,290
natively super cool super easy to

454
00:16:31,290 --> 00:16:33,210
understand there are some caveats though

455
00:16:33,210 --> 00:16:35,400
you want to be careful first off its not

456
00:16:35,400 --> 00:16:38,460
immutable so anything in that target

457
00:16:38,460 --> 00:16:40,740
object any sorry in the source object

458
00:16:40,740 --> 00:16:42,180
that is not a primitive type will be

459
00:16:42,180 --> 00:16:44,490
copying by reference so just be careful

460
00:16:44,490 --> 00:16:46,890
the other is you won't copy properties

461
00:16:46,890 --> 00:16:48,540
that aren't its own so it won't traverse

462
00:16:48,540 --> 00:16:49,800
the dependency tree up the prototype

463
00:16:49,800 --> 00:16:51,690
train if you need that you need a little

464
00:16:51,690 --> 00:16:55,200
extra work on your own alright so we've

465
00:16:55,200 --> 00:16:56,760
talked about syntax we've talked about

466
00:16:56,760 --> 00:16:58,020
enhancements all that stuff's great

467
00:16:58,020 --> 00:17:00,000
there's some really good syntax sugar

468
00:17:00,000 --> 00:17:02,150
there's a nice shortcuts tercer code etc

469
00:17:02,150 --> 00:17:05,010
but ultimately in my opinion the really

470
00:17:05,010 --> 00:17:07,230
important category of updates are the

471
00:17:07,230 --> 00:17:08,640
brand-new features this is what I call

472
00:17:08,640 --> 00:17:10,650
the good stuff in es6 starting with

473
00:17:10,650 --> 00:17:12,990
symbols symbols are a new primitive type

474
00:17:12,990 --> 00:17:15,420
and their primary purpose is to provide

475
00:17:15,420 --> 00:17:17,730
unique and mutable identifiers for

476
00:17:17,730 --> 00:17:19,770
well-known methods and the primary

477
00:17:19,770 --> 00:17:21,570
target audience of browser vendors that

478
00:17:21,570 --> 00:17:24,240
are implementing built-ins so in the

479
00:17:24,240 --> 00:17:27,000
absence of static typing in interfaces

480
00:17:27,000 --> 00:17:29,130
and access modifiers in JavaScript these

481
00:17:29,130 --> 00:17:31,530
provide us a way of predictably defining

482
00:17:31,530 --> 00:17:34,650
expected behaviors on objects semantics

483
00:17:34,650 --> 00:17:35,400
are pretty simple

484
00:17:35,400 --> 00:17:36,960
we call this symbol function it's

485
00:17:36,960 --> 00:17:38,580
actually not a constructor despite the

486
00:17:38,580 --> 00:17:40,950
capital S we get back this immutable

487
00:17:40,950 --> 00:17:43,740
unique symbol here we're using computed

488
00:17:43,740 --> 00:17:45,780
syntax on an object computed property

489
00:17:45,780 --> 00:17:47,550
syntax to reference it and then we get a

490
00:17:47,550 --> 00:17:48,960
nice accompanying little reflection

491
00:17:48,960 --> 00:17:50,850
method to inspect the symbols on an

492
00:17:50,850 --> 00:17:53,340
object one of the side effects of this

493
00:17:53,340 --> 00:17:55,260
are one of the interesting side cases

494
00:17:55,260 --> 00:17:56,730
aside from its main one is you can

495
00:17:56,730 --> 00:17:57,290
actually at

496
00:17:57,290 --> 00:17:59,240
true privacy so here we've got a closure

497
00:17:59,240 --> 00:18:01,640
that returns a constructor and in that

498
00:18:01,640 --> 00:18:03,560
closure we create a new symbol and then

499
00:18:03,560 --> 00:18:05,600
every constructor every instance created

500
00:18:05,600 --> 00:18:06,980
from that constructor gets a truly

501
00:18:06,980 --> 00:18:09,940
private property keyed by that symbol

502
00:18:09,940 --> 00:18:14,420
all right next up is irritable or maybe

503
00:18:14,420 --> 00:18:17,480
iterables iterables is a new interface

504
00:18:17,480 --> 00:18:19,400
in JavaScript we don't have interfaces

505
00:18:19,400 --> 00:18:21,440
in JavaScript but it's a contract and

506
00:18:21,440 --> 00:18:23,600
all of the built-in collections array

507
00:18:23,600 --> 00:18:25,610
strings which are just collections of

508
00:18:25,610 --> 00:18:27,860
characters and the new datatypes map and

509
00:18:27,860 --> 00:18:30,290
set they all implement this so here for

510
00:18:30,290 --> 00:18:33,070
example is the iterator or irritable

511
00:18:33,070 --> 00:18:35,200
irritable the iterable interface

512
00:18:35,200 --> 00:18:37,340
implemented on an array and you

513
00:18:37,340 --> 00:18:39,140
basically just get an iterator back by

514
00:18:39,140 --> 00:18:40,010
calling a method

515
00:18:40,010 --> 00:18:41,780
he'd by the well-known symbol symbol

516
00:18:41,780 --> 00:18:43,820
iterator and then you call next on it

517
00:18:43,820 --> 00:18:47,090
until it's done kind of verbose there's

518
00:18:47,090 --> 00:18:48,530
easier ways to consume it and we

519
00:18:48,530 --> 00:18:50,210
actually got a couple of new syntaxes in

520
00:18:50,210 --> 00:18:52,160
es6 to consume this one of which is four

521
00:18:52,160 --> 00:18:54,560
of four of is like four in on objects

522
00:18:54,560 --> 00:18:56,210
only instead of going over keys it

523
00:18:56,210 --> 00:18:58,880
returns the values and then the spread

524
00:18:58,880 --> 00:19:00,860
operator that we've already seen also

525
00:19:00,860 --> 00:19:03,530
will consume any interval so here we're

526
00:19:03,530 --> 00:19:04,910
going to call the symbol iterator method

527
00:19:04,910 --> 00:19:07,130
on a string get that consider ATAR and

528
00:19:07,130 --> 00:19:08,810
consume it with the spread operator it's

529
00:19:08,810 --> 00:19:10,100
like string dot split with a lot more

530
00:19:10,100 --> 00:19:15,430
characters so you can implement

531
00:19:15,430 --> 00:19:19,400
iterables yourself on any object just by

532
00:19:19,400 --> 00:19:21,380
implementing a method keyed by symbol

533
00:19:21,380 --> 00:19:23,410
iterator and following that interface

534
00:19:23,410 --> 00:19:27,380
you can do it yourself but it turns out

535
00:19:27,380 --> 00:19:29,200
there's a better way and that is

536
00:19:29,200 --> 00:19:32,780
generators so generators are just

537
00:19:32,780 --> 00:19:35,450
functions that can be paused and then

538
00:19:35,450 --> 00:19:37,610
later resumed and they have three main

539
00:19:37,610 --> 00:19:41,080
roles the first role is as producer

540
00:19:41,080 --> 00:19:44,710
producer of what producer of iterables

541
00:19:44,710 --> 00:19:48,020
we can with a generator function return

542
00:19:48,020 --> 00:19:50,360
an iterable from a function and since

543
00:19:50,360 --> 00:19:53,270
functions can be composed and iterables

544
00:19:53,270 --> 00:19:55,070
give us values one of the time when we

545
00:19:55,070 --> 00:19:57,980
ask for them they let us be lazy and

546
00:19:57,980 --> 00:19:59,210
what I mean by that is that we can

547
00:19:59,210 --> 00:20:01,640
compose generator functions too lazily

548
00:20:01,640 --> 00:20:04,220
evaluate collections one at a time and

549
00:20:04,220 --> 00:20:06,440
gate those such that we never go more

550
00:20:06,440 --> 00:20:08,020
than what we're looking for

551
00:20:08,020 --> 00:20:11,010
the second role of generators is as

552
00:20:11,010 --> 00:20:12,870
Zoomers so in addition to yielding

553
00:20:12,870 --> 00:20:14,640
values out generators can actually take

554
00:20:14,640 --> 00:20:16,950
values in so we can do things like

555
00:20:16,950 --> 00:20:19,320
here's a generic consumer that takes an

556
00:20:19,320 --> 00:20:21,720
iterable and some consumer it starts off

557
00:20:21,720 --> 00:20:23,400
the generator and then passes it

558
00:20:23,400 --> 00:20:24,510
everything in that interval to the

559
00:20:24,510 --> 00:20:26,250
consumer this is a contrived example but

560
00:20:26,250 --> 00:20:27,900
there's probably some practical

561
00:20:27,900 --> 00:20:29,670
applications that I just haven't gone to

562
00:20:29,670 --> 00:20:30,060
yet

563
00:20:30,060 --> 00:20:32,550
and the last and most important role of

564
00:20:32,550 --> 00:20:34,200
generators is as co-routines

565
00:20:34,200 --> 00:20:36,600
so these are functions that both take in

566
00:20:36,600 --> 00:20:38,580
and yield values and probably the most

567
00:20:38,580 --> 00:20:40,440
popular implementation of this out in

568
00:20:40,440 --> 00:20:42,420
the open source community is redux saga

569
00:20:42,420 --> 00:20:44,430
for those who aren't familiar with this

570
00:20:44,430 --> 00:20:46,290
it's a side effect library used to

571
00:20:46,290 --> 00:20:48,780
handle asynchronous actions in redux and

572
00:20:48,780 --> 00:20:51,840
basically it's middleware that sits in

573
00:20:51,840 --> 00:20:54,150
between a dispatch and the Redux store

574
00:20:54,150 --> 00:20:58,080
and these directives that redux give you

575
00:20:58,080 --> 00:21:01,140
the call put etc those just handle

576
00:21:01,140 --> 00:21:03,210
resolving promises and feeding the

577
00:21:03,210 --> 00:21:04,920
generator with next when the result of

578
00:21:04,920 --> 00:21:08,550
the promise ok proxies the metaphor from

579
00:21:08,550 --> 00:21:10,350
the web holds up pretty well most people

580
00:21:10,350 --> 00:21:12,330
are familiar with proxy from a web proxy

581
00:21:12,330 --> 00:21:14,130
that sits between you and a web server

582
00:21:14,130 --> 00:21:15,600
and it's actually a pretty good metaphor

583
00:21:15,600 --> 00:21:17,520
it holds up pretty well and when we talk

584
00:21:17,520 --> 00:21:18,960
about proxies in JavaScript what we're

585
00:21:18,960 --> 00:21:21,810
talking about is reflection or more

586
00:21:21,810 --> 00:21:24,110
specifically reflective meta programming

587
00:21:24,110 --> 00:21:26,670
in reflective meta programming comes in

588
00:21:26,670 --> 00:21:27,300
three flavors

589
00:21:27,300 --> 00:21:30,240
the first is introspection so

590
00:21:30,240 --> 00:21:32,310
introspection is the ability to inspect

591
00:21:32,310 --> 00:21:34,860
the structure of a running program and

592
00:21:34,860 --> 00:21:37,170
we've had this since at least es5 with

593
00:21:37,170 --> 00:21:38,970
object keys and going back even further

594
00:21:38,970 --> 00:21:41,340
to es 3 where the object of has own

595
00:21:41,340 --> 00:21:44,670
property the second type of reflective

596
00:21:44,670 --> 00:21:47,130
meta programming is self modification

597
00:21:47,130 --> 00:21:49,800
and we've had this since at least es5

598
00:21:49,800 --> 00:21:52,580
with things like object defined property

599
00:21:52,580 --> 00:21:54,660
and then the last type of reflective

600
00:21:54,660 --> 00:21:58,890
metaprogramming is Inception we all know

601
00:21:58,890 --> 00:22:00,710
that's impossible it's actually

602
00:22:00,710 --> 00:22:03,170
intercession which is the ability to

603
00:22:03,170 --> 00:22:05,580
redefine the semantics of some

604
00:22:05,580 --> 00:22:07,260
operations in a running program this is

605
00:22:07,260 --> 00:22:08,490
where it gets really interesting but

606
00:22:08,490 --> 00:22:10,710
what does that mean in JavaScript well

607
00:22:10,710 --> 00:22:12,660
one of those would be to protential e

608
00:22:12,660 --> 00:22:14,640
intercept a getter and a setter on an

609
00:22:14,640 --> 00:22:16,950
object right and then redefine how that

610
00:22:16,950 --> 00:22:18,450
works and we've been able to do this in

611
00:22:18,450 --> 00:22:20,970
cs5 with object dot defined property

612
00:22:20,970 --> 00:22:22,950
here we go through each of the keys on

613
00:22:22,950 --> 00:22:24,509
the source object and went and then we

614
00:22:24,509 --> 00:22:26,219
find a new object that intercepts that

615
00:22:26,219 --> 00:22:29,249
and we can redefine those semantics so

616
00:22:29,249 --> 00:22:31,349
proxies in es6 give us a slightly terse

617
00:22:31,349 --> 00:22:33,119
or syntax for the same thing they're

618
00:22:33,119 --> 00:22:35,699
traps sort of analogous to traps in an

619
00:22:35,699 --> 00:22:38,789
operating system and in this case it's

620
00:22:38,789 --> 00:22:41,039
one-size-fits-all you do a set and you

621
00:22:41,039 --> 00:22:42,959
get in the target whatever the prop name

622
00:22:42,959 --> 00:22:45,869
is and potentially a value and we can do

623
00:22:45,869 --> 00:22:47,219
interesting things with this like

624
00:22:47,219 --> 00:22:51,869
validation in this example since you

625
00:22:51,869 --> 00:22:53,879
know since we can basically obfuscate

626
00:22:53,879 --> 00:22:56,009
the internals of the object we can do

627
00:22:56,009 --> 00:22:57,209
some interesting things we can embody

628
00:22:57,209 --> 00:22:59,129
common patterns like the facade pattern

629
00:22:59,129 --> 00:23:00,539
so here for example we've got a POJO

630
00:23:00,539 --> 00:23:02,039
plain old JavaScript object that's

631
00:23:02,039 --> 00:23:04,679
wrapping local storage and you use it

632
00:23:04,679 --> 00:23:06,209
just by setting and getting properties

633
00:23:06,209 --> 00:23:08,639
excuse me and the object the

634
00:23:08,639 --> 00:23:10,109
applications here are boundless there's

635
00:23:10,109 --> 00:23:11,459
all sorts of great things that you could

636
00:23:11,459 --> 00:23:14,399
obvious kate behind a simple pojo since

637
00:23:14,399 --> 00:23:16,079
functions are also objects we can

638
00:23:16,079 --> 00:23:18,659
actually intercept function calls so we

639
00:23:18,659 --> 00:23:20,309
can use the the corresponding reflect

640
00:23:20,309 --> 00:23:21,869
API I'm not going to talk about a whole

641
00:23:21,869 --> 00:23:23,309
lot but it maps one to one with the

642
00:23:23,309 --> 00:23:25,440
traps available to a proxy and so here

643
00:23:25,440 --> 00:23:26,849
we can redefine the semantics of a

644
00:23:26,849 --> 00:23:28,889
function this is a an alternate and very

645
00:23:28,889 --> 00:23:30,209
verbose way of doing partial application

646
00:23:30,209 --> 00:23:33,659
of a function so here's the all that all

647
00:23:33,659 --> 00:23:35,609
the traps that you get like the one

648
00:23:35,609 --> 00:23:36,809
that's really interesting here in my

649
00:23:36,809 --> 00:23:38,639
mind is constructed let's you redefine a

650
00:23:38,639 --> 00:23:40,739
constructor so you can do conditional

651
00:23:40,739 --> 00:23:42,389
instantiation of objects you can do

652
00:23:42,389 --> 00:23:43,979
selective data hiding you can do all

653
00:23:43,979 --> 00:23:45,839
sorts of really things including being

654
00:23:45,839 --> 00:23:48,179
paranoid because proxies also come in a

655
00:23:48,179 --> 00:23:50,549
revocable variant so you can issue a

656
00:23:50,549 --> 00:23:52,289
proxy and then at some later point you

657
00:23:52,289 --> 00:23:54,749
can revoke access to it so here we're

658
00:23:54,749 --> 00:23:56,369
going to revoke access whenever anyone

659
00:23:56,369 --> 00:23:58,469
tries to write to a private property

660
00:23:58,469 --> 00:24:00,629
keyed with an underscore and not only is

661
00:24:00,629 --> 00:24:02,759
it paranoid it's rude because we don't

662
00:24:02,759 --> 00:24:05,909
even give an error we just revoke all

663
00:24:05,909 --> 00:24:09,059
right last up is promises es6 brings us

664
00:24:09,059 --> 00:24:12,539
native promises finally or I'll actually

665
00:24:12,539 --> 00:24:15,059
finally didn't make the cut it did drop

666
00:24:15,059 --> 00:24:18,929
in ES 2018 just last month a month

667
00:24:18,929 --> 00:24:22,139
before but we do get native promises

668
00:24:22,139 --> 00:24:24,239
they come in a constructor form we also

669
00:24:24,239 --> 00:24:25,889
get some static methods to return a

670
00:24:25,889 --> 00:24:28,409
promise immediately or handle concurrent

671
00:24:28,409 --> 00:24:30,539
promises we didn't get the ability

672
00:24:30,539 --> 00:24:32,909
either to cancel a promise that's

673
00:24:32,909 --> 00:24:34,829
already underway but on the bright side

674
00:24:34,829 --> 00:24:36,479
you won't ever have any broken promises

675
00:24:36,479 --> 00:24:38,470
but these shortcomings

676
00:24:38,470 --> 00:24:39,760
have led to some criticism in the

677
00:24:39,760 --> 00:24:41,440
community and a lot of people still

678
00:24:41,440 --> 00:24:44,170
prefer libraries like Q or Bluebird for

679
00:24:44,170 --> 00:24:45,280
their promised needs but I would argue

680
00:24:45,280 --> 00:24:48,070
that just like this solved the 80% use

681
00:24:48,070 --> 00:24:49,960
case for querying the Dom without

682
00:24:49,960 --> 00:24:52,120
needing jQuery I think this is also

683
00:24:52,120 --> 00:24:54,130
probably gonna solve the 80% use case

684
00:24:54,130 --> 00:24:57,340
for basic promise usage so all this is

685
00:24:57,340 --> 00:24:58,150
amazing right

686
00:24:58,150 --> 00:25:00,460
but the es expect didn't come without

687
00:25:00,460 --> 00:25:02,740
some controversy there's always people

688
00:25:02,740 --> 00:25:05,260
out there that legitimately or not want

689
00:25:05,260 --> 00:25:07,540
to complain about new things the first

690
00:25:07,540 --> 00:25:09,820
set of controversy came around syntax so

691
00:25:09,820 --> 00:25:11,320
there's a big part of the surface area

692
00:25:11,320 --> 00:25:13,720
in es6 that's just syntactic sugar it's

693
00:25:13,720 --> 00:25:15,190
just new ways of expressing things we

694
00:25:15,190 --> 00:25:17,200
could already do and we had some people

695
00:25:17,200 --> 00:25:19,240
that were in the camp I've I've already

696
00:25:19,240 --> 00:25:20,830
learned the s5 why do I need to learn

697
00:25:20,830 --> 00:25:22,570
all this new syntax it's not giving me

698
00:25:22,570 --> 00:25:24,790
anything new then the other camp was

699
00:25:24,790 --> 00:25:26,950
that effort could have better be spent

700
00:25:26,950 --> 00:25:28,720
on entirely new features versus just

701
00:25:28,720 --> 00:25:31,720
syntax sugar but never underestimate

702
00:25:31,720 --> 00:25:34,180
developer happiness a lot of developers

703
00:25:34,180 --> 00:25:36,010
are coming at JavaScript first through

704
00:25:36,010 --> 00:25:38,200
es6 they like these features and there's

705
00:25:38,200 --> 00:25:39,640
some like me that think they're a great

706
00:25:39,640 --> 00:25:43,150
tourist expression and a time-saver so

707
00:25:43,150 --> 00:25:44,830
if you're developers are happy they're

708
00:25:44,830 --> 00:25:46,750
likely to be more engaged and you should

709
00:25:46,750 --> 00:25:48,280
be happy too and then there's also

710
00:25:48,280 --> 00:25:49,990
statistics there's been quite a few

711
00:25:49,990 --> 00:25:52,420
studies showing a relevant correlation

712
00:25:52,420 --> 00:25:54,010
between the overall lines of code and

713
00:25:54,010 --> 00:25:55,690
the code base and the incidence of

714
00:25:55,690 --> 00:25:57,580
defect so if you can reduce the lines of

715
00:25:57,580 --> 00:25:59,950
code by any means you should see an

716
00:25:59,950 --> 00:26:01,690
accompanying decrease in defect

717
00:26:01,690 --> 00:26:04,780
incidence all right how many people use

718
00:26:04,780 --> 00:26:07,600
source maps anyone used source maps okay

719
00:26:07,600 --> 00:26:09,190
we know we no longer live in a world

720
00:26:09,190 --> 00:26:10,930
where we run the code we write right

721
00:26:10,930 --> 00:26:13,420
we're going through multiple stages of

722
00:26:13,420 --> 00:26:15,130
transformation and along the way source

723
00:26:15,130 --> 00:26:17,350
Maps map the symbols that are produced

724
00:26:17,350 --> 00:26:18,910
all the way back to your original source

725
00:26:18,910 --> 00:26:21,790
letting you debug the code you wrote as

726
00:26:21,790 --> 00:26:24,910
you're troubleshooting but it's not

727
00:26:24,910 --> 00:26:25,480
perfect

728
00:26:25,480 --> 00:26:27,310
this is a game of catch the breakpoint

729
00:26:27,310 --> 00:26:29,200
from some production code I wrote a few

730
00:26:29,200 --> 00:26:31,300
years ago the experience is vastly

731
00:26:31,300 --> 00:26:34,090
superior to console dot log but it's not

732
00:26:34,090 --> 00:26:37,510
perfect yet but by far the single most

733
00:26:37,510 --> 00:26:39,610
controversial single feature in es6 is

734
00:26:39,610 --> 00:26:41,950
classes and I'm here to tell you

735
00:26:41,950 --> 00:26:44,080
definitively three years later that

736
00:26:44,080 --> 00:26:45,790
JavaScript still doesn't have classes I

737
00:26:45,790 --> 00:26:49,030
know if it walks like a duck talks like

738
00:26:49,030 --> 00:26:50,120
a duck

739
00:26:50,120 --> 00:26:53,210
it's not a duck it's just syntax sugar

740
00:26:53,210 --> 00:26:54,890
on top of constructors in the prototype

741
00:26:54,890 --> 00:26:59,090
chain this D sugars into this and this

742
00:26:59,090 --> 00:27:03,080
just disha goes into this so you know

743
00:27:03,080 --> 00:27:04,790
there's really polar opposites on this

744
00:27:04,790 --> 00:27:06,680
topic some people love them some people

745
00:27:06,680 --> 00:27:08,660
hate them there's not a lot of people in

746
00:27:08,660 --> 00:27:10,730
the middle like me they're just sort of

747
00:27:10,730 --> 00:27:12,350
pragmatist and accept them for what they

748
00:27:12,350 --> 00:27:14,420
are on the pro side

749
00:27:14,420 --> 00:27:16,790
it's a tercer syntax I actually admire

750
00:27:16,790 --> 00:27:18,530
the terse syntax I just wish they could

751
00:27:18,530 --> 00:27:19,550
have figured out how to call it

752
00:27:19,550 --> 00:27:21,320
something other than classes and bring

753
00:27:21,320 --> 00:27:23,240
in that kind of the metaphor from class

754
00:27:23,240 --> 00:27:25,760
based oh oh there's a lot of other

755
00:27:25,760 --> 00:27:27,650
benefits but I think the main reason

756
00:27:27,650 --> 00:27:29,690
this was done was to make JavaScript

757
00:27:29,690 --> 00:27:31,460
more approachable to people coming from

758
00:27:31,460 --> 00:27:33,560
class-based or languages like Java and

759
00:27:33,560 --> 00:27:35,750
c-sharp but there's some serious

760
00:27:35,750 --> 00:27:40,640
non-trivial cons as well and I think the

761
00:27:40,640 --> 00:27:42,500
biggest one is that the syntax this new

762
00:27:42,500 --> 00:27:44,180
syntax is so different from the

763
00:27:44,180 --> 00:27:46,250
underlying semantics of prototype chains

764
00:27:46,250 --> 00:27:48,560
that it just confuses those same Oh devs

765
00:27:48,560 --> 00:27:51,260
that came from Java and c-sharp and this

766
00:27:51,260 --> 00:27:52,820
was beautifully illustrated when I gave

767
00:27:52,820 --> 00:27:54,740
my in-depth series during the coding

768
00:27:54,740 --> 00:27:56,210
portion one of the guys was a Java dev

769
00:27:56,210 --> 00:27:58,070
and he just stopped and looked at me it

770
00:27:58,070 --> 00:28:01,780
was like that's not how this works but

771
00:28:01,780 --> 00:28:04,430
they're here to stay I think you know

772
00:28:04,430 --> 00:28:06,230
with major libraries and frameworks like

773
00:28:06,230 --> 00:28:09,290
angular and react disseminating class

774
00:28:09,290 --> 00:28:11,110
syntax everywhere we're stuck with them

775
00:28:11,110 --> 00:28:14,030
so wrapping up why do I think any of

776
00:28:14,030 --> 00:28:16,010
this is important well the main reason I

777
00:28:16,010 --> 00:28:17,630
think that this set of updates

778
00:28:17,630 --> 00:28:19,910
particularly the updates to the built-in

779
00:28:19,910 --> 00:28:22,310
library built in standard library are

780
00:28:22,310 --> 00:28:23,510
important is because they let us go

781
00:28:23,510 --> 00:28:25,880
native further than we could before and

782
00:28:25,880 --> 00:28:27,620
by going native I mean that all things

783
00:28:27,620 --> 00:28:29,840
considered all things being equal I'm a

784
00:28:29,840 --> 00:28:32,150
huge proponent of using a native feature

785
00:28:32,150 --> 00:28:33,980
of a language over it's equivalent in a

786
00:28:33,980 --> 00:28:35,720
library or framework it makes your code

787
00:28:35,720 --> 00:28:38,000
more future-proof it makes it easier for

788
00:28:38,000 --> 00:28:40,340
new debts to understand and it also

789
00:28:40,340 --> 00:28:42,350
reduces potentially a bundle size and so

790
00:28:42,350 --> 00:28:43,460
some of these things that we get with

791
00:28:43,460 --> 00:28:45,680
es6 let us reduce the dependencies we're

792
00:28:45,680 --> 00:28:47,060
going to pull into our bundles deliver

793
00:28:47,060 --> 00:28:48,890
less JavaScript and allow our code to be

794
00:28:48,890 --> 00:28:54,230
future proofed so how much of es6 is

795
00:28:54,230 --> 00:28:56,030
legit and how much of it is just hype I

796
00:28:56,030 --> 00:28:58,520
don't think a lot of it is hype and we

797
00:28:58,520 --> 00:29:01,550
have to remember that es6 is decided by

798
00:29:01,550 --> 00:29:02,780
a committee

799
00:29:02,780 --> 00:29:05,180
and quite a few of these features were

800
00:29:05,180 --> 00:29:06,920
actually originally considered for es4

801
00:29:06,920 --> 00:29:09,350
work on which began right after the es 3

802
00:29:09,350 --> 00:29:11,510
spec was finalized in 1999 so I think we

803
00:29:11,510 --> 00:29:15,380
can safely say that ESX is legit what's

804
00:29:15,380 --> 00:29:15,950
next

805
00:29:15,950 --> 00:29:17,630
well most teams have barely scratched

806
00:29:17,630 --> 00:29:20,630
the surface of what you can do and I'm

807
00:29:20,630 --> 00:29:22,370
just as guilty I think most people

808
00:29:22,370 --> 00:29:24,740
haven't gone beyond syntactic sugar very

809
00:29:24,740 --> 00:29:26,510
few teams have implemented proxies

810
00:29:26,510 --> 00:29:27,980
there's some technical limitations there

811
00:29:27,980 --> 00:29:29,990
as well generators also haven't been

812
00:29:29,990 --> 00:29:33,080
widely used outside of Redux sagas but

813
00:29:33,080 --> 00:29:35,780
I'm a pragmatist so I don't just glom on

814
00:29:35,780 --> 00:29:36,980
to something because it's shiny there's

815
00:29:36,980 --> 00:29:39,800
got to be a tangible reason to use it so

816
00:29:39,800 --> 00:29:41,330
what's next for the language should we

817
00:29:41,330 --> 00:29:43,330
expect some more earth-shattering

818
00:29:43,330 --> 00:29:46,730
life-changing updates like es6 well

819
00:29:46,730 --> 00:29:50,030
probably not because es6 was the last

820
00:29:50,030 --> 00:29:52,130
major update the first and last major

821
00:29:52,130 --> 00:29:53,780
update the language will ever get the

822
00:29:53,780 --> 00:29:55,910
committee decided to move to yearly

823
00:29:55,910 --> 00:29:58,160
incremental releases hence the name yes

824
00:29:58,160 --> 00:30:00,920
2015 and it seems to be working because

825
00:30:00,920 --> 00:30:06,050
yes 2016 had exactly two features the

826
00:30:06,050 --> 00:30:07,790
exponentiation operator and a rate up

827
00:30:07,790 --> 00:30:10,010
for design that includes which left me

828
00:30:10,010 --> 00:30:11,810
feeling gypped because couldn't really

829
00:30:11,810 --> 00:30:15,170
give an in-depth talk on es 2016 yes

830
00:30:15,170 --> 00:30:17,720
2017 was a bit more ambitious it has

831
00:30:17,720 --> 00:30:20,060
features like async and a weight and a

832
00:30:20,060 --> 00:30:22,130
handful of other important features

833
00:30:22,130 --> 00:30:24,770
yes 2018 just dropped in June it

834
00:30:24,770 --> 00:30:27,500
includes promise dot finally finally it

835
00:30:27,500 --> 00:30:30,290
includes object rest spread properties a

836
00:30:30,290 --> 00:30:32,030
synchronous generators some other

837
00:30:32,030 --> 00:30:34,640
important stuff the other versions are

838
00:30:34,640 --> 00:30:36,680
coming yearly we'll start seeing this

839
00:30:36,680 --> 00:30:38,270
thing gradually evolve and then the real

840
00:30:38,270 --> 00:30:39,620
game-changer for all of us is

841
00:30:39,620 --> 00:30:42,110
webassembly webassembly is a bytecode

842
00:30:42,110 --> 00:30:44,540
format for the browser that lets other

843
00:30:44,540 --> 00:30:46,340
languages transpile directly to the

844
00:30:46,340 --> 00:30:48,590
browser and it lets me say something

845
00:30:48,590 --> 00:30:50,210
that I never thought I would say in my

846
00:30:50,210 --> 00:30:52,010
23 years of software development and

847
00:30:52,010 --> 00:30:53,810
that is if you want to do cool things on

848
00:30:53,810 --> 00:30:54,320
the web

849
00:30:54,320 --> 00:30:58,480
learn C and lastly I give you ice cream

850
00:30:58,480 --> 00:31:01,210
what does ice cream have to do with es6

851
00:31:01,210 --> 00:31:03,560
absolutely nothing but my ten-year-old

852
00:31:03,560 --> 00:31:04,970
daughter asked me to include a slide on

853
00:31:04,970 --> 00:31:06,710
ice cream and you don't say no to that

854
00:31:06,710 --> 00:31:09,590
 that's all I got

