1
00:00:09,800 --> 00:00:12,200
[applause] 

2
00:00:12,200 --> 00:00:13,200
Hello there!

3
00:00:13,800 --> 00:00:14,600
First of all

4
00:00:14,600 --> 00:00:18,050
I just want to pay tribute to the organizer of this conference

5
00:00:18,050 --> 00:00:22,480
I think it ’s been a great experience from beginning to end.

6
00:00:22,480 --> 00:00:23,160
and so...

7
00:00:23,160 --> 00:00:26,260
[applause]

8
00:00:26,260 --> 00:00:27,500
Awesome

9
00:00:28,000 --> 00:00:30,320
Hello everyone! My name is Anjana Vakil

10
00:00:30,920 --> 00:00:35,400
I became an English teacher and became a computational linguist

11
00:00:35,400 --> 00:00:37,100
Before turning into a software developer

12
00:00:37,350 --> 00:00:40,300
As I mentioned just now

13
00:00:41,000 --> 00:00:43,900
About six months ago, I knew nothing about functional programming

14
00:00:43,900 --> 00:00:45,900
Just a little knowledge of little Xu

15
00:00:45,900 --> 00:00:48,250
Want to do today

16
00:00:48,750 --> 00:00:51,250
Take you over and see what i have learned

17
00:00:51,250 --> 00:00:54,600
About functional programming with JavaScript

18
00:00:54,850 --> 00:00:57,800
I am not an expert in this area

19
00:00:57,800 --> 00:01:01,480
So this will be my journey of learning with you

20
00:01:01,480 --> 00:01:03,000
Nothing more

21
00:01:03,750 --> 00:01:07,100
In the end, I will try to spare some time to answer some questions

22
00:01:07,100 --> 00:01:09,100
See how you wait

23
00:01:09,100 --> 00:01:12,600
So why am I standing here

24
00:01:12,600 --> 00:01:15,500
Share with you about JavaScript functional programming?

25
00:01:15,650 --> 00:01:18,450
About six months ago, in the fall of 2015

26
00:01:18,450 --> 00:01:21,440
I went to a programming group in New York

27
00:01:21,440 --> 00:01:23,000
Called The Recurse Centre

28
00:01:23,200 --> 00:01:24,400
Its quick promotion

29
00:01:24,400 --> 00:01:28,120
It should be one of the best programming group experiences I have participated in

30
00:01:28,120 --> 00:01:29,820
Is a programming retreat

31
00:01:29,820 --> 00:01:31,200
You can go there to study

32
00:01:31,200 --> 00:01:34,300
Things that are interesting to you in computer science

33
00:01:34,950 --> 00:01:35,900
So i got there

34
00:01:35,900 --> 00:01:38,100
Many people are talking about functional programming

35
00:01:38,100 --> 00:01:41,500
Functional programming, Haskell, Clojure, all these great things

36
00:01:41,500 --> 00:01:44,160
Many people who are using JavaScript are starting to enter nodes

37
00:01:44,300 --> 00:01:46,300
These are some very interesting topics

38
00:01:46,300 --> 00:01:47,900
So I started talking to the people there

39
00:01:47,900 --> 00:01:50,200
Want to know what these things are

40
00:01:50,450 --> 00:01:53,080
So what is functional programming?

41
00:01:53,480 --> 00:01:55,800
This question can be answered in several different ways

42
00:01:56,200 --> 00:01:58,880
First, this is a programming paradigm

43
00:01:59,580 --> 00:02:02,760
Other examples include imperative programming

44
00:02:02,760 --> 00:02:04,560
Like always saying do this and then do that

45
00:02:04,560 --> 00:02:06,350
Object-oriented programming

46
00:02:06,350 --> 00:02:09,450
Maybe many of you have written object-oriented JavaScript

47
00:02:09,450 --> 00:02:12,480
You have objects and they have ways

48
00:02:12,480 --> 00:02:14,780
Then you change them and so on

49
00:02:15,100 --> 00:02:17,520
Functional programming is also a paradigm

50
00:02:17,520 --> 00:02:19,480
Function is king

51
00:02:19,480 --> 00:02:21,480
We will discuss later what this means

52
00:02:22,280 --> 00:02:24,580
This is also a coding style

53
00:02:24,580 --> 00:02:26,100
Organization code

54
00:02:26,100 --> 00:02:27,500
Write code

55
00:02:28,350 --> 00:02:30,000
Project-like style

56
00:02:30,400 --> 00:02:34,000
Not only that, it ’s an accessible mentality

57
00:02:34,000 --> 00:02:35,480
A way of thinking

58
00:02:35,480 --> 00:02:37,480
A way to approach the task

59
00:02:38,180 --> 00:02:40,320
This is also a very interesting trend

60
00:02:40,320 --> 00:02:43,360
There are many popular words

61
00:02:43,360 --> 00:02:47,400
Talking to someone at a pre-meeting or other occasion will make you super popular

62
00:02:47,700 --> 00:02:48,400
I'm just kidding

63
00:02:48,400 --> 00:02:50,400
But this caused a lot of attention

64
00:02:50,400 --> 00:02:53,000
So I think this is very important

65
00:02:53,000 --> 00:02:55,200
To find out why everyone is so excited about it

66
00:02:56,500 --> 00:03:00,640
Why use JavaScript exclusively for functional programming?

67
00:03:00,940 --> 00:03:03,440
I don't know if you have similar experience

68
00:03:03,700 --> 00:03:06,000
Maybe for more experienced JavaScript developers

69
00:03:06,000 --> 00:03:08,000
But when I started learning JavaScript

70
00:03:08,000 --> 00:03:12,650
Some object-oriented programming experience in Java, C-Sharp

71
00:03:12,650 --> 00:03:13,560
Those things

72
00:03:13,860 --> 00:03:18,480
I find object-oriented JavaScript very confusing

73
00:03:19,300 --> 00:03:22,400
How does prototype inheritance work?

74
00:03:23,800 --> 00:03:25,700
A few of you, raise your hands to see

75
00:03:25,700 --> 00:03:29,600
Who has encountered an error, problem or accident

76
00:03:29,900 --> 00:03:30,600
Do something ...

77
00:03:30,600 --> 00:03:32,600
Yeah, right?

78
00:03:32,750 --> 00:03:35,200
I found it really tricky and confusing

79
00:03:35,200 --> 00:03:37,950
So I thought, well, I know I want to learn more about JavaScript

80
00:03:37,950 --> 00:03:39,950
But let me let go of the object

81
00:03:39,950 --> 00:03:43,100
Try to think functionally

82
00:03:43,100 --> 00:03:45,450
May be simpler in some ways

83
00:03:45,450 --> 00:03:47,250
And avoid some of them

84
00:03:47,550 --> 00:03:51,400
Caused an error by binding this to the wrong thing

85
00:03:51,900 --> 00:03:55,760
So at least functional JavaScript is more secure for me

86
00:03:56,200 --> 00:03:57,160
Not so tricky

87
00:03:57,160 --> 00:03:58,600
Easier to debug

88
00:03:58,600 --> 00:04:01,500
But easier to maintain when building projects

89
00:04:02,100 --> 00:04:03,700
We will look at some features later

90
00:04:03,700 --> 00:04:05,700
Will become easy

91
00:04:06,900 --> 00:04:10,400
Moreover, there is already a large developer community

92
00:04:10,400 --> 00:04:12,700
They write JavaScript in a functional style

93
00:04:12,700 --> 00:04:15,100
Many libraries outside

94
00:04:15,100 --> 00:04:18,680
Help you write functional JavaScript

95
00:04:18,780 --> 00:04:21,480
Many people are experts

96
00:04:21,480 --> 00:04:25,800
For example, there is a talk about Ramda in the next room

97
00:04:26,000 --> 00:04:27,450
Someone here can talk to you too

98
00:04:27,450 --> 00:04:30,360
And they probably know more about functional JavaScript than I do

99
00:04:30,460 --> 00:04:32,160
But the point is that there is already a group

100
00:04:32,160 --> 00:04:36,360
So this doesn't necessarily need to be done by yourself

101
00:04:36,360 --> 00:04:38,160
Fighting JavaScript

102
00:04:38,160 --> 00:04:39,760
There are others who support you

103
00:04:39,760 --> 00:04:41,460
And I found it really helpful

104
00:04:43,100 --> 00:04:43,460
Ok

105
00:04:43,460 --> 00:04:45,460
Hope by now i have convinced you

106
00:04:45,460 --> 00:04:47,880
Functional programming is at least fun

107
00:04:47,880 --> 00:04:51,360
And we can use JavaScript to compile

108
00:04:52,760 --> 00:04:54,360
What shall we do?

109
00:04:54,360 --> 00:04:55,660
What does it mean?

110
00:04:56,400 --> 00:04:57,860
This is the question i am asking myself

111
00:04:58,460 --> 00:04:59,460
Most important

112
00:04:59,460 --> 00:05:02,960
Maybe it sounds tautological or obvious

113
00:05:02,960 --> 00:05:04,040
In functional programming

114
00:05:04,040 --> 00:05:05,840
You will want to do everything with functions

115
00:05:05,840 --> 00:05:10,440
So we use functions to express everything in the program

116
00:05:11,200 --> 00:05:12,800
Of course, the function is just a

117
00:05:12,800 --> 00:05:15,880
Something that accepts input and gives output

118
00:05:16,100 --> 00:05:17,780
So what we have to think about is

119
00:05:17,780 --> 00:05:21,480
Types of data flow for program input and output

120
00:05:21,480 --> 00:05:24,280
Rather than thinking about objects and their interactions

121
00:05:24,280 --> 00:05:25,150
And how they work

122
00:05:25,150 --> 00:05:30,000
Or compare the imperative steps to the steps on the recipe

123
00:05:30,200 --> 00:05:32,600
Here we are thinking about how to express it all

124
00:05:32,600 --> 00:05:34,050
In terms of functions

125
00:05:34,050 --> 00:05:36,050
Accept input, provide output

126
00:05:37,750 --> 00:05:39,160
for example

127
00:05:39,160 --> 00:05:42,160
This would be a non-functional way to get the text

128
00:05:42,160 --> 00:05:44,400
"Hi, I'm Anjana" appears on the screen

129
00:05:44,400 --> 00:05:49,800
I can assign a variable I call "name"

130
00:05:49,800 --> 00:05:51,400
And store the text "Anjana"

131
00:05:51,550 --> 00:05:55,520
I can say hello, such as "Hi, I am" or "Hello, I am", or something

132
00:05:55,520 --> 00:05:57,520
Then log it to the console

133
00:05:57,520 --> 00:06:00,400
It's an imperative style

134
00:06:00,400 --> 00:06:03,000
Do this first, then do that, then do this other

135
00:06:03,200 --> 00:06:04,200
No function here

136
00:06:04,200 --> 00:06:08,080
We are not expressing this in terms of how inputs are converted to outputs

137
00:06:08,980 --> 00:06:11,700
Maybe a more practical way to do the same

138
00:06:11,900 --> 00:06:14,520
This is a very simple example

139
00:06:14,800 --> 00:06:17,000
Is to define a function called greet

140
00:06:17,000 --> 00:06:19,400
With parameter name

141
00:06:19,650 --> 00:06:22,840
And return a string with "Hi, I am"

142
00:06:23,000 --> 00:06:24,840
To the beginning of the name

143
00:06:24,840 --> 00:06:26,440
For example, if I enter greet

144
00:06:26,440 --> 00:06:27,640
String Anjana

145
00:06:28,300 --> 00:06:29,360
As input

146
00:06:29,360 --> 00:06:31,360
Then I get the output "Hi, I'm Anjana"

147
00:06:31,800 --> 00:06:34,720
This is a way to express this function from a function

148
00:06:37,120 --> 00:06:39,000
OK, so ...

149
00:06:39,000 --> 00:06:41,600
Maybe the main question about functional programming

150
00:06:41,600 --> 00:06:43,800
Is to avoid side effects

151
00:06:44,100 --> 00:06:46,100
Instead, use pure functions

152
00:06:46,100 --> 00:06:47,440
What does that mean?

153
00:06:47,440 --> 00:06:50,760
Side effects are anything a function might do

154
00:06:50,760 --> 00:06:55,560
Not using your input to calculate its output

155
00:06:55,800 --> 00:06:57,560
And return that output

156
00:06:58,160 --> 00:06:59,560
E.g

157
00:07:00,300 --> 00:07:03,500
Printing something on the console is not returning output

158
00:07:03,500 --> 00:07:05,000
It is doing other things

159
00:07:05,000 --> 00:07:07,300
Something on the side of a function

160
00:07:07,700 --> 00:07:14,160
Or if your function uses some globally defined variables

161
00:07:14,160 --> 00:07:16,000
To calculate its output

162
00:07:16,000 --> 00:07:19,800
It doesn't just depend on the input of the function

163
00:07:19,800 --> 00:07:21,000
So that ’s not pure

164
00:07:21,000 --> 00:07:23,350
It gets something from outside the function

165
00:07:23,350 --> 00:07:26,000
And somehow include it in the function's function

166
00:07:26,950 --> 00:07:31,000
That's just a quick explanation of what a pure function is

167
00:07:31,000 --> 00:07:33,000
Can avoid side effects

168
00:07:34,500 --> 00:07:36,000
For more information

169
00:07:36,000 --> 00:07:39,000
There are many articles on Wikipedia about such things

170
00:07:39,200 --> 00:07:40,240
But basically

171
00:07:40,240 --> 00:07:42,100
You want your function to do nothing

172
00:07:42,100 --> 00:07:44,950
Except accepting input, use only that input to

173
00:07:44,950 --> 00:07:46,000
Calculation output

174
00:07:46,000 --> 00:07:47,000
Then return

175
00:07:47,000 --> 00:07:48,000
That is pure

176
00:07:48,700 --> 00:07:52,040
For example, this function

177
00:07:52,740 --> 00:07:56,360
We have a globally defined variable name

178
00:07:56,700 --> 00:07:58,550
Will be used in the function

179
00:07:58,550 --> 00:08:01,440
What you see in this last line

180
00:08:01,440 --> 00:08:03,500
It is used so there is no input

181
00:08:03,500 --> 00:08:06,100
We do not have a name as a parameter to this function

182
00:08:06,100 --> 00:08:08,500
It just reads some information from the global state

183
00:08:08,700 --> 00:08:09,600
That is not pure

184
00:08:09,900 --> 00:08:11,300
The reason it is impure is because

185
00:08:11,450 --> 00:08:14,450
And the return value of this function is not what we care about

186
00:08:14,450 --> 00:08:16,160
We care about doing something

187
00:08:16,160 --> 00:08:18,000
Change the world in some way

188
00:08:18,000 --> 00:08:19,100
Except return value

189
00:08:19,100 --> 00:08:21,000
In this case, print to the console

190
00:08:21,500 --> 00:08:24,120
This is not a pure function

191
00:08:24,320 --> 00:08:26,320
A pure function might look like this

192
00:08:27,900 --> 00:08:29,160
it's here

193
00:08:29,160 --> 00:08:30,660
The only thing that matters for this output

194
00:08:30,660 --> 00:08:32,900
Is its input

195
00:08:32,900 --> 00:08:36,200
The arguments we pass to it

196
00:08:36,400 --> 00:08:39,840
The only thing it has to do is return its output

197
00:08:40,940 --> 00:08:43,750
I seem to say a lot of pure functions

198
00:08:43,750 --> 00:08:47,000
Because at least for me this is really a key thing

199
00:08:47,000 --> 00:08:51,200
A key part of my functional programming

200
00:08:51,200 --> 00:08:53,900
Is to think in the purest way

201
00:08:56,200 --> 00:09:00,000
Another key point is the use of higher-order functions

202
00:09:00,250 --> 00:09:04,400
Therefore, this refers to some functions that can accept other functions as input

203
00:09:04,400 --> 00:09:07,880
A function that can return a function as an output

204
00:09:07,980 --> 00:09:11,720
Basically treat the function itself as an object

205
00:09:11,720 --> 00:09:14,400
They can be passed to other functions

206
00:09:14,400 --> 00:09:17,680
You can have layers of functions in functions

207
00:09:17,680 --> 00:09:19,380
This is the so-called higher-order function

208
00:09:19,380 --> 00:09:21,380
Often appears in functional programming

209
00:09:22,980 --> 00:09:25,500
This is a random example

210
00:09:25,500 --> 00:09:28,280
Suppose we have this function here

211
00:09:28,280 --> 00:09:30,280
makeAdjectifier

212
00:09:30,280 --> 00:09:31,780
We give it an adjective

213
00:09:32,150 --> 00:09:34,720
It actually gives back a function

214
00:09:34,820 --> 00:09:37,920
It doesn't give back strings, numbers or similar

215
00:09:37,920 --> 00:09:39,220
It gives us a function

216
00:09:39,450 --> 00:09:43,840
This will add adjectives to the string you provide

217
00:09:44,200 --> 00:09:47,840
For example, I can use the makeAdjectifier function

218
00:09:48,440 --> 00:09:50,100
Enter "cool"

219
00:09:50,250 --> 00:09:52,900
And get a function that becomes a coolifier

220
00:09:53,550 --> 00:09:56,200
When I pass the string to coolifier

221
00:09:56,750 --> 00:09:59,280
"Cool" will be added to the string

222
00:09:59,380 --> 00:10:02,720
If I write "conference", I get "cool conference"

223
00:10:03,320 --> 00:10:08,000
The concept is that we have a higher-order function

224
00:10:08,100 --> 00:10:09,200
Give back a function

225
00:10:09,750 --> 00:10:12,350
Probably digest this concept

226
00:10:12,350 --> 00:10:13,350
At least for me

227
00:10:13,350 --> 00:10:16,750
One of the keys to being able to write code in a functional style

228
00:10:16,750 --> 00:10:18,100
Because we will see later

229
00:10:18,100 --> 00:10:20,100
We need these higher order functions

230
00:10:20,100 --> 00:10:25,500
To avoid some tricks

231
00:10:25,500 --> 00:10:27,500
We are used to using from other examples

232
00:10:27,900 --> 00:10:31,280
What to learn if you want to integrate functional thinking

233
00:10:31,280 --> 00:10:34,400
For me it's about getting familiar with the concept

234
00:10:36,600 --> 00:10:37,050
it is good

235
00:10:37,050 --> 00:10:38,900
One of the things we want to avoid is

236
00:10:38,900 --> 00:10:41,200
What we are used to doing is iterating

237
00:10:41,200 --> 00:10:43,600
Use something like "for" or "while"

238
00:10:43,600 --> 00:10:47,600
We are used to iterating through a list and performing operations on all items in it

239
00:10:48,100 --> 00:10:50,600
Functional style

240
00:10:50,600 --> 00:10:55,600
We may use higher-order functions, such as Map or Reduce or Filter

241
00:10:55,600 --> 00:10:57,600
Usually as input

242
00:10:57,600 --> 00:11:01,480
Not just a list of ways to do something

243
00:11:01,680 --> 00:11:05,040
But also the function to be applied

244
00:11:06,440 --> 00:11:09,600
For the sake of time, I won't go into details

245
00:11:09,600 --> 00:11:12,250
Map, Reduce and Filter functions

246
00:11:12,250 --> 00:11:17,880
But because of my colleague Khalid, I found

247
00:11:18,100 --> 00:11:21,750
A cool graph, properly interpreting Map and Reduce

248
00:11:21,750 --> 00:11:23,150
Maybe you have seen it before

249
00:11:23,150 --> 00:11:25,550
Everyone, MapReduce sandwich!

250
00:11:26,550 --> 00:11:29,550
The idea here is, suppose you have a list

251
00:11:29,550 --> 00:11:31,750
In this case a bunch of vegetables

252
00:11:32,450 --> 00:11:33,600
Uncut, whole vegetables

253
00:11:33,600 --> 00:11:35,100
There is bread here too

254
00:11:35,550 --> 00:11:39,000
We want to transform the data somehow

255
00:11:39,000 --> 00:11:41,750
For example, we slice the data

256
00:11:41,750 --> 00:11:45,160
We have a "slice" or "cut" or "chop" function

257
00:11:45,460 --> 00:11:48,360
Apply it to every item in the list

258
00:11:48,360 --> 00:11:53,000
I usually make "vegetables for sandwiches"

259
00:11:54,150 --> 00:11:54,900
Complete these

260
00:11:54,900 --> 00:11:56,200
This is chopped

261
00:11:56,900 --> 00:12:00,000
But we will use Map in a functional style

262
00:12:00,600 --> 00:12:04,840
After giving it the list of materials, give the function "chop"

263
00:12:05,300 --> 00:12:10,360
And I will get a new list with all materials already chopped up

264
00:12:11,150 --> 00:12:12,960
Then we have a Reduce function

265
00:12:12,960 --> 00:12:18,760
Basically group all the items in the list together

266
00:12:18,760 --> 00:12:20,760
In this case, layering

267
00:12:20,760 --> 00:12:22,460
To make a delicious sandwich

268
00:12:23,100 --> 00:12:25,100
And Filter

269
00:12:25,300 --> 00:12:27,500
Maybe you hate cucumber

270
00:12:27,900 --> 00:12:29,500
You can have a Filter function

271
00:12:29,500 --> 00:12:31,500
make sure

272
00:12:32,150 --> 00:12:35,600
Only non-cucumber vegetables can pass the filter

273
00:12:36,100 --> 00:12:39,480
This is the way we use these higher order functions

274
00:12:39,480 --> 00:12:45,480
To become familiar with iterations of the type "for" or "while"

275
00:12:45,480 --> 00:12:48,300
What you are used to doing in functional programming

276
00:12:48,300 --> 00:12:51,560
We provide functions to higher-order functions

277
00:12:51,560 --> 00:12:53,160
Such as Map, Reduce and Filter

278
00:12:53,160 --> 00:12:55,000
Get the sandwich we want

279
00:12:56,000 --> 00:12:59,600
To reiterate, this is not a completely clear way of explaining

280
00:12:59,600 --> 00:13:01,400
To explain the operation of Map, Reduce and Filter

281
00:13:01,400 --> 00:13:03,800
But a lot of information on the Internet

282
00:13:03,900 --> 00:13:07,120
We want to use these instead of "for"

283
00:13:09,120 --> 00:13:11,220
Another thing we have to do is

284
00:13:11,220 --> 00:13:14,900
We need to avoid mutation data, avoid mutation

285
00:13:16,300 --> 00:13:20,280
Mutation refers to the placement of a change object

286
00:13:20,880 --> 00:13:23,500
When we have something immutable

287
00:13:23,500 --> 00:13:26,400
I believe many people are familiar with the term

288
00:13:26,400 --> 00:13:29,100
This cannot be changed by data placement

289
00:13:29,100 --> 00:13:31,850
Once set, it will always exist

290
00:13:31,850 --> 00:13:33,160
It will never change

291
00:13:34,000 --> 00:13:35,200
Let's see an example

292
00:13:35,300 --> 00:13:36,750
Because for me

293
00:13:36,750 --> 00:13:39,250
This is another thing that requires a little harder understanding

294
00:13:39,850 --> 00:13:43,600
This is an example of a non-functional mutation

295
00:13:44,550 --> 00:13:46,750
We have a room variable to store the list

296
00:13:46,750 --> 00:13:48,750
"H1", "H2" and "H3"

297
00:13:48,750 --> 00:13:50,200
Because we think the room is like that

298
00:13:50,200 --> 00:13:52,200
At least that's where I thought the room was

299
00:13:52,900 --> 00:13:56,050
It was later discovered that it was not actually "H3" but "H4"

300
00:13:56,050 --> 00:14:01,600
So let's replace the content at index [2] in the room with "H4"

301
00:14:02,200 --> 00:14:05,440
So our room has actually changed

302
00:14:05,440 --> 00:14:07,700
We start with ["H1", "H2", "H3"]

303
00:14:07,700 --> 00:14:09,200
Replaced by ["H1", "H2", "H4"]

304
00:14:09,450 --> 00:14:12,480
It is still stored in the variable "room"

305
00:14:12,480 --> 00:14:14,480
But actually we have changed some placement

306
00:14:15,300 --> 00:14:18,880
And this is avoided by functional programming

307
00:14:18,880 --> 00:14:20,880
Because this can cause a lot of problems

308
00:14:20,880 --> 00:14:23,350
This is one of the reasons why we pay special attention to this

309
00:14:23,350 --> 00:14:25,750
And through such object-oriented methods

310
00:14:25,750 --> 00:14:29,320
Sometimes you can change things in unexpected ways

311
00:14:29,420 --> 00:14:31,220
You thought you were dealing with

312
00:14:31,220 --> 00:14:34,300
If I thought the room meant ["H1", "H2", "H3"]

313
00:14:34,500 --> 00:14:36,800
And I don't know anywhere else in my code

314
00:14:36,800 --> 00:14:40,100
I have replaced something in the array of rooms

315
00:14:41,200 --> 00:14:42,600
I may be in trouble

316
00:14:42,600 --> 00:14:44,900
I may end up introducing errors in the code

317
00:14:44,900 --> 00:14:46,900
And it ’s hard to track them

318
00:14:46,900 --> 00:14:48,800
Because the room here is right

319
00:14:48,800 --> 00:14:50,080
The room there is wrong

320
00:14:50,080 --> 00:14:52,080
what! What happened? What went wrong?

321
00:14:52,080 --> 00:14:52,900
My goodness!

322
00:14:52,900 --> 00:14:54,400
Crying in front of the computer

323
00:14:54,600 --> 00:14:55,400
No, that's just me

324
00:14:56,600 --> 00:14:58,800
So a better way

325
00:14:58,800 --> 00:15:02,120
Is to treat all data as constant and never change

326
00:15:02,900 --> 00:15:04,120
E.g

327
00:15:04,820 --> 00:15:08,360
Even if nothing changes, we still have the wrong room

328
00:15:08,360 --> 00:15:09,860
["H1", "H2", "H3"]

329
00:15:10,100 --> 00:15:11,600
But instead of changing its position

330
00:15:11,600 --> 00:15:13,600
I want to sort out a new room array

331
00:15:13,950 --> 00:15:15,600
Use this map function

332
00:15:15,600 --> 00:15:17,600
Is what we mentioned just now

333
00:15:17,950 --> 00:15:19,600
Where I want to map

334
00:15:20,050 --> 00:15:24,360
I'm adding functions to the map

335
00:15:24,760 --> 00:15:28,100
It will look at each room in the list

336
00:15:28,600 --> 00:15:30,200
If it is "H3"

337
00:15:30,800 --> 00:15:33,000
Ugh! I am missing an = sign

338
00:15:33,000 --> 00:15:34,300
This is the temporary slideshow ...

339
00:15:34,500 --> 00:15:39,690
If the room is "H3", return "H4" instead of "H3"

340
00:15:39,790 --> 00:15:42,090
Otherwise the room prototype is returned

341
00:15:43,000 --> 00:15:46,440
OK, it ’s not important to understand this example

342
00:15:46,600 --> 00:15:50,840
But the point is, once I assign this new room variable

343
00:15:50,840 --> 00:15:55,560
New rooms have correct values ​​should be "H1", "H2" and "H4"

344
00:15:55,560 --> 00:15:58,800
But the room is the same as before

345
00:15:58,800 --> 00:16:00,000
No change at all

346
00:16:00,300 --> 00:16:02,550
This is the same as the room

347
00:16:02,550 --> 00:16:03,800
We will not change it

348
00:16:03,950 --> 00:16:07,380
This is very important for functional programming

349
00:16:07,580 --> 00:16:08,350
As i said

350
00:16:08,350 --> 00:16:10,750
It can help you avoid a lot of trouble and many mistakes

351
00:16:12,650 --> 00:16:14,650
How much time do I have?

352
00:16:14,650 --> 00:16:15,300
it is good

353
00:16:15,300 --> 00:16:18,160
We have some time to talk about persistent data structures

354
00:16:19,100 --> 00:16:21,760
The problem with invariance is

355
00:16:21,760 --> 00:16:25,760
When you treat arrays and things like this as invariant

356
00:16:25,860 --> 00:16:28,900
What you end up doing is making everything

357
00:16:29,000 --> 00:16:32,680
If I want to change a room in this list

358
00:16:32,680 --> 00:16:34,680
I have to make a whole new array

359
00:16:35,700 --> 00:16:38,350
When you deal with small things like this

360
00:16:38,350 --> 00:16:39,450
Maybe it's not a big deal

361
00:16:39,450 --> 00:16:42,000
But as objects grow larger and more complex

362
00:16:42,200 --> 00:16:44,600
This brings efficiency issues

363
00:16:44,600 --> 00:16:46,600
Because if you want to copy everything

364
00:16:46,600 --> 00:16:48,600
Things that haven't even changed

365
00:16:48,800 --> 00:16:51,050
Every time you make a small adjustment

366
00:16:51,050 --> 00:16:52,950
You want to have a new copy

367
00:16:52,950 --> 00:16:55,720
Will cost you a lot of time

368
00:16:56,320 --> 00:16:58,720


369
00:16:58,720 --> 00:17:01,100
Must read everything in the list carefully to copy it

370
00:17:01,100 --> 00:17:03,300
Will eventually take up a lot of space

371
00:17:03,300 --> 00:17:05,960
Maybe once objects start to grow

372
00:17:05,960 --> 00:17:07,560
It will be a problem

373
00:17:08,100 --> 00:17:13,520
One thing that is very popular in the functional world

374
00:17:13,720 --> 00:17:16,720
One way to address these efficiency issues

375
00:17:17,100 --> 00:17:19,300
Is to use persistent data structures

376
00:17:20,200 --> 00:17:24,950
This is what Phil Bagwell introduced theoretically

377
00:17:24,950 --> 00:17:27,100
He wrote a paper called The Ideal Hash Tree

378
00:17:28,200 --> 00:17:30,100
After that I can put a link in the slide

379
00:17:30,300 --> 00:17:33,640
Rich Hickey, Clojure

380
00:17:34,100 --> 00:17:38,320
Data structure implemented using Bagwell's idea

381
00:17:38,720 --> 00:17:43,500
Make Clojure more efficient for these immutable data structures

382
00:17:43,500 --> 00:17:45,500
And these functional operations

383
00:17:46,100 --> 00:17:46,400
it is good

384
00:17:46,400 --> 00:17:49,800
Persistent data structure operation

385
00:17:49,800 --> 00:17:50,800
If you indulge me

386
00:17:50,800 --> 00:17:53,400
I will use this blackboard

387
00:17:53,800 --> 00:17:56,100
We go retro type yes that's happening

388
00:17:58,100 --> 00:17:58,400
it is good

389
00:17:58,400 --> 00:18:06,560
If we have an array with H1, H2, H3

390
00:18:08,000 --> 00:18:12,120
Usually what I do in a variable world is get rid of this

391
00:18:12,120 --> 00:18:14,120
And use H4 instead

392
00:18:14,700 --> 00:18:16,320
But as we said, we want to avoid this

393
00:18:16,320 --> 00:18:23,800
If I copy it into a new array

394
00:18:23,800 --> 00:18:25,800
I copy H1

395
00:18:25,800 --> 00:18:27,800
I copy H2

396
00:18:28,000 --> 00:18:31,800
Then I replaced, instead of copying H3, I put in H4

397
00:18:31,950 --> 00:18:32,200
Great!

398
00:18:32,200 --> 00:18:34,100
But now I have to store two arrays

399
00:18:34,100 --> 00:18:35,200
Took a lot of time

400
00:18:35,200 --> 00:18:37,200
See how long it took me to do all this

401
00:18:37,500 --> 00:18:38,480
Isn't it?

402
00:18:38,480 --> 00:18:41,100
I know you are as unhappy about it as I am

403
00:18:41,100 --> 00:18:42,500
Your expression tells me

404
00:18:43,700 --> 00:18:50,840
Conversely, if we represent this array as a tree

405
00:18:54,400 --> 00:18:59,400
Every leaf node of this tree

406
00:18:59,400 --> 00:19:02,000
Is one of the things I want to save

407
00:19:02,200 --> 00:19:06,680
Maybe one of two or three or even 32 things

408
00:19:07,100 --> 00:19:09,720
If I want to change something

409
00:19:09,720 --> 00:19:12,300
I don't need to replace the entire array

410
00:19:12,550 --> 00:19:16,680
I just need to create a new node, like this H4

411
00:19:17,280 --> 00:19:19,900
I can make a new tree

412
00:19:19,900 --> 00:19:25,400
Repeat H1 and H2 instead

413
00:19:25,400 --> 00:19:29,840
I can use the same thing and just build new nodes

414
00:19:29,840 --> 00:19:33,160
Connect them to this new element

415
00:19:33,700 --> 00:19:41,840
So now I have a data structure containing H1, H2 and H4

416
00:19:42,150 --> 00:19:45,560
But there is no need to rebuild

417
00:19:45,760 --> 00:19:48,300
I only need to change a small part

418
00:19:48,300 --> 00:19:51,360
And reuse the old structure of lists

419
00:19:51,600 --> 00:19:56,400
This concept or theme is called structural sharing

420
00:19:56,400 --> 00:20:01,160
Because we can share some parts with the old and new versions

421
00:20:01,560 --> 00:20:04,500
Allows us to add more efficiently

422
00:20:04,500 --> 00:20:08,840
Change or move things from a vector or array

423
00:20:09,500 --> 00:20:15,480
This can also be used for things like maps, hash maps, etc.

424
00:20:15,780 --> 00:20:19,980
Basically expands the functional programming world

425
00:20:19,980 --> 00:20:23,040
So we do n’t need to waste time

426
00:20:23,040 --> 00:20:25,040
And expensive space

427
00:20:25,040 --> 00:20:28,800
To keep updating our constant data

428
00:20:29,250 --> 00:20:32,120
So, to do this in JavaScript

429
00:20:32,320 --> 00:20:34,720
There are several very popular libraries

430
00:20:35,000 --> 00:20:37,400
I especially like Mori

431
00:20:37,550 --> 00:20:39,400
Show you the link later

432
00:20:39,400 --> 00:20:41,880
It actually uses ClojureScript

433
00:20:41,880 --> 00:20:44,600
Has this kind of data structure

434
00:20:44,800 --> 00:20:46,800
After porting them to JavaScript

435
00:20:46,800 --> 00:20:48,800
Use them directly from JavaScript

436
00:20:48,800 --> 00:20:49,560
it's great

437
00:20:49,560 --> 00:20:52,900
It also has many general-purpose functional programming helpers

438
00:20:52,900 --> 00:20:55,600
Such as Map and Reduce and many other things

439
00:20:55,950 --> 00:20:58,800
There is another popular library called Immutable.js

440
00:20:58,800 --> 00:20:59,880
It was launched by Facebook

441
00:20:59,880 --> 00:21:02,480
Is complete JavaScript

442
00:21:02,680 --> 00:21:04,380
I have no experience myself

443
00:21:04,380 --> 00:21:06,380
But I know many people like it too

444
00:21:06,680 --> 00:21:08,580
Yes so these are

445
00:21:08,580 --> 00:21:11,000
You can try to use immutable data structures

446
00:21:11,000 --> 00:21:14,880
If you feel impatient

447
00:21:16,100 --> 00:21:16,600
I understand

448
00:21:16,600 --> 00:21:19,200
I can feel your excitement yes, great

449
00:21:19,200 --> 00:21:20,800
Ok we continue

450
00:21:21,700 --> 00:21:23,200
If you are ready to try

451
00:21:24,100 --> 00:21:27,600
As I said, we have Mori and Immutable.js

452
00:21:28,000 --> 00:21:29,600
Links to these libraries

453
00:21:29,850 --> 00:21:31,700
There are also many utility libraries

454
00:21:31,700 --> 00:21:34,800
Don't pay too much attention to this persistent data structure

455
00:21:34,950 --> 00:21:41,000
Instead give you a lot of help functions such as Map, Reduce, etc.

456
00:21:42,300 --> 00:21:45,360
For example Underscore, Lodash

457
00:21:45,560 --> 00:21:48,000
Today I discovered that Ramda is one thing

458
00:21:48,500 --> 00:21:50,300
Because a few days ago there was a talk about Ramda

459
00:21:50,550 --> 00:21:51,700
there are more

460
00:21:51,900 --> 00:21:55,900
In fact, Javascript has some built-in functions

461
00:21:55,900 --> 00:22:00,300
For example, arrays have built-in Map, Reduce functions

462
00:22:00,300 --> 00:22:04,160
A few slides ago we saw this room.map

463
00:22:04,700 --> 00:22:09,280
This is because the array prototype has these functions Map, Reduce, etc.

464
00:22:09,400 --> 00:22:13,000
You can even do some functional programming with pure JavaScript

465
00:22:13,000 --> 00:22:15,000
No need to use any libraries

466
00:22:17,150 --> 00:22:17,650
it is good

467
00:22:17,650 --> 00:22:20,340
If you sit there and think

468
00:22:20,340 --> 00:22:24,850
what? I don't understand immutability

469
00:22:24,850 --> 00:22:27,000
Side effects, what about pure functions now

470
00:22:27,400 --> 00:22:32,240
If you want to learn more about all these popular words

471
00:22:32,240 --> 00:22:33,900
Like I said, all these catchy buzzwords

472
00:22:33,900 --> 00:22:36,400
It's the word I've been throwing at you for the past twenty minutes

473
00:22:36,800 --> 00:22:41,000
I highly recommend a good introductory article called

474
00:22:41,000 --> 00:22:43,000
"Introduction to Functional Programming"

475
00:22:43,100 --> 00:22:44,300
Written by Mary Rose Cook

476
00:22:44,300 --> 00:22:47,000
A former promoter at The Recurse Center

477
00:22:47,000 --> 00:22:48,000
Is what I keep mentioning

478
00:22:48,850 --> 00:22:50,300
Link there

479
00:22:50,300 --> 00:22:54,040
But basically this is a very good introduction

480
00:22:54,040 --> 00:22:56,400
Some more depth

481
00:22:56,400 --> 00:23:00,000
Some "commandments" for functional programming

482
00:23:00,000 --> 00:23:01,280
I also mentioned today

483
00:23:01,480 --> 00:23:04,380
If you are a little curious

484
00:23:04,380 --> 00:23:07,680
But it ’s not clear what I mentioned

485
00:23:07,680 --> 00:23:09,080
I highly recommend you take a look

486
00:23:10,180 --> 00:23:13,280
I guess that ’s all for my speech

487
00:23:13,780 --> 00:23:16,600
We should have a few minutes to answer the question

488
00:23:16,600 --> 00:23:18,000
About eight minutes

489
00:23:18,300 --> 00:23:21,700
But first I really want to thank you

490
00:23:22,200 --> 00:23:23,600
My name is Anjana Vakil

491
00:23:23,600 --> 00:23:25,100
Anjana Vakil on Twitter

492
00:23:25,100 --> 00:23:26,700
There is a link to my GitHub

493
00:23:26,700 --> 00:23:28,600
Would love to stay in touch

494
00:23:28,600 --> 00:23:30,800
If anyone is learning

495
00:23:30,800 --> 00:23:33,680
Functional Javascript, newbie like me

496
00:23:33,980 --> 00:23:35,280
Welcome to contact me

497
00:23:35,280 --> 00:23:36,520
Can support each other

498
00:23:37,000 --> 00:23:39,200
I want to thank in particular

499
00:23:39,200 --> 00:23:41,800
JSUnconf Organizer

500
00:23:41,800 --> 00:23:43,550
Especially these diverse sponsors

501
00:23:43,550 --> 00:23:45,650
I was also sponsored

502
00:23:45,650 --> 00:23:48,100
It should not come without a great agenda

503
00:23:48,400 --> 00:23:52,120
And all the sponsors who sponsored these tickets

504
00:23:52,420 --> 00:23:55,000
Special thanks to The Recurse Center

505
00:23:55,000 --> 00:23:58,250
And alumni who helped me learn so much

506
00:23:58,250 --> 00:24:00,250
Including the latter, Khalid

507
00:24:00,700 --> 00:24:02,850
There is another alumni Sal Becker

508
00:24:02,850 --> 00:24:04,850
Think i explained a lot about this

509
00:24:04,850 --> 00:24:08,700
After a lot of conversation at The Recurse Center

510
00:24:09,100 --> 00:24:12,100
If you are interested in spending time

511
00:24:12,100 --> 00:24:18,280
Self-directed educational programming seminar in New York

512
00:24:18,280 --> 00:24:20,480
Be sure to check out recurse.com

513
00:24:20,480 --> 00:24:22,000
Is an amazing group

514
00:24:22,650 --> 00:24:24,840
Ok, that's it, thank you

515
00:24:24,840 --> 00:24:33,000
[applause]

516
00:24:33,500 --> 00:24:35,000
Thank you very much

517
00:24:35,300 --> 00:24:37,000
Yes,_____

518
00:24:37,000 --> 00:24:41,300
Does anyone have any questions about functional programming?

519
00:24:43,200 --> 00:24:45,300
I don't know if I can answer it, but I can try

520
00:24:45,700 --> 00:24:46,440
Yes

521
00:24:55,100 --> 00:24:57,600
Actually, my professors

522
00:24:57,600 --> 00:24:59,600
Always say object-oriented programming

523
00:24:59,600 --> 00:25:02,880
Better than functional programming

524
00:25:03,280 --> 00:25:06,100
I was thinking that would be better

525
00:25:06,100 --> 00:25:08,100
Or do you think we should use

526
00:25:08,100 --> 00:25:09,900
Functional programming on JavaScript only

527
00:25:09,900 --> 00:25:14,100
Or other programming language such as C _____

528
00:25:15,600 --> 00:25:16,800
I think this is a good question

529
00:25:16,800 --> 00:25:19,000
Kind of entered

530
00:25:19,650 --> 00:25:23,000
I think this is a programming paradigm

531
00:25:23,300 --> 00:25:25,800
When I was learning functional programming

532
00:25:26,300 --> 00:25:29,240
I even started to wonder what a programming paradigm was

533
00:25:29,240 --> 00:25:31,000
Why do people argue about them

534
00:25:31,000 --> 00:25:33,300
Why people hate functional programming

535
00:25:33,300 --> 00:25:34,720
We have to do it functionally

536
00:25:34,720 --> 00:25:37,120
Why do n’t people think that functional programming sucks

537
00:25:37,120 --> 00:25:38,820
We need object oriented

538
00:25:38,820 --> 00:25:41,820
I came to the conclusion

539
00:25:42,620 --> 00:25:46,650
No one is better or worse than the others

540
00:25:46,650 --> 00:25:49,280
They just have different advantages and disadvantages

541
00:25:49,280 --> 00:25:51,180
And different situations

542
00:25:51,180 --> 00:25:54,820
They will be the best tools

543
00:25:55,100 --> 00:25:56,520
To solve that problem

544
00:25:56,820 --> 00:25:59,750
For example, if you want to write scripts quickly

545
00:25:59,750 --> 00:26:03,240
I did it quickly on your computer

546
00:26:03,540 --> 00:26:05,540
You may only do it in an imperative way

547
00:26:05,540 --> 00:26:07,240
Do this, then do that, then do another thing

548
00:26:07,240 --> 00:26:08,300
If you don't need to maintain it

549
00:26:08,300 --> 00:26:10,000
Just need it to happen there

550
00:26:10,120 --> 00:26:13,600
Imperative programming is a perfectly legal paradigm

551
00:26:14,100 --> 00:26:17,300
If you want to model real objects

552
00:26:17,300 --> 00:26:18,700
And how they interact

553
00:26:18,700 --> 00:26:22,100
How they work and what you can do

554
00:26:22,100 --> 00:26:24,100
It ’s like modeling, I do n’t know ...

555
00:26:24,500 --> 00:26:26,100
Library book

556
00:26:26,100 --> 00:26:29,850
Or teacher and students

557
00:26:29,850 --> 00:26:31,850
And how they are related to each other

558
00:26:32,260 --> 00:26:36,080
Maybe it makes most sense to consider it in an object-oriented way

559
00:26:36,380 --> 00:26:38,700
Because that's the problem you want to solve

560
00:26:38,700 --> 00:26:40,000
Object is being modeled

561
00:26:40,200 --> 00:26:42,000
Is the origin of this paradigm

562
00:26:43,000 --> 00:26:46,080
But if you want to avoid some of them

563
00:26:46,080 --> 00:26:46,960
That's what i said

564
00:26:46,960 --> 00:26:48,960
When you may have something

565
00:26:48,960 --> 00:26:51,560
Does not involve real objects

566
00:26:51,560 --> 00:26:54,240
It ’s because of what needs to be used

567
00:26:54,240 --> 00:26:57,440
And this brings all kinds of side effects and weird errors

568
00:26:57,440 --> 00:26:58,800
It's hard to track

569
00:26:59,000 --> 00:27:00,900
Then maybe you have to think again

570
00:27:00,900 --> 00:27:03,050
Functions on data

571
00:27:03,050 --> 00:27:05,550
Passing things through multiple functions

572
00:27:05,550 --> 00:27:09,150
And went through various transformations

573
00:27:09,150 --> 00:27:12,400
Not that the data is changing

574
00:27:12,400 --> 00:27:14,850
However based on old input

575
00:27:14,850 --> 00:27:16,850
We are getting new output

576
00:27:16,950 --> 00:27:19,850
Then functional programming might be the way

577
00:27:19,850 --> 00:27:23,700
And it has a lot of points for example

578
00:27:24,250 --> 00:27:28,200
You can break things into small functions that only do one thing

579
00:27:28,200 --> 00:27:29,900
If you want to change something

580
00:27:29,900 --> 00:27:32,960
You don't have to change the structure of the entire class

581
00:27:32,960 --> 00:27:34,800
Just change a small function

582
00:27:34,800 --> 00:27:36,400
That function is responsible for doing what you want to change

583
00:27:36,700 --> 00:27:40,440
I think this has its advantages and disadvantages

584
00:27:40,800 --> 00:27:44,780
Nor would it say that it is better than object-oriented in all cases

585
00:27:44,780 --> 00:27:48,440
But I wouldn't say it is better to target in all cases

586
00:27:48,740 --> 00:27:51,240
It really depends on your situation

587
00:27:52,000 --> 00:27:54,800
It also introduced the programming principles very well.

588
00:27:54,800 --> 00:27:58,760
I used to be a philosophy major, maybe it ’s why

589
00:27:59,760 --> 00:28:01,000
Do you have any other questions?

590
00:28:10,600 --> 00:28:12,000
You mentioned the Map function

591
00:28:12,000 --> 00:28:14,200
And the Map function does not work properly

592
00:28:14,200 --> 00:28:17,000
Then do you mix ...

593
00:28:18,500 --> 00:28:22,240
Previously, I was more familiar with object-oriented programming style

594
00:28:22,240 --> 00:28:25,160
Instead of over-functional

595
00:28:25,960 --> 00:28:27,160
That's pretty cool

596
00:28:27,160 --> 00:28:31,000
Teaching knowledge to test our function

597
00:28:31,000 --> 00:28:34,120
Can also avoid concurrency

598
00:28:34,120 --> 00:28:37,500
Map functions may introduce features

599
00:28:38,500 --> 00:28:42,600
Non-blocking, concurrency and commitment

600
00:28:42,600 --> 00:28:46,520
I do n’t think I am qualified to talk here

601
00:28:46,720 --> 00:28:49,800
I want to leave this question to the audience

602
00:28:49,800 --> 00:28:51,400
Does anyone have a response?

603
00:28:52,900 --> 00:29:10,900
_____

604
00:29:10,900 --> 00:29:12,400
Fight, fight, fight

605
00:29:12,400 --> 00:29:14,400
Just kidding

606
00:29:15,100 --> 00:29:16,400
Kidding i'm just kidding

607
00:29:16,400 --> 00:29:18,800
It will break the rules

608
00:29:18,800 --> 00:29:22,000
_____

609
00:29:22,000 --> 00:29:25,520
I guess it might be a hindrance to the conversation here

610
00:29:25,520 --> 00:29:29,800
But we can discuss outside or in a small room later

611
00:29:29,800 --> 00:29:31,600
[laughter]

612
00:29:31,600 --> 00:29:35,440
Thank you for your opening question

613
00:29:35,640 --> 00:29:36,500
That is a good question

614
00:29:36,500 --> 00:29:38,300
I also want to know the answer

615
00:29:38,800 --> 00:29:40,500
Looking forward to having more communication with you

616
00:29:41,100 --> 00:29:42,000
I guess...

617
00:29:42,000 --> 00:29:46,320
That's it for our speech today

618
00:29:46,320 --> 00:29:46,920
thank you all

619
00:29:46,920 --> 00:29:48,120
thanks again

