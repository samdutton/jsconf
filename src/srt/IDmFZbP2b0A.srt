1
00:00:15,580 --> 00:00:17,560

so I'm Michael is the shoe here we both

2
00:00:17,560 --> 00:00:21,300
worked on Lola with JavaScript and I

3
00:00:21,300 --> 00:00:24,070
guess it's a programming language right

4
00:00:24,070 --> 00:00:25,150
it's not the mobile world's most

5
00:00:25,150 --> 00:00:26,920
beautiful programming language it's

6
00:00:26,920 --> 00:00:29,230
still JavaScript however so you can so a

7
00:00:29,230 --> 00:00:32,379
low-level JavaScript now well JavaScript

8
00:00:32,379 --> 00:00:35,980
program will just part us as a low-level

9
00:00:35,980 --> 00:00:37,300
JavaScript program so you can actually

10
00:00:37,300 --> 00:00:39,460
it's just JavaScript with semantic type

11
00:00:39,460 --> 00:00:41,890
annotations and what is it for what's it

12
00:00:41,890 --> 00:00:44,650
good for well it's only the real purpose

13
00:00:44,650 --> 00:00:46,269
of it is to let you write sort of memory

14
00:00:46,269 --> 00:00:49,510
efficient code in JavaScript a little

15
00:00:49,510 --> 00:00:51,790
bit less painfully and of course it

16
00:00:51,790 --> 00:00:54,159
compiles to JavaScript so here's my

17
00:00:54,159 --> 00:00:55,900
favorite data structure that I learned

18
00:00:55,900 --> 00:00:57,760
when I started computer science it's a

19
00:00:57,760 --> 00:01:01,059
linked list so can anyone see the the

20
00:01:01,059 --> 00:01:03,220
code all right so this is how I would

21
00:01:03,220 --> 00:01:05,890
write a linked list in JavaScript now if

22
00:01:05,890 --> 00:01:08,200
you wanted to create say a linked list

23
00:01:08,200 --> 00:01:10,810
of 40 million JavaScript objects which

24
00:01:10,810 --> 00:01:12,070
is quite impressive that you can do it

25
00:01:12,070 --> 00:01:14,229
so quickly it takes about two to four

26
00:01:14,229 --> 00:01:16,810
seconds in either spider monkey spider

27
00:01:16,810 --> 00:01:19,990
monkey or and v8 which is pretty good

28
00:01:19,990 --> 00:01:22,090
but if you actually look at what's going

29
00:01:22,090 --> 00:01:24,340
on here is the JavaScript every

30
00:01:24,340 --> 00:01:25,810
individual JavaScript object is quite

31
00:01:25,810 --> 00:01:28,930
fat right it has a as a header which

32
00:01:28,930 --> 00:01:30,250
contains some sort of type information

33
00:01:30,250 --> 00:01:32,830
either pointed to the prototype or some

34
00:01:32,830 --> 00:01:33,970
data structure that maintains this

35
00:01:33,970 --> 00:01:35,830
information about the object perhaps

36
00:01:35,830 --> 00:01:38,860
some GC flags it has several properties

37
00:01:38,860 --> 00:01:41,770
in it so on a little in the linked list

38
00:01:41,770 --> 00:01:44,770
example we had only we were only seeing

39
00:01:44,770 --> 00:01:46,540
two properties but it may be that the

40
00:01:46,540 --> 00:01:48,610
object when it was first created had

41
00:01:48,610 --> 00:01:50,920
more properties in it perhaps slots to

42
00:01:50,920 --> 00:01:52,390
hold these four properties because

43
00:01:52,390 --> 00:01:54,250
objects are extensible and each

44
00:01:54,250 --> 00:01:56,700
individual property within the object

45
00:01:56,700 --> 00:01:59,229
could sometimes be up to four bytes long

46
00:01:59,229 --> 00:02:00,760
eight bytes long right because you can

47
00:02:00,760 --> 00:02:02,770
have a store into double perhaps a

48
00:02:02,770 --> 00:02:05,229
reference so they're quite fat so if you

49
00:02:05,229 --> 00:02:06,479
look at what this looks like in memory

50
00:02:06,479 --> 00:02:09,640
you just end up with these very fat sort

51
00:02:09,640 --> 00:02:10,959
of JavaScript objects and you can

52
00:02:10,959 --> 00:02:13,440
represent this much more efficiently

53
00:02:13,440 --> 00:02:15,819
with using some sort of an array data

54
00:02:15,819 --> 00:02:17,470
structure right so you can just allocate

55
00:02:17,470 --> 00:02:19,000
little notes than the array and then you

56
00:02:19,000 --> 00:02:21,640
can use you can treat pointers offsets

57
00:02:21,640 --> 00:02:23,130
within the array and you do some like

58
00:02:23,130 --> 00:02:26,489
really ugly JavaScript

59
00:02:26,489 --> 00:02:28,629
code to sort of manipulate this data

60
00:02:28,629 --> 00:02:30,400
structure now you can do is very

61
00:02:30,400 --> 00:02:32,140
efficiently so one thing we learn from

62
00:02:32,140 --> 00:02:34,180
em scripting is that using typed arrays

63
00:02:34,180 --> 00:02:35,560
you can add some model memory pretty

64
00:02:35,560 --> 00:02:37,840
efficiently so I guess I don't have to

65
00:02:37,840 --> 00:02:39,129
explain typed arrays but it's actually

66
00:02:39,129 --> 00:02:41,200
just a real quick just allow me to

67
00:02:41,200 --> 00:02:44,500
overlay different views on an array

68
00:02:44,500 --> 00:02:46,840
buffer so essentially the way although

69
00:02:46,840 --> 00:02:49,120
Jess work so we just you sort of request

70
00:02:49,120 --> 00:02:51,250
a memory module what allocates so you

71
00:02:51,250 --> 00:02:53,500
want 32 megabytes or so and then it

72
00:02:53,500 --> 00:02:55,150
gives you ability to read and write in

73
00:02:55,150 --> 00:02:57,430
this data in this write buffer using

74
00:02:57,430 --> 00:03:00,069
these views now okay so the previous

75
00:03:00,069 --> 00:03:02,349
example if you want to write it in c

76
00:03:02,349 --> 00:03:04,480
like way you basically write this kind

77
00:03:04,480 --> 00:03:10,329
of JavaScript so here you essentially

78
00:03:10,329 --> 00:03:13,269
like p you disappointed to the first

79
00:03:13,269 --> 00:03:15,430
object and the p glass is supporting

80
00:03:15,430 --> 00:03:17,049
index to the last object in the

81
00:03:17,049 --> 00:03:20,409
ArrayList into the in 32 array and you

82
00:03:20,409 --> 00:03:23,019
need to sort of like manual pointer

83
00:03:23,019 --> 00:03:25,060
assignments and so on now if you ran

84
00:03:25,060 --> 00:03:26,680
this kind of code in spider monkey or in

85
00:03:26,680 --> 00:03:28,959
v8 it's about 10 times faster than the

86
00:03:28,959 --> 00:03:31,480
previous example so which is quite a big

87
00:03:31,480 --> 00:03:33,699
difference now this is obviously for

88
00:03:33,699 --> 00:03:35,530
several reasons so but what is more

89
00:03:35,530 --> 00:03:38,579
interesting is the memory usage so I

90
00:03:38,579 --> 00:03:42,400
sort of an I used that addy trace probe

91
00:03:42,400 --> 00:03:43,750
to sort of measure an amount of memory

92
00:03:43,750 --> 00:03:46,629
that's requested form the operating

93
00:03:46,629 --> 00:03:48,879
system by both spider monkey and v8 and

94
00:03:48,879 --> 00:03:51,790
for the an example with objects it's

95
00:03:51,790 --> 00:03:54,940
about two point four gigabytes right the

96
00:03:54,940 --> 00:03:56,319
actual amount of data that we really

97
00:03:56,319 --> 00:03:58,060
need is about only about 300 megabytes

98
00:03:58,060 --> 00:04:02,169
right but the amount of the matter of

99
00:04:02,169 --> 00:04:04,000
sort of memory requested is much much

100
00:04:04,000 --> 00:04:06,729
larger so it's about 8.2 four times and

101
00:04:06,729 --> 00:04:09,220
spider monkey and if v8 it's about 13 or

102
00:04:09,220 --> 00:04:11,979
so now this does this is virtual memory

103
00:04:11,979 --> 00:04:14,500
so I'm not saying the vengers really

104
00:04:14,500 --> 00:04:16,510
used this much memory but you know it's

105
00:04:16,510 --> 00:04:19,269
still quite significant if you were to

106
00:04:19,269 --> 00:04:21,519
program the same thing using structs you

107
00:04:21,519 --> 00:04:23,169
would end up with only about a 1.3 x

108
00:04:23,169 --> 00:04:26,380
sort of memory overhead so in either

109
00:04:26,380 --> 00:04:27,789
case both like the difference between

110
00:04:27,789 --> 00:04:30,120
using objects instructs is about 8x

111
00:04:30,120 --> 00:04:32,530
somewhere between four and eight X which

112
00:04:32,530 --> 00:04:34,630
is quite significant I think so

113
00:04:34,630 --> 00:04:36,130
basically we want to do is like can you

114
00:04:36,130 --> 00:04:38,020
just write this kind of code in

115
00:04:38,020 --> 00:04:39,070
JavaScript

116
00:04:39,070 --> 00:04:42,340
and I understand it's extremely ugly to

117
00:04:42,340 --> 00:04:44,740
seek seek pointers and arrows and stuff

118
00:04:44,740 --> 00:04:46,180
right but it kind of fits into the

119
00:04:46,180 --> 00:04:48,280
syntax we really only need to do is just

120
00:04:48,280 --> 00:04:49,900
sort of add these like see style type

121
00:04:49,900 --> 00:04:52,330
annotations in front of variable

122
00:04:52,330 --> 00:04:56,140
declarations okay so we sort of tweeted

123
00:04:56,140 --> 00:04:57,220
about this we worked on it for like

124
00:04:57,220 --> 00:04:59,860
three weeks tweeted and then could

125
00:04:59,860 --> 00:05:01,510
imagine like the tweets right so what

126
00:05:01,510 --> 00:05:03,190
have we done the world just wrapped

127
00:05:03,190 --> 00:05:07,090
around and swallowed its own tail this

128
00:05:07,090 --> 00:05:08,530
is my favorite sometimes you just want

129
00:05:08,530 --> 00:05:10,300
to tell people please instead of doing

130
00:05:10,300 --> 00:05:12,250
this go volunteer a soup kitchen or

131
00:05:12,250 --> 00:05:15,400
something and I totally agree it's crazy

132
00:05:15,400 --> 00:05:17,620
crazy all right so how this all get

133
00:05:17,620 --> 00:05:18,790
started well when I was working on

134
00:05:18,790 --> 00:05:22,390
Broadway Jess I was really surprised the

135
00:05:22,390 --> 00:05:23,680
fact that like you can actually write a

136
00:05:23,680 --> 00:05:26,530
codec in JavaScript and without any sort

137
00:05:26,530 --> 00:05:29,080
of like interruptions I mean the frames

138
00:05:29,080 --> 00:05:31,300
were like I mean it was not as efficient

139
00:05:31,300 --> 00:05:33,250
obviously a see but you had no GC pauses

140
00:05:33,250 --> 00:05:34,860
which is kind of really important for

141
00:05:34,860 --> 00:05:38,890
doing that kind of programming so we

142
00:05:38,890 --> 00:05:40,150
sort of looked at I'm script and so can

143
00:05:40,150 --> 00:05:41,740
we just take sort of the good parts of

144
00:05:41,740 --> 00:05:44,770
em script and I mean it's great but it

145
00:05:44,770 --> 00:05:46,990
still relies on a C and C++ to change so

146
00:05:46,990 --> 00:05:47,800
if you want actually want to integrate

147
00:05:47,800 --> 00:05:49,270
write some code like this in your

148
00:05:49,270 --> 00:05:50,620
JavaScript program so you have to rely

149
00:05:50,620 --> 00:05:53,200
on the C and C++ toolchain and then use

150
00:05:53,200 --> 00:05:56,710
llvm and compile to JavaScript so can't

151
00:05:56,710 --> 00:05:59,500
we just sort of why not just take the c

152
00:05:59,500 --> 00:06:00,970
and java script and add them together

153
00:06:00,970 --> 00:06:04,270
and we came up with LHS this is sort of

154
00:06:04,270 --> 00:06:06,070
well originally named of star yes but

155
00:06:06,070 --> 00:06:07,120
then everyone complained that they

156
00:06:07,120 --> 00:06:09,370
couldn't google it so we changed it like

157
00:06:09,370 --> 00:06:12,100
the next day all right so what do you

158
00:06:12,100 --> 00:06:13,240
really get well the first thing you get

159
00:06:13,240 --> 00:06:14,560
is there's no more of our statements it

160
00:06:14,560 --> 00:06:16,540
just lets write this is sort of make it

161
00:06:16,540 --> 00:06:19,780
look more like me now c c sharp java and

162
00:06:19,780 --> 00:06:22,630
so on block scoping you get machine

163
00:06:22,630 --> 00:06:25,210
types so if you declare a variable y

164
00:06:25,210 --> 00:06:27,010
which is the maximum injure sighs and

165
00:06:27,010 --> 00:06:29,500
you add one to it you don't get sort of

166
00:06:29,500 --> 00:06:31,390
overflow into a double you just end up

167
00:06:31,390 --> 00:06:35,410
with zero you can declare structs like

168
00:06:35,410 --> 00:06:38,500
you would expect and C in C the C basic

169
00:06:38,500 --> 00:06:42,160
well sort of see ish with declaring your

170
00:06:42,160 --> 00:06:44,050
functions within the stroke

171
00:06:44,050 --> 00:06:45,940
and here I should have done is

172
00:06:45,940 --> 00:06:49,120
overridden this sort of to mean a

173
00:06:49,120 --> 00:06:51,280
pointer to the vector struct rather than

174
00:06:51,280 --> 00:06:54,340
JavaScript is but so essentially this

175
00:06:54,340 --> 00:06:56,409
what this looks like right you can you

176
00:06:56,409 --> 00:06:57,909
can have constructors it's this is a

177
00:06:57,909 --> 00:07:00,550
much more efficient representation it's

178
00:07:00,550 --> 00:07:01,930
only takes about eight bytes right for

179
00:07:01,930 --> 00:07:04,090
the two floats and property axis is a

180
00:07:04,090 --> 00:07:05,139
lot faster because when you say

181
00:07:05,139 --> 00:07:08,440
something like Carville ah sativex you

182
00:07:08,440 --> 00:07:09,819
don't have to do point I chasing to get

183
00:07:09,819 --> 00:07:11,470
the objects and then request properties

184
00:07:11,470 --> 00:07:13,960
you just compute an offset into the car

185
00:07:13,960 --> 00:07:17,590
sort of data structure we also have a

186
00:07:17,590 --> 00:07:21,099
raise likessee Ras multi-dimensional you

187
00:07:21,099 --> 00:07:23,169
can just compute offsets until very

188
00:07:23,169 --> 00:07:27,669
quickly unions some people also wanted

189
00:07:27,669 --> 00:07:29,580
these bit fields that people do in C

190
00:07:29,580 --> 00:07:31,860
actually even know this was possible but

191
00:07:31,860 --> 00:07:34,900
so well I guess we'll try and see if we

192
00:07:34,900 --> 00:07:37,870
can do that as well of course you also

193
00:07:37,870 --> 00:07:40,270
have pointers so declaring code like

194
00:07:40,270 --> 00:07:41,889
this when you say you have a swap

195
00:07:41,889 --> 00:07:45,879
function takes two pointers so you can

196
00:07:45,879 --> 00:07:48,069
do all this weird see pointers you can

197
00:07:48,069 --> 00:07:49,870
also take addresses of local variables

198
00:07:49,870 --> 00:07:51,159
right so the way how do we implement

199
00:07:51,159 --> 00:07:53,590
this right you can't get an address to a

200
00:07:53,590 --> 00:07:56,710
javascript thing so if at any point you

201
00:07:56,710 --> 00:07:58,330
take a verse of a reference of

202
00:07:58,330 --> 00:08:02,529
JavaScript object well variable we just

203
00:08:02,529 --> 00:08:04,060
allocate on the stack so we emulate the

204
00:08:04,060 --> 00:08:07,210
stack using this SP variable we

205
00:08:07,210 --> 00:08:09,279
decrement it out of the mouse works but

206
00:08:09,279 --> 00:08:11,169
so this would be like a method

207
00:08:11,169 --> 00:08:12,729
activation frame we just subtract the

208
00:08:12,729 --> 00:08:15,460
stack pointer and then we allocate X

209
00:08:15,460 --> 00:08:18,219
variable at the first stack location and

210
00:08:18,219 --> 00:08:21,900
then the next one at the following one

211
00:08:21,900 --> 00:08:24,099
you can just stack and heap allocation

212
00:08:24,099 --> 00:08:25,930
of structs so you can for example write

213
00:08:25,930 --> 00:08:27,729
code like let vector V 0 and then you

214
00:08:27,729 --> 00:08:29,740
can call a constructor and this comes oh

215
00:08:29,740 --> 00:08:33,539
by the way for the on the right side

216
00:08:33,539 --> 00:08:37,659
okay on your right it's what we compile

217
00:08:37,659 --> 00:08:42,070
to and on the left is LJ s good so you

218
00:08:42,070 --> 00:08:43,360
can declare for example two vectors on

219
00:08:43,360 --> 00:08:46,000
the stack and if you want to assign one

220
00:08:46,000 --> 00:08:48,250
vector to another since the use of value

221
00:08:48,250 --> 00:08:52,610
types we just made a mem copy operation

222
00:08:52,610 --> 00:08:55,649
of course you can also declare you can

223
00:08:55,649 --> 00:08:57,089
allocate things on a heap so you can say

224
00:08:57,089 --> 00:08:59,640
new vector so here new means something

225
00:08:59,640 --> 00:09:01,290
else because we know what the type of

226
00:09:01,290 --> 00:09:03,330
vector is it's a it's a struct type then

227
00:09:03,330 --> 00:09:04,890
we just they made a Mallick followed by

228
00:09:04,890 --> 00:09:06,959
a call to the constructor the delete

229
00:09:06,959 --> 00:09:08,670
operator is also over in to mean

230
00:09:08,670 --> 00:09:10,410
something else in this case it calls

231
00:09:10,410 --> 00:09:13,649
free on the allocate address of course

232
00:09:13,649 --> 00:09:14,610
this means you have to implement your

233
00:09:14,610 --> 00:09:16,680
own on malloc and free and we have I

234
00:09:16,680 --> 00:09:19,140
read the sea can get our book and I try

235
00:09:19,140 --> 00:09:20,670
to understand how malik like we just

236
00:09:20,670 --> 00:09:22,140
copied exactly the same implementation

237
00:09:22,140 --> 00:09:24,890
of malik and pasted it in analogous and

238
00:09:24,890 --> 00:09:28,170
more or less worked all right so i think

239
00:09:28,170 --> 00:09:30,330
this is shoes so she's going to talk

240
00:09:30,330 --> 00:09:31,800
about sort of the more implementation

241
00:09:31,800 --> 00:09:40,680
details hello not great all right so i'm

242
00:09:40,680 --> 00:09:42,240
going to talk more about the

243
00:09:42,240 --> 00:09:45,029
implementation sign the compiler so what

244
00:09:45,029 --> 00:09:47,399
do we get with kind of emulating the

245
00:09:47,399 --> 00:09:49,529
heap using a giant typed array well my

246
00:09:49,529 --> 00:09:51,630
other things we get safety in quotes

247
00:09:51,630 --> 00:09:55,380
since we have the entire memory in a

248
00:09:55,380 --> 00:09:57,120
typed array it means we cannot get

249
00:09:57,120 --> 00:09:59,070
crashes in the traditional sense like if

250
00:09:59,070 --> 00:10:01,620
you read out of bounds or something that

251
00:10:01,620 --> 00:10:04,410
your your program crashes basically all

252
00:10:04,410 --> 00:10:07,470
you get here is well you get your

253
00:10:07,470 --> 00:10:08,910
program probably just as a bug is your

254
00:10:08,910 --> 00:10:10,649
reading memory that you didn't intend to

255
00:10:10,649 --> 00:10:14,750
but this allows us to basically have the

256
00:10:14,750 --> 00:10:17,670
C type system and let you do unchecked

257
00:10:17,670 --> 00:10:20,010
casts and memory operations they are

258
00:10:20,010 --> 00:10:22,440
unchecked and that everything's in

259
00:10:22,440 --> 00:10:24,360
reinterpret cast like in the bottom here

260
00:10:24,360 --> 00:10:27,270
you can cast anything to a pointer

261
00:10:27,270 --> 00:10:30,779
there's really no complaints and but

262
00:10:30,779 --> 00:10:33,750
you're not going to get any crashes the

263
00:10:33,750 --> 00:10:35,130
compiler itself is fairly

264
00:10:35,130 --> 00:10:39,089
straightforward we've used several very

265
00:10:39,089 --> 00:10:40,770
useful open source tools like a spring

266
00:10:40,770 --> 00:10:44,670
line Nia's cochin to hook into basically

267
00:10:44,670 --> 00:10:47,070
a couple transformation passes but most

268
00:10:47,070 --> 00:10:49,170
of the stuff we use was was is available

269
00:10:49,170 --> 00:10:53,310
to to the web we use we extend ass prima

270
00:10:53,310 --> 00:10:56,730
to with the ability to parse type

271
00:10:56,730 --> 00:10:58,740
annotations and some other see

272
00:10:58,740 --> 00:11:00,000
constructs then we run a couple

273
00:11:00,000 --> 00:11:01,620
transformation passes and then we pass

274
00:11:01,620 --> 00:11:03,660
it off to yes coach n to serialize to

275
00:11:03,660 --> 00:11:06,420
JavaScript if any of you has had the

276
00:11:06,420 --> 00:11:08,130
misfortune of writing a sea front end

277
00:11:08,130 --> 00:11:11,370
you will know that cast expressions are

278
00:11:11,370 --> 00:11:13,350
a pain in the ass to deal with because

279
00:11:13,350 --> 00:11:15,360
they are ambiguous between function

280
00:11:15,360 --> 00:11:17,730
calls and cast expressions you don't

281
00:11:17,730 --> 00:11:19,230
really know until you have parsed the

282
00:11:19,230 --> 00:11:21,240
entire program what is a function and

283
00:11:21,240 --> 00:11:24,329
what's a type and yeah it suggests just

284
00:11:24,329 --> 00:11:27,449
a little aside that's not everything and

285
00:11:27,449 --> 00:11:30,600
c is nice and clean and simple so what

286
00:11:30,600 --> 00:11:34,020
what do pointers compiled down to in ljs

287
00:11:34,020 --> 00:11:36,150
on the left column the leftmost column

288
00:11:36,150 --> 00:11:38,310
you see ljs code in the middle column

289
00:11:38,310 --> 00:11:41,640
you see ljs generated javascript and in

290
00:11:41,640 --> 00:11:43,230
the rightmost column you see em script

291
00:11:43,230 --> 00:11:45,900
and generated JavaScript so basically we

292
00:11:45,900 --> 00:11:48,870
have three pointers of varying sizes the

293
00:11:48,870 --> 00:11:52,050
I means it that it's signed and the 32

294
00:11:52,050 --> 00:11:54,449
means how many bits it has and then 16

295
00:11:54,449 --> 00:11:55,920
and eight and so forth and then we

296
00:11:55,920 --> 00:11:57,959
assign them to each other and we do some

297
00:11:57,959 --> 00:12:01,230
dereferences now typed arrays as you

298
00:12:01,230 --> 00:12:03,930
know allow you a couple of use such as

299
00:12:03,930 --> 00:12:07,880
32 bits and 16-bit into nate biton's and

300
00:12:07,880 --> 00:12:10,170
what it doesn't really allow you outside

301
00:12:10,170 --> 00:12:11,790
of data view which is slow but it

302
00:12:11,790 --> 00:12:13,560
doesn't really allow you is unaligned

303
00:12:13,560 --> 00:12:15,810
memory access you can basically only

304
00:12:15,810 --> 00:12:18,149
read things at sixteen byte 16-bit

305
00:12:18,149 --> 00:12:20,040
boundaries a bit boundaries 32-bit

306
00:12:20,040 --> 00:12:22,560
boundaries and what this allows us to do

307
00:12:22,560 --> 00:12:24,810
when generating pointer code is to

308
00:12:24,810 --> 00:12:26,930
instead of storing byte addressable

309
00:12:26,930 --> 00:12:30,089
addresses as inside the pointers we can

310
00:12:30,089 --> 00:12:33,690
store the indices into their respective

311
00:12:33,690 --> 00:12:36,690
heaps into respective views on the same

312
00:12:36,690 --> 00:12:44,430
heap so instead of instead of scaling

313
00:12:44,430 --> 00:12:47,070
the address when we're indexing into the

314
00:12:47,070 --> 00:12:49,649
array we only scale it in ljs when we're

315
00:12:49,649 --> 00:12:52,649
assigning into the pointer so this lets

316
00:12:52,649 --> 00:12:55,079
us save a few operations we're basically

317
00:12:55,079 --> 00:12:56,940
betting on the fact that you're probably

318
00:12:56,940 --> 00:12:58,589
going to be accessing memory a lot more

319
00:12:58,589 --> 00:13:01,589
than doing people doing pointer

320
00:13:01,589 --> 00:13:04,589
mutations between different widths and

321
00:13:04,589 --> 00:13:06,240
scripting does as little differently

322
00:13:06,240 --> 00:13:08,250
whereas they always scale the address

323
00:13:08,250 --> 00:13:10,410
when they access but then since

324
00:13:10,410 --> 00:13:11,939
everything is byte addressable they

325
00:13:11,939 --> 00:13:14,900
don't need to scale the addresses when

326
00:13:14,900 --> 00:13:17,010
they assign the pointers to each other

327
00:13:17,010 --> 00:13:18,810
this is just the trade-off between

328
00:13:18,810 --> 00:13:21,480
what you think your program is going to

329
00:13:21,480 --> 00:13:24,680
be doing more another nice thing about

330
00:13:24,680 --> 00:13:27,120
things like I'll jsm scripting is that

331
00:13:27,120 --> 00:13:30,060
when you compile your code that now the

332
00:13:30,060 --> 00:13:32,100
hat that has machine types you're

333
00:13:32,100 --> 00:13:33,390
generating code that's much more

334
00:13:33,390 --> 00:13:35,670
friendly to your jets than normal

335
00:13:35,670 --> 00:13:38,910
JavaScript now jets including the

336
00:13:38,910 --> 00:13:40,680
JavaScript Jets really like monomorphic

337
00:13:40,680 --> 00:13:43,320
code meaning if your program happens to

338
00:13:43,320 --> 00:13:45,710
basically only work on one type ever

339
00:13:45,710 --> 00:13:48,839
your variables are basically monomorphic

340
00:13:48,839 --> 00:13:51,390
instead of polymorphic they can annotate

341
00:13:51,390 --> 00:13:53,250
or sorry they can optimize much better

342
00:13:53,250 --> 00:13:56,640
and we have higher level information as

343
00:13:56,640 --> 00:13:58,350
the Ojays program that this thing is in

344
00:13:58,350 --> 00:14:00,240
fact an enter this thing is in fact the

345
00:14:00,240 --> 00:14:03,300
you int or whatever and we it'd be nice

346
00:14:03,300 --> 00:14:05,640
to tell the engine somehow that you know

347
00:14:05,640 --> 00:14:08,839
we know this for a fact so you shouldn't

348
00:14:08,839 --> 00:14:12,270
emits a overflow checks for addition in

349
00:14:12,270 --> 00:14:14,460
javascript because in javascript we

350
00:14:14,460 --> 00:14:16,170
don't we only have one number type of

351
00:14:16,170 --> 00:14:18,330
course the engines represent them is

352
00:14:18,330 --> 00:14:19,680
either and in 32 which eventually

353
00:14:19,680 --> 00:14:21,830
overflows to a double or something but

354
00:14:21,830 --> 00:14:23,970
to the JavaScript programmer there's

355
00:14:23,970 --> 00:14:25,740
only one there's only one number type

356
00:14:25,740 --> 00:14:31,050
and addition it's not closed on the

357
00:14:31,050 --> 00:14:32,640
integers for instance and it'd be really

358
00:14:32,640 --> 00:14:34,920
nice if we can tell digit that it is for

359
00:14:34,920 --> 00:14:36,270
this program closed on the on the

360
00:14:36,270 --> 00:14:38,760
integers then it can emit more efficient

361
00:14:38,760 --> 00:14:42,690
code so in things like ljs we can do

362
00:14:42,690 --> 00:14:45,630
things such as compile ends down all

363
00:14:45,630 --> 00:14:47,910
accesses of variables that are declared

364
00:14:47,910 --> 00:14:51,660
to be ends with a bitwise or 0 this has

365
00:14:51,660 --> 00:14:53,339
the effect of telling the engine that

366
00:14:53,339 --> 00:14:55,650
every use of this variable is truncated

367
00:14:55,650 --> 00:14:58,280
to 32-bit ins and you can just kind of

368
00:14:58,280 --> 00:15:01,950
forget about the overflow checks among

369
00:15:01,950 --> 00:15:03,660
other things this lets you have more

370
00:15:03,660 --> 00:15:07,920
predictable performance because a chitet

371
00:15:07,920 --> 00:15:11,850
language usually have dynamic checks for

372
00:15:11,850 --> 00:15:13,760
soundness and they end up recompiling

373
00:15:13,760 --> 00:15:16,830
doing this lets you also sometimes get

374
00:15:16,830 --> 00:15:20,520
rid of those dynamic checks all right so

375
00:15:20,520 --> 00:15:22,020
that's basically what we have in the

376
00:15:22,020 --> 00:15:23,640
language fairly simple and how we

377
00:15:23,640 --> 00:15:25,260
compiled them I thought we compile the

378
00:15:25,260 --> 00:15:27,480
more interesting bits this is just an

379
00:15:27,480 --> 00:15:30,540
example code for how would we might use

380
00:15:30,540 --> 00:15:32,130
it this is a

381
00:15:32,130 --> 00:15:34,830
struct of a 4 by 4 matrix with some

382
00:15:34,830 --> 00:15:37,650
accompanying multiplication function

383
00:15:37,650 --> 00:15:40,940
that does simple matrix multiplication

384
00:15:40,940 --> 00:15:43,470
but this is not so nice to use all we

385
00:15:43,470 --> 00:15:45,420
have a destruct so maybe we can write a

386
00:15:45,420 --> 00:15:48,690
thin wrapper that has one field which

387
00:15:48,690 --> 00:15:51,570
basically makes the new struct and then

388
00:15:51,570 --> 00:15:54,840
use some casts here and there to call

389
00:15:54,840 --> 00:15:56,670
the multiplication method that we

390
00:15:56,670 --> 00:15:59,070
defined so we end up having a more

391
00:15:59,070 --> 00:16:02,130
JavaScript e interface note that we

392
00:16:02,130 --> 00:16:04,800
actually manually cast dis de m and

393
00:16:04,800 --> 00:16:07,170
other not em back to capital m star

394
00:16:07,170 --> 00:16:08,940
because once we're in JavaScript land

395
00:16:08,940 --> 00:16:11,160
the types are gone that the type system

396
00:16:11,160 --> 00:16:13,320
is simply not strong enough we don't

397
00:16:13,320 --> 00:16:14,580
want it to be strong enough to be able

398
00:16:14,580 --> 00:16:16,440
to somehow infer that this dynamin other

399
00:16:16,440 --> 00:16:20,520
dem are in fact mstars so here you have

400
00:16:20,520 --> 00:16:25,000
to write some manual interfacing code

401
00:16:25,010 --> 00:16:27,210
but then this leads the question now

402
00:16:27,210 --> 00:16:29,730
that you're manually managing memory you

403
00:16:29,730 --> 00:16:31,830
can have memory leaks so what do you do

404
00:16:31,830 --> 00:16:34,050
well maybe you can have a free function

405
00:16:34,050 --> 00:16:37,470
which then calls the delete operator

406
00:16:37,470 --> 00:16:38,790
which then actually frees the memory

407
00:16:38,790 --> 00:16:41,790
allocated in the end of the heap but we

408
00:16:41,790 --> 00:16:45,390
can't do that either well we can but you

409
00:16:45,390 --> 00:16:47,280
have to do this manually will be nice if

410
00:16:47,280 --> 00:16:49,740
we had some language level support but

411
00:16:49,740 --> 00:16:52,920
we're no longer relying on the GC if the

412
00:16:52,920 --> 00:16:54,840
language could expose finalizes then we

413
00:16:54,840 --> 00:16:56,460
can do this but we can't expose

414
00:16:56,460 --> 00:16:59,340
finalizes for reasons of not exposing GC

415
00:16:59,340 --> 00:17:02,190
state already 5 weak references it'd be

416
00:17:02,190 --> 00:17:03,870
nice if we could do that too but we

417
00:17:03,870 --> 00:17:05,699
don't have weak references either with

418
00:17:05,699 --> 00:17:07,949
requite with weak references we can tell

419
00:17:07,949 --> 00:17:09,449
if something is about to be collected

420
00:17:09,449 --> 00:17:14,819
much as with finalizes so now we have

421
00:17:14,819 --> 00:17:16,140
but but we've gone through this before

422
00:17:16,140 --> 00:17:18,089
with see without the without the memory

423
00:17:18,089 --> 00:17:21,180
problems and the double fries and the

424
00:17:21,180 --> 00:17:23,880
remembering not remembering to free over

425
00:17:23,880 --> 00:17:25,829
the summer one of our interns Tim Disney

426
00:17:25,829 --> 00:17:27,930
of sweet j/s fame haven't checked out

427
00:17:27,930 --> 00:17:30,630
his macros work you already should he

428
00:17:30,630 --> 00:17:32,850
worked briefly he wrote this in like two

429
00:17:32,850 --> 00:17:34,890
weeks or something he since now the heap

430
00:17:34,890 --> 00:17:36,600
is a JavaScript object and so easily

431
00:17:36,600 --> 00:17:38,460
instrumental he basically wrote the

432
00:17:38,460 --> 00:17:41,010
equivalent of a valgrind like tool for

433
00:17:41,010 --> 00:17:43,140
ljs which then detects these things

434
00:17:43,140 --> 00:17:45,840
that's pretty cool

435
00:17:45,840 --> 00:17:48,580
another interesting property of

436
00:17:48,580 --> 00:17:50,350
something like knowledge is is is that

437
00:17:50,350 --> 00:17:52,750
since it is not dependent on the entire

438
00:17:52,750 --> 00:17:55,690
C and C++ to chain it seems like it

439
00:17:55,690 --> 00:17:57,100
should have better interoperability with

440
00:17:57,100 --> 00:18:00,340
JavaScript but we cannot yet store j/s

441
00:18:00,340 --> 00:18:02,800
object in the LG as heap because typed

442
00:18:02,800 --> 00:18:05,470
arrays only take basically those machine

443
00:18:05,470 --> 00:18:08,500
types and they do not take any arbitrary

444
00:18:08,500 --> 00:18:10,540
object we have a couple ideas on how we

445
00:18:10,540 --> 00:18:12,790
might do this maybe we can have an

446
00:18:12,790 --> 00:18:14,800
object ID mapping when we need to store

447
00:18:14,800 --> 00:18:16,690
an object maybe we can have a shadow

448
00:18:16,690 --> 00:18:19,030
heap that only stores object that is not

449
00:18:19,030 --> 00:18:21,100
a typed array a shadow heap of normal

450
00:18:21,100 --> 00:18:24,610
JavaScript array but it's in the works

451
00:18:24,610 --> 00:18:28,090
and yeah but interop is basically pretty

452
00:18:28,090 --> 00:18:31,270
hard so some general concluding remarks

453
00:18:31,270 --> 00:18:33,910
this is kind of crazy as that as to as

454
00:18:33,910 --> 00:18:37,060
the tweets have shown but it's not a

455
00:18:37,060 --> 00:18:38,410
general purpose tool we're not asking

456
00:18:38,410 --> 00:18:40,120
you please write all your j/s this way

457
00:18:40,120 --> 00:18:41,950
it's it's that that's asking you to go

458
00:18:41,950 --> 00:18:45,400
back to like 1960s so but if you have a

459
00:18:45,400 --> 00:18:47,950
few bit of bits of code in your in your

460
00:18:47,950 --> 00:18:50,320
little game or whatever application

461
00:18:50,320 --> 00:18:52,000
you're working on that really needs that

462
00:18:52,000 --> 00:18:55,000
memory compactness that actually lets

463
00:18:55,000 --> 00:18:57,490
you write real data structures that have

464
00:18:57,490 --> 00:18:59,410
higher structure overhead if you have if

465
00:18:59,410 --> 00:19:01,480
you have like prefix trees with a lot of

466
00:19:01,480 --> 00:19:03,250
links with very little data per node

467
00:19:03,250 --> 00:19:04,960
that's going to kill you when you

468
00:19:04,960 --> 00:19:07,030
allocate a ton of little objects in

469
00:19:07,030 --> 00:19:08,710
JavaScript this lets you get around that

470
00:19:08,710 --> 00:19:12,610
and if you really miss you know assembly

471
00:19:12,610 --> 00:19:13,870
and stuff and you're not lucky enough to

472
00:19:13,870 --> 00:19:15,760
work on the jet engines this gets you

473
00:19:15,760 --> 00:19:18,910
back in touch with the bits and bytes so

474
00:19:18,910 --> 00:19:21,760
the status of this project right now is

475
00:19:21,760 --> 00:19:25,690
that we have a research prototype which

476
00:19:25,690 --> 00:19:27,100
really is just a nicer way of saying

477
00:19:27,100 --> 00:19:31,030
it's really buggy but it works for the

478
00:19:31,030 --> 00:19:34,630
most part we have a nice if you have

479
00:19:34,630 --> 00:19:37,060
note installed it has a command-line

480
00:19:37,060 --> 00:19:39,670
compiler that you can use it ships with

481
00:19:39,670 --> 00:19:41,980
some with you know the ke andar malik

482
00:19:41,980 --> 00:19:43,690
implementation which is the probably not

483
00:19:43,690 --> 00:19:46,540
the Mallik you want but it works we have

484
00:19:46,540 --> 00:19:50,670
at least two users me and Michael but

485
00:19:50,670 --> 00:19:54,010
apparently this was made known to known

486
00:19:54,010 --> 00:19:56,530
to us via Twitter the other day so so we

487
00:19:56,530 --> 00:19:58,540
rewrote this entire language though you

488
00:19:58,540 --> 00:20:00,430
you have manual memory management so you

489
00:20:00,430 --> 00:20:02,860
can have compact you know nice efficient

490
00:20:02,860 --> 00:20:04,570
code and the first thing that someone

491
00:20:04,570 --> 00:20:07,360
writes and publicly tweets is a marking

492
00:20:07,360 --> 00:20:12,610
sleep GC it's quite amazing all right

493
00:20:12,610 --> 00:20:23,200
thank you for listening happy to take

494
00:20:23,200 --> 00:20:36,259
any questions

495
00:20:36,269 --> 00:20:46,390
sorry

496
00:20:46,400 --> 00:20:51,110
so right now the the oh sorry the

497
00:20:51,110 --> 00:20:54,530
question was if i want to write part of

498
00:20:54,530 --> 00:20:56,630
my program in normal javascript and a

499
00:20:56,630 --> 00:20:58,100
little another little part of my program

500
00:20:58,100 --> 00:20:59,690
in LG s what hoops do i have to jump

501
00:20:59,690 --> 00:21:00,760
through to get them to work together

502
00:21:00,760 --> 00:21:03,170
right now the command line compiler

503
00:21:03,170 --> 00:21:07,190
generates a module pattern around your

504
00:21:07,190 --> 00:21:09,770
ljs code which then is just normal

505
00:21:09,770 --> 00:21:13,550
javascript code the problem is the types

506
00:21:13,550 --> 00:21:16,010
are erased in the generator JavaScript

507
00:21:16,010 --> 00:21:19,700
code so you have to basically have a

508
00:21:19,700 --> 00:21:22,000
little exports father you write yourself

509
00:21:22,000 --> 00:21:24,500
to preserve the types when you need to

510
00:21:24,500 --> 00:21:29,030
use it from elsewhere like in the matrix

511
00:21:29,030 --> 00:21:32,990
example that we showed in the prototype

512
00:21:32,990 --> 00:21:35,300
that malfunction when you get this time

513
00:21:35,300 --> 00:21:37,760
out you don't know that it's a M star

514
00:21:37,760 --> 00:21:40,600
and you have to basically cast it back

515
00:21:40,600 --> 00:21:43,820
but otherwise is I mean we just generate

516
00:21:43,820 --> 00:21:45,080
normal JavaScript function so you can

517
00:21:45,080 --> 00:21:48,410
just call it it's parameterize around

518
00:21:48,410 --> 00:21:50,750
the typed array heap and you can choose

519
00:21:50,750 --> 00:21:52,100
how big you want that to be when you

520
00:21:52,100 --> 00:21:59,410
generate the code

521
00:21:59,420 --> 00:22:05,040
for example when when I malach or free

522
00:22:05,040 --> 00:22:07,680
something is it just to make sure that I

523
00:22:07,680 --> 00:22:09,750
got it right yeah you have implemented

524
00:22:09,750 --> 00:22:12,120
your own heat which is a typed array and

525
00:22:12,120 --> 00:22:14,130
there are all the memory operations

526
00:22:14,130 --> 00:22:17,400
performed on right yeah so I mean it's

527
00:22:17,400 --> 00:22:18,780
essentially keeping a free list

528
00:22:18,780 --> 00:22:21,180
internally so every like allocate when

529
00:22:21,180 --> 00:22:24,270
you send new it just finds the next like

530
00:22:24,270 --> 00:22:26,730
free list know it and then like it gives

531
00:22:26,730 --> 00:22:28,440
you a sort of it has to put the malach

532
00:22:28,440 --> 00:22:30,270
header in front right so I mean it's

533
00:22:30,270 --> 00:22:32,340
just it's like arm position dialogue you

534
00:22:32,340 --> 00:22:36,270
know regarding the alignment of areas

535
00:22:36,270 --> 00:22:38,550
you talked about what happens when I can

536
00:22:38,550 --> 00:22:41,340
you go back to the align the alignment

537
00:22:41,340 --> 00:22:45,120
slide when I takes the let's say the X

538
00:22:45,120 --> 00:22:48,240
array it which is an ia32 array and

539
00:22:48,240 --> 00:22:52,770
constituent I 16 array then I can access

540
00:22:52,770 --> 00:22:59,280
unaligned memory right so so you

541
00:22:59,280 --> 00:23:01,500
determine up casting a pointer or Yeah

542
00:23:01,500 --> 00:23:03,690
right and I'm you can never cat because

543
00:23:03,690 --> 00:23:05,970
basically when you when we shift over to

544
00:23:05,970 --> 00:23:08,370
like scale the pointer addresses then

545
00:23:08,370 --> 00:23:18,890
you basically just lose the precision so

546
00:23:18,900 --> 00:23:20,980
two pointers you know on top of each

547
00:23:20,980 --> 00:23:22,960
other I mean they basically have to be

548
00:23:22,960 --> 00:23:25,090
aligned to the widest all right that

549
00:23:25,090 --> 00:23:37,130
would be I guess Toby

550
00:23:37,140 --> 00:23:39,120
right that would be a problem we can we

551
00:23:39,120 --> 00:23:41,280
can fix them well just put them

552
00:23:41,280 --> 00:23:49,060
different places research prototype yes

553
00:23:49,070 --> 00:23:51,450
yeah actually like just a minute ago I

554
00:23:51,450 --> 00:23:53,490
realized that we if someone throws an

555
00:23:53,490 --> 00:23:55,710
exception like we don't do anything

556
00:23:55,710 --> 00:23:59,000
about the stack pointer to like fix it

557
00:23:59,000 --> 00:24:04,650
yeah okay question um and point a

558
00:24:04,650 --> 00:24:07,920
ruthless II am there you just lied for

559
00:24:07,920 --> 00:24:11,790
that or example is it even necessary or

560
00:24:11,790 --> 00:24:14,820
I mean I mean do you want what you want

561
00:24:14,820 --> 00:24:17,190
to do that yeah i mean if used to

562
00:24:17,190 --> 00:24:20,900
writing your array traversal code using

563
00:24:20,900 --> 00:24:23,220
bumping pointers instead of using that

564
00:24:23,220 --> 00:24:26,370
index you can do that is fine i mean

565
00:24:26,370 --> 00:24:29,250
it's it's the generator codes not too

566
00:24:29,250 --> 00:24:31,080
bad to read either because they're

567
00:24:31,080 --> 00:24:32,610
you're not kind of crossing this

568
00:24:32,610 --> 00:24:35,670
alignment boundary you're just bumping a

569
00:24:35,670 --> 00:24:38,250
pointer of the same alignment so it's

570
00:24:38,250 --> 00:24:41,400
actually just a bump in the an increment

571
00:24:41,400 --> 00:24:43,320
in the generator javascript code also

572
00:24:43,320 --> 00:24:46,260
it's not it's not too bit of course the

573
00:24:46,260 --> 00:24:47,490
rest of code is going to be hard to reap

574
00:24:47,490 --> 00:24:50,850
is it's all going to be it access into

575
00:24:50,850 --> 00:24:56,190
the memory so what lessons are you gonna

576
00:24:56,190 --> 00:24:58,500
take from this if any and put them in

577
00:24:58,500 --> 00:25:03,330
normal spider monkey what do you mean

578
00:25:03,330 --> 00:25:06,090
like like the features language or no no

579
00:25:06,090 --> 00:25:08,010
but like what can we do you how can you

580
00:25:08,010 --> 00:25:09,990
make spider monkey faster you know you

581
00:25:09,990 --> 00:25:11,700
seem like some of the original examples

582
00:25:11,700 --> 00:25:14,490
in some ways you do know the types yeah

583
00:25:14,490 --> 00:25:16,320
and you can always do things like trick

584
00:25:16,320 --> 00:25:18,360
so i can say you can met do pattern

585
00:25:18,360 --> 00:25:20,400
matching on like the kinds of code they

586
00:25:20,400 --> 00:25:22,500
generate i think so for this particular

587
00:25:22,500 --> 00:25:24,150
pattern i can like have a fast

588
00:25:24,150 --> 00:25:26,100
optimization like the example with over

589
00:25:26,100 --> 00:25:29,190
0 yeah i think with em scripting and

590
00:25:29,190 --> 00:25:33,990
especially its its is driven in the new

591
00:25:33,990 --> 00:25:35,970
in the new spider monkey janiyah monkey

592
00:25:35,970 --> 00:25:39,000
there's there's analysis to look for fit

593
00:25:39,000 --> 00:25:40,710
wise operations and things that truncate

594
00:25:40,710 --> 00:25:43,010
to 32 bits and

595
00:25:43,010 --> 00:25:45,950
and omit overflow checks and and boxing

596
00:25:45,950 --> 00:25:48,020
and stuff like that so we should be

597
00:25:48,020 --> 00:25:50,240
doing lots of bitwise operations and and

598
00:25:50,240 --> 00:25:52,820
so on shifting by two instead of

599
00:25:52,820 --> 00:25:54,410
dividing by eight things like that I'm

600
00:25:54,410 --> 00:25:56,090
gonna say no because that's gonna make

601
00:25:56,090 --> 00:25:57,710
your code look a lot worse if you want

602
00:25:57,710 --> 00:25:59,420
to do that as like an extra bill pass

603
00:25:59,420 --> 00:26:02,750
feel free but like you know it seems bad

604
00:26:02,750 --> 00:26:04,100
to have the programmer to jump through

605
00:26:04,100 --> 00:26:06,350
hoops to optimize for a specific it

606
00:26:06,350 --> 00:26:12,230
seems like all right you so you talked

607
00:26:12,230 --> 00:26:13,700
about the memory overhead in just

608
00:26:13,700 --> 00:26:16,340
vanilla JavaScript objects I'm curious

609
00:26:16,340 --> 00:26:19,340
if there's a crossover point where the

610
00:26:19,340 --> 00:26:21,380
cost of you malloc and free implemented

611
00:26:21,380 --> 00:26:23,480
in JavaScript becomes higher than the

612
00:26:23,480 --> 00:26:25,520
cost of memory allocations and garbage

613
00:26:25,520 --> 00:26:27,080
collections that are implemented in C++

614
00:26:27,080 --> 00:26:28,190
probably typically in most of the

615
00:26:28,190 --> 00:26:30,020
engines do you have any data on that

616
00:26:30,020 --> 00:26:32,630
like in other words how much random

617
00:26:32,630 --> 00:26:34,250
allocation and freeing what I have to do

618
00:26:34,250 --> 00:26:37,850
for the overhead of the regular objects

619
00:26:37,850 --> 00:26:39,410
to actually be smaller than the overhead

620
00:26:39,410 --> 00:26:41,270
of allocation and freeing that you guys

621
00:26:41,270 --> 00:26:43,040
have to do manual in JavaScript well I

622
00:26:43,040 --> 00:26:44,420
don't think it's America's family matter

623
00:26:44,420 --> 00:26:46,160
of like because I mean the GC is really

624
00:26:46,160 --> 00:26:48,680
really fast right so it's not about fat

625
00:26:48,680 --> 00:26:49,880
in particular is that you don't have any

626
00:26:49,880 --> 00:26:52,370
GC pauses so even if it's about the same

627
00:26:52,370 --> 00:26:54,670
speed it would be sort of a smoother

628
00:26:54,670 --> 00:26:56,420
really are talking primarily about

629
00:26:56,420 --> 00:26:59,300
pauses so if we like if insiders we got

630
00:26:59,300 --> 00:27:02,390
the pauses down to negligible speed we

631
00:27:02,390 --> 00:27:04,490
will be faced the on par with the goals

632
00:27:04,490 --> 00:27:05,930
that you trying to accomplish yeah is

633
00:27:05,930 --> 00:27:08,480
that I could but I don't think it'd be

634
00:27:08,480 --> 00:27:10,880
hard to keep it sort of consistent speed

635
00:27:10,880 --> 00:27:12,650
I mean sometimes like you want to

636
00:27:12,650 --> 00:27:15,050
control exactly if you have if you're

637
00:27:15,050 --> 00:27:17,480
drawing frames maybe you want to trigger

638
00:27:17,480 --> 00:27:21,980
GC exactly at this point in time so that

639
00:27:21,980 --> 00:27:23,300
your animation looks a little bit

640
00:27:23,300 --> 00:27:26,720
smoother even if you get your GC to be

641
00:27:26,720 --> 00:27:29,210
extremely fast it's unlikely that

642
00:27:29,210 --> 00:27:30,710
they'll exposed that level of control

643
00:27:30,710 --> 00:27:35,150
right I mean you can always just do like

644
00:27:35,150 --> 00:27:36,800
region allocation scheme so you can do

645
00:27:36,800 --> 00:27:39,710
your own Melek you just wipe out the

646
00:27:39,710 --> 00:27:40,820
whole thing when you're done with that

647
00:27:40,820 --> 00:27:46,300
so sorry didn't you see the disco de

648
00:27:46,300 --> 00:27:49,760
looks more like C code herbs and

649
00:27:49,760 --> 00:27:53,270
JavaScript code and in this case I think

650
00:27:53,270 --> 00:27:57,590
more efficient right Collins the simple

651
00:27:57,590 --> 00:28:05,530
truth and to use node.js model right on

652
00:28:05,530 --> 00:28:12,760
sibley spoofs no crash k repeat on what

653
00:28:12,760 --> 00:28:17,030
you make right you're modest for not

654
00:28:17,030 --> 00:28:21,880
just in on the Clean Cities blues and

655
00:28:21,880 --> 00:28:25,820
didn't you think that it's very empty

656
00:28:25,820 --> 00:28:30,190
will be more affection since this no

657
00:28:30,190 --> 00:28:32,660
utrom le writing actually running in C++

658
00:28:32,660 --> 00:28:34,600
modules and then I think bindings to

659
00:28:34,600 --> 00:28:37,460
good job well I mean should certainly

660
00:28:37,460 --> 00:28:39,110
that's much more efficient no Jess but

661
00:28:39,110 --> 00:28:40,850
if you want to run on the browser

662
00:28:40,850 --> 00:28:44,900
something I didn't see benefits from

663
00:28:44,900 --> 00:28:51,950
this variant from this Ze'ev around but

664
00:28:51,950 --> 00:28:55,040
they run so I mean detection running

665
00:28:55,040 --> 00:28:56,630
native code right you can just are

666
00:28:56,630 --> 00:28:57,740
writing a native code and the writing

667
00:28:57,740 --> 00:28:59,300
and using some foreign function

668
00:28:59,300 --> 00:29:03,290
interface to use it inside now or I'm

669
00:29:03,290 --> 00:29:07,540
not familiar with what exactly you're

670
00:29:07,540 --> 00:29:14,370
asking the node stuff

671
00:29:14,380 --> 00:29:17,270
004 noches I mean I think you're better

672
00:29:17,270 --> 00:29:19,250
off just writing you know he's writing a

673
00:29:19,250 --> 00:29:20,930
seed right but if you want to needed to

674
00:29:20,930 --> 00:29:30,620
run in the browser yeah

675
00:29:30,630 --> 00:29:32,790
right right this is I mean the compiler

676
00:29:32,790 --> 00:29:34,320
is in JavaScript for you while you can

677
00:29:34,320 --> 00:29:36,240
bundle the compiler on your page and

678
00:29:36,240 --> 00:29:38,400
whatever the rest of things the nice

679
00:29:38,400 --> 00:29:40,230
thing do you get with all JavaScript

680
00:29:40,230 --> 00:29:43,650
solutions ok great ok so I think that's

681
00:29:43,650 --> 00:29:45,360
it for this thank you very much you and

