1
00:00:07,730 --> 00:00:13,250

I'm going to talk about node so briefly

2
00:00:13,250 --> 00:00:17,570
so notice is a server-side j/s platform

3
00:00:17,570 --> 00:00:23,130
it's built on Google's v8 it does it I

4
00:00:23,130 --> 00:00:25,650
Oh in a very special way which I will

5
00:00:25,650 --> 00:00:29,550
describe in great detail it uses the

6
00:00:29,550 --> 00:00:34,280
common J's module system and it's

7
00:00:34,280 --> 00:00:37,800
written in C which has confused a lot of

8
00:00:37,800 --> 00:00:40,739
people so it's a rather large C project

9
00:00:40,739 --> 00:00:47,909
actually so the thesis is that IO has to

10
00:00:47,909 --> 00:00:52,350
be done differently we're doing it wrong

11
00:00:52,350 --> 00:00:55,260
everything the way that we're thinking

12
00:00:55,260 --> 00:01:00,659
about doing IO really makes things

13
00:01:00,659 --> 00:01:04,019
difficult so writing servers and writing

14
00:01:04,019 --> 00:01:07,560
any sort of application is difficult

15
00:01:07,560 --> 00:01:10,110
because of how we're doing

16
00:01:10,110 --> 00:01:15,509
io so a lot of web applications have

17
00:01:15,509 --> 00:01:20,250
such line of code like you query a

18
00:01:20,250 --> 00:01:22,530
database and then you return a result

19
00:01:22,530 --> 00:01:27,270
and then you use the result and so the

20
00:01:27,270 --> 00:01:29,640
question is what is your web framework

21
00:01:29,640 --> 00:01:33,240
doing well that while this line of code

22
00:01:33,240 --> 00:01:39,329
is running so in many cases you're not

23
00:01:39,329 --> 00:01:41,100
doing anything at all you're just

24
00:01:41,100 --> 00:01:43,850
sitting there while the database is

25
00:01:43,850 --> 00:01:47,899
waiting to respond and that might be

26
00:01:47,899 --> 00:01:55,490
that the database is in San Francisco or

27
00:01:55,490 --> 00:01:59,719
it might be

28
00:01:59,729 --> 00:02:06,969
thank you there's a lot of reasons okay

29
00:02:06,969 --> 00:02:12,879
well the point is is that you can't just

30
00:02:12,879 --> 00:02:16,930
wait for it to respond there's a big

31
00:02:16,930 --> 00:02:19,989
difference between what happens inside

32
00:02:19,989 --> 00:02:23,140
your CPU inside your memory and what

33
00:02:23,140 --> 00:02:25,060
happens when you go to something outside

34
00:02:25,060 --> 00:02:28,629
of that if you go to a disk or if you go

35
00:02:28,629 --> 00:02:31,360
to a network if you have to do a TCP

36
00:02:31,360 --> 00:02:33,130
connection to a different server even if

37
00:02:33,130 --> 00:02:37,630
it's in your same hosting center then

38
00:02:37,630 --> 00:02:40,060
you're talking about millions of clock

39
00:02:40,060 --> 00:02:42,430
cycles instead of hundreds of clock

40
00:02:42,430 --> 00:02:47,829
cycles or tens of clock cycles so you

41
00:02:47,829 --> 00:02:50,799
can't do nothing so obviously better

42
00:02:50,799 --> 00:02:54,010
software can do better than just wait

43
00:02:54,010 --> 00:02:57,060
for the database to respond it can

44
00:02:57,060 --> 00:03:00,129
multitask so you can have different

45
00:03:00,129 --> 00:03:06,400
threads of execution running so the

46
00:03:06,400 --> 00:03:08,200
question is is that the best that we can

47
00:03:08,200 --> 00:03:12,430
do and I think you can look at two

48
00:03:12,430 --> 00:03:15,670
popular web servers and see how they're

49
00:03:15,670 --> 00:03:20,799
doing i/o and decide if what what

50
00:03:20,799 --> 00:03:22,239
they're doing right and what they're

51
00:03:22,239 --> 00:03:26,889
doing wrong so here's a benchmark which

52
00:03:26,889 --> 00:03:33,819
is possibly not visible to you but it

53
00:03:33,819 --> 00:03:36,910
shows concurrency on like the number of

54
00:03:36,910 --> 00:03:38,829
concurrent clients on the web server on

55
00:03:38,829 --> 00:03:41,650
the horizontal axis and on the vertical

56
00:03:41,650 --> 00:03:45,010
axis it shows requests per second and so

57
00:03:45,010 --> 00:03:49,150
this is engine X and Apache and what you

58
00:03:49,150 --> 00:03:54,510
see is that the the engine X is is

59
00:03:54,510 --> 00:03:58,209
responding faster not so much faster

60
00:03:58,209 --> 00:04:00,880
twice as fast three times as fast

61
00:04:00,880 --> 00:04:02,470
especially when you get to higher

62
00:04:02,470 --> 00:04:07,570
concurrency who cares but the big

63
00:04:07,570 --> 00:04:10,970
difference is when you look at

64
00:04:10,970 --> 00:04:15,930
versus memory so again on the horizontal

65
00:04:15,930 --> 00:04:19,229
axis is is the number of clients on your

66
00:04:19,229 --> 00:04:22,320
server but now on the vertical axis you

67
00:04:22,320 --> 00:04:42,080
have memory and

68
00:04:42,090 --> 00:04:48,160
it looks great online okay so the point

69
00:04:48,160 --> 00:04:51,190
is is that Apache uses tons of memory

70
00:04:51,190 --> 00:04:53,320
when you start getting a lot of clients

71
00:04:53,320 --> 00:04:56,470
if you have 3,000 people like connecting

72
00:04:56,470 --> 00:04:59,470
to your Apache server you're using mini

73
00:04:59,470 --> 00:05:01,720
megabytes of memory whereas in genexus

74
00:05:01,720 --> 00:05:04,060
stays very stable it stays with a small

75
00:05:04,060 --> 00:05:09,630
footprint and the question really is

76
00:05:09,630 --> 00:05:12,550
what's the difference between these two

77
00:05:12,550 --> 00:05:15,250
and the big difference is that Apache

78
00:05:15,250 --> 00:05:18,150
uses threads for each connection and

79
00:05:18,150 --> 00:05:26,229
nginx uses an event loop okay so to be a

80
00:05:26,229 --> 00:05:30,030
slightly technical the first benchmark

81
00:05:30,030 --> 00:05:32,949
kind of tells you that context switching

82
00:05:32,949 --> 00:05:35,199
between the different threads which is

83
00:05:35,199 --> 00:05:38,289
what Apache does is is not free it costs

84
00:05:38,289 --> 00:05:44,080
some CPU time and the second one is that

85
00:05:44,080 --> 00:05:48,580
each thread takes memory and that ends

86
00:05:48,580 --> 00:05:52,750
up being a lot of memory and kind of in

87
00:05:52,750 --> 00:05:58,020
the building tight little server thing

88
00:05:58,020 --> 00:06:00,250
community if you want to make a little

89
00:06:00,250 --> 00:06:02,289
engine X server or you want to make a

90
00:06:02,289 --> 00:06:06,310
little IRC server everybody knows that

91
00:06:06,310 --> 00:06:08,440
you can't use threats for connections

92
00:06:08,440 --> 00:06:10,240
this is not the right way to do

93
00:06:10,240 --> 00:06:12,550
concurrency the right way to do

94
00:06:12,550 --> 00:06:14,470
concurrency is to have a single thread

95
00:06:14,470 --> 00:06:17,919
and have an event loop so you do

96
00:06:17,919 --> 00:06:20,500
something and then you're done with it

97
00:06:20,500 --> 00:06:21,789
and then you do something else and

98
00:06:21,789 --> 00:06:24,190
you're done with it but that requires

99
00:06:24,190 --> 00:06:27,880
though is that what you do never takes

100
00:06:27,880 --> 00:06:29,949
very long you have to have non-blocking

101
00:06:29,949 --> 00:06:38,979
i/o so apache uses OS threads there's

102
00:06:38,979 --> 00:06:40,780
other threading systems you could have

103
00:06:40,780 --> 00:06:43,570
green threads or you could have

104
00:06:43,570 --> 00:06:45,780
co-routines

105
00:06:45,780 --> 00:06:49,750
these can help the situation very much

106
00:06:49,750 --> 00:06:53,169
but it's still machinery it's still

107
00:06:53,169 --> 00:06:54,620
something that

108
00:06:54,620 --> 00:06:59,690
needs to be done you have to you have to

109
00:06:59,690 --> 00:07:02,660
do something to create the illusion that

110
00:07:02,660 --> 00:07:07,669
when you connect to the database your

111
00:07:07,669 --> 00:07:10,100
program halts you don't move on to the

112
00:07:10,100 --> 00:07:13,010
next line until it comes back it's an

113
00:07:13,010 --> 00:07:14,930
illusion your programs not halting it's

114
00:07:14,930 --> 00:07:16,970
doing all these other things but it

115
00:07:16,970 --> 00:07:22,130
looks like it's halted so I say that

116
00:07:22,130 --> 00:07:23,810
threaded concurrency is a leaky

117
00:07:23,810 --> 00:07:28,010
abstraction it's it creates pains you

118
00:07:28,010 --> 00:07:32,240
have locking problems you can you have

119
00:07:32,240 --> 00:07:34,310
these memory problems it's hard to think

120
00:07:34,310 --> 00:07:37,729
about it's not a very good abstraction

121
00:07:37,729 --> 00:07:39,110
for what's really happening on your

122
00:07:39,110 --> 00:07:46,340
computer so code like this where you

123
00:07:46,340 --> 00:07:51,229
call a function and it connects to some

124
00:07:51,229 --> 00:07:53,120
server and returns something from that

125
00:07:53,120 --> 00:07:57,710
server as if no time has passed and then

126
00:07:57,710 --> 00:07:59,150
you're going to use the result beyond

127
00:07:59,150 --> 00:08:03,020
that this somehow either requires

128
00:08:03,020 --> 00:08:05,990
blocking the entire process or you're

129
00:08:05,990 --> 00:08:07,460
going to have to have some sort of

130
00:08:07,460 --> 00:08:08,479
threading system

131
00:08:08,479 --> 00:08:11,360
maybe it's co-routines but it's probably

132
00:08:11,360 --> 00:08:14,810
going to require multiple execution

133
00:08:14,810 --> 00:08:19,099
stacks but you could have the code like

134
00:08:19,099 --> 00:08:22,130
this where you make the query to the

135
00:08:22,130 --> 00:08:24,949
database and instead of waiting for the

136
00:08:24,949 --> 00:08:27,680
response inside that function you give

137
00:08:27,680 --> 00:08:32,159
it a callback in one form or another

138
00:08:32,169 --> 00:08:35,750
when this happens you can your execution

139
00:08:35,750 --> 00:08:37,370
can run right through that statement

140
00:08:37,370 --> 00:08:40,789
make that request and continue doing

141
00:08:40,789 --> 00:08:43,550
other things when the request comes back

142
00:08:43,550 --> 00:08:45,650
millions and millions of clock cycles

143
00:08:45,650 --> 00:08:48,550
later you can execute the callback

144
00:08:48,550 --> 00:08:51,080
there's no machinery involved in this

145
00:08:51,080 --> 00:08:53,089
all you need is a pointer to that

146
00:08:53,089 --> 00:08:59,779
callback so this is how we need to do i

147
00:08:59,779 --> 00:09:03,410
oh if you want very fast high

148
00:09:03,410 --> 00:09:06,050
concurrency servers you have to design

149
00:09:06,050 --> 00:09:07,970
them like this

150
00:09:07,970 --> 00:09:12,779
mm-hmm so okay you say yeah but

151
00:09:12,779 --> 00:09:15,149
everybody's talking about threads you

152
00:09:15,149 --> 00:09:17,399
know my boss says that Java threads are

153
00:09:17,399 --> 00:09:19,620
super cool blah blah blah why isn't

154
00:09:19,620 --> 00:09:22,170
everybody doing this why should you

155
00:09:22,170 --> 00:09:26,100
believe me well there's there's two

156
00:09:26,100 --> 00:09:29,430
reasons I think they can be summed up in

157
00:09:29,430 --> 00:09:32,910
two reasons anyway and it would be

158
00:09:32,910 --> 00:09:37,079
cultural infrastructure 'el so I think

159
00:09:37,079 --> 00:09:39,420
that there's a cultural bias against

160
00:09:39,420 --> 00:09:42,360
doing non-blocking i/o you know your

161
00:09:42,360 --> 00:09:44,760
first program that you ever do io with

162
00:09:44,760 --> 00:09:46,440
is something where you enter your name

163
00:09:46,440 --> 00:09:49,529
and then you get the results somebody

164
00:09:49,529 --> 00:09:52,079
types that in but you block on that

165
00:09:52,079 --> 00:09:53,810
function you don't do anything else and

166
00:09:53,810 --> 00:09:56,940
then you print out the name so we're

167
00:09:56,940 --> 00:10:00,870
taught to like demand input and we kind

168
00:10:00,870 --> 00:10:03,180
of treat it the same way on on sockets

169
00:10:03,180 --> 00:10:06,209
so we connect to the database and all

170
00:10:06,209 --> 00:10:08,040
right give me the give me the give me

171
00:10:08,040 --> 00:10:13,620
the response so people see code like

172
00:10:13,620 --> 00:10:16,440
this where instead of waiting you just

173
00:10:16,440 --> 00:10:19,740
give a call back and they say I can't do

174
00:10:19,740 --> 00:10:20,100
that

175
00:10:20,100 --> 00:10:22,380
that's that spaghetti code that's too

176
00:10:22,380 --> 00:10:25,890
complicated I think we should reconsider

177
00:10:25,890 --> 00:10:28,230
this I don't think it is necessarily

178
00:10:28,230 --> 00:10:31,529
more complicated maybe in the simplest

179
00:10:31,529 --> 00:10:34,380
cases like this but when you start

180
00:10:34,380 --> 00:10:38,130
writing an IRC server it becomes very

181
00:10:38,130 --> 00:10:42,899
natural to write code like this and the

182
00:10:42,899 --> 00:10:45,180
other reason would be the missing

183
00:10:45,180 --> 00:10:48,269
infrastructure so remember if you're on

184
00:10:48,269 --> 00:10:50,880
an event loop you can never block on i/o

185
00:10:50,880 --> 00:10:52,800
you can never wait for the database to

186
00:10:52,800 --> 00:10:54,720
respond because you're in a single

187
00:10:54,720 --> 00:10:56,790
threat if you ever wait everything else

188
00:10:56,790 --> 00:10:58,470
shuts down we're in a threaded

189
00:10:58,470 --> 00:11:00,810
environment you can wait occasionally or

190
00:11:00,810 --> 00:11:05,279
for very long periods of time so the

191
00:11:05,279 --> 00:11:06,810
problem is is that we just don't have

192
00:11:06,810 --> 00:11:09,149
like libraries available to us to do

193
00:11:09,149 --> 00:11:14,250
this sort of non blocking i/o so just a

194
00:11:14,250 --> 00:11:16,680
couple of examples like POSIX has an

195
00:11:16,680 --> 00:11:19,740
asynchronous file IO specification but

196
00:11:19,740 --> 00:11:20,910
it's really hard to

197
00:11:20,910 --> 00:11:25,290
find such libraries man pages often

198
00:11:25,290 --> 00:11:29,240
don't state if a functions going to

199
00:11:29,240 --> 00:11:31,770
access the disk or not you just don't

200
00:11:31,770 --> 00:11:36,960
know which is important closures and

201
00:11:36,960 --> 00:11:39,450
anonymous functions you don't have in C

202
00:11:39,450 --> 00:11:44,030
so that makes writing such evented code

203
00:11:44,030 --> 00:11:49,980
difficult and things like live MySQL

204
00:11:49,980 --> 00:11:51,840
client don't support asynchronous

205
00:11:51,840 --> 00:11:54,150
queries I think they actually might do

206
00:11:54,150 --> 00:11:55,500
asynchronous queries but not

207
00:11:55,500 --> 00:11:58,800
asynchronous connections and Aengus

208
00:11:58,800 --> 00:12:01,440
asynchronous DNS resolution is is really

209
00:12:01,440 --> 00:12:11,820
difficult to find so there are certain

210
00:12:11,820 --> 00:12:15,270
solutions you might have heard of event

211
00:12:15,270 --> 00:12:18,630
machine or pythons twisted or if you

212
00:12:18,630 --> 00:12:21,690
come from Perl any event these are

213
00:12:21,690 --> 00:12:24,510
libraries that provide such an event

214
00:12:24,510 --> 00:12:27,930
loop with non-blocking sockets and it is

215
00:12:27,930 --> 00:12:30,450
fairly easy to use them to create

216
00:12:30,450 --> 00:12:34,830
efficient servers but I think that users

217
00:12:34,830 --> 00:12:39,380
are kind of confused as how to use this

218
00:12:39,380 --> 00:12:41,910
if you're using Ruby there's all of

219
00:12:41,910 --> 00:12:44,070
these libraries available you have a

220
00:12:44,070 --> 00:12:45,690
vent machine in here and you want to

221
00:12:45,690 --> 00:12:47,510
know how do I use these other ones and

222
00:12:47,510 --> 00:12:49,920
usually the answer to that is you can't

223
00:12:49,920 --> 00:12:53,400
because the MySQL library for Ruby

224
00:12:53,400 --> 00:12:55,980
blocks on everything so you can't just

225
00:12:55,980 --> 00:13:00,420
throw that into an event loop but people

226
00:13:00,420 --> 00:13:02,700
don't know that and so users really

227
00:13:02,700 --> 00:13:06,840
still require some knowledge of event

228
00:13:06,840 --> 00:13:10,650
loops or non-blocking i/o which almost

229
00:13:10,650 --> 00:13:14,430
nobody has and so it's doesn't abstract

230
00:13:14,430 --> 00:13:19,410
the problem very well but yeah luckily

231
00:13:19,410 --> 00:13:22,350
JavaScript was was designed in such a

232
00:13:22,350 --> 00:13:25,350
way that that it was built for an event

233
00:13:25,350 --> 00:13:27,960
though the browser side JavaScript that

234
00:13:27,960 --> 00:13:30,390
you have is an event loop you create a

235
00:13:30,390 --> 00:13:32,550
button somebody clicks it you get a

236
00:13:32,550 --> 00:13:34,019
unclick callback

237
00:13:34,019 --> 00:13:38,160
this is exactly what one needs to do

238
00:13:38,160 --> 00:13:43,019
event the stuff so yeah it has anonymous

239
00:13:43,019 --> 00:13:45,959
functions and closures when you're on

240
00:13:45,959 --> 00:13:47,879
the browser you only get one call back

241
00:13:47,879 --> 00:13:49,769
at a time you're not getting multiple

242
00:13:49,769 --> 00:13:51,600
callbacks and you don't need to lock

243
00:13:51,600 --> 00:13:55,589
variables and the i/o is just done

244
00:13:55,589 --> 00:14:01,290
through those callbacks so I think

245
00:14:01,290 --> 00:14:04,410
everybody in this room who is familiar

246
00:14:04,410 --> 00:14:10,259
with Java JavaScript is already kind of

247
00:14:10,259 --> 00:14:14,489
prepared for writing evented servers you

248
00:14:14,489 --> 00:14:16,529
don't you you don't really need to know

249
00:14:16,529 --> 00:14:21,119
that much more so right so that was a

250
00:14:21,119 --> 00:14:27,569
long motivation so what I want to make

251
00:14:27,569 --> 00:14:32,249
is a non-blocking

252
00:14:32,249 --> 00:14:34,230
infrastructure so that you can make very

253
00:14:34,230 --> 00:14:37,439
highly concurrent servers and you don't

254
00:14:37,439 --> 00:14:39,089
need to know about it we're going to

255
00:14:39,089 --> 00:14:41,730
abstract all of the difficult

256
00:14:41,730 --> 00:14:43,709
non-blocking event loop you don't need

257
00:14:43,709 --> 00:14:45,529
to know about that it's just going to be

258
00:14:45,529 --> 00:14:55,709
callbacks so right so so let me just

259
00:14:55,709 --> 00:14:57,600
give some design goals and then I'll

260
00:14:57,600 --> 00:15:00,600
give some actual practical examples of

261
00:15:00,600 --> 00:15:06,059
how to build a server so first of all no

262
00:15:06,059 --> 00:15:09,600
function should perform i/o to receive

263
00:15:09,600 --> 00:15:17,189
disk or network information from or from

264
00:15:17,189 --> 00:15:19,110
another process you have to have some

265
00:15:19,110 --> 00:15:20,699
sort of callback so you can never have

266
00:15:20,699 --> 00:15:23,069
that sort of function that makes some

267
00:15:23,069 --> 00:15:24,990
query that return something that's not

268
00:15:24,990 --> 00:15:31,079
allowed it should be low-level so I want

269
00:15:31,079 --> 00:15:33,299
everything to be able to stream in and

270
00:15:33,299 --> 00:15:37,619
out you never should never force the

271
00:15:37,619 --> 00:15:41,669
user to buffer data and if you're

272
00:15:41,669 --> 00:15:44,189
familiar with like Ruby on Rails or

273
00:15:44,189 --> 00:15:47,430
something a lot of places

274
00:15:47,430 --> 00:15:49,770
you to buffer data in one way or another

275
00:15:49,770 --> 00:15:52,950
I don't want to make those choices for

276
00:15:52,950 --> 00:15:55,050
you it's low level people can build on

277
00:15:55,050 --> 00:15:57,510
top of that so if they want to buffer

278
00:15:57,510 --> 00:16:01,320
their data then they can do that but at

279
00:16:01,320 --> 00:16:04,260
my level at the node level it should not

280
00:16:04,260 --> 00:16:07,430
make any sort of decisions like that and

281
00:16:07,430 --> 00:16:11,880
similarly I shouldn't remove any

282
00:16:11,880 --> 00:16:14,490
functionality at the POSIX layer so for

283
00:16:14,490 --> 00:16:17,029
example have close TCP connections

284
00:16:17,029 --> 00:16:20,220
everybody's shrugging but there's good

285
00:16:20,220 --> 00:16:22,790
stuff to be had that everybody ignores

286
00:16:22,790 --> 00:16:28,380
um and so I should also have like some

287
00:16:28,380 --> 00:16:30,270
built-in support you don't want to write

288
00:16:30,270 --> 00:16:33,060
everything I want you to I want it to be

289
00:16:33,060 --> 00:16:36,089
low level but I think TCP and DNS and

290
00:16:36,089 --> 00:16:40,050
HTTP are infrastructural protocols

291
00:16:40,050 --> 00:16:41,910
they're very important and so there

292
00:16:41,910 --> 00:16:44,160
should be very good support for them in

293
00:16:44,160 --> 00:16:50,190
such a system and in particular with

294
00:16:50,190 --> 00:16:54,690
with HTTP it should it's going to have

295
00:16:54,690 --> 00:16:56,250
many features so we're going to have

296
00:16:56,250 --> 00:16:58,650
chunked request chunked responses I'm

297
00:16:58,650 --> 00:17:01,740
going to have keepalive and importantly

298
00:17:01,740 --> 00:17:04,949
it should be you should be able to get a

299
00:17:04,949 --> 00:17:08,160
request and respond to it at will so you

300
00:17:08,160 --> 00:17:11,100
should be able to hang requests and this

301
00:17:11,100 --> 00:17:13,400
is what you need for comet style

302
00:17:13,400 --> 00:17:15,449
applications if you want to do a long

303
00:17:15,449 --> 00:17:17,850
pole then you have to hang that request

304
00:17:17,850 --> 00:17:20,100
and wait till you have something to tell

305
00:17:20,100 --> 00:17:25,170
the user mm-hmm and finally the the API

306
00:17:25,170 --> 00:17:29,340
needs to be familiar so if I'm going to

307
00:17:29,340 --> 00:17:31,020
have a timer I'm going to call it set

308
00:17:31,020 --> 00:17:33,090
timeout it's going to it should look

309
00:17:33,090 --> 00:17:36,030
like browser JavaScript and where it's

310
00:17:36,030 --> 00:17:38,130
not browser JavaScript where I'm talking

311
00:17:38,130 --> 00:17:41,670
about POSIX stuff then it should use the

312
00:17:41,670 --> 00:17:43,350
POSIX names that is I don't want to

313
00:17:43,350 --> 00:17:46,679
reinvent what people are doing I just

314
00:17:46,679 --> 00:17:48,929
kind of want to present an idealized

315
00:17:48,929 --> 00:17:51,570
version of that and then finally it

316
00:17:51,570 --> 00:17:54,030
should be platform independent at the

317
00:17:54,030 --> 00:17:56,210
moment I don't compile on Windows but

318
00:17:56,210 --> 00:18:01,600
there's no reason I can't and I hope to

319
00:18:01,600 --> 00:18:08,230
okay so now now some actual examples so

320
00:18:08,230 --> 00:18:10,910
note is you have to compile it so you

321
00:18:10,910 --> 00:18:15,440
have to download it so there's no

322
00:18:15,440 --> 00:18:17,420
binaries is what I want to say and you

323
00:18:17,420 --> 00:18:19,280
there's no real dependencies other than

324
00:18:19,280 --> 00:18:22,520
Python so it should be fairly easy to to

325
00:18:22,520 --> 00:18:25,190
build it's not it's not very difficult

326
00:18:25,190 --> 00:18:28,670
or at least it should not be okay so

327
00:18:28,670 --> 00:18:31,640
here's here's your first example this

328
00:18:31,640 --> 00:18:35,090
program is going to output hello after

329
00:18:35,090 --> 00:18:42,110
having waited two seconds so first first

330
00:18:42,110 --> 00:18:46,310
we require the SIS model which we need

331
00:18:46,310 --> 00:18:49,010
to output some some data this is the

332
00:18:49,010 --> 00:18:52,880
common j/s require uses the semantics

333
00:18:52,880 --> 00:18:56,360
defined by command j s then we set a

334
00:18:56,360 --> 00:19:00,130
timeout for 2,000 milliseconds mm-hmm

335
00:19:00,130 --> 00:19:02,870
importantly the callback inside is not

336
00:19:02,870 --> 00:19:05,840
done right now first we print hello

337
00:19:05,840 --> 00:19:09,590
which comes after that two seconds later

338
00:19:09,590 --> 00:19:15,950
world is printed out so node after the

339
00:19:15,950 --> 00:19:19,160
world is printed out no two exits so

340
00:19:19,160 --> 00:19:21,200
that's kind of important when there's

341
00:19:21,200 --> 00:19:23,660
nothing else to do on the event loop if

342
00:19:23,660 --> 00:19:26,180
there's no more timers than it exits

343
00:19:26,180 --> 00:19:30,110
it's the end of the process okay so so

344
00:19:30,110 --> 00:19:32,120
here's what you would do you would put

345
00:19:32,120 --> 00:19:34,760
it into a file called hello world GS and

346
00:19:34,760 --> 00:19:37,280
then run it with the node program and

347
00:19:37,280 --> 00:19:39,710
you get hello to send kids later world

348
00:19:39,710 --> 00:19:45,410
in the process exits okay mmm-hmm so now

349
00:19:45,410 --> 00:19:47,210
we're going to change the hello world

350
00:19:47,210 --> 00:19:51,830
program and what we'll do this time is

351
00:19:51,830 --> 00:19:54,920
is we're going to go in a loop so we're

352
00:19:54,920 --> 00:19:58,880
going to use the the set interval

353
00:19:58,880 --> 00:20:01,520
function and we're going to loop forever

354
00:20:01,520 --> 00:20:04,220
and print out a message and then what we

355
00:20:04,220 --> 00:20:05,840
want when the user kills it when they

356
00:20:05,840 --> 00:20:08,840
hit control-c that it prints out a

357
00:20:08,840 --> 00:20:11,420
message and then exits and this is to

358
00:20:11,420 --> 00:20:13,430
demonstrate the special

359
00:20:13,430 --> 00:20:17,060
process object in node and the how you

360
00:20:17,060 --> 00:20:19,850
set a signal handler the for the

361
00:20:19,850 --> 00:20:23,780
interrupt signal the second okay so so

362
00:20:23,780 --> 00:20:27,650
again we do the require we just need one

363
00:20:27,650 --> 00:20:29,420
function so let's just pull it out into

364
00:20:29,420 --> 00:20:32,600
a variable in the next three lines we

365
00:20:32,600 --> 00:20:34,880
set up the interval which calls that

366
00:20:34,880 --> 00:20:39,740
callback every 500 milliseconds right

367
00:20:39,740 --> 00:20:41,870
and then the last couple lines we're

368
00:20:41,870 --> 00:20:46,760
setting up a signal handler so you do

369
00:20:46,760 --> 00:20:48,980
this by calling this add listener

370
00:20:48,980 --> 00:20:52,190
function which is should be fairly

371
00:20:52,190 --> 00:20:57,230
familiar if you're used to the Dom then

372
00:20:57,230 --> 00:20:59,420
you put you you print out goodbye and

373
00:20:59,420 --> 00:21:05,330
then you you exit the process so this

374
00:21:05,330 --> 00:21:11,030
this process object emits events when it

375
00:21:11,030 --> 00:21:13,580
receives a signal so it emits the sig

376
00:21:13,580 --> 00:21:17,660
int event there it would be the same for

377
00:21:17,660 --> 00:21:21,200
any other signal that that the process

378
00:21:21,200 --> 00:21:26,720
might get so so this is like the dome

379
00:21:26,720 --> 00:21:29,870
you just add a listener to catch what

380
00:21:29,870 --> 00:21:33,080
the process is doing there's a couple of

381
00:21:33,080 --> 00:21:35,390
other things on the process like the PID

382
00:21:35,390 --> 00:21:37,760
the program arguments the environment

383
00:21:37,760 --> 00:21:40,510
current working directory memory usage

384
00:21:40,510 --> 00:21:44,720
useful things so the the way that

385
00:21:44,720 --> 00:21:48,050
process emits these events is is pretty

386
00:21:48,050 --> 00:21:52,190
typical for node so many objects emit

387
00:21:52,190 --> 00:21:55,280
events it's kind of the the fundamental

388
00:21:55,280 --> 00:22:00,260
paradigm in in in node so like for

389
00:22:00,260 --> 00:22:02,300
example a TCP server would emit a

390
00:22:02,300 --> 00:22:04,970
connection event every time somebody

391
00:22:04,970 --> 00:22:08,150
connects and like if you have somebody's

392
00:22:08,150 --> 00:22:12,200
doing an HTTP upload it would emit the

393
00:22:12,200 --> 00:22:15,110
request object to admit a body event

394
00:22:15,110 --> 00:22:16,970
each time you get a packet of that

395
00:22:16,970 --> 00:22:19,130
upload so somebody's uploading a stream

396
00:22:19,130 --> 00:22:22,160
a movie or so to your server and you get

397
00:22:22,160 --> 00:22:26,180
body body body

398
00:22:26,190 --> 00:22:30,210
so yeah all objects that emit events are

399
00:22:30,210 --> 00:22:36,030
instances of the event in meter class mm

400
00:22:36,030 --> 00:22:39,270
okay so so here's here's the first TCP

401
00:22:39,270 --> 00:22:42,000
server example so we're going make a TCP

402
00:22:42,000 --> 00:22:44,040
server it's going to listen on port 8000

403
00:22:44,040 --> 00:22:46,350
and then when somebody connects we're

404
00:22:46,350 --> 00:22:48,750
going to send the the peer a message

405
00:22:48,750 --> 00:22:50,550
we're going to say hello and then we're

406
00:22:50,550 --> 00:22:52,170
going close to the connection so a very

407
00:22:52,170 --> 00:22:56,280
simple TCP server so we have to require

408
00:22:56,280 --> 00:22:58,560
the TCP module that's what we do in the

409
00:22:58,560 --> 00:23:00,780
first line and then we create a server

410
00:23:00,780 --> 00:23:05,820
object s and we that's a TCP server and

411
00:23:05,820 --> 00:23:07,860
then we add a listener for the

412
00:23:07,860 --> 00:23:11,130
connection event and we get this object

413
00:23:11,130 --> 00:23:13,680
C from from the connection event that's

414
00:23:13,680 --> 00:23:18,000
that's our connection we send it hello

415
00:23:18,000 --> 00:23:21,210
we close and then finally we have to

416
00:23:21,210 --> 00:23:27,720
start it listening on port 8000 so if if

417
00:23:27,720 --> 00:23:32,910
we tried that then we would start the we

418
00:23:32,910 --> 00:23:34,710
would put that code in this server Jas

419
00:23:34,710 --> 00:23:37,920
and you can tell that to localhost

420
00:23:37,920 --> 00:23:40,860
at a port 8000 and you get hello and

421
00:23:40,860 --> 00:23:43,050
then the the server closes the

422
00:23:43,050 --> 00:23:52,500
connection okay so we can simplify this

423
00:23:52,500 --> 00:23:54,240
a little bit so the the connection

424
00:23:54,240 --> 00:23:55,560
listener does it you don't need to call

425
00:23:55,560 --> 00:23:57,480
this add listener you can just pass it

426
00:23:57,480 --> 00:23:59,700
to the constructor and so so we can

427
00:23:59,700 --> 00:24:01,680
simplify this program until just a

428
00:24:01,680 --> 00:24:08,550
couple lines by doing this so file i/o

429
00:24:08,550 --> 00:24:13,200
and notice non-blocking this is

430
00:24:13,200 --> 00:24:15,630
something that's usually very hard to do

431
00:24:15,630 --> 00:24:21,720
and note it's quite hard not to do which

432
00:24:21,720 --> 00:24:24,870
is good I mean the the way that you

433
00:24:24,870 --> 00:24:27,540
should be doing things should be easy in

434
00:24:27,540 --> 00:24:28,890
the way you shouldn't be doing things

435
00:24:28,890 --> 00:24:33,930
should be difficult okay so so what

436
00:24:33,930 --> 00:24:36,730
we're going to do is we're going to

437
00:24:36,730 --> 00:24:39,429
look at the last time somebody modified

438
00:24:39,429 --> 00:24:43,059
EDC password so first we require the

439
00:24:43,059 --> 00:24:45,340
POSIX module which has all of our file

440
00:24:45,340 --> 00:24:47,919
i/o operations and we pull out this stat

441
00:24:47,919 --> 00:24:52,389
function we require our puts function

442
00:24:52,389 --> 00:24:56,889
get that from the sis module and then we

443
00:24:56,889 --> 00:24:59,649
call stat on EDC password and it returns

444
00:24:59,649 --> 00:25:03,419
a province which I'll talk more about

445
00:25:03,419 --> 00:25:05,950
and then we add a call back to the

446
00:25:05,950 --> 00:25:08,859
promise which gets called when when the

447
00:25:08,859 --> 00:25:12,730
stat operation was complete and then

448
00:25:12,730 --> 00:25:14,799
finally we print out the the modified

449
00:25:14,799 --> 00:25:21,129
time so the these these promise objects

450
00:25:21,129 --> 00:25:23,379
are pretty common all the file

451
00:25:23,379 --> 00:25:26,470
operations return a promise and so a

452
00:25:26,470 --> 00:25:28,659
promise is is an event emitter which

453
00:25:28,659 --> 00:25:32,230
which emits a success or an error event

454
00:25:32,230 --> 00:25:35,950
so if you do some file operation you

455
00:25:35,950 --> 00:25:37,989
don't want to block because that's going

456
00:25:37,989 --> 00:25:40,359
to be a long time you can't just shut

457
00:25:40,359 --> 00:25:42,129
down your server while you spin the disk

458
00:25:42,129 --> 00:25:46,600
so you send off this request to the to

459
00:25:46,600 --> 00:25:49,509
the disk ok tell me what time that that

460
00:25:49,509 --> 00:25:51,909
file was modified I'm going to go do

461
00:25:51,909 --> 00:25:54,789
other things and then eventually it

462
00:25:54,789 --> 00:25:57,970
comes back and it says success I got the

463
00:25:57,970 --> 00:25:59,609
answer for you here it is

464
00:25:59,609 --> 00:26:04,720
or error so the the promise dot add

465
00:26:04,720 --> 00:26:07,649
callback was was just API sugar for for

466
00:26:07,649 --> 00:26:14,200
promise at this nurse first success okay

467
00:26:14,200 --> 00:26:16,269
so we're getting progressively more

468
00:26:16,269 --> 00:26:19,720
complicated now we're going to do an

469
00:26:19,720 --> 00:26:24,129
HTTP server we have to require the the

470
00:26:24,129 --> 00:26:29,470
HTTP module and we create a HTTP server

471
00:26:29,470 --> 00:26:33,190
object and the callback for this which

472
00:26:33,190 --> 00:26:36,039
is called on each request gives you a

473
00:26:36,039 --> 00:26:40,919
request object in a response object so

474
00:26:40,919 --> 00:26:44,379
then we send that the header the the 200

475
00:26:44,379 --> 00:26:46,840
success code and content type text plane

476
00:26:46,840 --> 00:26:50,530
and we send body hello send body world

477
00:26:50,530 --> 00:26:54,640
and then we finished the response this

478
00:26:54,640 --> 00:26:58,960
is slightly more complicated than if you

479
00:26:58,960 --> 00:27:02,050
were at the narwhal talk before Tom

480
00:27:02,050 --> 00:27:05,440
promotes the the J SGI specification

481
00:27:05,440 --> 00:27:08,380
this is more complicated than that but

482
00:27:08,380 --> 00:27:12,710
it's it's for a good reason

483
00:27:12,720 --> 00:27:18,940
J SGI requires you to Iraq to rap it's

484
00:27:18,940 --> 00:27:21,400
it's the same thing you have a function

485
00:27:21,400 --> 00:27:23,590
and then you return the result so all

486
00:27:23,590 --> 00:27:25,090
the processing happens in a single

487
00:27:25,090 --> 00:27:27,490
function which as I said at the

488
00:27:27,490 --> 00:27:29,020
beginning is something we want to avoid

489
00:27:29,020 --> 00:27:30,840
if you have to connect to the database

490
00:27:30,840 --> 00:27:34,240
then you don't want to you don't want to

491
00:27:34,240 --> 00:27:37,210
have to respond in one function now I

492
00:27:37,210 --> 00:27:41,110
think that there's some ways to do that

493
00:27:41,110 --> 00:27:44,350
with with J SGI but i like this i think

494
00:27:44,350 --> 00:27:48,940
it's it's simple enough so let's let's

495
00:27:48,940 --> 00:27:51,900
try this out so we put the the code into

496
00:27:51,900 --> 00:27:54,010
HTTP server j yes

497
00:27:54,010 --> 00:27:57,190
we're uncurl on it and we get hello

498
00:27:57,190 --> 00:28:01,040
world

499
00:28:01,050 --> 00:28:04,930
okay now slightly more complicated we're

500
00:28:04,930 --> 00:28:06,820
going to do the same thing we're going

501
00:28:06,820 --> 00:28:09,100
to have an HTTP server which outputs

502
00:28:09,100 --> 00:28:12,760
hello world but instead of outputting at

503
00:28:12,760 --> 00:28:14,860
all at once it's going to output hello

504
00:28:14,860 --> 00:28:17,500
and then it's going to output world two

505
00:28:17,500 --> 00:28:20,590
seconds later so what we do is we put a

506
00:28:20,590 --> 00:28:23,290
set timeout in there so we wait for 2000

507
00:28:23,290 --> 00:28:28,670
milliseconds in the the request callback

508
00:28:28,680 --> 00:28:33,670
so you might wonder like okay who cares

509
00:28:33,670 --> 00:28:36,790
why would anybody want to do this but

510
00:28:36,790 --> 00:28:40,990
this is important because while the

511
00:28:40,990 --> 00:28:43,090
server doesn't shut down when when the

512
00:28:43,090 --> 00:28:44,290
set timeout is called

513
00:28:44,290 --> 00:28:46,210
it doesn't say set timeout it's not

514
00:28:46,210 --> 00:28:48,430
asleep you're not sleeping for two

515
00:28:48,430 --> 00:28:50,110
seconds and not doing anything else

516
00:28:50,110 --> 00:28:52,990
you're serving requests so here's a

517
00:28:52,990 --> 00:28:54,190
request here's a request here's a

518
00:28:54,190 --> 00:28:56,650
request and then suddenly okay that

519
00:28:56,650 --> 00:28:58,450
one's done that one's done that one's

520
00:28:58,450 --> 00:29:01,000
done this is the exact behavior that

521
00:29:01,000 --> 00:29:04,000
you'd need for comet style application

522
00:29:04,000 --> 00:29:06,160
if you need to do a long pole you have

523
00:29:06,160 --> 00:29:07,960
to be able to hang requests in an

524
00:29:07,960 --> 00:29:10,300
efficient way and this demonstrates how

525
00:29:10,300 --> 00:29:13,750
you can do that this isn't the right way

526
00:29:13,750 --> 00:29:15,610
to do a long pole thing but it

527
00:29:15,610 --> 00:29:20,270
demonstrates that you can hang requests

528
00:29:20,280 --> 00:29:23,890
so let's try it out we put into a file

529
00:29:23,890 --> 00:29:27,760
HTTP server to call it with node run

530
00:29:27,760 --> 00:29:30,760
curl we get hello two seconds later we

531
00:29:30,760 --> 00:29:35,770
get world a streaming web server okay we

532
00:29:35,770 --> 00:29:38,500
can also use we can also call programs

533
00:29:38,500 --> 00:29:42,100
with node one would hope so we can do

534
00:29:42,100 --> 00:29:46,810
that with the Cissy XE command of course

535
00:29:46,810 --> 00:29:49,780
this also returns a promise because it's

536
00:29:49,780 --> 00:29:50,860
something that doesn't happen

537
00:29:50,860 --> 00:29:52,780
immediately it doesn't happen in memory

538
00:29:52,780 --> 00:29:57,010
but you know if you do LS / that might

539
00:29:57,010 --> 00:29:58,720
have to spin the disk and so there's

540
00:29:58,720 --> 00:30:02,050
some time that happens between the time

541
00:30:02,050 --> 00:30:03,610
that that starts and the time that that

542
00:30:03,610 --> 00:30:05,940
finishes so we have to have a callback

543
00:30:05,940 --> 00:30:08,680
so we we add a callback to the promise

544
00:30:08,680 --> 00:30:11,080
object which is returned from sista XE

545
00:30:11,080 --> 00:30:17,530
and then we output the output okay so

546
00:30:17,530 --> 00:30:20,410
but I told you before that I never would

547
00:30:20,410 --> 00:30:22,420
force people to buffer data and that

548
00:30:22,420 --> 00:30:25,540
just buffered the data so there's also a

549
00:30:25,540 --> 00:30:29,200
lower-level way to call sub process to

550
00:30:29,200 --> 00:30:32,280
call it to make a child process where

551
00:30:32,280 --> 00:30:35,230
you can stream the data through through

552
00:30:35,230 --> 00:30:37,840
the standard i/o so you can stream that

553
00:30:37,840 --> 00:30:40,390
if you're you LS on a huge directory you

554
00:30:40,390 --> 00:30:42,100
don't want to buffer all of that data in

555
00:30:42,100 --> 00:30:45,160
memory you want to stream it to the to

556
00:30:45,160 --> 00:30:48,670
the to the parent process and pars it

557
00:30:48,670 --> 00:30:51,190
and handle it do whatever with it but

558
00:30:51,190 --> 00:30:54,190
hopefully not buffer it so this is a

559
00:30:54,190 --> 00:30:56,230
simple form of inter process

560
00:30:56,230 --> 00:31:01,690
communication so this is an example of

561
00:31:01,690 --> 00:31:03,910
that where we're going to launch the cat

562
00:31:03,910 --> 00:31:08,260
program like the UNIX cat program which

563
00:31:08,260 --> 00:31:10,900
whatever you you send to it it just

564
00:31:10,900 --> 00:31:14,170
sends the same thing back and so we

565
00:31:14,170 --> 00:31:17,020
create the child process in line 3

566
00:31:17,020 --> 00:31:20,380
we add a listener for output so every

567
00:31:20,380 --> 00:31:22,210
time that there's some output it calls

568
00:31:22,210 --> 00:31:24,430
that that callback and then in the last

569
00:31:24,430 --> 00:31:26,620
couple lines we write data to the cat

570
00:31:26,620 --> 00:31:29,440
process and so that's sending that hello

571
00:31:29,440 --> 00:31:33,700
world and line eleven and twelve to the

572
00:31:33,700 --> 00:31:37,030
standard in of the cat process and then

573
00:31:37,030 --> 00:31:39,130
finally we call closed which closes the

574
00:31:39,130 --> 00:31:42,850
standard end of the cat process and cat

575
00:31:42,850 --> 00:31:44,740
terminates when it's standard in is is

576
00:31:44,740 --> 00:31:49,030
complete okay so we can Street we can

577
00:31:49,030 --> 00:31:52,510
create sub processes we can create child

578
00:31:52,510 --> 00:31:55,300
processes and stream data in and out of

579
00:31:55,300 --> 00:32:01,210
out of them okay so so now I have a demo

580
00:32:01,210 --> 00:32:06,060
for you I wrote an IRC server in node

581
00:32:06,060 --> 00:32:09,880
just a hack really but just to

582
00:32:09,880 --> 00:32:14,770
demonstrate what you can do so maybe

583
00:32:14,770 --> 00:32:16,690
this will work maybe this won't work but

584
00:32:16,690 --> 00:32:19,330
let's let's try to go to IRC no js' dot

585
00:32:19,330 --> 00:32:44,690
org and go on to the node.js channel

586
00:32:44,700 --> 00:32:47,940
okay so so I have my my terminal here

587
00:32:47,940 --> 00:32:49,649
I'm actually logged into the server so

588
00:32:49,649 --> 00:32:52,230
well first of all I'm going to connect

589
00:32:52,230 --> 00:32:53,669
to the server hopefully it's still

590
00:32:53,669 --> 00:33:06,840
running and it hasn't crashed

591
00:33:06,850 --> 00:33:10,840
okay so so now I'm connected and I I

592
00:33:10,840 --> 00:33:22,990
will join the OGS

593
00:33:23,000 --> 00:33:26,960
okay so so if if people did that you can

594
00:33:26,960 --> 00:33:29,870
see people talking so so this this IRC

595
00:33:29,870 --> 00:33:35,570
server is is running on node this is an

596
00:33:35,570 --> 00:33:38,450
IRC client of course what I want to do

597
00:33:38,450 --> 00:33:47,299
is actually show yes I want to I also

598
00:33:47,299 --> 00:33:49,159
have a repo library a read eval print

599
00:33:49,159 --> 00:33:51,679
loop and so since we have an event loop

600
00:33:51,679 --> 00:33:54,080
we can add all sorts of io to this this

601
00:33:54,080 --> 00:33:56,240
is one process but we can add a repo to

602
00:33:56,240 --> 00:33:57,919
it without thinking about it because

603
00:33:57,919 --> 00:34:00,500
what we do is we do all the on our event

604
00:34:00,500 --> 00:34:02,450
loop we we do all the connections we

605
00:34:02,450 --> 00:34:04,220
send all the messages we come back and

606
00:34:04,220 --> 00:34:06,440
then we can do the repo things if we

607
00:34:06,440 --> 00:34:08,389
wanted to add an HTTP server to that

608
00:34:08,389 --> 00:34:10,159
that would also be possible all in the

609
00:34:10,159 --> 00:34:12,530
same process just by going around the

610
00:34:12,530 --> 00:34:14,210
event loop and since nothing blocks we

611
00:34:14,210 --> 00:34:20,240
can just add as much IO as we want to so

612
00:34:20,240 --> 00:34:29,159
I show you the repo now

613
00:34:29,169 --> 00:34:48,659
kind of

614
00:34:48,669 --> 00:34:52,539
okay so it's running on screen so I'm

615
00:34:52,539 --> 00:35:05,010
just going to open the screen

616
00:35:05,020 --> 00:35:09,570
there it is okay so this is the ircd

617
00:35:09,570 --> 00:35:13,090
repo thing and so what I can do is is I

618
00:35:13,090 --> 00:35:16,480
have total control over the IRC server

619
00:35:16,480 --> 00:35:20,170
so for example I can kill some of these

620
00:35:20,170 --> 00:35:39,870
users off

621
00:35:39,880 --> 00:35:42,530
yeah okay

622
00:35:42,530 --> 00:35:47,119
I have full control I could also make

623
00:35:47,119 --> 00:36:42,890
people like say things

624
00:36:42,900 --> 00:36:46,480
okay anyway the point is we have a we

625
00:36:46,480 --> 00:36:52,360
have a repo to to the IRC server and of

626
00:36:52,360 --> 00:36:54,190
course if I just control see it then

627
00:36:54,190 --> 00:36:56,560
everybody will go away and they're

628
00:36:56,560 --> 00:36:59,470
offline now because the IRC server is

629
00:36:59,470 --> 00:37:01,810
gone and if I turn it back on then it's

630
00:37:01,810 --> 00:37:42,530
just there okay so so that's my my demo

631
00:37:42,540 --> 00:37:48,510
okay yeah so so check out the the code

632
00:37:48,510 --> 00:37:51,360
if you want it's it's just 400 lines or

633
00:37:51,360 --> 00:37:57,090
so I think this demonstrates that node

634
00:37:57,090 --> 00:37:59,760
abstracts the real problem of writing an

635
00:37:59,760 --> 00:38:02,130
IRC server away because if you look at

636
00:38:02,130 --> 00:38:03,900
the code of that it's just okay somebody

637
00:38:03,900 --> 00:38:05,730
connects okay I have a list of users

638
00:38:05,730 --> 00:38:08,520
okay I send this user that message it's

639
00:38:08,520 --> 00:38:11,580
it's really quite easy to follow in my

640
00:38:11,580 --> 00:38:15,600
humble opinion whereas if you try to sit

641
00:38:15,600 --> 00:38:18,270
down and write an IRC server say in Ruby

642
00:38:18,270 --> 00:38:21,630
I think you'll find it very difficult

643
00:38:21,630 --> 00:38:23,670
okay I guess who can use event machine

644
00:38:23,670 --> 00:38:28,590
and you might find it okay but I think

645
00:38:28,590 --> 00:38:32,400
that this really abstracts the the the

646
00:38:32,400 --> 00:38:35,700
problem of writing a concurrent server

647
00:38:35,700 --> 00:38:37,980
so if you want to throw together say a

648
00:38:37,980 --> 00:38:41,220
message queue demon startup node type

649
00:38:41,220 --> 00:38:43,020
out a hundred lines of JavaScript and

650
00:38:43,020 --> 00:38:45,270
there's your message queue demon that

651
00:38:45,270 --> 00:38:47,520
that does whatever specific thing that

652
00:38:47,520 --> 00:38:51,450
you need it to do okay so so just

653
00:38:51,450 --> 00:38:54,720
briefly uh I talked about the internal

654
00:38:54,720 --> 00:38:58,590
design of node so note is not some big

655
00:38:58,590 --> 00:39:03,390
monolithic app it's it's a bunch of C

656
00:39:03,390 --> 00:39:07,020
libraries that are kind of hacked

657
00:39:07,020 --> 00:39:09,990
together in various ways so the v8 is

658
00:39:09,990 --> 00:39:11,760
not a little seed library it's a huge C

659
00:39:11,760 --> 00:39:16,290
library that's by Google of course the

660
00:39:16,290 --> 00:39:19,800
Lib Evie event loop and Libby IO thread

661
00:39:19,800 --> 00:39:22,350
pool are a really nice little libraries

662
00:39:22,350 --> 00:39:24,270
and they're both written by marked

663
00:39:24,270 --> 00:39:29,210
layman there's a HTTP parser which is

664
00:39:29,210 --> 00:39:32,150
quite advanced it could do all sorts of

665
00:39:32,150 --> 00:39:35,130
streaming sort of things that's by me

666
00:39:35,130 --> 00:39:38,580
and a socket library by me too and then

667
00:39:38,580 --> 00:39:42,930
a you you DNS is is a DNS resolver which

668
00:39:42,930 --> 00:39:49,830
is important so the way that I do this

669
00:39:49,830 --> 00:39:53,450
is

670
00:39:53,460 --> 00:39:55,170
there's a lot of system calls that you

671
00:39:55,170 --> 00:39:56,910
might do if you have to access the file

672
00:39:56,910 --> 00:40:01,650
system those system calls those POSIX

673
00:40:01,650 --> 00:40:03,780
system calls can block and so what I do

674
00:40:03,780 --> 00:40:05,670
is I have a thread pool underneath

675
00:40:05,670 --> 00:40:11,430
everything and I say ok I want to do

676
00:40:11,430 --> 00:40:14,880
this system call I want to read a

677
00:40:14,880 --> 00:40:17,400
directory I pack it up and then I send

678
00:40:17,400 --> 00:40:19,680
it off to the thread pool it does stuff

679
00:40:19,680 --> 00:40:24,240
and then it comes back signal handlers

680
00:40:24,240 --> 00:40:27,450
are usually asynchronous from the rest

681
00:40:27,450 --> 00:40:31,770
of your execution stack and this this

682
00:40:31,770 --> 00:40:33,660
thread pool thing these things are kind

683
00:40:33,660 --> 00:40:36,300
of asynchronous from the main nodejs

684
00:40:36,300 --> 00:40:38,880
event loop and so they have to notify

685
00:40:38,880 --> 00:40:40,770
they have to be marshaled back into the

686
00:40:40,770 --> 00:40:43,470
main event loop you have to say ok wait

687
00:40:43,470 --> 00:40:45,809
your turn alright now we can process the

688
00:40:45,809 --> 00:40:47,339
signal handler you can't just do it

689
00:40:47,339 --> 00:40:49,500
immediately when the result comes from

690
00:40:49,500 --> 00:40:51,420
the event loop you can't just say stop

691
00:40:51,420 --> 00:40:53,190
everything we're going to do this you

692
00:40:53,190 --> 00:40:55,380
have to say ok all right now we can

693
00:40:55,380 --> 00:40:57,750
process you and we I do this by by using

694
00:40:57,750 --> 00:41:00,920
a pipe from the thread pool in and from

695
00:41:00,920 --> 00:41:04,740
signal handlers in and you can select on

696
00:41:04,740 --> 00:41:09,599
that pipe another thing that I did is

697
00:41:09,599 --> 00:41:12,270
I'm worried about what happens if you

698
00:41:12,270 --> 00:41:16,319
pipe a huge file into node so say this

699
00:41:16,319 --> 00:41:21,720
this file is 200 megabytes and has a

700
00:41:21,720 --> 00:41:24,720
list of domain names and you want to

701
00:41:24,720 --> 00:41:28,650
look them all up so each line is a

702
00:41:28,650 --> 00:41:31,349
domain name and you want to do dns

703
00:41:31,349 --> 00:41:33,390
resolution on them but you can't block

704
00:41:33,390 --> 00:41:35,130
the dns resolution or else it's going to

705
00:41:35,130 --> 00:41:36,510
be really slow what you want to do is

706
00:41:36,510 --> 00:41:38,280
read it and stream it into your node

707
00:41:38,280 --> 00:41:40,950
process read the lines do the DNS

708
00:41:40,950 --> 00:41:42,540
lookups and this should all be on the

709
00:41:42,540 --> 00:41:47,099
same event level so the problem is is

710
00:41:47,099 --> 00:41:52,619
that in UNIX or in any POSIX system the

711
00:41:52,619 --> 00:41:54,750
standard EDD file descriptor is going to

712
00:41:54,750 --> 00:41:59,250
refer to a file and you can't select on

713
00:41:59,250 --> 00:42:02,280
files you can't add them to your event

714
00:42:02,280 --> 00:42:04,319
loop you can't just read from them

715
00:42:04,319 --> 00:42:06,470
because that's going to block

716
00:42:06,470 --> 00:42:09,540
so what you do is you create a pumping

717
00:42:09,540 --> 00:42:12,420
thread and you have a pipe and so you do

718
00:42:12,420 --> 00:42:15,780
these blocking reads from the file pump

719
00:42:15,780 --> 00:42:18,089
them into the pipe a which goes into the

720
00:42:18,089 --> 00:42:20,430
main application and in this way you can

721
00:42:20,430 --> 00:42:22,740
stream data into the the server in a

722
00:42:22,740 --> 00:42:24,720
non-blocking way with just one extra

723
00:42:24,720 --> 00:42:26,820
thread these are the sort of things that

724
00:42:26,820 --> 00:42:29,730
you might have to do know about if you

725
00:42:29,730 --> 00:42:33,060
were going to write this yourself you

726
00:42:33,060 --> 00:42:34,500
don't have to do that it's under the

727
00:42:34,500 --> 00:42:38,400
it's down below the the API that the

728
00:42:38,400 --> 00:42:41,160
users deal with if you're interested

729
00:42:41,160 --> 00:42:43,080
look in the source directory at the

730
00:42:43,080 --> 00:42:49,980
coupling okay so so what's next I have

731
00:42:49,980 --> 00:42:52,440
to fix some some API issues there's

732
00:42:52,440 --> 00:42:55,230
various things that are very kind of

733
00:42:55,230 --> 00:43:01,080
ugly I want to have more modularity I

734
00:43:01,080 --> 00:43:04,230
want to have break up the libraries into

735
00:43:04,230 --> 00:43:06,900
DLL so that the the coronoid process is

736
00:43:06,900 --> 00:43:09,839
very small and that if you need the HTTP

737
00:43:09,839 --> 00:43:13,260
server you would load a DLL to some

738
00:43:13,260 --> 00:43:16,770
shared object to to get the HTTP parser

739
00:43:16,770 --> 00:43:20,400
for example I'm going to include some

740
00:43:20,400 --> 00:43:23,160
libraries for like MySQL and Postgres

741
00:43:23,160 --> 00:43:26,880
into the core distribution I need to

742
00:43:26,880 --> 00:43:30,990
improve performance that's always an

743
00:43:30,990 --> 00:43:33,660
issue there's there's a some low-hanging

744
00:43:33,660 --> 00:43:36,839
fruit that I know about that we can that

745
00:43:36,839 --> 00:43:39,750
we can pick and make it faster TLS

746
00:43:39,750 --> 00:43:43,170
support is on its way and then finally I

747
00:43:43,170 --> 00:43:45,390
would like to do some sort of web worker

748
00:43:45,390 --> 00:43:48,330
like thing which would probably just

749
00:43:48,330 --> 00:43:52,349
extend the the child process object so

750
00:43:52,349 --> 00:43:54,780
that you can create processes and kind

751
00:43:54,780 --> 00:43:57,390
of do IPC between them in a in a nice

752
00:43:57,390 --> 00:44:03,330
way so right now the version is 0.1

753
00:44:03,330 --> 00:44:07,800
point 17 I will release 0.2 which will

754
00:44:07,800 --> 00:44:10,109
be kind of the first version that I

755
00:44:10,109 --> 00:44:12,390
would hope that other people would use

756
00:44:12,390 --> 00:44:14,580
at the moment I think it's a bit hacky

757
00:44:14,580 --> 00:44:17,250
and if your experimental then please use

758
00:44:17,250 --> 00:44:19,860
it but

759
00:44:19,860 --> 00:44:23,610
if not then wait for 0.2 and I think

760
00:44:23,610 --> 00:44:26,130
that will be good because I will freeze

761
00:44:26,130 --> 00:44:29,400
the API or at least some of it and so

762
00:44:29,400 --> 00:44:31,230
you can kind of build on it with some

763
00:44:31,230 --> 00:44:32,940
confidence that I won't change it out

764
00:44:32,940 --> 00:44:37,800
from underneath mmm okay so yes any

765
00:44:37,800 --> 00:44:59,900
questions

766
00:44:59,910 --> 00:45:03,660
so the the question is if like if you

767
00:45:03,660 --> 00:45:05,670
make changes to the source file well it

768
00:45:05,670 --> 00:45:07,650
will it load in those changes

769
00:45:07,650 --> 00:45:11,579
no but Felix and I have been hacking on

770
00:45:11,579 --> 00:45:13,859
this a bit this weekend it's something

771
00:45:13,859 --> 00:45:32,980
I'd like to add yes

772
00:45:32,990 --> 00:45:35,460
so the question is what do I do with

773
00:45:35,460 --> 00:45:39,050
blocking rights when you have a socket

774
00:45:39,050 --> 00:45:41,460
there's a right buffer in the kernel and

775
00:45:41,460 --> 00:45:43,950
you can only write so much data to the

776
00:45:43,950 --> 00:45:45,450
right buffer before it gets filled up

777
00:45:45,450 --> 00:45:48,030
this kernel can't push out all the data

778
00:45:48,030 --> 00:45:51,000
to the network as fast as it wants to

779
00:45:51,000 --> 00:45:53,700
there's some buffer that that can

780
00:45:53,700 --> 00:45:55,290
possibly fill up so if you're streaming

781
00:45:55,290 --> 00:45:57,630
a file out of the socket to somewhere

782
00:45:57,630 --> 00:46:00,990
else then that can block in node it

783
00:46:00,990 --> 00:46:04,290
doesn't block it buffers the data it

784
00:46:04,290 --> 00:46:06,990
will allocate data internally if you do

785
00:46:06,990 --> 00:46:09,480
that and what you could do is get a

786
00:46:09,480 --> 00:46:12,420
callback win that buffer when the kernel

787
00:46:12,420 --> 00:46:14,700
buffer drains so what you can do if you

788
00:46:14,700 --> 00:46:17,730
want to stream a file to somebody you

789
00:46:17,730 --> 00:46:21,030
start sending it and then you send a say

790
00:46:21,030 --> 00:46:25,320
a megabyte which may fill up the buffer

791
00:46:25,320 --> 00:46:27,300
may not fill up the buffer and then you

792
00:46:27,300 --> 00:46:29,430
wait till it drains and then you send

793
00:46:29,430 --> 00:46:31,710
another megabyte and so in this way you

794
00:46:31,710 --> 00:46:34,020
can stream data the the right buffer

795
00:46:34,020 --> 00:46:36,030
will never fill up what will happen is

796
00:46:36,030 --> 00:46:39,950
all allocate memory so in in user space

797
00:46:39,950 --> 00:46:57,630
so so rights don't block

798
00:46:57,640 --> 00:47:02,640
yes

799
00:47:02,650 --> 00:47:06,620
so the question is what is my stance on

800
00:47:06,620 --> 00:47:12,710
common j/s so common je s I think has a

801
00:47:12,710 --> 00:47:14,840
lot of good proposals so the module

802
00:47:14,840 --> 00:47:18,730
system I'm using there's a binary

803
00:47:18,730 --> 00:47:21,680
proposal and there's a package proposal

804
00:47:21,680 --> 00:47:25,070
which which look very good at the moment

805
00:47:25,070 --> 00:47:27,230
commonjs has only ratified I think the

806
00:47:27,230 --> 00:47:30,590
the module proposal and the assert this

807
00:47:30,590 --> 00:47:33,140
testing library proposal so it doesn't

808
00:47:33,140 --> 00:47:36,020
define things like IO so I think those

809
00:47:36,020 --> 00:47:38,900
discussions will be ongoing I think

810
00:47:38,900 --> 00:47:40,460
there's some people who want it more in

811
00:47:40,460 --> 00:47:42,530
a blocking state I want it more in a

812
00:47:42,530 --> 00:47:44,600
vented State and so we'll fight it out

813
00:47:44,600 --> 00:47:59,480
over the next couple months or so yes

814
00:47:59,490 --> 00:48:06,220
a little bit I would like to have more

815
00:48:06,220 --> 00:48:08,190
money for it

816
00:48:08,190 --> 00:48:10,630
writing your own open-source project

817
00:48:10,630 --> 00:48:14,650
requires a lot of effort and yeah it

