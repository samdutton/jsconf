1
00:00:13,280 --> 00:00:18,189

everyone so how many of you are

2
00:00:18,189 --> 00:00:21,410
front-end engineers you work with mostly

3
00:00:21,410 --> 00:00:23,689
on the front end okay how many of you

4
00:00:23,689 --> 00:00:28,759
back-end engineers okay more about 60%

5
00:00:28,759 --> 00:00:33,110
cocoa cocoa how many of you think they

6
00:00:33,110 --> 00:00:37,130
know no js' but are still here okay so

7
00:00:37,130 --> 00:00:38,600
you have enough time to go to the next

8
00:00:38,600 --> 00:00:45,110
room so if you have computers if you're

9
00:00:45,110 --> 00:00:48,410
not tired already from all this amazing

10
00:00:48,410 --> 00:00:50,809
information you can code along with me

11
00:00:50,809 --> 00:00:54,699
and because I have some code examples or

12
00:00:54,699 --> 00:01:00,350
you can just relax and know that all the

13
00:01:00,350 --> 00:01:03,469
slides are on the github so yep take a

14
00:01:03,469 --> 00:01:08,200
picture it's their soul open source okay

15
00:01:08,200 --> 00:01:11,960
so just to remind you why we here and

16
00:01:11,960 --> 00:01:14,570
why it's good to know such thing as no

17
00:01:14,570 --> 00:01:17,750
js' and JavaScript so generally software

18
00:01:17,750 --> 00:01:21,619
is kind of becoming everywhere our

19
00:01:21,619 --> 00:01:24,439
life's becoming digital so by building

20
00:01:24,439 --> 00:01:26,119
better software we can actually improve

21
00:01:26,119 --> 00:01:29,659
lives of other people a little bit about

22
00:01:29,659 --> 00:01:30,320
myself

23
00:01:30,320 --> 00:01:32,810
she already introduced me so I will skip

24
00:01:32,810 --> 00:01:35,689
through the slides faster some of my

25
00:01:35,689 --> 00:01:38,509
books practical node and Pro Express we

26
00:01:38,509 --> 00:01:41,570
have them here my publisher a press they

27
00:01:41,570 --> 00:01:44,479
currently provided the books so we will

28
00:01:44,479 --> 00:01:47,539
do the giveaways and signing you can

29
00:01:47,539 --> 00:01:53,119
find me on Twitter and blog and some of

30
00:01:53,119 --> 00:01:55,159
the other highlights I've worked at

31
00:01:55,159 --> 00:01:58,130
Storify and DocuSign early users of

32
00:01:58,130 --> 00:01:58,880
nodejs

33
00:01:58,880 --> 00:02:02,060
so I know what I'm talking about more or

34
00:02:02,060 --> 00:02:02,929
less

35
00:02:02,929 --> 00:02:05,240
Capital one it's famous for its Viking

36
00:02:05,240 --> 00:02:08,420
commercials it's one of the top 10 US

37
00:02:08,420 --> 00:02:10,490
banks I promise I'm not going to have a

38
00:02:10,490 --> 00:02:15,710
lot of gifts only two more okay so let's

39
00:02:15,710 --> 00:02:18,080
start with basics first of all like why

40
00:02:18,080 --> 00:02:20,600
do we even want to use node.js right

41
00:02:20,600 --> 00:02:24,230
because we might have people completely

42
00:02:24,230 --> 00:02:25,810
new to know the ass

43
00:02:25,810 --> 00:02:29,180
so there are typically two categories of

44
00:02:29,180 --> 00:02:32,150
systems one is input and output bount

45
00:02:32,150 --> 00:02:34,700
and another a cpu-bound so when we're

46
00:02:34,700 --> 00:02:37,239
building web applications we're usually

47
00:02:37,239 --> 00:02:40,159
working with the input and output bound

48
00:02:40,159 --> 00:02:42,890
systems so what is input and output it

49
00:02:42,890 --> 00:02:45,260
could be writing to the database as

50
00:02:45,260 --> 00:02:49,010
making a request to a server or a third

51
00:02:49,010 --> 00:02:52,420
party service or doing something else

52
00:02:52,420 --> 00:02:56,269
which is usually takes a lot of time

53
00:02:56,269 --> 00:03:00,409
just for the waiting for that process so

54
00:03:00,409 --> 00:03:02,090
know just has the thing it's called

55
00:03:02,090 --> 00:03:05,540
non-blocking i/o now or non-blocking

56
00:03:05,540 --> 00:03:09,879
input and output why this is good so

57
00:03:09,879 --> 00:03:12,730
when we're working with nodejs and

58
00:03:12,730 --> 00:03:15,650
usually we're building web servers we

59
00:03:15,650 --> 00:03:17,959
might have some clients making requests

60
00:03:17,959 --> 00:03:21,260
so under the hood of nodejs we have a

61
00:03:21,260 --> 00:03:23,959
vent loop which was borrowed from google

62
00:03:23,959 --> 00:03:27,170
chrome v8 engine so that event loop is

63
00:03:27,170 --> 00:03:29,329
always looking for things to execute and

64
00:03:29,329 --> 00:03:32,239
then it delegates the actual jobs the

65
00:03:32,239 --> 00:03:35,359
actual processes to some other systems

66
00:03:35,359 --> 00:03:38,900
for example a file system or database

67
00:03:38,900 --> 00:03:44,359
etc so when the delegation happens event

68
00:03:44,359 --> 00:03:47,150
loop also passes the callback which is

69
00:03:47,150 --> 00:03:49,609
typically some JavaScript or node.js

70
00:03:49,609 --> 00:03:52,549
code and when the system is done it's

71
00:03:52,549 --> 00:03:54,620
over it's finished that callback is

72
00:03:54,620 --> 00:03:57,290
executed and usually that go back has

73
00:03:57,290 --> 00:03:59,900
the code to send back the data to the

74
00:03:59,900 --> 00:04:01,819
client if we're talking about web

75
00:04:01,819 --> 00:04:05,030
servers so how many of your Java

76
00:04:05,030 --> 00:04:09,349
developers or started with Java okay so

77
00:04:09,349 --> 00:04:11,930
even if you're not hardcore Java

78
00:04:11,930 --> 00:04:13,669
developer you kind of guess what is

79
00:04:13,669 --> 00:04:16,459
happening here there is a sleep method

80
00:04:16,459 --> 00:04:20,510
and the key here probably this is the

81
00:04:20,510 --> 00:04:22,280
most important piece in like the whole

82
00:04:22,280 --> 00:04:25,070
presentation the key here is that Java

83
00:04:25,070 --> 00:04:28,970
process will be put into so to say sleep

84
00:04:28,970 --> 00:04:32,419
so nothing will be executed until that

85
00:04:32,419 --> 00:04:35,240
one second passes so 1,000 milliseconds

86
00:04:35,240 --> 00:04:38,780
or one second blocks the entire process

87
00:04:38,780 --> 00:04:42,940
game contrat that with this node.js code

88
00:04:42,940 --> 00:04:46,100
where we're scheduling the process in

89
00:04:46,100 --> 00:04:48,590
the future by using a callback so that

90
00:04:48,590 --> 00:04:50,570
function is sort of a set timeout it's

91
00:04:50,570 --> 00:04:53,360
not executed right away it will be

92
00:04:53,360 --> 00:04:56,540
executed in the future so from step one

93
00:04:56,540 --> 00:04:59,180
we skip right to the step two then one

94
00:04:59,180 --> 00:05:02,060
second passes and we would see step

95
00:05:02,060 --> 00:05:05,000
three so why this is good because we

96
00:05:05,000 --> 00:05:07,669
could execute more code while the

97
00:05:07,669 --> 00:05:10,340
waiting is happening so the waiting is

98
00:05:10,340 --> 00:05:11,510
not actually sleeping

99
00:05:11,510 --> 00:05:14,330
it's just scheduling in the future so we

100
00:05:14,330 --> 00:05:16,370
would see step one step two then we

101
00:05:16,370 --> 00:05:18,620
would see step four and then we would

102
00:05:18,620 --> 00:05:21,800
see after 1000 milliseconds step three

103
00:05:21,800 --> 00:05:23,900
and step five so this is probably the

104
00:05:23,900 --> 00:05:26,960
most important piece from this whole

105
00:05:26,960 --> 00:05:30,380
presentation not just allows you to

106
00:05:30,380 --> 00:05:34,690
write faster applications typically

107
00:05:34,690 --> 00:05:37,520
because we're utilizing that idle

108
00:05:37,520 --> 00:05:40,910
waiting time so let's talk about web

109
00:05:40,910 --> 00:05:43,130
servers a little bit so this is how we

110
00:05:43,130 --> 00:05:45,830
would write a web server schematically

111
00:05:45,830 --> 00:05:49,400
of course just a diagram using some of

112
00:05:49,400 --> 00:05:52,340
those blocking i/o systems like Python

113
00:05:52,340 --> 00:05:56,539
Ruby Java etc each subsequent request

114
00:05:56,539 --> 00:05:58,940
would be blocked by the previous request

115
00:05:58,940 --> 00:06:01,280
so you have the queue and they have to

116
00:06:01,280 --> 00:06:04,460
wait in that queue I always like to give

117
00:06:04,460 --> 00:06:06,380
this a knowledge of a coffee shop you go

118
00:06:06,380 --> 00:06:08,800
to coffee shop and you order your drink

119
00:06:08,800 --> 00:06:12,080
he or she the barista the cashier at the

120
00:06:12,080 --> 00:06:14,330
register they would take your order they

121
00:06:14,330 --> 00:06:16,160
would take your money and then they

122
00:06:16,160 --> 00:06:19,270
would turn around and make you drink and

123
00:06:19,270 --> 00:06:22,190
usually that leads to long lines people

124
00:06:22,190 --> 00:06:25,550
are waiting in line because each person

125
00:06:25,550 --> 00:06:28,280
before you has to order the drink and

126
00:06:28,280 --> 00:06:30,260
wait for that drink right so you have

127
00:06:30,260 --> 00:06:33,260
unhappy customers the line is blocked

128
00:06:33,260 --> 00:06:35,780
your typical blocking input and output

129
00:06:35,780 --> 00:06:41,090
system now let's take a look how things

130
00:06:41,090 --> 00:06:43,760
are in no js' so we have event loop

131
00:06:43,760 --> 00:06:46,400
again and event loop delegates the

132
00:06:46,400 --> 00:06:49,789
processes to others underlying systems

133
00:06:49,789 --> 00:06:52,529
so event loop is almost never

134
00:06:52,529 --> 00:06:54,959
locked it's almost never blocked and

135
00:06:54,959 --> 00:06:57,749
that's a good thing and it's also a

136
00:06:57,749 --> 00:06:59,609
single-threaded we will talk about it in

137
00:06:59,609 --> 00:07:02,459
the next slide but basically going back

138
00:07:02,459 --> 00:07:04,739
to our coffee shop analogies this is how

139
00:07:04,739 --> 00:07:07,799
Starbucks works and maybe Dunkin Donuts

140
00:07:07,799 --> 00:07:11,359
which I've heard people like in Iceland

141
00:07:11,359 --> 00:07:14,039
so people are happier they're sitting at

142
00:07:14,039 --> 00:07:16,709
the tables because it's asynchronous we

143
00:07:16,709 --> 00:07:18,869
have this non-blocking in input and

144
00:07:18,869 --> 00:07:21,119
output system implemented so you go

145
00:07:21,119 --> 00:07:23,639
order your drink they write down your

146
00:07:23,639 --> 00:07:26,459
name and or maybe they give you number

147
00:07:26,459 --> 00:07:28,589
and then you go back to your table and

148
00:07:28,589 --> 00:07:32,219
you continue working on your JavaScript

149
00:07:32,219 --> 00:07:34,739
application and they call you you go

150
00:07:34,739 --> 00:07:36,839
back and get your drink right so people

151
00:07:36,839 --> 00:07:39,479
are happy we don't have a line and also

152
00:07:39,479 --> 00:07:42,719
this process tends to be a better at

153
00:07:42,719 --> 00:07:44,879
scaling because the only way you can

154
00:07:44,879 --> 00:07:47,129
actually scale the blocking system by

155
00:07:47,129 --> 00:07:48,839
increasing the number of threads or

156
00:07:48,839 --> 00:07:50,879
increasing the number of registers the

157
00:07:50,879 --> 00:07:53,549
cash registers that will increase the

158
00:07:53,549 --> 00:07:56,099
number of lines but in this example you

159
00:07:56,099 --> 00:07:59,599
can increase the number of workers so

160
00:07:59,599 --> 00:08:02,549
multi-threading it's not necessarily a

161
00:08:02,549 --> 00:08:05,849
great thing sometimes it can blow up in

162
00:08:05,849 --> 00:08:07,619
your face especially if you don't know

163
00:08:07,619 --> 00:08:10,049
how to use it so it comes with

164
00:08:10,049 --> 00:08:12,599
complexity and it was born out of the

165
00:08:12,599 --> 00:08:15,119
necessity how you would scale a blocking

166
00:08:15,119 --> 00:08:19,079
system right so the blocking system they

167
00:08:19,079 --> 00:08:21,269
have to be multi-threaded in nodejs

168
00:08:21,269 --> 00:08:23,879
it's a single threaded system so it

169
00:08:23,879 --> 00:08:25,649
eliminates complexities such as

170
00:08:25,649 --> 00:08:27,979
synchronizing the data between threads

171
00:08:27,979 --> 00:08:31,949
deadlocks racing conditions etc but it's

172
00:08:31,949 --> 00:08:34,169
still possible to write blocking code in

173
00:08:34,169 --> 00:08:38,129
ogs so by just the knowing that no js'

174
00:08:38,129 --> 00:08:41,339
is have the non blocking i/o it's still

175
00:08:41,339 --> 00:08:42,959
not going to prevent developers from

176
00:08:42,959 --> 00:08:46,259
writing blocking code let's take a look

177
00:08:46,259 --> 00:08:49,170
at this example and you can run there is

178
00:08:49,170 --> 00:08:51,990
a file blocking j/s so you can just go

179
00:08:51,990 --> 00:08:53,850
into your terminal and execute that file

180
00:08:53,850 --> 00:08:58,379
once you get my source code and I get

181
00:08:58,379 --> 00:09:00,959
anywhere from 100 milliseconds to 1,000

182
00:09:00,959 --> 00:09:04,350
milliseconds obviously most of the times

183
00:09:04,350 --> 00:09:06,570
we don't get the blocking code

184
00:09:06,570 --> 00:09:09,030
just obvious which is like a for-loop

185
00:09:09,030 --> 00:09:12,300
this blocking code is buried inside of

186
00:09:12,300 --> 00:09:15,440
the module I know that module that

187
00:09:15,440 --> 00:09:19,980
that's how so the way to know that it's

188
00:09:19,980 --> 00:09:21,810
a synchronous basically you need either

189
00:09:21,810 --> 00:09:24,150
to read the documentation or read the

190
00:09:24,150 --> 00:09:28,470
source code in this case FS the naming

191
00:09:28,470 --> 00:09:29,550
convention

192
00:09:29,550 --> 00:09:31,920
it has the word sink in it so we know

193
00:09:31,920 --> 00:09:33,570
that it's a synchronous module by

194
00:09:33,570 --> 00:09:36,420
looking at it another dead giveaway

195
00:09:36,420 --> 00:09:38,010
signer that the content will be

196
00:09:38,010 --> 00:09:40,230
available right there on the next line

197
00:09:40,230 --> 00:09:43,230
so I can assign var and then the result

198
00:09:43,230 --> 00:09:46,080
of read file sync and I can cancel log

199
00:09:46,080 --> 00:09:49,050
that so we will go from top to bottom

200
00:09:49,050 --> 00:09:52,800
just as in any other traditional

201
00:09:52,800 --> 00:09:55,350
programming language in a synchronous

202
00:09:55,350 --> 00:09:57,300
language so it's very easy to reason

203
00:09:57,300 --> 00:09:59,820
about but this would not be very

204
00:09:59,820 --> 00:10:02,340
efficient code this is much more

205
00:10:02,340 --> 00:10:05,550
efficient code it's also in node.js but

206
00:10:05,550 --> 00:10:09,570
now we're using a function which is read

207
00:10:09,570 --> 00:10:12,450
file not read file sync and with this

208
00:10:12,450 --> 00:10:15,420
file we're using callbacks so the trick

209
00:10:15,420 --> 00:10:17,250
here is that the data would not be

210
00:10:17,250 --> 00:10:20,010
available on the next line so council

211
00:10:20,010 --> 00:10:22,710
log hello Ruby would not have the

212
00:10:22,710 --> 00:10:25,290
content of the file available the

213
00:10:25,290 --> 00:10:27,630
content of the file will be available in

214
00:10:27,630 --> 00:10:29,310
the future when the callback is

215
00:10:29,310 --> 00:10:32,430
happening and your result might vary so

216
00:10:32,430 --> 00:10:35,610
first you might get the accounts or IP

217
00:10:35,610 --> 00:10:38,700
addresses from IPS dot txt or you might

218
00:10:38,700 --> 00:10:42,360
get IPS first depending on what file is

219
00:10:42,360 --> 00:10:44,790
larger right so we're executing them in

220
00:10:44,790 --> 00:10:47,520
parallel parallel and concurrency the

221
00:10:47,520 --> 00:10:49,290
different terms but when it comes to

222
00:10:49,290 --> 00:10:53,130
node.js they usually interchangeable so

223
00:10:53,130 --> 00:10:55,710
node.js is typically much much faster

224
00:10:55,710 --> 00:10:58,670
than other platforms and languages

225
00:10:58,670 --> 00:11:02,220
because of this input optimization input

226
00:11:02,220 --> 00:11:04,680
and output and optimization but let's be

227
00:11:04,680 --> 00:11:07,050
honest how many of you actually hit the

228
00:11:07,050 --> 00:11:10,760
bottleneck when it counts a performance

229
00:11:10,760 --> 00:11:13,530
personally I don't experience that

230
00:11:13,530 --> 00:11:15,950
problem if I have that problem I can add

231
00:11:15,950 --> 00:11:19,280
RAM I can add CPU I can add workers

232
00:11:19,280 --> 00:11:21,710
it's it's cheaper to scale than it used

233
00:11:21,710 --> 00:11:23,540
to be ten years ago so I'm not building

234
00:11:23,540 --> 00:11:27,350
the next Facebook or Google for me my

235
00:11:27,350 --> 00:11:30,980
personal no js' benefit and a lot of

236
00:11:30,980 --> 00:11:32,870
other developers also shared this is

237
00:11:32,870 --> 00:11:37,010
that we can use javascript so we have

238
00:11:37,010 --> 00:11:39,110
one language two rules to rule basically

239
00:11:39,110 --> 00:11:42,380
the entire stack we can think faster we

240
00:11:42,380 --> 00:11:44,510
can reuse code if I'm using lodash or

241
00:11:44,510 --> 00:11:46,730
underscore on the browser can use that

242
00:11:46,730 --> 00:11:50,210
on on the server as well and also if I'm

243
00:11:50,210 --> 00:11:52,910
using the same API the same interface

244
00:11:52,910 --> 00:11:57,380
all over the stack I'm learning quicker

245
00:11:57,380 --> 00:11:59,540
I don't need to refer to the

246
00:11:59,540 --> 00:12:02,810
documentation that that much so the good

247
00:12:02,810 --> 00:12:05,720
thing about not just that most of this

248
00:12:05,720 --> 00:12:07,880
classes the subjects they are available

249
00:12:07,880 --> 00:12:11,000
as this right we have arrays drinks

250
00:12:11,000 --> 00:12:14,630
primitives so if you know nodejs it's

251
00:12:14,630 --> 00:12:16,640
very easy if you know JavaScript it's

252
00:12:16,640 --> 00:12:18,590
very easy to get started with node it

253
00:12:18,590 --> 00:12:21,350
could take it just like a weekend but

254
00:12:21,350 --> 00:12:24,620
note is not triple equals browser so

255
00:12:24,620 --> 00:12:26,630
there are a few differences we will talk

256
00:12:26,630 --> 00:12:28,580
about them for example there is no

257
00:12:28,580 --> 00:12:30,980
window object obviously there is no

258
00:12:30,980 --> 00:12:35,050
windows when we work with nodejs right

259
00:12:35,050 --> 00:12:39,650
but there is global so if you're just

260
00:12:39,650 --> 00:12:42,190
working with the browser JavaScript

261
00:12:42,190 --> 00:12:46,280
think about global as the window it can

262
00:12:46,280 --> 00:12:48,580
surf everywhere it's kind of magical and

263
00:12:48,580 --> 00:12:54,170
then it has properties by the way the

264
00:12:54,170 --> 00:12:56,600
property it's also accessible without

265
00:12:56,600 --> 00:12:59,810
the prefix without global dot so I can

266
00:12:59,810 --> 00:13:01,670
just say understorms the score dual name

267
00:13:01,670 --> 00:13:04,520
for example it would work so all the

268
00:13:04,520 --> 00:13:06,860
properties of global they also kind of

269
00:13:06,860 --> 00:13:10,130
global in themselves so file name would

270
00:13:10,130 --> 00:13:13,940
give me the path an absolute path to the

271
00:13:13,940 --> 00:13:16,400
currently running script the dear name

272
00:13:16,400 --> 00:13:18,440
would also give me the path but without

273
00:13:18,440 --> 00:13:22,280
the filename so we don't have that in

274
00:13:22,280 --> 00:13:24,380
the browser right you don't want to

275
00:13:24,380 --> 00:13:27,530
navigate the websites and you don't want

276
00:13:27,530 --> 00:13:30,620
the websites to know your file system

277
00:13:30,620 --> 00:13:32,690
what folder you're running the script

278
00:13:32,690 --> 00:13:34,460
but on the server it's a completely

279
00:13:34,460 --> 00:13:36,350
different picture we have that extra

280
00:13:36,350 --> 00:13:39,110
information another thing we don't have

281
00:13:39,110 --> 00:13:42,230
in the browser javascript is modules so

282
00:13:42,230 --> 00:13:43,820
modules are native in nodejs

283
00:13:43,820 --> 00:13:46,730
the way we work with them we have module

284
00:13:46,730 --> 00:13:49,550
to export and then we have required to

285
00:13:49,550 --> 00:13:53,540
import modules it's started from the

286
00:13:53,540 --> 00:13:55,850
common J's where web standard the

287
00:13:55,850 --> 00:13:58,310
browser standard but now it's more or

288
00:13:58,310 --> 00:14:02,930
less the standard for nongenius some of

289
00:14:02,930 --> 00:14:06,890
the other useful things that we can do

290
00:14:06,890 --> 00:14:08,540
with node which we cannot do with the

291
00:14:08,540 --> 00:14:13,940
browser JavaScript process or global

292
00:14:13,940 --> 00:14:16,790
dead process it will give you a lot of

293
00:14:16,790 --> 00:14:19,450
information about the underlying node.js

294
00:14:19,450 --> 00:14:22,850
process and your machine for example you

295
00:14:22,850 --> 00:14:25,250
can get the process ID we can get the

296
00:14:25,250 --> 00:14:27,230
versions not just the version of node.js

297
00:14:27,230 --> 00:14:29,630
but the version of the v8 engine for

298
00:14:29,630 --> 00:14:32,540
example can get the architecture if it's

299
00:14:32,540 --> 00:14:35,180
Windows or if it's some of the POSIX

300
00:14:35,180 --> 00:14:38,030
systems if you're building a

301
00:14:38,030 --> 00:14:40,370
command-line tool like web pack or grunt

302
00:14:40,370 --> 00:14:43,250
you can get those options and

303
00:14:43,250 --> 00:14:45,470
command-line arguments inside the vien

304
00:14:45,470 --> 00:14:48,260
of your node process we can get

305
00:14:48,260 --> 00:14:51,050
environmental variables things like API

306
00:14:51,050 --> 00:14:55,760
keys passwords etc can get the app time

307
00:14:55,760 --> 00:14:58,130
and current memory usage from the

308
00:14:58,130 --> 00:15:03,620
machine as well and CWD that's very

309
00:15:03,620 --> 00:15:06,200
similar to the door name but only if

310
00:15:06,200 --> 00:15:08,750
you're running your node program from

311
00:15:08,750 --> 00:15:10,760
the same file from the same folder from

312
00:15:10,760 --> 00:15:13,130
the same directory in which you have the

313
00:15:13,130 --> 00:15:16,310
source code so in some cases this value

314
00:15:16,310 --> 00:15:18,950
would be different and then we can exit

315
00:15:18,950 --> 00:15:20,810
the current process and we can also

316
00:15:20,810 --> 00:15:24,020
terminate other processes that comes in

317
00:15:24,020 --> 00:15:26,180
handy when we're scaling when we use in

318
00:15:26,180 --> 00:15:29,900
clusters okay so this is a tricky

319
00:15:29,900 --> 00:15:32,089
question so who likes and understands

320
00:15:32,089 --> 00:15:40,010
callbacks okay it's like 40% what about

321
00:15:40,010 --> 00:15:44,750
callback hell once in a while we might

322
00:15:44,750 --> 00:15:46,520
get ourselves into this mess

323
00:15:46,520 --> 00:15:50,779
right so developmental scalability that

324
00:15:50,779 --> 00:15:53,779
means bringing more people more

325
00:15:53,779 --> 00:15:56,270
developers to current projects having

326
00:15:56,270 --> 00:15:58,310
more people work on a single piece of

327
00:15:58,310 --> 00:16:02,899
code and callbacks they're not very

328
00:16:02,899 --> 00:16:06,410
developmental scalable that that's how I

329
00:16:06,410 --> 00:16:08,360
feel sometimes and working with

330
00:16:08,360 --> 00:16:13,700
callbacks so there are other patterns

331
00:16:13,700 --> 00:16:17,390
like promises and async await and

332
00:16:17,390 --> 00:16:20,480
generators but they don't solve all the

333
00:16:20,480 --> 00:16:23,240
problems they sold some of the problem

334
00:16:23,240 --> 00:16:28,430
that callbacks have but what if you for

335
00:16:28,430 --> 00:16:33,110
example want to execute something many

336
00:16:33,110 --> 00:16:35,450
many times and you want to execute that

337
00:16:35,450 --> 00:16:37,940
not just at the end like with callbacks

338
00:16:37,940 --> 00:16:39,740
or promises but you want to execute it

339
00:16:39,740 --> 00:16:41,690
in the middle or in the beginning of a

340
00:16:41,690 --> 00:16:46,750
job or a process so please meet event or

341
00:16:46,750 --> 00:16:50,240
event emitters they're a singleton pad

342
00:16:50,240 --> 00:16:52,399
not a single term they absorber pattern

343
00:16:52,399 --> 00:16:55,490
so no js' observer pattern a good thing

344
00:16:55,490 --> 00:16:57,800
about events they are everywhere in the

345
00:16:57,800 --> 00:17:00,589
core node.js modules so if you know how

346
00:17:00,589 --> 00:17:04,069
to work with events you would understand

347
00:17:04,069 --> 00:17:06,350
how to work with pretty much all of the

348
00:17:06,350 --> 00:17:09,650
core modules of nodejs so we have our

349
00:17:09,650 --> 00:17:11,990
subject we have an object and then we

350
00:17:11,990 --> 00:17:14,089
have event triggers right so we have

351
00:17:14,089 --> 00:17:16,970
three things working together so to

352
00:17:16,970 --> 00:17:19,400
create an object all we need to do is

353
00:17:19,400 --> 00:17:22,780
require events and then we using

354
00:17:22,780 --> 00:17:25,550
prototypal inheritance to create an

355
00:17:25,550 --> 00:17:28,760
object and then we can attach event

356
00:17:28,760 --> 00:17:32,179
listeners so for example I want to

357
00:17:32,179 --> 00:17:37,220
listen for the done event a good thing

358
00:17:37,220 --> 00:17:40,010
about event listeners and like callbacks

359
00:17:40,010 --> 00:17:43,059
or promises that we can have multiple

360
00:17:43,059 --> 00:17:46,670
pieces of logic executed on a single

361
00:17:46,670 --> 00:17:49,520
event so for example knock it's a single

362
00:17:49,520 --> 00:17:51,880
event but I can have many many

363
00:17:51,880 --> 00:17:54,950
functionality executed and the order in

364
00:17:54,950 --> 00:17:56,690
which it will be executed is the same

365
00:17:56,690 --> 00:17:59,870
order in which I define them now this is

366
00:17:59,870 --> 00:18:00,320
very big

367
00:18:00,320 --> 00:18:04,210
take example so let's see something more

368
00:18:04,210 --> 00:18:06,980
real-life something more realistic so

369
00:18:06,980 --> 00:18:09,309
let's say I have a job which is like a

370
00:18:09,309 --> 00:18:12,500
job to send email and then I have three

371
00:18:12,500 --> 00:18:16,159
different types of emails monthly weekly

372
00:18:16,159 --> 00:18:20,240
and daily emails so I want to implement

373
00:18:20,240 --> 00:18:23,419
the job module the way that I can

374
00:18:23,419 --> 00:18:25,340
customize what is happening at the very

375
00:18:25,340 --> 00:18:29,299
end so my job module will emit an event

376
00:18:29,299 --> 00:18:33,679
job that Amit and then when I'm using

377
00:18:33,679 --> 00:18:36,200
this module when I'm actually consuming

378
00:18:36,200 --> 00:18:38,899
now I want to put that custom logic and

379
00:18:38,899 --> 00:18:41,149
the way I do it by creating an event

380
00:18:41,149 --> 00:18:44,419
listener so I know my module is emitting

381
00:18:44,419 --> 00:18:47,419
this event I know the name is done do an

382
00:18:47,419 --> 00:18:49,669
e so all I need to do is put an event

383
00:18:49,669 --> 00:18:52,970
listener the good thing compared to just

384
00:18:52,970 --> 00:18:55,580
callbacks if I don't specify this event

385
00:18:55,580 --> 00:18:58,250
listener it's not going to crash right

386
00:18:58,250 --> 00:19:00,259
if you don't specify a callback and your

387
00:19:00,259 --> 00:19:03,019
module expects it right so the module

388
00:19:03,019 --> 00:19:06,919
will crash another thing is that I can

389
00:19:06,919 --> 00:19:09,110
remove event listeners I can get the

390
00:19:09,110 --> 00:19:11,059
list of event listeners I can have many

391
00:19:11,059 --> 00:19:13,909
of them not just a single callbacks is

392
00:19:13,909 --> 00:19:15,850
typically just a single callback

393
00:19:15,850 --> 00:19:21,129
I've highly highly recommend this book

394
00:19:21,129 --> 00:19:25,519
node.js patterns oh it's not a book okay

395
00:19:25,519 --> 00:19:28,009
just a blog post I'll have the link to

396
00:19:28,009 --> 00:19:31,639
the book later ok so the next problem is

397
00:19:31,639 --> 00:19:34,519
how to handle large data so if you're

398
00:19:34,519 --> 00:19:36,919
working with files larger than 1

399
00:19:36,919 --> 00:19:39,350
gigabyte you might heat the buffer limit

400
00:19:39,350 --> 00:19:43,669
and it's just not a nice experience to

401
00:19:43,669 --> 00:19:46,549
wait for the entire large data to load

402
00:19:46,549 --> 00:19:50,059
so please meet streams they are

403
00:19:50,059 --> 00:19:52,539
abstractions to allow us to work with

404
00:19:52,539 --> 00:19:56,870
continuous chunking of data so we don't

405
00:19:56,870 --> 00:19:59,720
need to wait for the entire large chunk

406
00:19:59,720 --> 00:20:03,169
of data piece of data to load so there

407
00:20:03,169 --> 00:20:05,659
are four types of streams writable

408
00:20:05,659 --> 00:20:08,450
readable than the duplex which are both

409
00:20:08,450 --> 00:20:10,250
readable and writable and then the

410
00:20:10,250 --> 00:20:12,909
transform streams

411
00:20:12,909 --> 00:20:16,220
so streams inherit from Aventa meters so

412
00:20:16,220 --> 00:20:18,379
we will be using the knowledge which we

413
00:20:18,379 --> 00:20:20,899
just acquired in the previous slides to

414
00:20:20,899 --> 00:20:25,159
work with the Aventa meters so streams

415
00:20:25,159 --> 00:20:28,840
they're pretty much in a lot of places

416
00:20:28,840 --> 00:20:31,850
the HTTP requests and response their

417
00:20:31,850 --> 00:20:35,269
streams when we're reading from standard

418
00:20:35,269 --> 00:20:37,460
input and output those are streams as

419
00:20:37,460 --> 00:20:39,710
well when we're working with files their

420
00:20:39,710 --> 00:20:44,059
streams example of a readable stream

421
00:20:44,059 --> 00:20:47,629
process that STD in there is a read

422
00:20:47,629 --> 00:20:54,190
operation so this example will capture

423
00:20:54,190 --> 00:20:58,789
me typing on a keyboard and my program

424
00:20:58,789 --> 00:21:01,039
will output whatever I'm typing so line

425
00:21:01,039 --> 00:21:04,279
by line so when for each line I would

426
00:21:04,279 --> 00:21:07,730
have the console log chunk : output me

427
00:21:07,730 --> 00:21:12,259
the previous line you can run this demo

428
00:21:12,259 --> 00:21:14,570
on your computer's if you following

429
00:21:14,570 --> 00:21:18,440
along now our streams has another

430
00:21:18,440 --> 00:21:21,590
approach which you can also use so

431
00:21:21,590 --> 00:21:24,080
readable that read it's a synchronous

432
00:21:24,080 --> 00:21:26,869
method which returns the current chunk

433
00:21:26,869 --> 00:21:29,899
of data and once the stream is finished

434
00:21:29,899 --> 00:21:32,779
it will return null so we can put it in

435
00:21:32,779 --> 00:21:35,990
a while condition so when it's now the

436
00:21:35,990 --> 00:21:39,740
wild will stop working and it's it's

437
00:21:39,740 --> 00:21:41,509
okay that it's synchronous because each

438
00:21:41,509 --> 00:21:43,519
chunks is just a line of data if we're

439
00:21:43,519 --> 00:21:45,440
reading from a file working with the

440
00:21:45,440 --> 00:21:48,740
text data so it's not a big deal in this

441
00:21:48,740 --> 00:21:50,899
case it's synchronous what about

442
00:21:50,899 --> 00:21:53,840
writable streams so there is a write

443
00:21:53,840 --> 00:21:59,929
operation so the next example will write

444
00:21:59,929 --> 00:22:02,869
a an output to a terminal it's actually

445
00:22:02,869 --> 00:22:05,240
very similar to what counsel that log is

446
00:22:05,240 --> 00:22:10,450
using under the hood so what about HTTP

447
00:22:10,450 --> 00:22:14,509
so when we're working with HTTP that's

448
00:22:14,509 --> 00:22:17,059
where streams are really really

449
00:22:17,059 --> 00:22:19,730
beneficial because now your clients they

450
00:22:19,730 --> 00:22:21,529
can start receiving the data right away

451
00:22:21,529 --> 00:22:24,710
or if you're consuming the data you can

452
00:22:24,710 --> 00:22:26,390
transform the data right

453
00:22:26,390 --> 00:22:28,640
way so in this case we're using invent

454
00:22:28,640 --> 00:22:30,860
emitters and we're listening for the

455
00:22:30,860 --> 00:22:33,560
data which is coming from the request

456
00:22:33,560 --> 00:22:36,080
and then I have this function transform

457
00:22:36,080 --> 00:22:38,860
let's say it's a transform stream and

458
00:22:38,860 --> 00:22:42,020
maybe I'm writing this data somewhere or

459
00:22:42,020 --> 00:22:45,140
just transforming it it's very very

460
00:22:45,140 --> 00:22:48,560
useful another interface are using dot

461
00:22:48,560 --> 00:22:51,830
pipe it's very similar to Linux command

462
00:22:51,830 --> 00:22:54,200
line so you can pipe from one process to

463
00:22:54,200 --> 00:22:56,300
another or in this case from one string

464
00:22:56,300 --> 00:23:01,940
to another so to work with binary data

465
00:23:01,940 --> 00:23:04,190
and no gel there is a type called buffer

466
00:23:04,190 --> 00:23:08,270
in es6 there also in u67 they're also

467
00:23:08,270 --> 00:23:11,780
adding this similar but so far it's not

468
00:23:11,780 --> 00:23:15,470
as popular on the browser JavaScript so

469
00:23:15,470 --> 00:23:17,420
think about buffers as the binary type

470
00:23:17,420 --> 00:23:21,080
and when you're working with the file

471
00:23:21,080 --> 00:23:24,530
systems or even working with HTTP

472
00:23:24,530 --> 00:23:27,650
servers by default the data it's in

473
00:23:27,650 --> 00:23:31,160
buffer so if you see we're string that

474
00:23:31,160 --> 00:23:32,870
you're supposed to look like a normal

475
00:23:32,870 --> 00:23:34,610
text but it's bunch of numbers looks

476
00:23:34,610 --> 00:23:36,740
like an array probably you need to

477
00:23:36,740 --> 00:23:39,860
convert it from a buffer to a string to

478
00:23:39,860 --> 00:23:41,960
do that you can use a two string and

479
00:23:41,960 --> 00:23:47,060
then pass an encoding so FS module by

480
00:23:47,060 --> 00:23:50,840
default the data is the buffer and I

481
00:23:50,840 --> 00:23:54,740
have a example of Server Express server

482
00:23:54,740 --> 00:23:58,520
which uses two endpoints one with

483
00:23:58,520 --> 00:24:00,950
streams and other without streams once

484
00:24:00,950 --> 00:24:03,230
you start it you can go to slash stream

485
00:24:03,230 --> 00:24:06,800
and slash stream slash non stream non -

486
00:24:06,800 --> 00:24:08,930
stream and you would see the difference

487
00:24:08,930 --> 00:24:14,210
in my case the response time was way way

488
00:24:14,210 --> 00:24:17,420
faster for the stream endpoint and I

489
00:24:17,420 --> 00:24:18,890
have the large picture I have eight

490
00:24:18,890 --> 00:24:22,100
megabyte infographic so so that's

491
00:24:22,100 --> 00:24:26,420
noticeable some of their cool stream

492
00:24:26,420 --> 00:24:29,780
resources how to recommend stream

493
00:24:29,780 --> 00:24:32,120
adventure and stream handbook it's all

494
00:24:32,120 --> 00:24:36,710
open source free to use and view if you

495
00:24:36,710 --> 00:24:39,710
know streams you pretty much can become

496
00:24:39,710 --> 00:24:40,440
like a guru

497
00:24:40,440 --> 00:24:43,260
of nodejs in your team maybe even in

498
00:24:43,260 --> 00:24:46,370
your company if your company is not big

499
00:24:46,370 --> 00:24:49,920
so okay so back to scaling how we can

500
00:24:49,920 --> 00:24:51,930
scale node.js because remember it's

501
00:24:51,930 --> 00:24:54,360
single threaded right and this is one of

502
00:24:54,360 --> 00:24:56,610
the arguments which you might hear from

503
00:24:56,610 --> 00:24:59,580
your co-workers from hardcore Java

504
00:24:59,580 --> 00:25:01,800
developers like oh no just a single

505
00:25:01,800 --> 00:25:03,960
threaded we cannot use it

506
00:25:03,960 --> 00:25:07,470
well actually it's relatively easy to

507
00:25:07,470 --> 00:25:11,010
scale nodejs what we can do we can have

508
00:25:11,010 --> 00:25:13,740
one master process and then we can have

509
00:25:13,740 --> 00:25:16,890
multiple worker processes so the master

510
00:25:16,890 --> 00:25:20,040
will be just creating new workers and

511
00:25:20,040 --> 00:25:22,320
listening when those workers are dying

512
00:25:22,320 --> 00:25:26,580
or crashing to restart them and then the

513
00:25:26,580 --> 00:25:28,560
workers they would be actually doing all

514
00:25:28,560 --> 00:25:30,930
the heavy lifting they will be doing all

515
00:25:30,930 --> 00:25:33,480
the processing there would be our HTTP

516
00:25:33,480 --> 00:25:35,580
servers so the good thing about this

517
00:25:35,580 --> 00:25:38,300
core module cluster is the core module

518
00:25:38,300 --> 00:25:41,370
well that's a good thing probably the

519
00:25:41,370 --> 00:25:43,950
only good thing so there are better

520
00:25:43,950 --> 00:25:47,670
alternatives I have an example as well

521
00:25:47,670 --> 00:25:50,430
I'm using load test so you can load test

522
00:25:50,430 --> 00:25:53,130
your server with cluster and without the

523
00:25:53,130 --> 00:25:56,640
cluster so other alternatives are strong

524
00:25:56,640 --> 00:25:59,940
strong cluster control and PM to a lot

525
00:25:59,940 --> 00:26:02,760
of developers like p.m. 2 p.m. stands

526
00:26:02,760 --> 00:26:06,030
for process manager so basically you can

527
00:26:06,030 --> 00:26:08,940
use PM 2 or a similar tool without

528
00:26:08,940 --> 00:26:12,900
anything else just like that and your

529
00:26:12,900 --> 00:26:15,780
application would be really really good

530
00:26:15,780 --> 00:26:19,080
and robust in production so that's when

531
00:26:19,080 --> 00:26:25,660
you want to scale and go to production

532
00:26:25,670 --> 00:26:28,650
my personal favorite thing about PM 2

533
00:26:28,650 --> 00:26:30,270
that you don't need to modify your

534
00:26:30,270 --> 00:26:33,540
source code so you just use the source

535
00:26:33,540 --> 00:26:35,700
code exactly the same as for the single

536
00:26:35,700 --> 00:26:38,040
process PM 2 will create multiple

537
00:26:38,040 --> 00:26:40,590
process and utilize the maximum CPU

538
00:26:40,590 --> 00:26:43,140
power from each machine so that's a

539
00:26:43,140 --> 00:26:46,350
vertical scaling I have some demos as

540
00:26:46,350 --> 00:26:49,740
well in the source code so you can play

541
00:26:49,740 --> 00:26:53,220
with that there are multiple ways to

542
00:26:53,220 --> 00:26:54,060
start

543
00:26:54,060 --> 00:26:56,370
a different process not just fork so

544
00:26:56,370 --> 00:26:59,700
fork it's mostly for nodejs and then we

545
00:26:59,700 --> 00:27:01,380
have spawn which is pretty much for

546
00:27:01,380 --> 00:27:04,020
anything they work very similarly you

547
00:27:04,020 --> 00:27:07,080
can process big big data large data with

548
00:27:07,080 --> 00:27:09,890
both of them because they use stream and

549
00:27:09,890 --> 00:27:14,310
exact it does not use dream it uses just

550
00:27:14,310 --> 00:27:16,440
a callback so you don't use event

551
00:27:16,440 --> 00:27:19,320
emitters and obviously if it uses a

552
00:27:19,320 --> 00:27:21,420
buffer you will run into buffer limits

553
00:27:21,420 --> 00:27:24,620
so usually exact it's for small command

554
00:27:24,620 --> 00:27:28,110
here's an example spoon no js' program

555
00:27:28,110 --> 00:27:30,570
yes so I can run a different node.js

556
00:27:30,570 --> 00:27:34,680
instance for it very similar only don't

557
00:27:34,680 --> 00:27:36,870
need to specify that it's note so it's

558
00:27:36,870 --> 00:27:39,390
only going to work with node process it

559
00:27:39,390 --> 00:27:42,780
an exact example I have a callback so in

560
00:27:42,780 --> 00:27:45,450
the callback I would get STD out STD in

561
00:27:45,450 --> 00:27:49,580
STD are from that process

562
00:27:49,580 --> 00:27:54,060
okay so asynchronous errors they're a

563
00:27:54,060 --> 00:27:56,970
little bit tricky because remember that

564
00:27:56,970 --> 00:28:00,600
event loop from the first slides so

565
00:28:00,600 --> 00:28:03,030
actually what happens when we use event

566
00:28:03,030 --> 00:28:06,180
loop will lose the context so this is

567
00:28:06,180 --> 00:28:07,710
how you would handle errors in

568
00:28:07,710 --> 00:28:10,980
traditional languages and asynchronous

569
00:28:10,980 --> 00:28:13,200
errors in JavaScript we will put try

570
00:28:13,200 --> 00:28:16,950
catch but try catch totally useless when

571
00:28:16,950 --> 00:28:19,200
it comes to asynchronous code because

572
00:28:19,200 --> 00:28:21,000
that event loop when it schedules

573
00:28:21,000 --> 00:28:23,340
something in the future it loses the

574
00:28:23,340 --> 00:28:25,890
contents it loses the try catch so when

575
00:28:25,890 --> 00:28:29,100
the callbacks come comes back we don't

576
00:28:29,100 --> 00:28:31,080
have that try catch anymore so this will

577
00:28:31,080 --> 00:28:35,310
fail miserably and this is how I feel

578
00:28:35,310 --> 00:28:37,620
when I work with that and try to debug

579
00:28:37,620 --> 00:28:41,460
is synchronous errors I promise this is

580
00:28:41,460 --> 00:28:47,690
the last gift so how to deal with this

581
00:28:47,690 --> 00:28:50,580
there are multiple things that consider

582
00:28:50,580 --> 00:28:53,000
that I consider the best practice I

583
00:28:53,000 --> 00:28:56,010
would not go into details about all of

584
00:28:56,010 --> 00:28:59,310
them but I think the most important one

585
00:28:59,310 --> 00:29:02,400
is uncaught exception so process

586
00:29:02,400 --> 00:29:03,840
remember process how many of you

587
00:29:03,840 --> 00:29:06,050
remember process

588
00:29:06,050 --> 00:29:08,460
okay that's a good ratio half of the

589
00:29:08,460 --> 00:29:11,240
room another half is already sleeping

590
00:29:11,240 --> 00:29:14,970
ungass exception so process that on

591
00:29:14,970 --> 00:29:23,280
uncut exception this is how we attach an

592
00:29:23,280 --> 00:29:25,650
event listener so again process

593
00:29:25,650 --> 00:29:28,140
implements event listener and the event

594
00:29:28,140 --> 00:29:32,450
emitter pattern why this is good because

595
00:29:32,450 --> 00:29:34,920
this is like the last step before

596
00:29:34,920 --> 00:29:39,420
application crashes so we definitely

597
00:29:39,420 --> 00:29:42,420
want to listen to this error handler to

598
00:29:42,420 --> 00:29:46,110
this event we want to log it we want to

599
00:29:46,110 --> 00:29:48,180
maybe send an email or a slack

600
00:29:48,180 --> 00:29:50,880
notification and then we want to exit

601
00:29:50,880 --> 00:29:52,680
gracefully so we don't want to resume

602
00:29:52,680 --> 00:29:55,050
the application because the state might

603
00:29:55,050 --> 00:30:00,000
be lost at this point okay here's the

604
00:30:00,000 --> 00:30:03,740
domain which is softly deprecated

605
00:30:03,740 --> 00:30:06,750
nothing scary about self-deprecation it

606
00:30:06,750 --> 00:30:08,190
just means they're going to remove it

607
00:30:08,190 --> 00:30:11,190
from the core but I'm sure it will be

608
00:30:11,190 --> 00:30:14,100
like a standalone NPM module the way it

609
00:30:14,100 --> 00:30:16,890
works we can put code inside of the main

610
00:30:16,890 --> 00:30:20,010
dot run and even it's a synchronous code

611
00:30:20,010 --> 00:30:23,250
it will still catch those pairs it will

612
00:30:23,250 --> 00:30:25,770
still casual sizing cursors so if you're

613
00:30:25,770 --> 00:30:28,200
building an express server you can wrap

614
00:30:28,200 --> 00:30:31,830
all middleware all routes in the main

615
00:30:31,830 --> 00:30:34,110
dog run or you can just rub a single

616
00:30:34,110 --> 00:30:37,140
route I have a few examples in the

617
00:30:37,140 --> 00:30:40,170
source code folder as well so this code

618
00:30:40,170 --> 00:30:44,400
will run okay and then the last bonus

619
00:30:44,400 --> 00:30:48,500
part we three minutes over the time so I

620
00:30:48,500 --> 00:30:52,470
will move a little bit faster it's about

621
00:30:52,470 --> 00:30:56,850
writing the C++ add-ons so a lot of

622
00:30:56,850 --> 00:30:58,650
people think that no jess is just

623
00:30:58,650 --> 00:31:01,620
JavaScript well actually there is more C

624
00:31:01,620 --> 00:31:04,530
and C++ in nodejs itself in the platform

625
00:31:04,530 --> 00:31:07,710
itself than JavaScript and it's very

626
00:31:07,710 --> 00:31:10,350
very straightforward how to make them

627
00:31:10,350 --> 00:31:12,450
work together if you want to write a

628
00:31:12,450 --> 00:31:15,570
module or a driver to your database or

629
00:31:15,570 --> 00:31:19,260
maybe some hardware device

630
00:31:19,260 --> 00:31:22,050
all you need to do is have a simple aah

631
00:31:22,050 --> 00:31:24,210
splat file obviously right

632
00:31:24,210 --> 00:31:25,950
so I'm going to work if you don't have

633
00:31:25,950 --> 00:31:28,980
the source code and then notice this

634
00:31:28,980 --> 00:31:34,080
thing so this thing will output a string

635
00:31:34,080 --> 00:31:37,680
and then I'm exporting my method so you

636
00:31:37,680 --> 00:31:39,420
need to do two things inside of your C

637
00:31:39,420 --> 00:31:41,820
code you need to well write your code

638
00:31:41,820 --> 00:31:45,180
right and then expose it as the method

639
00:31:45,180 --> 00:31:48,750
and then I'm creating this JSON file

640
00:31:48,750 --> 00:31:52,590
which has the name of my add-on the name

641
00:31:52,590 --> 00:31:57,390
of my library and my source code I'm

642
00:31:57,390 --> 00:31:59,640
installing no gyp which will do the

643
00:31:59,640 --> 00:32:02,640
compilation and run this two commands

644
00:32:02,640 --> 00:32:06,060
configure and build and that's it boom I

645
00:32:06,060 --> 00:32:09,300
would have this folder build release now

646
00:32:09,300 --> 00:32:12,300
from the node all I'm doing is just

647
00:32:12,300 --> 00:32:16,620
requiring this folder and I can use my

648
00:32:16,620 --> 00:32:19,410
method so hello that's the same method

649
00:32:19,410 --> 00:32:22,470
that I defined and exported in C++ so

650
00:32:22,470 --> 00:32:25,290
that would output Capital One when I run

651
00:32:25,290 --> 00:32:28,380
it so you can basically communicate

652
00:32:28,380 --> 00:32:30,930
between two worlds two different

653
00:32:30,930 --> 00:32:33,240
languages I think that's pretty pretty

654
00:32:33,240 --> 00:32:36,380
cool if you want to hear more about

655
00:32:36,380 --> 00:32:39,330
node.js at Capital One we are top US

656
00:32:39,330 --> 00:32:44,140
bank there is a YouTube video and

657
00:32:44,150 --> 00:32:46,260
30-second summary we'll make it like

658
00:32:46,260 --> 00:32:49,320
three seconds summary so invented meters

659
00:32:49,320 --> 00:32:53,910
streams clusters the main c++ add-ons

660
00:32:53,910 --> 00:33:00,840
and streams so this slides on github to

661
00:33:00,840 --> 00:33:05,250
search my name and also find it can

662
00:33:05,250 --> 00:33:08,370
reach me on twitter and if you want to

663
00:33:08,370 --> 00:33:12,060
learn more at node university I have I

664
00:33:12,060 --> 00:33:14,370
would have this stock available there

665
00:33:14,370 --> 00:33:17,670
for free all open-source as an online

666
00:33:17,670 --> 00:33:19,410
course and also have a bunch of other

667
00:33:19,410 --> 00:33:22,440
online courses and node.js as well one

668
00:33:22,440 --> 00:33:24,840
last thing this is a quote from coding

669
00:33:24,840 --> 00:33:28,170
horror dot-com and JavaScript is

670
00:33:28,170 --> 00:33:31,200
everywhere and it could be a good thing

671
00:33:31,200 --> 00:33:32,930
or it could be a scary thing

672
00:33:32,930 --> 00:33:36,080
to think about Tesla running on

673
00:33:36,080 --> 00:33:39,910
JavaScript but if you think about

674
00:33:39,910 --> 00:33:42,350
terminators running on JavaScript

675
00:33:42,350 --> 00:33:46,130
maybe humanity will have a hope thank

676
00:33:46,130 --> 00:33:46,730
you everyone

