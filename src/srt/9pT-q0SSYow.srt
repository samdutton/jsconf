1
00:00:00,000 --> 00:00:18,600

oh hello everyone I can see that people

2
00:00:18,600 --> 00:00:21,060
are still having a coffee out there so

3
00:00:21,060 --> 00:00:23,220
hopefully you can rush and come in so

4
00:00:23,220 --> 00:00:24,810
that we don't lose much time with this

5
00:00:24,810 --> 00:00:27,060
presentation okay so we start my name is

6
00:00:27,060 --> 00:00:29,160
Naruto so ease as they were mentioning

7
00:00:29,160 --> 00:00:31,920
I'm from Argentina very living kale and

8
00:00:31,920 --> 00:00:36,600
I came to talk about api's the

9
00:00:36,600 --> 00:00:38,730
presentation slice are already online so

10
00:00:38,730 --> 00:00:39,840
you can actually check it out

11
00:00:39,840 --> 00:00:42,140
slice come slash lilo so slash

12
00:00:42,140 --> 00:00:44,940
component-based API you can actually

13
00:00:44,940 --> 00:00:47,610
take a picture of that if you want to

14
00:00:47,610 --> 00:00:50,250
check it out later I will give quite

15
00:00:50,250 --> 00:00:52,739
some stuff 25 minutes is kind of hard to

16
00:00:52,739 --> 00:00:55,199
fit everything in so if you want to find

17
00:00:55,199 --> 00:00:57,750
out more later I mean maybe we can go in

18
00:00:57,750 --> 00:00:59,910
more detail and my twitter handle is

19
00:00:59,910 --> 00:01:03,420
your service same as my surname okay so

20
00:01:03,420 --> 00:01:06,570
we start so if we're talking old api's

21
00:01:06,570 --> 00:01:08,700
we must talk about the current host

22
00:01:08,700 --> 00:01:13,830
stuff which is what graph cured right so

23
00:01:13,830 --> 00:01:17,130
graph QL is increasingly popular this is

24
00:01:17,130 --> 00:01:19,590
the stats from the state of JavaScript

25
00:01:19,590 --> 00:01:22,470
from last year that is says that 20% of

26
00:01:22,470 --> 00:01:24,720
people who have used it they have they

27
00:01:24,720 --> 00:01:25,979
have liked it so they won't talk should

28
00:01:25,979 --> 00:01:29,159
use it again and 62% they have heard of

29
00:01:29,159 --> 00:01:31,409
it unlike to learn so I mean this is

30
00:01:31,409 --> 00:01:34,140
certainly gaining ground and we can

31
00:01:34,140 --> 00:01:36,210
expect graph QL to be the new normal

32
00:01:36,210 --> 00:01:39,720
affion maybe time out for rest a lot of

33
00:01:39,720 --> 00:01:41,820
rest api switch are still out there of

34
00:01:41,820 --> 00:01:43,680
course but it like if you have to start

35
00:01:43,680 --> 00:01:45,390
a new project quite likely you might

36
00:01:45,390 --> 00:01:46,770
actually want to do it graph QL oh

37
00:01:46,770 --> 00:01:49,829
that's the situation right now so why is

38
00:01:49,829 --> 00:01:52,649
it so the one characteristic from graph

39
00:01:52,649 --> 00:01:54,720
QL that everyone talks about is how you

40
00:01:54,720 --> 00:01:56,549
can actually get exactly the data that

41
00:01:56,549 --> 00:01:59,040
you need to fill your layouts your

42
00:01:59,040 --> 00:02:00,990
components so say that you have this

43
00:02:00,990 --> 00:02:03,689
layout ok so this is like a widget with

44
00:02:03,689 --> 00:02:05,549
a feature director we have they're

45
00:02:05,549 --> 00:02:07,619
showing a couple of themes and each film

46
00:02:07,619 --> 00:02:10,270
showing some of its outdoors

47
00:02:10,270 --> 00:02:12,010
so the way that you actually fetch the

48
00:02:12,010 --> 00:02:14,740
data through mmm through okay well

49
00:02:14,740 --> 00:02:17,110
actually you need to get data so in the

50
00:02:17,110 --> 00:02:18,910
case of the director we need to get the

51
00:02:18,910 --> 00:02:21,610
name the country on the avatar then for

52
00:02:21,610 --> 00:02:23,080
each of the things we have the thumbnail

53
00:02:23,080 --> 00:02:25,600
and the time and then for reactors we

54
00:02:25,600 --> 00:02:28,300
have the avatar and the name so graph QL

55
00:02:28,300 --> 00:02:30,670
is very straightforward you can define a

56
00:02:30,670 --> 00:02:32,740
scheme and then you define a query that

57
00:02:32,740 --> 00:02:35,110
lets you get the data as you need it and

58
00:02:35,110 --> 00:02:37,210
what you're actually get from this is a

59
00:02:37,210 --> 00:02:39,070
response with the data in the structure

60
00:02:39,070 --> 00:02:40,540
as you need it so this is actually quite

61
00:02:40,540 --> 00:02:42,790
cool right you get exactly what you need

62
00:02:42,790 --> 00:02:45,130
so this is improvement of a rest and why

63
00:02:45,130 --> 00:02:48,550
is taking over from rest and this plays

64
00:02:48,550 --> 00:02:50,680
very nicely with components so if you're

65
00:02:50,680 --> 00:02:52,330
actually guys calling with Riyadh and

66
00:02:52,330 --> 00:02:55,680
buges I guess that's in the situation

67
00:02:55,680 --> 00:03:00,070
you will actually love graph QL because

68
00:03:00,070 --> 00:03:02,710
it goes one-to-one with with with the

69
00:03:02,710 --> 00:03:04,300
concept of components so in this

70
00:03:04,300 --> 00:03:06,160
situation we have an outer component

71
00:03:06,160 --> 00:03:10,360
called feature director which has a film

72
00:03:10,360 --> 00:03:12,520
it iterates over the list of films and

73
00:03:12,520 --> 00:03:15,460
each film component has an called an

74
00:03:15,460 --> 00:03:19,030
actor component okay and if you actually

75
00:03:19,030 --> 00:03:20,920
pay attention to this is exactly the

76
00:03:20,920 --> 00:03:23,560
same structure so very practical for

77
00:03:23,560 --> 00:03:26,590
this so so far so good graph QL is

78
00:03:26,590 --> 00:03:29,830
awesome but it is not perfect and

79
00:03:29,830 --> 00:03:31,630
luckily so it comes with a few

80
00:03:31,630 --> 00:03:33,910
limitations or trade-offs we can

81
00:03:33,910 --> 00:03:36,850
actually say so one of the trade-offs is

82
00:03:36,850 --> 00:03:38,590
that it is not catchable on the back end

83
00:03:38,590 --> 00:03:42,730
you can still cache the aquarium but it

84
00:03:42,730 --> 00:03:44,620
has to be on the client side and there

85
00:03:44,620 --> 00:03:46,480
is a penalty for that because you're

86
00:03:46,480 --> 00:03:48,760
adding code to the front-end you had to

87
00:03:48,760 --> 00:03:50,170
part the JavaScript you had to execute

88
00:03:50,170 --> 00:03:52,980
the JavaScript sorry not ideal okay

89
00:03:52,980 --> 00:03:55,390
another problem is that this is

90
00:03:55,390 --> 00:03:58,450
acceptable to denial of service attacks

91
00:03:58,450 --> 00:04:00,400
because now you're given a lot of power

92
00:04:00,400 --> 00:04:02,410
to the client to fetch whatever data

93
00:04:02,410 --> 00:04:07,570
they want so if any evil person they

94
00:04:07,570 --> 00:04:10,720
won't actually take your database down

95
00:04:10,720 --> 00:04:13,360
they can actually execute a very complex

96
00:04:13,360 --> 00:04:16,060
query that maybe you're thoroughly like

97
00:04:16,060 --> 00:04:18,040
take one second to process it doesn't

98
00:04:18,040 --> 00:04:20,680
seem so much but actually doing that for

99
00:04:20,680 --> 00:04:22,630
many many thousands of course can

100
00:04:22,630 --> 00:04:24,100
actually take the data rate down on your

101
00:04:24,100 --> 00:04:24,699
server

102
00:04:24,699 --> 00:04:27,009
so once again they can be mitigated

103
00:04:27,009 --> 00:04:30,070
they're like strategies for dealing with

104
00:04:30,070 --> 00:04:34,000
the with these gos attacks but it's all

105
00:04:34,000 --> 00:04:35,590
in complexity to the application now you

106
00:04:35,590 --> 00:04:36,850
had to actually think about the

107
00:04:36,850 --> 00:04:38,500
complexity of the query you have to

108
00:04:38,500 --> 00:04:41,169
think out the nested that the depth of

109
00:04:41,169 --> 00:04:42,850
the query you can limit that you can

110
00:04:42,850 --> 00:04:44,470
actually think about timeout so once

111
00:04:44,470 --> 00:04:48,639
again this is not ideal so let me

112
00:04:48,639 --> 00:04:49,690
present you a project that I've been

113
00:04:49,690 --> 00:04:52,389
working on that it's called the

114
00:04:52,389 --> 00:04:55,810
component based API and before anything

115
00:04:55,810 --> 00:04:57,220
I need to say it's a work in progress

116
00:04:57,220 --> 00:04:59,020
and it will be released in a few months

117
00:04:59,020 --> 00:05:01,510
so I'm kind of sorry about this I wanted

118
00:05:01,510 --> 00:05:03,789
to finish it for J's conf

119
00:05:03,789 --> 00:05:05,740
be here saying okay we're releasing it

120
00:05:05,740 --> 00:05:09,070
today and you know I mean a planning

121
00:05:09,070 --> 00:05:10,930
time management of time is one of the

122
00:05:10,930 --> 00:05:12,699
most complex things in software

123
00:05:12,699 --> 00:05:15,580
development so it hasn't happened it has

124
00:05:15,580 --> 00:05:16,930
been like two months away from being

125
00:05:16,930 --> 00:05:20,770
ready for like six months now and still

126
00:05:20,770 --> 00:05:24,400
a few months away so yeah I'm sorry

127
00:05:24,400 --> 00:05:27,699
about this but everything that I'm going

128
00:05:27,699 --> 00:05:29,530
to show you now is working all the

129
00:05:29,530 --> 00:05:31,210
fundamental having implemented and I

130
00:05:31,210 --> 00:05:32,470
also have it running on a couple of

131
00:05:32,470 --> 00:05:35,919
production sites so whatever you will

132
00:05:35,919 --> 00:05:38,080
actually see here is pretty much there

133
00:05:38,080 --> 00:05:39,490
okay I'm not talking I'm not bluffing

134
00:05:39,490 --> 00:05:41,229
everything I will show is actually

135
00:05:41,229 --> 00:05:45,190
working I will try to do this following

136
00:05:45,190 --> 00:05:48,039
the example by graphical of having an

137
00:05:48,039 --> 00:05:50,380
open specification so then you can

138
00:05:50,380 --> 00:05:51,639
implement it for different technologies

139
00:05:51,639 --> 00:05:53,470
and how different systems interact with

140
00:05:53,470 --> 00:05:54,930
each other independently of their

141
00:05:54,930 --> 00:05:57,190
underlying implementation that's pretty

142
00:05:57,190 --> 00:06:00,639
cool what it is and finally it's a

143
00:06:00,639 --> 00:06:02,380
recognition that not everything is bad

144
00:06:02,380 --> 00:06:05,289
about rest so graph QL is actually

145
00:06:05,289 --> 00:06:07,000
taking over from rest not because rest

146
00:06:07,000 --> 00:06:09,280
is pal both have advantages and

147
00:06:09,280 --> 00:06:12,330
disadvantages and actually they may even

148
00:06:12,330 --> 00:06:14,380
complement each other in the sense that

149
00:06:14,380 --> 00:06:16,720
res has advantages that graphical does

150
00:06:16,720 --> 00:06:20,050
not have and the other way around so I

151
00:06:20,050 --> 00:06:22,000
was actually thinking this is actually

152
00:06:22,000 --> 00:06:23,650
pretty cool from retina to discard that

153
00:06:23,650 --> 00:06:25,570
and were actually try to do is to get

154
00:06:25,570 --> 00:06:28,030
the best from both approaches which is

155
00:06:28,030 --> 00:06:31,270
what I'm going to show you now so mostly

156
00:06:31,270 --> 00:06:34,750
concerning fetching data basically the

157
00:06:34,750 --> 00:06:36,400
good thing about graph QL is that it

158
00:06:36,400 --> 00:06:38,110
allows you to fetch the data that you

159
00:06:38,110 --> 00:06:39,820
need exactly that and that was the big

160
00:06:39,820 --> 00:06:41,860
problem with rest so I actually took

161
00:06:41,860 --> 00:06:44,110
this it allows you to fetch exactly the

162
00:06:44,110 --> 00:06:45,250
data that you need like Rafkin

163
00:06:45,250 --> 00:06:50,110
but it has an interface like rest so if

164
00:06:50,110 --> 00:06:52,120
in graph curl you have a Korean of this

165
00:06:52,120 --> 00:06:53,980
type you have a feature detector with a

166
00:06:53,980 --> 00:06:57,430
few properties then film with a few

167
00:06:57,430 --> 00:07:00,430
properties and then an actor the way

168
00:07:00,430 --> 00:07:02,350
that I translate this through the URL is

169
00:07:02,350 --> 00:07:04,480
first I get the properties for the

170
00:07:04,480 --> 00:07:08,340
director and I pass it through a field

171
00:07:08,340 --> 00:07:12,100
parameter on the uran then I get the

172
00:07:12,100 --> 00:07:14,950
property for the film and I also passes

173
00:07:14,950 --> 00:07:16,690
through the fields parameter in a kind

174
00:07:16,690 --> 00:07:19,240
of dot notation so it now films to

175
00:07:19,240 --> 00:07:21,580
tighten and then a pipe thumbnail to say

176
00:07:21,580 --> 00:07:23,290
this property or that probably watch a

177
00:07:23,290 --> 00:07:25,960
deeper the and that property and finally

178
00:07:25,960 --> 00:07:27,970
once again for the actors starting from

179
00:07:27,970 --> 00:07:31,570
the root films dot actors dot name pipe

180
00:07:31,570 --> 00:07:34,930
avatar so having these syntax I can

181
00:07:34,930 --> 00:07:37,540
actually query the the service from the

182
00:07:37,540 --> 00:07:40,450
URL so we have solved the catch ability

183
00:07:40,450 --> 00:07:43,090
issue because now my URL is my

184
00:07:43,090 --> 00:07:45,670
identifier and I can actually cache this

185
00:07:45,670 --> 00:07:47,320
in the backend so that's the first thing

186
00:07:47,320 --> 00:07:49,600
that is actually solved a combination

187
00:07:49,600 --> 00:07:52,450
from rest and graphical now concerning

188
00:07:52,450 --> 00:07:54,670
the shape of the data that were actually

189
00:07:54,670 --> 00:07:58,780
fetching so in graph QL what you have is

190
00:07:58,780 --> 00:08:01,360
that the shape of the data mirrors one

191
00:08:01,360 --> 00:08:04,780
to one their query right you say give me

192
00:08:04,780 --> 00:08:06,160
future director and then the future

193
00:08:06,160 --> 00:08:08,560
director has the film and if you has a

194
00:08:08,560 --> 00:08:10,930
doctor and you're actually returning

195
00:08:10,930 --> 00:08:13,150
exactly that same shape but I decide to

196
00:08:13,150 --> 00:08:16,300
use the structure as the data has been

197
00:08:16,300 --> 00:08:19,240
defined on the database assuming there

198
00:08:19,240 --> 00:08:21,220
is an SQL database maybe this doesn't

199
00:08:21,220 --> 00:08:23,290
make much sense within no SQL database

200
00:08:23,290 --> 00:08:25,090
but you have an SQL database that you

201
00:08:25,090 --> 00:08:27,010
have like tables and you're thinking of

202
00:08:27,010 --> 00:08:29,200
rows and columns okay and then you have

203
00:08:29,200 --> 00:08:30,910
relationships among the entities that

204
00:08:30,910 --> 00:08:31,540
you have an ID

205
00:08:31,540 --> 00:08:33,340
pointing to an object on another table

206
00:08:33,340 --> 00:08:37,229
so that was my model on which I actually

207
00:08:37,229 --> 00:08:40,330
implemented this so once again this is

208
00:08:40,330 --> 00:08:41,830
graph QL this is how you get the

209
00:08:41,830 --> 00:08:44,200
response and what we have in this other

210
00:08:44,200 --> 00:08:49,590
paradigm is databases and then you

211
00:08:49,590 --> 00:08:52,500
this you can call it the table sort of I

212
00:08:52,500 --> 00:08:54,600
call it people with the idea of the

213
00:08:54,600 --> 00:08:56,850
entity okay now he has the name the

214
00:08:56,850 --> 00:08:59,940
country avatar and themes and the film's

215
00:08:59,940 --> 00:09:02,700
is of being nested to get the entity of

216
00:09:02,700 --> 00:09:05,510
the film it has a reference to the ID

217
00:09:05,510 --> 00:09:09,420
entity so then we go to the film's down

218
00:09:09,420 --> 00:09:12,420
here here we have the entity with that

219
00:09:12,420 --> 00:09:14,640
idea so this one has its own property

220
00:09:14,640 --> 00:09:16,290
style thumbnail and then he has the

221
00:09:16,290 --> 00:09:19,170
property actors which is an ID pointing

222
00:09:19,170 --> 00:09:23,070
to the actor entity back again on people

223
00:09:23,070 --> 00:09:25,680
so it's you know as you can see this is

224
00:09:25,680 --> 00:09:28,920
actually replicating sort of the

225
00:09:28,920 --> 00:09:30,210
structure of the database are you have

226
00:09:30,210 --> 00:09:33,150
it on the back end like like bringing it

227
00:09:33,150 --> 00:09:36,420
to the front end these solves the denial

228
00:09:36,420 --> 00:09:40,310
of service attacks now why is that I

229
00:09:40,310 --> 00:09:42,779
will actually have a different quality

230
00:09:42,779 --> 00:09:44,550
to explain better this is a tiny bit

231
00:09:44,550 --> 00:09:45,720
exaggerated I don't think I would

232
00:09:45,720 --> 00:09:47,460
actually have a body like this but it

233
00:09:47,460 --> 00:09:48,779
makes the point imagine that you have

234
00:09:48,779 --> 00:09:50,279
this query that you're querying for

235
00:09:50,279 --> 00:09:52,529
posts and all the post you bring the

236
00:09:52,529 --> 00:09:54,870
tile and the author then the author you

237
00:09:54,870 --> 00:09:56,130
have the name and followers the

238
00:09:56,130 --> 00:09:57,390
followers have the name and the

239
00:09:57,390 --> 00:09:59,010
recommended post which has a tile author

240
00:09:59,010 --> 00:10:02,520
whatever okay so if you actually pay

241
00:10:02,520 --> 00:10:03,660
attention to this you are given

242
00:10:03,660 --> 00:10:06,930
different names to the same two entities

243
00:10:06,930 --> 00:10:11,430
which are the post and the users okay so

244
00:10:11,430 --> 00:10:12,870
if you actually think about this in

245
00:10:12,870 --> 00:10:14,910
terms of graph QL you have a nested

246
00:10:14,910 --> 00:10:16,380
relationship upon all of the entities

247
00:10:16,380 --> 00:10:18,630
and you have a query executes after

248
00:10:18,630 --> 00:10:20,190
query executes in after a query executes

249
00:10:20,190 --> 00:10:22,260
after acquiring right so everything is

250
00:10:22,260 --> 00:10:25,890
is compound and I've read in a paper

251
00:10:25,890 --> 00:10:28,530
that the complexity of this I don't know

252
00:10:28,530 --> 00:10:30,150
if it is right or not because I hadn't

253
00:10:30,150 --> 00:10:32,310
seen any validation of the paper I can

254
00:10:32,310 --> 00:10:34,650
share the URL with you but he says that

255
00:10:34,650 --> 00:10:37,350
the complexity is exponential to fetch

256
00:10:37,350 --> 00:10:40,470
data and it's polynomial to find out the

257
00:10:40,470 --> 00:10:43,680
complexity of the query so that if it

258
00:10:43,680 --> 00:10:46,010
goes over the threshold of your security

259
00:10:46,010 --> 00:10:48,779
limitations you cannot execute it but at

260
00:10:48,779 --> 00:10:51,510
least it takes polynomial time but if

261
00:10:51,510 --> 00:10:53,580
you think about this structure in terms

262
00:10:53,580 --> 00:10:56,400
of database that you have in there like

263
00:10:56,400 --> 00:10:58,560
SQL database this is simply two tables

264
00:10:58,560 --> 00:11:00,480
like post and users with relationships

265
00:11:00,480 --> 00:11:02,370
among them and you have actually made it

266
00:11:02,370 --> 00:11:03,089
flat

267
00:11:03,089 --> 00:11:05,819
No and because it's flood and I know

268
00:11:05,819 --> 00:11:07,259
that the entity that I will have is the

269
00:11:07,259 --> 00:11:09,989
sender I already have loaded in advance

270
00:11:09,989 --> 00:11:11,969
I just get the aquarium sorry I get the

271
00:11:11,969 --> 00:11:14,249
IDS from the forth or executions and

272
00:11:14,249 --> 00:11:16,439
then I compile everything together the

273
00:11:16,439 --> 00:11:20,789
time complexity is linear so because

274
00:11:20,789 --> 00:11:23,029
it's linear you can actually have 200

275
00:11:23,029 --> 00:11:27,719
nested the relationship among entity can

276
00:11:27,719 --> 00:11:30,509
be like 200 levels down okay

277
00:11:30,509 --> 00:11:32,909
and this still be performs well I don't

278
00:11:32,909 --> 00:11:34,019
know if that's a game with graph QL I

279
00:11:34,019 --> 00:11:35,399
don't think that you'll have a use case

280
00:11:35,399 --> 00:11:39,179
to have like 200 levels deep down but if

281
00:11:39,179 --> 00:11:41,429
you ever had to this performs better

282
00:11:41,429 --> 00:11:44,889
because it's flat

283
00:11:44,899 --> 00:11:47,879
so let's I'll show you a tiny bit more

284
00:11:47,879 --> 00:11:49,829
about the API response whether we

285
00:11:49,829 --> 00:11:51,869
actually get so the idea is that you

286
00:11:51,869 --> 00:11:54,449
have the data it comes back how do you

287
00:11:54,449 --> 00:11:55,889
use the data right I mean how do I know

288
00:11:55,889 --> 00:11:57,869
which is the data that I need to show in

289
00:11:57,869 --> 00:12:00,389
my component so we say that we have

290
00:12:00,389 --> 00:12:02,069
another component called feature

291
00:12:02,069 --> 00:12:04,379
director getting its fields name country

292
00:12:04,379 --> 00:12:07,709
now water then you have an inner

293
00:12:07,709 --> 00:12:10,949
component the film and then you have

294
00:12:10,949 --> 00:12:12,959
another another component the actor

295
00:12:12,959 --> 00:12:16,139
right so the way that I actually solved

296
00:12:16,139 --> 00:12:19,379
that problem is that you have the idea

297
00:12:19,379 --> 00:12:24,419
of the of the entity that is querying

298
00:12:24,419 --> 00:12:27,329
for the data in this case the the one

299
00:12:27,329 --> 00:12:28,649
who's calling for the data is a feature

300
00:12:28,649 --> 00:12:30,359
director is saying I need the feature

301
00:12:30,359 --> 00:12:32,609
director okay and then the subcomponents

302
00:12:32,609 --> 00:12:34,919
will be asking for properties from this

303
00:12:34,919 --> 00:12:38,669
rich field entity so this guy he says

304
00:12:38,669 --> 00:12:41,479
here the future director the result is

305
00:12:41,479 --> 00:12:46,319
entity with ID 1 ok from which database

306
00:12:46,319 --> 00:12:49,589
or which database tell it appears under

307
00:12:49,589 --> 00:12:53,099
the key ID which is people so when you

308
00:12:53,099 --> 00:12:56,669
go to people here it says people entity

309
00:12:56,669 --> 00:13:00,689
with ID 1 name country avatar and then

310
00:13:00,689 --> 00:13:03,289
films and then he gives me the ID of the

311
00:13:03,289 --> 00:13:07,079
films from this guy so and it is 1 and 2

312
00:13:07,079 --> 00:13:09,899
where do I retrieve this data from here

313
00:13:09,899 --> 00:13:11,830
it says from the

314
00:13:11,830 --> 00:13:14,589
key under films which is called films

315
00:13:14,589 --> 00:13:17,380
also so now we come to films and he

316
00:13:17,380 --> 00:13:19,990
gives me the entity okay Tyler thumbnail

317
00:13:19,990 --> 00:13:22,060
actors and I trust he gives me the

318
00:13:22,060 --> 00:13:24,610
actors with IDs two and three once again

319
00:13:24,610 --> 00:13:27,490
what do I get them from from films dot

320
00:13:27,490 --> 00:13:29,500
actors and he says you have to get these

321
00:13:29,500 --> 00:13:33,399
from the database or table called people

322
00:13:33,399 --> 00:13:36,640
okay so now in people two and three we

323
00:13:36,640 --> 00:13:38,709
have these entities and you can see that

324
00:13:38,709 --> 00:13:40,209
the data that are actually retrieved

325
00:13:40,209 --> 00:13:42,519
from from each is exactly what they need

326
00:13:42,519 --> 00:13:46,240
so this number one is George Lucas is

327
00:13:46,240 --> 00:13:47,589
the director I need to display the

328
00:13:47,589 --> 00:13:50,950
avatar from him and the country okay a

329
00:13:50,950 --> 00:13:53,920
one McGregor he's only an actor so I'm

330
00:13:53,920 --> 00:13:56,560
not sure in the the country from him and

331
00:13:56,560 --> 00:13:57,940
not even display this

332
00:13:57,940 --> 00:13:59,740
okay so doesn't bring it is pretty much

333
00:13:59,740 --> 00:14:03,220
like graph QL but the data is arranged

334
00:14:03,220 --> 00:14:06,279
on a different structure what is the

335
00:14:06,279 --> 00:14:07,450
cool thing about this one thing that

336
00:14:07,450 --> 00:14:10,000
they take normalized so you can see on

337
00:14:10,000 --> 00:14:11,760
the example we have the same actor twice

338
00:14:11,760 --> 00:14:14,800
Natalie Portman so in graphic where you

339
00:14:14,800 --> 00:14:16,420
actually bring this data twice here you

340
00:14:16,420 --> 00:14:20,230
bring it only once then they they say

341
00:14:20,230 --> 00:14:22,149
unique database containing all the dates

342
00:14:22,149 --> 00:14:23,980
and the client so you can actually merge

343
00:14:23,980 --> 00:14:25,570
all of these because now it's flat you

344
00:14:25,570 --> 00:14:29,050
know how like next levels with renaming

345
00:14:29,050 --> 00:14:31,149
of the same entity now you know I posted

346
00:14:31,149 --> 00:14:33,579
suppose the user is a user it's flat you

347
00:14:33,579 --> 00:14:35,200
can actually merge it when you bring it

348
00:14:35,200 --> 00:14:37,300
from the from your cultural API you

349
00:14:37,300 --> 00:14:39,010
merge it on the client and you have a

350
00:14:39,010 --> 00:14:40,750
cache so if you know that you will need

351
00:14:40,750 --> 00:14:42,670
to fetch this data later on and you

352
00:14:42,670 --> 00:14:44,260
already have retrieved it you have it

353
00:14:44,260 --> 00:14:45,579
there you don't even need to make that

354
00:14:45,579 --> 00:14:47,260
that call so this is awesome for

355
00:14:47,260 --> 00:14:51,420
performance because the most performing

356
00:14:51,420 --> 00:14:53,920
application is the one that does not

357
00:14:53,920 --> 00:14:56,709
need to make that HTTP call if it is

358
00:14:56,709 --> 00:14:58,630
redundant don't make it and this makes

359
00:14:58,630 --> 00:15:01,600
it possible and finally another cool

360
00:15:01,600 --> 00:15:04,060
property is that because the dates

361
00:15:04,060 --> 00:15:05,290
already share among all of the

362
00:15:05,290 --> 00:15:07,839
components if one component is fetching

363
00:15:07,839 --> 00:15:11,740
data okay and this data has been updated

364
00:15:11,740 --> 00:15:13,870
in the time in between and another

365
00:15:13,870 --> 00:15:15,790
component also was using the same data

366
00:15:15,790 --> 00:15:18,610
then both components can be render

367
00:15:18,610 --> 00:15:21,160
Europe you can observe on the database

368
00:15:21,160 --> 00:15:23,589
basically so it's a building content

369
00:15:23,589 --> 00:15:24,030
object

370
00:15:24,030 --> 00:15:25,470
on the fly and then observe this object

371
00:15:25,470 --> 00:15:28,380
you can actually have an idea of being

372
00:15:28,380 --> 00:15:30,570
overly observing the database and the

373
00:15:30,570 --> 00:15:33,540
layout can be can react to the data

374
00:15:33,540 --> 00:15:35,190
inside the database this is not

375
00:15:35,190 --> 00:15:38,430
implemented by the way but the

376
00:15:38,430 --> 00:15:40,650
architecture supports this and that's

377
00:15:40,650 --> 00:15:41,970
hopefully one of the upcoming things are

378
00:15:41,970 --> 00:15:44,460
will implement soon so concerning the

379
00:15:44,460 --> 00:15:46,020
API response I don't have enough time so

380
00:15:46,020 --> 00:15:47,850
I cannot show it to you but if you are

381
00:15:47,850 --> 00:15:49,050
going to check out the presentation

382
00:15:49,050 --> 00:15:50,970
later on you can click on these two

383
00:15:50,970 --> 00:15:53,010
links and this is deployed on a

384
00:15:53,010 --> 00:15:54,300
production server so you can actually

385
00:15:54,300 --> 00:15:56,960
see it working already so having this

386
00:15:56,960 --> 00:15:59,100
everything that comes that I would

387
00:15:59,100 --> 00:16:01,380
actually explain in the next slides is

388
00:16:01,380 --> 00:16:06,230
working so let's see how this works so

389
00:16:06,230 --> 00:16:08,790
the important thing here and I'm sorry

390
00:16:08,790 --> 00:16:11,220
about this is that the components are

391
00:16:11,220 --> 00:16:13,440
implemented partly in the front end and

392
00:16:13,440 --> 00:16:15,990
partly in the back end so I know that

393
00:16:15,990 --> 00:16:19,950
you're not that you don't trust back-end

394
00:16:19,950 --> 00:16:23,970
developers yeah this is something that

395
00:16:23,970 --> 00:16:26,760
believe me makes sense and I will try to

396
00:16:26,760 --> 00:16:28,230
convince you so that maybe you can have

397
00:16:28,230 --> 00:16:32,700
a tiny bit more of steam for us but the

398
00:16:32,700 --> 00:16:35,190
thing about these is that is it not back

399
00:16:35,190 --> 00:16:37,680
end or front end the component actually

400
00:16:37,680 --> 00:16:40,020
lives pretty in the back end and the

401
00:16:40,020 --> 00:16:42,450
front end and implements part of your

402
00:16:42,450 --> 00:16:44,220
responsibilities where it makes most

403
00:16:44,220 --> 00:16:46,830
sense so what am I talking about here is

404
00:16:46,830 --> 00:16:47,400
a following

405
00:16:47,400 --> 00:16:50,850
I have delineated four layers okay that

406
00:16:50,850 --> 00:16:53,330
make it up as a progressively enhanced

407
00:16:53,330 --> 00:16:57,660
service from API to application on the

408
00:16:57,660 --> 00:16:59,130
very first layer you have the data layer

409
00:16:59,130 --> 00:17:02,220
okay so this is basically your API you

410
00:17:02,220 --> 00:17:05,220
define what data the component needs and

411
00:17:05,220 --> 00:17:06,600
having that alone you really have the

412
00:17:06,600 --> 00:17:08,790
API you can actually stop it there okay

413
00:17:08,790 --> 00:17:11,550
but you can also continue you can on top

414
00:17:11,550 --> 00:17:13,410
of the data layer you can add a

415
00:17:13,410 --> 00:17:15,930
configuration layer okay on the backend

416
00:17:15,930 --> 00:17:18,000
so I'm talking about defining classes

417
00:17:18,000 --> 00:17:19,560
and styles and the strings that you need

418
00:17:19,560 --> 00:17:21,270
to display in your view that you

419
00:17:21,270 --> 00:17:24,060
actually set it up on the backend then

420
00:17:24,060 --> 00:17:26,970
we got referent in the view layer is in

421
00:17:26,970 --> 00:17:28,500
the fronton and of course reactivity

422
00:17:28,500 --> 00:17:30,620
also will happen on on the front end so

423
00:17:30,620 --> 00:17:33,000
what basically I'm saying with all of

424
00:17:33,000 --> 00:17:35,790
this is that the application your own

425
00:17:35,790 --> 00:17:37,620
application that you have for your own

426
00:17:37,620 --> 00:17:40,740
it can be model as an extension of your

427
00:17:40,740 --> 00:17:42,990
API so you have to provide an API for

428
00:17:42,990 --> 00:17:44,940
your clients to retrieve your data well

429
00:17:44,940 --> 00:17:46,890
your application can actually continue

430
00:17:46,890 --> 00:17:50,460
from there and and yeah and demonstrate

431
00:17:50,460 --> 00:17:53,390
the API the application becomes the API

432
00:17:53,390 --> 00:17:56,190
the other thing is that the examples

433
00:17:56,190 --> 00:17:57,450
that I showed you about querying

434
00:17:57,450 --> 00:17:59,779
specific fields to the URL which is the

435
00:17:59,779 --> 00:18:01,890
basically the graph QL like

436
00:18:01,890 --> 00:18:04,799
functionality is simply a specific use

437
00:18:04,799 --> 00:18:07,020
case of this architecture because what I

438
00:18:07,020 --> 00:18:09,899
do is to basically on runtime create the

439
00:18:09,899 --> 00:18:13,380
hierarchy of components that I need to

440
00:18:13,380 --> 00:18:15,270
match those fields and I and I give it

441
00:18:15,270 --> 00:18:17,190
back to you so that's just one use case

442
00:18:17,190 --> 00:18:18,840
and what you can do with this is

443
00:18:18,840 --> 00:18:20,669
actually much more so I found out

444
00:18:20,669 --> 00:18:23,789
actually pretty pretty cool how does

445
00:18:23,789 --> 00:18:26,070
this work so on the back end we have a

446
00:18:26,070 --> 00:18:28,980
component hierarchy which is how a

447
00:18:28,980 --> 00:18:30,659
component relates to each other like I

448
00:18:30,659 --> 00:18:33,390
own like I'm dropping this component and

449
00:18:33,390 --> 00:18:34,610
that component wrapping that component

450
00:18:34,610 --> 00:18:38,250
you have props you have data fields and

451
00:18:38,250 --> 00:18:40,200
you have the configuration so I have

452
00:18:40,200 --> 00:18:43,350
coded this in PHP this PHP code so you

453
00:18:43,350 --> 00:18:45,929
have functions get some modules which

454
00:18:45,929 --> 00:18:47,730
first define the hierarchy or how

455
00:18:47,730 --> 00:18:49,230
companies read to each other then you

456
00:18:49,230 --> 00:18:51,870
have init props and init props is very

457
00:18:51,870 --> 00:18:53,940
interesting I mean it receives a module

458
00:18:53,940 --> 00:18:57,649
and the object props to initialize a

459
00:18:57,649 --> 00:19:00,659
component can set properties for itself

460
00:19:00,659 --> 00:19:03,240
of course and also for his children

461
00:19:03,240 --> 00:19:05,340
component like all the way down right

462
00:19:05,340 --> 00:19:07,919
and every ancestor has higher priority

463
00:19:07,919 --> 00:19:11,190
over its children so the top most

464
00:19:11,190 --> 00:19:13,440
component at every job conferring the

465
00:19:13,440 --> 00:19:15,510
properties overriding all the properties

466
00:19:15,510 --> 00:19:18,390
from its children ok that's one thing

467
00:19:18,390 --> 00:19:19,470
but second thing that this is on the

468
00:19:19,470 --> 00:19:21,539
back end so it's a very easy to set

469
00:19:21,539 --> 00:19:24,299
properties horizontally not just

470
00:19:24,299 --> 00:19:26,250
vertically so you can actually in just

471
00:19:26,250 --> 00:19:29,010
one line of code say all these many

472
00:19:29,010 --> 00:19:31,200
components inject this property and it

473
00:19:31,200 --> 00:19:33,029
just works and you don't need to deploy

474
00:19:33,029 --> 00:19:34,590
any JavaScript file you know when you

475
00:19:34,590 --> 00:19:37,799
change one string you know like I mean

476
00:19:37,799 --> 00:19:41,460
one description or one class name ok it

477
00:19:41,460 --> 00:19:43,590
you you touching it on the bakken and

478
00:19:43,590 --> 00:19:45,029
it's already live no need to deploy

479
00:19:45,029 --> 00:19:46,640
anything only for web pack or anything

480
00:19:46,640 --> 00:19:49,080
then you have the data fields I will

481
00:19:49,080 --> 00:19:50,370
explain this tiny bit later

482
00:19:50,370 --> 00:19:54,230
and the configuration and this is the

483
00:19:54,230 --> 00:19:56,309
how it looks on the view have

484
00:19:56,309 --> 00:19:58,620
implemented he would handlebars so this

485
00:19:58,620 --> 00:20:00,930
is an example of a drop-down and you can

486
00:20:00,930 --> 00:20:03,360
see basically a deal then they say

487
00:20:03,360 --> 00:20:06,540
button then they say a ul and it

488
00:20:06,540 --> 00:20:08,820
iterates all of its sub modules and for

489
00:20:08,820 --> 00:20:11,400
each of them like it prints on LI and it

490
00:20:11,400 --> 00:20:13,050
says each of the sub modules

491
00:20:13,050 --> 00:20:15,840
render yourself so what's so cool about

492
00:20:15,840 --> 00:20:18,840
this is that the component the view in

493
00:20:18,840 --> 00:20:21,210
this case is completely decoupled from

494
00:20:21,210 --> 00:20:23,550
its children this drop-down doesn't know

495
00:20:23,550 --> 00:20:25,020
whose children is going to be you

496
00:20:25,020 --> 00:20:27,570
actually settle that on the on the on

497
00:20:27,570 --> 00:20:30,090
the back end through configuration so

498
00:20:30,090 --> 00:20:31,830
then you are really playing like Lego

499
00:20:31,830 --> 00:20:33,870
like this is on steroids because you

500
00:20:33,870 --> 00:20:35,250
have any one implementation of the of

501
00:20:35,250 --> 00:20:37,620
the view that you can actually add

502
00:20:37,620 --> 00:20:39,780
inject everywhere yesterday when we had

503
00:20:39,780 --> 00:20:42,660
the talk by issue and she was mentioning

504
00:20:42,660 --> 00:20:45,929
about this approp collapsing right this

505
00:20:45,929 --> 00:20:47,670
complexity of props because you don't

506
00:20:47,670 --> 00:20:50,520
want to separate the component into

507
00:20:50,520 --> 00:20:51,510
another component because the

508
00:20:51,510 --> 00:20:53,400
functionality is kind of the same and

509
00:20:53,400 --> 00:20:56,370
you don't want to duplicate : right you

510
00:20:56,370 --> 00:20:58,350
want to stick to dry and then you end up

511
00:20:58,350 --> 00:21:00,660
having a monster and you're saying it's

512
00:21:00,660 --> 00:21:02,490
okay you can repeat call it makes sense

513
00:21:02,490 --> 00:21:05,250
okay with this architecture they no need

514
00:21:05,250 --> 00:21:07,020
for that because this is how the

515
00:21:07,020 --> 00:21:09,080
component looks like in the front end

516
00:21:09,080 --> 00:21:11,850
okay it's extremely decoupled from all

517
00:21:11,850 --> 00:21:14,309
of its children so then they know a prop

518
00:21:14,309 --> 00:21:19,290
Clips it just cannot happen so every

519
00:21:19,290 --> 00:21:22,260
component creates its context on the

520
00:21:22,260 --> 00:21:24,840
back end and it receives its context on

521
00:21:24,840 --> 00:21:27,450
the front end and only its context conde

522
00:21:27,450 --> 00:21:29,280
on the view you just don't care about

523
00:21:29,280 --> 00:21:32,660
having to iterate the data you carried

524
00:21:32,660 --> 00:21:34,740
the view doesn't know or doesn't care

525
00:21:34,740 --> 00:21:36,690
about its subcomponents and props can be

526
00:21:36,690 --> 00:21:41,550
set vertically and horizontally so this

527
00:21:41,550 --> 00:21:43,800
is the component architecture let's say

528
00:21:43,800 --> 00:21:45,330
that we actually have a page in this

529
00:21:45,330 --> 00:21:48,750
case / po / lovely tango at the very top

530
00:21:48,750 --> 00:21:50,730
of the other page my component is called

531
00:21:50,730 --> 00:21:54,320
post and it will contain some other

532
00:21:54,320 --> 00:21:57,330
components right so in this case I have

533
00:21:57,330 --> 00:21:59,850
a sub component called post l1 called

534
00:21:59,850 --> 00:22:01,920
post thumbnail and one called post

535
00:22:01,920 --> 00:22:03,860
content so this is

536
00:22:03,860 --> 00:22:05,929
the way to represent is very simple okay

537
00:22:05,929 --> 00:22:07,580
just like that this is an

538
00:22:07,580 --> 00:22:09,380
oversimplification I mean you can see

539
00:22:09,380 --> 00:22:11,090
that like a big widget there and the

540
00:22:11,090 --> 00:22:12,710
widget contains other components in the

541
00:22:12,710 --> 00:22:14,750
component contains other components this

542
00:22:14,750 --> 00:22:16,670
is just to simply to simplify okay it

543
00:22:16,670 --> 00:22:18,830
makes the case and the way that it works

544
00:22:18,830 --> 00:22:20,450
on the backend is that you define the

545
00:22:20,450 --> 00:22:21,590
relationships among all of these

546
00:22:21,590 --> 00:22:25,100
components with that function for

547
00:22:25,100 --> 00:22:26,960
retrieving data each component must

548
00:22:26,960 --> 00:22:28,640
define what data fits in is from the

549
00:22:28,640 --> 00:22:32,059
database just for itself without

550
00:22:32,059 --> 00:22:33,679
including the data fields for its sub

551
00:22:33,679 --> 00:22:35,270
components so you can think of these

552
00:22:35,270 --> 00:22:37,400
like fragments in graph QL but on

553
00:22:37,400 --> 00:22:39,890
steroids because once again each level

554
00:22:39,890 --> 00:22:42,679
of the component defines this is my data

555
00:22:42,679 --> 00:22:45,049
that I need not my cell components

556
00:22:45,049 --> 00:22:46,549
somewhere QL right now you have the

557
00:22:46,549 --> 00:22:48,410
possibility of a component getting the

558
00:22:48,410 --> 00:22:50,990
data also for its sub components okay

559
00:22:50,990 --> 00:22:53,299
but in this case each component at each

560
00:22:53,299 --> 00:22:55,190
layer says this is the data Deranian at

561
00:22:55,190 --> 00:22:57,500
every single level and the cool thing

562
00:22:57,500 --> 00:22:59,360
about this is a by having this

563
00:22:59,360 --> 00:23:01,940
architecture the endpoint URL from which

564
00:23:01,940 --> 00:23:04,220
to fetch the data and also the query to

565
00:23:04,220 --> 00:23:06,320
execute against the database can be

566
00:23:06,320 --> 00:23:07,790
automatically generated from the

567
00:23:07,790 --> 00:23:10,250
component hierarchy itself so what does

568
00:23:10,250 --> 00:23:12,710
this mean so we have this component

569
00:23:12,710 --> 00:23:16,760
architecture right so the originally the

570
00:23:16,760 --> 00:23:19,460
topmost component says I need to fetch

571
00:23:19,460 --> 00:23:22,010
data from this post okay the one

572
00:23:22,010 --> 00:23:24,500
corresponding to the URL and for that

573
00:23:24,500 --> 00:23:27,200
moment on all the components inside of

574
00:23:27,200 --> 00:23:29,059
this guy whenever they fetch a property

575
00:23:29,059 --> 00:23:32,299
it will be referencing this entity in

576
00:23:32,299 --> 00:23:34,010
this post so post title will actually

577
00:23:34,010 --> 00:23:35,960
load property title the post terminal

578
00:23:35,960 --> 00:23:37,400
will load property thumbnail and post

579
00:23:37,400 --> 00:23:39,260
constant will actually load property

580
00:23:39,260 --> 00:23:42,679
content so iterating from the topmost

581
00:23:42,679 --> 00:23:44,870
component all the way down you get the

582
00:23:44,870 --> 00:23:46,760
property from each and you can construct

583
00:23:46,760 --> 00:23:49,610
the URL so now this endpoint URL okay

584
00:23:49,610 --> 00:23:51,230
that I was showing you how you can fetch

585
00:23:51,230 --> 00:23:53,480
the data and you need it like graph QL

586
00:23:53,480 --> 00:23:55,790
like sorts I don't even need to call it

587
00:23:55,790 --> 00:23:58,160
anymore because it's automatically

588
00:23:58,160 --> 00:24:00,290
generated from the structure of the

589
00:24:00,290 --> 00:24:02,900
components itself and that's amazing if

590
00:24:02,900 --> 00:24:04,220
you actually change one component that

591
00:24:04,220 --> 00:24:07,910
you have another component is it already

592
00:24:07,910 --> 00:24:11,179
works but not only that because now this

593
00:24:11,179 --> 00:24:14,179
is on living on the backend I have the

594
00:24:14,179 --> 00:24:15,470
possibility to also create the query

595
00:24:15,470 --> 00:24:17,390
okay so you can also say

596
00:24:17,390 --> 00:24:19,850
so execute the data Amelie on the server

597
00:24:19,850 --> 00:24:21,620
and retrieve and return the date I

598
00:24:21,620 --> 00:24:23,179
merely no need to actually have that

599
00:24:23,179 --> 00:24:26,809
round-trip to give to load the client

600
00:24:26,809 --> 00:24:28,070
and then the client needs to fetch the

601
00:24:28,070 --> 00:24:29,179
data from the server and then the server

602
00:24:29,179 --> 00:24:30,740
returns the date and then you render

603
00:24:30,740 --> 00:24:32,830
that you can just return the data

604
00:24:32,830 --> 00:24:35,420
directly that's an option understand

605
00:24:35,420 --> 00:24:37,160
that you had to do this but now you had

606
00:24:37,160 --> 00:24:38,740
the possibility you can actually choose

607
00:24:38,740 --> 00:24:42,230
so if you actually want to have like

608
00:24:42,230 --> 00:24:45,170
relationships among entities this also

609
00:24:45,170 --> 00:24:47,360
works when we're actually loading this

610
00:24:47,360 --> 00:24:50,360
post author component he will actually

611
00:24:50,360 --> 00:24:52,520
change the entity from the post to the

612
00:24:52,520 --> 00:24:54,980
post offer okay and from that moment on

613
00:24:54,980 --> 00:24:56,780
all the sub components from this guy

614
00:24:56,780 --> 00:24:58,640
will be loading properties on this

615
00:24:58,640 --> 00:25:01,490
entity on the user or author in this

616
00:25:01,490 --> 00:25:04,130
case the user name lost property name

617
00:25:04,130 --> 00:25:07,220
and the user loads property avatar once

618
00:25:07,220 --> 00:25:10,160
again the endpoint URL and the database

619
00:25:10,160 --> 00:25:14,030
query are automatically generated how

620
00:25:14,030 --> 00:25:15,200
does it look on the back and on the

621
00:25:15,200 --> 00:25:18,320
front end so we had a view for the outer

622
00:25:18,320 --> 00:25:22,580
most component which is basically a

623
00:25:22,580 --> 00:25:25,250
simple field line saying okay now inject

624
00:25:25,250 --> 00:25:28,160
this entity into the context and then

625
00:25:28,160 --> 00:25:31,130
iterate over all my sub modules or sub

626
00:25:31,130 --> 00:25:33,410
components and for each of them render

627
00:25:33,410 --> 00:25:35,660
yourself using this entity on your

628
00:25:35,660 --> 00:25:40,460
context okay so when this sub component

629
00:25:40,460 --> 00:25:41,780
the receive the data in this case the

630
00:25:41,780 --> 00:25:45,049
tile it just prints itself okay you have

631
00:25:45,049 --> 00:25:46,549
the objector having loaded on its

632
00:25:46,549 --> 00:25:48,770
context and he says I want to show my

633
00:25:48,770 --> 00:25:51,380
property tile that you have expesive ID

634
00:25:51,380 --> 00:25:52,070
on the backend

635
00:25:52,070 --> 00:25:54,169
okay property tile but now also because

636
00:25:54,169 --> 00:25:56,000
we can load configuration we can even do

637
00:25:56,000 --> 00:25:58,040
something like this we can actually say

638
00:25:58,040 --> 00:26:00,230
okay I want instead of saying h1

639
00:26:00,230 --> 00:26:01,549
straight on the view you can actually

640
00:26:01,549 --> 00:26:04,700
say h1 through configuration add a class

641
00:26:04,700 --> 00:26:07,280
also and you can change this through

642
00:26:07,280 --> 00:26:10,090
configuration that's pretty powerful

643
00:26:10,090 --> 00:26:17,680
what is it so

644
00:26:17,680 --> 00:26:19,960
when he reaches the post author is the

645
00:26:19,960 --> 00:26:21,850
same so this guy will actually change

646
00:26:21,850 --> 00:26:25,000
from the current post to the post of

647
00:26:25,000 --> 00:26:27,490
Thor into the context and tell all of

648
00:26:27,490 --> 00:26:29,920
its subcomponents render yourself using

649
00:26:29,920 --> 00:26:34,390
the new entity I had to wrap up so I'm

650
00:26:34,390 --> 00:26:35,800
going to be pretty quick now with this

651
00:26:35,800 --> 00:26:37,690
but I want to enumerate all the many

652
00:26:37,690 --> 00:26:39,610
advantages of this architecture first

653
00:26:39,610 --> 00:26:41,620
one is isomorphism which is basically

654
00:26:41,620 --> 00:26:43,660
the capability of running your call on

655
00:26:43,660 --> 00:26:45,580
the on the server side or on the front

656
00:26:45,580 --> 00:26:47,740
end you're thinking of JavaScript this

657
00:26:47,740 --> 00:26:50,500
is another approach so on one side the

658
00:26:50,500 --> 00:26:51,820
handle bar templates they can be

659
00:26:51,820 --> 00:26:55,180
compiled to run as PHP they say

660
00:26:55,180 --> 00:26:56,320
wonderful library called light on

661
00:26:56,320 --> 00:26:58,240
candidate at that and he runs like like

662
00:26:58,240 --> 00:27:00,760
native PHP code is very fast awesome and

663
00:27:00,760 --> 00:27:01,870
on the other side the pitch free

664
00:27:01,870 --> 00:27:04,450
configuration can be exported as a JSON

665
00:27:04,450 --> 00:27:07,060
file because basically this component

666
00:27:07,060 --> 00:27:11,110
hierarchy is a big array of components

667
00:27:11,110 --> 00:27:13,090
listing all of their properties and then

668
00:27:13,090 --> 00:27:14,590
saying these are my sub components

669
00:27:14,590 --> 00:27:16,270
listen they're producing these are minor

670
00:27:16,270 --> 00:27:18,550
components so listen an array you just

671
00:27:18,550 --> 00:27:20,800
execute JSON encode on this and you

672
00:27:20,800 --> 00:27:23,230
obtain a JSON so that means that you

673
00:27:23,230 --> 00:27:25,150
have on one side the possibility to run

674
00:27:25,150 --> 00:27:27,280
this on the server and execute

675
00:27:27,280 --> 00:27:29,500
server-side rendering okay I don't I

676
00:27:29,500 --> 00:27:31,990
decide you can export these for the

677
00:27:31,990 --> 00:27:33,700
front-end you have a service application

678
00:27:33,700 --> 00:27:36,340
it's up to you and the cone is the same

679
00:27:36,340 --> 00:27:38,620
an ewok it works on both back in and

680
00:27:38,620 --> 00:27:43,420
from them then you can also target

681
00:27:43,420 --> 00:27:46,810
specific components so in this case we

682
00:27:46,810 --> 00:27:49,690
have a post and the post has a component

683
00:27:49,690 --> 00:27:52,480
called post I'll I can through the URL

684
00:27:52,480 --> 00:27:54,880
saying I want the data just for this

685
00:27:54,880 --> 00:27:57,630
component and also for this other

686
00:27:57,630 --> 00:28:01,090
component okay and what you get is the

687
00:28:01,090 --> 00:28:02,800
equivalent of getting the data just for

688
00:28:02,800 --> 00:28:05,530
these two guys and nothing else and that

689
00:28:05,530 --> 00:28:08,500
I find wonderful because what it means

690
00:28:08,500 --> 00:28:10,000
is that the component is its own API

691
00:28:10,000 --> 00:28:12,460
imaginary have a component that is like

692
00:28:12,460 --> 00:28:15,190
a infinite scroll you reach the bottom

693
00:28:15,190 --> 00:28:16,810
of the page you need to get more data

694
00:28:16,810 --> 00:28:19,120
now the component can just talk to

695
00:28:19,120 --> 00:28:23,530
itself say I need more data so you

696
00:28:23,530 --> 00:28:25,810
construct the URL the current URL and

697
00:28:25,810 --> 00:28:28,360
the path to this component starting from

698
00:28:28,360 --> 00:28:30,230
the top and you will only

699
00:28:30,230 --> 00:28:32,210
the data for this guy and once again

700
00:28:32,210 --> 00:28:34,309
because the hierarchy is such that at

701
00:28:34,309 --> 00:28:36,500
the top you have one component at the

702
00:28:36,500 --> 00:28:39,049
very top then the website is its own API

703
00:28:39,049 --> 00:28:41,090
so then you know different between API

704
00:28:41,090 --> 00:28:43,130
and website anymore this is both an API

705
00:28:43,130 --> 00:28:47,390
and a website at the same time so you

706
00:28:47,390 --> 00:28:48,650
can also implement single page

707
00:28:48,650 --> 00:28:50,660
applications and you can also create

708
00:28:50,660 --> 00:28:53,630
pattern libraries very easily because

709
00:28:53,630 --> 00:28:56,120
you render a component and it gives you

710
00:28:56,120 --> 00:28:59,299
the the visual identity it a component

711
00:28:59,299 --> 00:29:02,150
also knows which is css3 hostel and it's

712
00:29:02,150 --> 00:29:04,460
JavaScript files it just that's it you

713
00:29:04,460 --> 00:29:05,840
don't need to call it somewhere else

714
00:29:05,840 --> 00:29:09,350
finally you can implement cope which

715
00:29:09,350 --> 00:29:11,960
means create once publish everywhere so

716
00:29:11,960 --> 00:29:13,250
you have a single source of truth for

717
00:29:13,250 --> 00:29:16,760
multiple platforms wave email apps so

718
00:29:16,760 --> 00:29:18,890
you can actually have a JS component

719
00:29:18,890 --> 00:29:21,049
that extends HTML CSS component and then

720
00:29:21,049 --> 00:29:23,299
html's is a component that extends from

721
00:29:23,299 --> 00:29:25,190
your abstract component so you can

722
00:29:25,190 --> 00:29:27,380
actually layer the generations of the

723
00:29:27,380 --> 00:29:28,700
other layout in this case we have a

724
00:29:28,700 --> 00:29:30,679
website and then you have the email

725
00:29:30,679 --> 00:29:32,419
every page on the website can be sent by

726
00:29:32,419 --> 00:29:36,580
email for no extra cost so I'm finishing

727
00:29:36,580 --> 00:29:40,610
yeah in a nutshell advantages of this

728
00:29:40,610 --> 00:29:42,890
architecture you have the client-side

729
00:29:42,890 --> 00:29:45,350
cache is it change the behavior of the

730
00:29:45,350 --> 00:29:47,990
application is isomorphic they've

731
00:29:47,990 --> 00:29:49,730
component anniversary's is own API

732
00:29:49,730 --> 00:29:51,850
implement single page applications

733
00:29:51,850 --> 00:29:53,929
generated pattern library you can

734
00:29:53,929 --> 00:29:54,770
implement cope

735
00:29:54,770 --> 00:29:57,590
so in summary from all of these you have

736
00:29:57,590 --> 00:29:59,809
a lot of reduced complexity because if

737
00:29:59,809 --> 00:30:01,160
you want to do all of these other things

738
00:30:01,160 --> 00:30:03,049
anyway you have to do two three four

739
00:30:03,049 --> 00:30:04,340
different technologies here with one

740
00:30:04,340 --> 00:30:06,110
with just one architecture you solve

741
00:30:06,110 --> 00:30:07,000
everything

742
00:30:07,000 --> 00:30:09,290
more output in less time with fewer

743
00:30:09,290 --> 00:30:14,690
resources so finishing finishing so this

744
00:30:14,690 --> 00:30:18,020
is open source of course MIT license the

745
00:30:18,020 --> 00:30:21,140
URL is github.com slash lilo so slash

746
00:30:21,140 --> 00:30:25,490
pop okay so check it out is not ready

747
00:30:25,490 --> 00:30:28,730
yet okay I'm a few months away from

748
00:30:28,730 --> 00:30:30,919
finishing okay so if you cannot wait

749
00:30:30,919 --> 00:30:32,960
come talk to me they know much

750
00:30:32,960 --> 00:30:34,490
documentation there's some documentation

751
00:30:34,490 --> 00:30:36,230
so you have to talk to me okay

752
00:30:36,230 --> 00:30:39,380
but check it out okay and once again if

753
00:30:39,380 --> 00:30:40,429
you want to check the presentations

754
00:30:40,429 --> 00:30:42,080
right so come so I shoulda loss of slash

755
00:30:42,080 --> 00:30:43,580
component by CPR you can click on the

756
00:30:43,580 --> 00:30:43,910
list

