1
00:00:16,820 --> 00:00:21,760

okay um I just flew in from being like

2
00:00:21,760 --> 00:00:23,930
SVP engineering or something at Mozilla

3
00:00:23,930 --> 00:00:25,790
I'm kind of busy lately and I was also

4
00:00:25,790 --> 00:00:27,950
at this thing called fluent I thought

5
00:00:27,950 --> 00:00:29,810
I'm doing a talk that's going to have

6
00:00:29,810 --> 00:00:31,849
more nerdcore stuff in it because I know

7
00:00:31,849 --> 00:00:35,989
and love my Jas conf audience thanks for

8
00:00:35,989 --> 00:00:42,379
being here so the first I'm going to

9
00:00:42,379 --> 00:00:43,820
talk about is the web is the native code

10
00:00:43,820 --> 00:00:47,300
platform which seems crazy it wasn't

11
00:00:47,300 --> 00:00:51,980
really working well until recently and i

12
00:00:51,980 --> 00:00:56,390
want to show what you guys all from came

13
00:00:56,390 --> 00:00:59,809
here for which is c epic games I'm

14
00:00:59,809 --> 00:01:06,710
religion 3 like I'm electrified I'm not

15
00:01:06,710 --> 00:01:09,259
going to move except I'm gonna have to

16
00:01:09,259 --> 00:01:11,450
play game and i'll talk about the tools

17
00:01:11,450 --> 00:01:13,300
you may be failure with for doing this

18
00:01:13,300 --> 00:01:16,190
why triple AAA games what does Triple A

19
00:01:16,190 --> 00:01:19,429
game mean I'm told it means like halo

20
00:01:19,429 --> 00:01:23,000
and top end you know xbox playstation

21
00:01:23,000 --> 00:01:27,080
games these really do want to be seen

22
00:01:27,080 --> 00:01:29,960
C++ games and to run at full speed they

23
00:01:29,960 --> 00:01:31,549
have to be compiled that way you know

24
00:01:31,549 --> 00:01:33,110
John Carmack said this at quakecon last

25
00:01:33,110 --> 00:01:36,680
year he's quite right but they're a good

26
00:01:36,680 --> 00:01:38,180
torture test the exercise all the

27
00:01:38,180 --> 00:01:40,700
hardware they stress memory and load

28
00:01:40,700 --> 00:01:42,920
time you can dodge a wrench you can

29
00:01:42,920 --> 00:01:46,880
dodge a ball and so yeah I switched from

30
00:01:46,880 --> 00:01:50,000
Wesley at patches actually I have both

31
00:01:50,000 --> 00:01:53,899
so we're very interested in pushing the

32
00:01:53,899 --> 00:01:56,149
boundaries of the web and even though if

33
00:01:56,149 --> 00:01:57,470
you really want to go full speed there's

34
00:01:57,470 --> 00:01:59,840
nothing like C or C++ if you want to

35
00:01:59,840 --> 00:02:03,619
reach everybody with a safe non-scary on

36
00:02:03,619 --> 00:02:05,930
the web just click and it runs

37
00:02:05,930 --> 00:02:09,200
experience you need the web stack web

38
00:02:09,200 --> 00:02:11,900
staff is pretty lame for a while we had

39
00:02:11,900 --> 00:02:13,700
the reboot browser competition with

40
00:02:13,700 --> 00:02:16,000
firefox and then it really got better

41
00:02:16,000 --> 00:02:19,820
and then it got even better some of this

42
00:02:19,820 --> 00:02:22,580
stuff you know indexdb okay

43
00:02:22,580 --> 00:02:24,530
it's getting there it's a work in

44
00:02:24,530 --> 00:02:26,000
progress the web is a work in progress

45
00:02:26,000 --> 00:02:28,250
but there's really awesome stuff coming

46
00:02:28,250 --> 00:02:31,370
between like Mozilla and Google people

47
00:02:31,370 --> 00:02:33,530
we've got pointer lock gamepad full

48
00:02:33,530 --> 00:02:36,740
screen working pretty well WebSockets

49
00:02:36,740 --> 00:02:40,550
and then stuff we're doing again

50
00:02:40,550 --> 00:02:42,020
collaborating with Google like web RTC

51
00:02:42,020 --> 00:02:45,590
gets you even farther you have any way

52
00:02:45,590 --> 00:02:48,470
low latency data as well as audio and

53
00:02:48,470 --> 00:02:51,230
video communications in web audio which

54
00:02:51,230 --> 00:02:53,180
who has originated great for multi shot

55
00:02:53,180 --> 00:02:54,740
effects something you really can't do

56
00:02:54,740 --> 00:02:58,370
with html5 audio positional affects the

57
00:02:58,370 --> 00:03:01,340
whole works so this is a pretty good

58
00:03:01,340 --> 00:03:04,459
platform now it's you know it's a little

59
00:03:04,459 --> 00:03:08,780
lumpy it grew gradually but you can do a

60
00:03:08,780 --> 00:03:10,850
lot and yet it's cut off from native

61
00:03:10,850 --> 00:03:13,640
code unless you use some script in which

62
00:03:13,640 --> 00:03:15,050
I think everyone here has probably heard

63
00:03:15,050 --> 00:03:18,560
of even then scripting was generating

64
00:03:18,560 --> 00:03:20,990
code Alonso coyote super genius it was a

65
00:03:20,990 --> 00:03:22,580
little research figured out how to

66
00:03:22,580 --> 00:03:24,230
generate JavaScript that ran pretty fast

67
00:03:24,230 --> 00:03:26,600
but until we formalized something called

68
00:03:26,600 --> 00:03:29,930
asman j/s it wasn't clear how fast it

69
00:03:29,930 --> 00:03:33,260
could be we wanted to push too

70
00:03:33,260 --> 00:03:34,820
predictable performance and i'll talk

71
00:03:34,820 --> 00:03:36,950
more about that in a minute so now we've

72
00:03:36,950 --> 00:03:38,209
got a native code platform it has a

73
00:03:38,209 --> 00:03:41,900
bunch of stuff and it works in some ways

74
00:03:41,900 --> 00:03:43,370
it's just another compiler target maybe

75
00:03:43,370 --> 00:03:44,810
it's the last compiler target because

76
00:03:44,810 --> 00:03:46,670
once you're done you know game guys do

77
00:03:46,670 --> 00:03:48,140
this all the time they poured they look

78
00:03:48,140 --> 00:03:50,480
at the audience size they see the ps4

79
00:03:50,480 --> 00:03:53,630
the port to that the web is really huge

80
00:03:53,630 --> 00:03:55,489
there are maybe eight million of 10

81
00:03:55,489 --> 00:03:57,050
million developers I don't know if I

82
00:03:57,050 --> 00:03:58,370
mary meeker had this in her latest

83
00:03:58,370 --> 00:04:00,830
slides it's going to be 20 million i

84
00:04:00,830 --> 00:04:02,300
talked to marc andreessen last year and

85
00:04:02,300 --> 00:04:03,769
he's betting on github big because he

86
00:04:03,769 --> 00:04:07,489
sees the developer community around open

87
00:04:07,489 --> 00:04:10,640
source show your work really heavy

88
00:04:10,640 --> 00:04:12,680
javascript emphasis he sees that growing

89
00:04:12,680 --> 00:04:15,019
to be bigger than any any native

90
00:04:15,019 --> 00:04:17,269
platform the population of native stack

91
00:04:17,269 --> 00:04:18,410
developers is in the hundreds of

92
00:04:18,410 --> 00:04:21,859
thousands by comparison so time for

93
00:04:21,859 --> 00:04:25,820
demos and we are still working on code

94
00:04:25,820 --> 00:04:27,470
loading so you will you will have to

95
00:04:27,470 --> 00:04:30,500
bear with this initial experience it's

96
00:04:30,500 --> 00:04:32,840
getting better we can do parallel

97
00:04:32,840 --> 00:04:34,230
loading workers

98
00:04:34,230 --> 00:04:37,980
we can make it better and turns out a

99
00:04:37,980 --> 00:04:39,660
lot of the code loading is not

100
00:04:39,660 --> 00:04:43,920
JavaScript compile time so we've we've

101
00:04:43,920 --> 00:04:46,080
got something else to blame let's make

102
00:04:46,080 --> 00:04:48,090
sure this is going to be loud am I on

103
00:04:48,090 --> 00:04:51,270
audio here I'm plugged in I don't care

104
00:04:51,270 --> 00:04:54,120
my volume oh thank you good let's hope

105
00:04:54,120 --> 00:04:59,880
that isn't too much so this is this is

106
00:04:59,880 --> 00:05:03,810
the fly through this is the sanctuary

107
00:05:03,810 --> 00:05:06,990
level of Unreal Tournament truck it's

108
00:05:06,990 --> 00:05:09,290
unreal engine 3 this is all JavaScript

109
00:05:09,290 --> 00:05:14,070
there's no plugin it's all WebGL of

110
00:05:14,070 --> 00:05:15,630
course you want to get on the GPU that's

111
00:05:15,630 --> 00:05:19,320
a good thing and i'm going to show you

112
00:05:19,320 --> 00:05:27,980
my mad skills

113
00:05:27,990 --> 00:05:32,210
you're over here there they are

114
00:05:32,220 --> 00:05:45,960
Oh No uh I'm gonna get out of here for

115
00:05:45,960 --> 00:05:50,719
our children good thing I'm invincible

116
00:05:50,729 --> 00:06:00,430
alright

117
00:06:00,440 --> 00:06:03,710
they're Thank You technical issues um

118
00:06:03,710 --> 00:06:09,180
that wasn't possible year ago we had no

119
00:06:09,180 --> 00:06:11,220
guarantee we could get to the speed we

120
00:06:11,220 --> 00:06:13,500
got until we did some work i'll talk

121
00:06:13,500 --> 00:06:17,130
about now so when you think about

122
00:06:17,130 --> 00:06:18,840
reaching people you have to think about

123
00:06:18,840 --> 00:06:21,240
javascript you guys know this i'm at JS

124
00:06:21,240 --> 00:06:25,230
conf and javascript PM's are fast but

125
00:06:25,230 --> 00:06:28,050
they they they don't necessarily give

126
00:06:28,050 --> 00:06:29,460
you the predictable performance you want

127
00:06:29,460 --> 00:06:31,950
so when you run a compiler like a C++

128
00:06:31,950 --> 00:06:34,560
compiler built on the llvm framework its

129
00:06:34,560 --> 00:06:36,060
kind of missin a and it's not a vm it's

130
00:06:36,060 --> 00:06:38,010
a compiler framework which is what I'm

131
00:06:38,010 --> 00:06:40,200
scripting uses awesome framework it's

132
00:06:40,200 --> 00:06:43,889
what client uses you you can tool to jas

133
00:06:43,889 --> 00:06:47,010
but can you get the speed so it turns

134
00:06:47,010 --> 00:06:48,990
out you can compile code can be faster

135
00:06:48,990 --> 00:06:53,340
it can be deterministic in types and

136
00:06:53,340 --> 00:06:57,389
memory use it can take the static types

137
00:06:57,389 --> 00:06:59,760
of your C++ program apart from unsafe

138
00:06:59,760 --> 00:07:01,650
casts and map those to JavaScript and

139
00:07:01,650 --> 00:07:02,910
you can preserve that happening if you

140
00:07:02,910 --> 00:07:04,320
don't do it you have code like this we

141
00:07:04,320 --> 00:07:05,610
all know this code it runs pretty fast

142
00:07:05,610 --> 00:07:08,130
in jits but you're having to guess in

143
00:07:08,130 --> 00:07:11,039
the JIT that that I as an integer you

144
00:07:11,039 --> 00:07:12,660
don't know what X might be you having to

145
00:07:12,660 --> 00:07:14,850
guess that the sum s won't overflow into

146
00:07:14,850 --> 00:07:16,320
a double and if it does you might have

147
00:07:16,320 --> 00:07:19,710
to recompile one of the insights that

148
00:07:19,710 --> 00:07:22,260
alone had was to take typed arrays from

149
00:07:22,260 --> 00:07:24,900
WebGL and use them as the heap use them

150
00:07:24,900 --> 00:07:27,150
as the the memory for data not the

151
00:07:27,150 --> 00:07:29,039
control stack and that can really give

152
00:07:29,039 --> 00:07:30,090
you speed up because then you're

153
00:07:30,090 --> 00:07:32,370
modeling memory is a bunch of 32-bit

154
00:07:32,370 --> 00:07:34,289
integers or by its or both you can you

155
00:07:34,289 --> 00:07:36,479
can model it multiple ways you can have

156
00:07:36,479 --> 00:07:38,039
multiple views on to the same underlying

157
00:07:38,039 --> 00:07:40,800
buffer and that gave a good speed up

158
00:07:40,800 --> 00:07:43,770
with them scripted but what we need to

159
00:07:43,770 --> 00:07:47,789
do is go further we need to get out of

160
00:07:47,789 --> 00:07:49,590
the unpredictable miss speculation

161
00:07:49,590 --> 00:07:51,660
regime of jets the garbage collection

162
00:07:51,660 --> 00:07:54,150
pauses are also an issue and if you load

163
00:07:54,150 --> 00:07:56,580
code you end up with large amounts of

164
00:07:56,580 --> 00:07:58,500
code and you end up with inevitable miss

165
00:07:58,500 --> 00:08:02,550
speculations rii compilations hard to

166
00:08:02,550 --> 00:08:05,370
analyze data flow let's say if you're

167
00:08:05,370 --> 00:08:07,289
doing type inference it you hit scaling

168
00:08:07,289 --> 00:08:10,770
limits so as some JSE's our answer to

169
00:08:10,770 --> 00:08:11,420
this

170
00:08:11,420 --> 00:08:13,580
this is a subset of JavaScript currently

171
00:08:13,580 --> 00:08:15,620
and our intention is to extend

172
00:08:15,620 --> 00:08:17,540
JavaScript so it always remains a subset

173
00:08:17,540 --> 00:08:20,030
that's not really cheating we're always

174
00:08:20,030 --> 00:08:21,560
extending JavaScript anyway if there's a

175
00:08:21,560 --> 00:08:23,240
gap in the language we try to fill it if

176
00:08:23,240 --> 00:08:26,090
it's got legitimate use cases so this is

177
00:08:26,090 --> 00:08:29,570
just another one of those drivers of use

178
00:08:29,570 --> 00:08:32,330
case extension use case based extension

179
00:08:32,330 --> 00:08:36,380
and that helps us run in other browsers

180
00:08:36,380 --> 00:08:37,940
which is also important if you if you

181
00:08:37,940 --> 00:08:39,260
tell someone they need a new plug-in or

182
00:08:39,260 --> 00:08:40,940
they need to get a new browser you're

183
00:08:40,940 --> 00:08:42,170
going to lose a lot of users see if you

184
00:08:42,170 --> 00:08:44,000
tell them it runs a little slower it

185
00:08:44,000 --> 00:08:45,320
might actually be tolerable it might

186
00:08:45,320 --> 00:08:46,970
also put competitive pressure on other

187
00:08:46,970 --> 00:08:48,980
browsers to level up and that happens

188
00:08:48,980 --> 00:08:50,630
all the time we've been doing it forever

189
00:08:50,630 --> 00:08:52,820
you know in 2008 when v8 launched there

190
00:08:52,820 --> 00:08:55,130
was a performance war that hasn't ever

191
00:08:55,130 --> 00:08:56,870
stopped really and it's still going on

192
00:08:56,870 --> 00:08:58,700
and I'm going to use the latest v8

193
00:08:58,700 --> 00:09:01,130
numbers when I show results here so what

194
00:09:01,130 --> 00:09:02,510
does asthma just look like it looks like

195
00:09:02,510 --> 00:09:05,030
this version of Java Script where you

196
00:09:05,030 --> 00:09:08,390
use coercion that are written as bitwise

197
00:09:08,390 --> 00:09:12,200
operators like that single bar 0 where

198
00:09:12,200 --> 00:09:15,020
pointer is stored back as an integer

199
00:09:15,020 --> 00:09:17,120
because it's been bored with 0 it

200
00:09:17,120 --> 00:09:18,770
doesn't change its value assuming it

201
00:09:18,770 --> 00:09:20,360
wasn't in it you're just just make sure

202
00:09:20,360 --> 00:09:21,860
that it is knitted your and since that

203
00:09:21,860 --> 00:09:23,630
assignment dominates the rest of the use

204
00:09:23,630 --> 00:09:24,890
of the pointer you can be sure it's an

205
00:09:24,890 --> 00:09:26,780
integer and if pointers recomputed it

206
00:09:26,780 --> 00:09:29,840
gets gets really reordered with 0 and

207
00:09:29,840 --> 00:09:31,190
you can do similar things for unsigned

208
00:09:31,190 --> 00:09:32,690
with triple right shift it's a good

209
00:09:32,690 --> 00:09:34,190
thing I added those operators to

210
00:09:34,190 --> 00:09:37,160
javascript in 1995 it was something I

211
00:09:37,160 --> 00:09:38,890
wanted to do as a low-level see hacker

212
00:09:38,890 --> 00:09:41,390
it was in Java it didn't make sense to

213
00:09:41,390 --> 00:09:42,650
leave them out even though their

214
00:09:42,650 --> 00:09:44,030
precedence is kind of wrong there's a

215
00:09:44,030 --> 00:09:45,710
nice history of that from dennis ritchie

216
00:09:45,710 --> 00:09:48,860
about why that happened but turns out

217
00:09:48,860 --> 00:09:50,390
they're pretty important for Asmodeus

218
00:09:50,390 --> 00:09:52,130
and other sorts of things people then

219
00:09:52,130 --> 00:09:54,350
hand coding bitwise operators for

220
00:09:54,350 --> 00:09:56,240
various special purposes in JavaScript

221
00:09:56,240 --> 00:09:59,050
and now it's critically important and

222
00:09:59,050 --> 00:10:00,890
this is something you also see in

223
00:10:00,890 --> 00:10:03,790
mandrel another script and I compiler

224
00:10:03,790 --> 00:10:05,990
what we do with asthma just as we make

225
00:10:05,990 --> 00:10:09,020
sure we know that there's always a sound

226
00:10:09,020 --> 00:10:10,910
type at every join point in the control

227
00:10:10,910 --> 00:10:12,770
flow graph we know what the types of

228
00:10:12,770 --> 00:10:14,480
things are and if we if we have to take

229
00:10:14,480 --> 00:10:17,210
a coercion step we will put it in the

230
00:10:17,210 --> 00:10:22,280
generated code and we can analyze not

231
00:10:22,280 --> 00:10:24,530
only four types we can also make sure

232
00:10:24,530 --> 00:10:25,300
all the memory and the

233
00:10:25,300 --> 00:10:27,670
eep is understood so that we don't have

234
00:10:27,670 --> 00:10:29,290
any garbage collection pauses that would

235
00:10:29,290 --> 00:10:34,180
really hurt your gameplay so let me talk

236
00:10:34,180 --> 00:10:35,589
a little bit more since this is jae's

237
00:10:35,589 --> 00:10:37,269
comp about oh yeah this is I want to

238
00:10:37,269 --> 00:10:38,410
talk about this other stuff I'll get to

239
00:10:38,410 --> 00:10:42,310
it s MJS has a very simple structure and

240
00:10:42,310 --> 00:10:44,860
it has this hint use Azamat currently

241
00:10:44,860 --> 00:10:46,149
doesn't mean anything if you if you

242
00:10:46,149 --> 00:10:47,350
ignore it you still can run pretty fast

243
00:10:47,350 --> 00:10:49,540
in for instance v8 and they did some

244
00:10:49,540 --> 00:10:50,920
work to make it even faster just before

245
00:10:50,920 --> 00:10:53,500
Google i/o but if you actually do take

246
00:10:53,500 --> 00:10:55,690
that hint you can do what we call ahead

247
00:10:55,690 --> 00:10:57,610
of time compilation it's not like you're

248
00:10:57,610 --> 00:11:00,490
running the compiler before you even go

249
00:11:00,490 --> 00:11:02,500
load your code it's happening though all

250
00:11:02,500 --> 00:11:03,880
at once and you can analyze everything

251
00:11:03,880 --> 00:11:06,910
you can see the entire module which is

252
00:11:06,910 --> 00:11:08,529
what's going on here you can see a type

253
00:11:08,529 --> 00:11:10,510
system this is where dave herman

254
00:11:10,510 --> 00:11:11,980
invented some funny names like double

255
00:11:11,980 --> 00:11:14,350
ish and in tisch I don't know if elvish

256
00:11:14,350 --> 00:11:18,490
makes sense dwarven oarfish dwarvish

257
00:11:18,490 --> 00:11:20,350
that's right Toki and said dwarvish with

258
00:11:20,350 --> 00:11:23,110
a V troll ish we should have trolls and

259
00:11:23,110 --> 00:11:25,959
and what this is doing is it's saying

260
00:11:25,959 --> 00:11:28,269
with JavaScript bitwise operators we can

261
00:11:28,269 --> 00:11:30,640
have in types we can have in types that

262
00:11:30,640 --> 00:11:32,860
might have to be coerced back to enter

263
00:11:32,860 --> 00:11:34,930
they cross a boundary so we're modeling

264
00:11:34,930 --> 00:11:38,380
that formalizing this and one more thing

265
00:11:38,380 --> 00:11:40,810
I want to show here this is the MJS spec

266
00:11:40,810 --> 00:11:45,970
it's on sm j org um is how this works

267
00:11:45,970 --> 00:11:47,920
for operators when you when you look at

268
00:11:47,920 --> 00:11:51,820
how JavaScript works it has all the math

269
00:11:51,820 --> 00:11:53,440
operators but currently they operate as

270
00:11:53,440 --> 00:11:54,430
if things were double-precision

271
00:11:54,430 --> 00:11:55,930
floating-point which isn't the best

272
00:11:55,930 --> 00:11:57,790
number type for going fast you want to

273
00:11:57,790 --> 00:12:00,100
stay in your CPU and your ALU you want

274
00:12:00,100 --> 00:12:03,520
to integer operations so these these

275
00:12:03,520 --> 00:12:06,790
types help us do that in some cases it's

276
00:12:06,790 --> 00:12:08,380
hard to make sure you stay there when

277
00:12:08,380 --> 00:12:10,660
you for instance do a multiply 32-bit x

278
00:12:10,660 --> 00:12:12,550
32 bit might give you 64 bits they might

279
00:12:12,550 --> 00:12:14,800
have to go to a double we actually have

280
00:12:14,800 --> 00:12:16,959
something in es6 it's already in called

281
00:12:16,959 --> 00:12:18,970
math I'm all which is an integer

282
00:12:18,970 --> 00:12:21,190
multiply so that helps that's an example

283
00:12:21,190 --> 00:12:23,290
of extending language really easy

284
00:12:23,290 --> 00:12:26,320
extension to to make smgs still be a

285
00:12:26,320 --> 00:12:28,540
subset make things go faster and we also

286
00:12:28,540 --> 00:12:30,699
have the math library of course and we

287
00:12:30,699 --> 00:12:33,240
have these nice WebGL typed arrays so

288
00:12:33,240 --> 00:12:37,540
get back to my prezzo that's how I some

289
00:12:37,540 --> 00:12:38,690
Jeff's works how fast is

290
00:12:38,690 --> 00:12:39,950
well this is pretty these are fresh

291
00:12:39,950 --> 00:12:42,980
results I think blue is Firefox red is

292
00:12:42,980 --> 00:12:47,330
chrome canary with the latest v8 and it

293
00:12:47,330 --> 00:12:50,480
has pretty good performance for the

294
00:12:50,480 --> 00:12:52,790
micro benchmarks the first nine in fact

295
00:12:52,790 --> 00:12:54,920
if you look at this chart one along the

296
00:12:54,920 --> 00:12:57,320
bottom means same speed is native the

297
00:12:57,320 --> 00:12:59,600
life I think it's Conway's life

298
00:12:59,600 --> 00:13:01,400
benchmark supposedly runs faster than

299
00:13:01,400 --> 00:13:02,960
native and be eight in Firefox that's

300
00:13:02,960 --> 00:13:05,900
actually a clang bug GCC beats them both

301
00:13:05,900 --> 00:13:07,550
as you expect you we're not going to

302
00:13:07,550 --> 00:13:10,670
really beat native speed unless there's

303
00:13:10,670 --> 00:13:11,630
something wrong with a native code

304
00:13:11,630 --> 00:13:14,930
compiler but these micro benchmarks are

305
00:13:14,930 --> 00:13:16,460
somewhat trivial if you look at the

306
00:13:16,460 --> 00:13:18,350
bottom six those are macro benchmarks

307
00:13:18,350 --> 00:13:19,760
those are real significant programs they

308
00:13:19,760 --> 00:13:21,620
have those scaling problems I mentioned

309
00:13:21,620 --> 00:13:25,400
one run in a non as MJ s optimized

310
00:13:25,400 --> 00:13:27,230
engine and you see this with with chrome

311
00:13:27,230 --> 00:13:29,120
now the v8 guys want to keep pushing and

312
00:13:29,120 --> 00:13:30,710
see how fast they can get without having

313
00:13:30,710 --> 00:13:32,090
to do the kind of asthma guess

314
00:13:32,090 --> 00:13:34,640
verification that we do and I hope they

315
00:13:34,640 --> 00:13:37,640
succeed I am NOT concerned about which

316
00:13:37,640 --> 00:13:39,830
way wins everybody wins if we get to the

317
00:13:39,830 --> 00:13:41,810
same speed but right now because we do

318
00:13:41,810 --> 00:13:44,330
this ahead of time verified all at once

319
00:13:44,330 --> 00:13:48,370
compile step we actually are unboxed 2d

320
00:13:48,370 --> 00:13:50,900
one point three three times slower than

321
00:13:50,900 --> 00:13:54,110
native code which is it's going to get

322
00:13:54,110 --> 00:13:56,300
only faster as we keep going we have

323
00:13:56,300 --> 00:13:58,220
more optimizations ahead of us so we're

324
00:13:58,220 --> 00:13:59,360
getting to the point where you don't

325
00:13:59,360 --> 00:14:00,800
care about the slow down from native

326
00:14:00,800 --> 00:14:04,370
code on modern hardware and even on the

327
00:14:04,370 --> 00:14:06,500
average hardware on the web the reach of

328
00:14:06,500 --> 00:14:08,900
the web the lack of a plug-in or a scary

329
00:14:08,900 --> 00:14:10,610
install dialogue or a need to switch

330
00:14:10,610 --> 00:14:12,170
browsers makes this a winning

331
00:14:12,170 --> 00:14:14,210
proposition for game developers like

332
00:14:14,210 --> 00:14:16,460
epic games we worked with them just in

333
00:14:16,460 --> 00:14:18,230
four days we brought up Unreal Engine 3

334
00:14:18,230 --> 00:14:20,480
that was amazing to them because because

335
00:14:20,480 --> 00:14:21,860
of the power of him script in because we

336
00:14:21,860 --> 00:14:24,530
had asthma j/s Odin monkey optimizing

337
00:14:24,530 --> 00:14:26,360
backend and spider monkey at the end of

338
00:14:26,360 --> 00:14:28,250
a week in Raleigh North Carolina we had

339
00:14:28,250 --> 00:14:31,630
unreal working and they were blown away

340
00:14:31,630 --> 00:14:35,330
so that's where we are right now and

341
00:14:35,330 --> 00:14:37,400
we're pushing that down toward one point

342
00:14:37,400 --> 00:14:39,530
pocket change X slower than native and

343
00:14:39,530 --> 00:14:41,980
that's I think going to change the world

344
00:14:41,980 --> 00:14:45,650
it isn't really for hand coding people

345
00:14:45,650 --> 00:14:46,760
are doing it there's a guy on github

346
00:14:46,760 --> 00:14:49,820
who's doing an awesome job but generally

347
00:14:49,820 --> 00:14:51,800
you don't want to do it the tooling

348
00:14:51,800 --> 00:14:52,550
isn't there you

349
00:14:52,550 --> 00:14:53,839
verification areas if you make the

350
00:14:53,839 --> 00:14:55,279
slightest mistake if the types don't

351
00:14:55,279 --> 00:14:58,610
agree at all the joint points if there's

352
00:14:58,610 --> 00:14:59,990
an inscription bug you might get that

353
00:14:59,990 --> 00:15:02,540
we're still early so we had some friends

354
00:15:02,540 --> 00:15:05,750
at Intel working with it and they said

355
00:15:05,750 --> 00:15:07,790
hey it's only 12 times you know sort of

356
00:15:07,790 --> 00:15:09,560
the native it's not too or 1.3 times

357
00:15:09,560 --> 00:15:11,779
slower what's going on I won't I said

358
00:15:11,779 --> 00:15:12,829
look in your console and sure enough

359
00:15:12,829 --> 00:15:14,810
they're having verification errors and

360
00:15:14,810 --> 00:15:16,490
alone I fixed the inscription bug right

361
00:15:16,490 --> 00:15:18,410
away so we're bringing it up and you

362
00:15:18,410 --> 00:15:19,459
don't want to hand code it too much

363
00:15:19,459 --> 00:15:21,920
Never Say Never people talk about

364
00:15:21,920 --> 00:15:23,810
writing assembly windows in JavaScript

365
00:15:23,810 --> 00:15:25,010
the problem is right now the boundary

366
00:15:25,010 --> 00:15:26,810
crossing is a little expensive because

367
00:15:26,810 --> 00:15:28,820
we're doing this this verification

368
00:15:28,820 --> 00:15:30,410
because we have to make sure the types

369
00:15:30,410 --> 00:15:33,260
going in satisfy the constraints inside

370
00:15:33,260 --> 00:15:35,990
the atom blob where they can't change so

371
00:15:35,990 --> 00:15:37,970
there's some overhead that makes it not

372
00:15:37,970 --> 00:15:40,459
yet desirable to write as in Windows but

373
00:15:40,459 --> 00:15:43,670
it could happen so this is part of my

374
00:15:43,670 --> 00:15:46,730
top where I see an evolutionary process

375
00:15:46,730 --> 00:15:49,010
that is running native code on the web

376
00:15:49,010 --> 00:15:51,890
at new native speed but safely with no

377
00:15:51,890 --> 00:15:54,290
extra plugins no memory safety your loss

378
00:15:54,290 --> 00:15:58,220
or any other concern like that that's

379
00:15:58,220 --> 00:16:01,100
big but people say what about my needs

380
00:16:01,100 --> 00:16:04,250
what about blub and you know it's a good

381
00:16:04,250 --> 00:16:06,589
question javascript isn't for everyone I

382
00:16:06,589 --> 00:16:09,440
think I was retweeted saying is by far

383
00:16:09,440 --> 00:16:12,770
not the best language for every task

384
00:16:12,770 --> 00:16:16,070
let's say I know it's gotten better and

385
00:16:16,070 --> 00:16:17,779
people like it and that's good and I'm

386
00:16:17,779 --> 00:16:18,920
working on it because it's not going to

387
00:16:18,920 --> 00:16:20,570
go away so i think it's it's or

388
00:16:20,570 --> 00:16:23,750
obligated to work on it but there are

389
00:16:23,750 --> 00:16:25,459
other languages that people are more

390
00:16:25,459 --> 00:16:26,720
productive in why shouldn't they use

391
00:16:26,720 --> 00:16:30,050
them so you know trans compilers if

392
00:16:30,050 --> 00:16:31,760
you're at the same semantic level not a

393
00:16:31,760 --> 00:16:33,800
big deal source maps tirar here i think

394
00:16:33,800 --> 00:16:37,339
in firefox and chrome thanks for getting

395
00:16:37,339 --> 00:16:38,899
to the point where you may be able to

396
00:16:38,899 --> 00:16:43,779
just use languages like Python Ruby Lua

397
00:16:43,779 --> 00:16:46,490
now if there's a real semantics Gavin

398
00:16:46,490 --> 00:16:47,750
this I think this happened with dart but

399
00:16:47,750 --> 00:16:51,110
I'm afraid they took out big number

400
00:16:51,110 --> 00:16:53,269
Terry position integer we could have

401
00:16:53,269 --> 00:16:54,560
added that the JavaScript it's still on

402
00:16:54,560 --> 00:16:57,260
the agenda it might happen in es7 but

403
00:16:57,260 --> 00:17:00,410
because it wasn't efficient in dart to

404
00:17:00,410 --> 00:17:01,820
jas or wasn't even implemented I think

405
00:17:01,820 --> 00:17:03,920
it was just double which isn't

406
00:17:03,920 --> 00:17:05,780
semantically the same not the same as

407
00:17:05,780 --> 00:17:06,410
dart VM

408
00:17:06,410 --> 00:17:08,300
get out I feel that that's that's a

409
00:17:08,300 --> 00:17:09,860
mistake i think if you need something

410
00:17:09,860 --> 00:17:11,720
like big numbs if there's a good reason

411
00:17:11,720 --> 00:17:14,300
for it in your language in your audience

412
00:17:14,300 --> 00:17:15,890
then maybe we should add at the

413
00:17:15,890 --> 00:17:17,510
javascript big numbers are something i

414
00:17:17,510 --> 00:17:19,610
wish i'd added 95 it would have settled

415
00:17:19,610 --> 00:17:21,410
a lot of arguments early but there

416
00:17:21,410 --> 00:17:25,790
wasn't time so you know how good can we

417
00:17:25,790 --> 00:17:30,050
get with just trans compilers not clear

418
00:17:30,050 --> 00:17:32,120
but as we fill these gaps we can do a

419
00:17:32,120 --> 00:17:34,070
lot with languages that are near the

420
00:17:34,070 --> 00:17:35,930
level of JavaScript now some languages

421
00:17:35,930 --> 00:17:38,360
want GC and if they're running a GC in

422
00:17:38,360 --> 00:17:42,080
this big typed array heap and we can

423
00:17:42,080 --> 00:17:44,600
actually connect that heap to the Dom or

424
00:17:44,600 --> 00:17:46,160
JavaScript objects which is on the road

425
00:17:46,160 --> 00:17:48,350
map now we have a problem of two garbage

426
00:17:48,350 --> 00:17:50,720
collectors fighting so you don't want

427
00:17:50,720 --> 00:17:53,960
multiple GCS you want to have one GC

428
00:17:53,960 --> 00:17:56,540
rule them all like in net like the

429
00:17:56,540 --> 00:17:57,890
modern JVM which supports multiple

430
00:17:57,890 --> 00:18:01,010
languages but has one GC so you want the

431
00:18:01,010 --> 00:18:03,320
JavaScript GC to have hooks safe hooks

432
00:18:03,320 --> 00:18:05,450
that the Assam Jas generated code can

433
00:18:05,450 --> 00:18:09,110
use in the guest heap which is that

434
00:18:09,110 --> 00:18:11,090
typed array and that's on the road map I

435
00:18:11,090 --> 00:18:12,950
wanted to just acknowledge this as an

436
00:18:12,950 --> 00:18:15,800
open issue you're working on alones akai

437
00:18:15,800 --> 00:18:19,520
has got Lou a vm this is not luigia to

438
00:18:19,520 --> 00:18:20,990
this is not the super awesome you know

439
00:18:20,990 --> 00:18:23,360
assembly coded lua but this is

440
00:18:23,360 --> 00:18:25,670
still pretty fast micro benchmarks legit

441
00:18:25,670 --> 00:18:27,200
two beats it but on Unreal Lua

442
00:18:27,200 --> 00:18:29,000
benchmarks which they're surprisingly a

443
00:18:29,000 --> 00:18:31,340
few in the web this is this is not a bad

444
00:18:31,340 --> 00:18:34,220
BM it's faster than Python and Ruby C

445
00:18:34,220 --> 00:18:38,300
Python this is M script ined and it

446
00:18:38,300 --> 00:18:41,420
works pretty well and it I'm going to

447
00:18:41,420 --> 00:18:44,000
run it here and see how it works it it's

448
00:18:44,000 --> 00:18:47,210
just a big c vm nice efficiently written

449
00:18:47,210 --> 00:18:51,890
portable interpreter vm and it has a

450
00:18:51,890 --> 00:18:53,840
garbage collector that garbage collector

451
00:18:53,840 --> 00:18:56,660
is not yet married to the javascript

452
00:18:56,660 --> 00:18:59,420
garbage collector so there there is a

453
00:18:59,420 --> 00:19:04,520
with leaks right the way this is running

454
00:19:04,520 --> 00:19:05,720
right now it's just going to allocate

455
00:19:05,720 --> 00:19:07,550
memory and not collect having it run its

456
00:19:07,550 --> 00:19:08,840
own collector as possible and then it

457
00:19:08,840 --> 00:19:11,120
can scavenge space again if you ever

458
00:19:11,120 --> 00:19:13,130
connect things between the the guests

459
00:19:13,130 --> 00:19:14,600
and the host heaps you'd have problems

460
00:19:14,600 --> 00:19:17,000
until we we do this lifting of the host

461
00:19:17,000 --> 00:19:19,070
you see into the guest heap which is

462
00:19:19,070 --> 00:19:19,820
possible

463
00:19:19,820 --> 00:19:24,500
is going to finish soon so if it is not

464
00:19:24,500 --> 00:19:27,820
going to go play some more games and

465
00:19:27,820 --> 00:19:30,470
another open issue is jits so I

466
00:19:30,470 --> 00:19:32,540
mentioned blueridge it too if you want

467
00:19:32,540 --> 00:19:35,720
to take a say a C code base that has

468
00:19:35,720 --> 00:19:39,020
some some assembly code generations

469
00:19:39,020 --> 00:19:40,880
machine code generation into right a

470
00:19:40,880 --> 00:19:43,010
bullet skewed old memory and script and

471
00:19:43,010 --> 00:19:44,210
is not going to solve that for you and

472
00:19:44,210 --> 00:19:46,520
it's formally unsafe so we'd have to do

473
00:19:46,520 --> 00:19:48,050
something like what the novel guys have

474
00:19:48,050 --> 00:19:49,820
been working on I'm not sure that is I

475
00:19:49,820 --> 00:19:51,620
saw activity the other year about it but

476
00:19:51,620 --> 00:19:53,720
doesn't seem like it's it's a big thing

477
00:19:53,720 --> 00:19:55,310
I think it's happening in the mono world

478
00:19:55,310 --> 00:19:57,560
to you can do it you have to be able to

479
00:19:57,560 --> 00:19:59,180
generate verified Adam code you have to

480
00:19:59,180 --> 00:20:00,650
be able to invalidate it when the JIT

481
00:20:00,650 --> 00:20:04,040
miss speculates so whether this pays off

482
00:20:04,040 --> 00:20:05,690
or not in the long run is an open issue

483
00:20:05,690 --> 00:20:07,940
but if it's important we can do it it's

484
00:20:07,940 --> 00:20:10,940
just more work it's on the road map and

485
00:20:10,940 --> 00:20:12,950
then thread this is actually significant

486
00:20:12,950 --> 00:20:15,110
if you talk about native code C C++

487
00:20:15,110 --> 00:20:17,000
people say where's pthreads I have to be

488
00:20:17,000 --> 00:20:18,530
able to write you know multi-core code

489
00:20:18,530 --> 00:20:21,830
there right javascript has always had a

490
00:20:21,830 --> 00:20:25,640
race free memory safe model of execution

491
00:20:25,640 --> 00:20:28,160
which doesn't allow you to observe

492
00:20:28,160 --> 00:20:32,660
shared mutable state you can see it only

493
00:20:32,660 --> 00:20:35,690
at event loop turns so there is this you

494
00:20:35,690 --> 00:20:38,300
know coarse-grained shared mutation and

495
00:20:38,300 --> 00:20:40,160
that that's enough that causes people

496
00:20:40,160 --> 00:20:41,690
enough headaches if you actually had

497
00:20:41,690 --> 00:20:44,390
fine grain you know races to update

498
00:20:44,390 --> 00:20:46,250
memory if you had people doing busy

499
00:20:46,250 --> 00:20:49,400
waiting on memory in JavaScript you'd

500
00:20:49,400 --> 00:20:51,320
have problems that we don't really want

501
00:20:51,320 --> 00:20:53,120
in the language you'd have to make your

502
00:20:53,120 --> 00:20:55,190
VMs multi-threaded nobody's done that

503
00:20:55,190 --> 00:20:57,740
Java VM in the 90 started out that way

504
00:20:57,740 --> 00:20:59,330
and was incredibly expensive they had

505
00:20:59,330 --> 00:21:01,100
research David bacon did at IBM research

506
00:21:01,100 --> 00:21:03,500
to optimize using atomic instructions

507
00:21:03,500 --> 00:21:05,270
and then so they realized well we can't

508
00:21:05,270 --> 00:21:06,800
really afford this overhead anyway so

509
00:21:06,800 --> 00:21:08,270
they ended up adding like

510
00:21:08,270 --> 00:21:09,830
single-threaded versions of all the data

511
00:21:09,830 --> 00:21:11,870
structures but if you look at v8 spider

512
00:21:11,870 --> 00:21:13,460
monkey just report all these engines are

513
00:21:13,460 --> 00:21:15,770
single threaded in their implementations

514
00:21:15,770 --> 00:21:18,140
and that's important so we must not

515
00:21:18,140 --> 00:21:20,480
pollute the JavaScript semantics either

516
00:21:20,480 --> 00:21:23,030
at the language level from pan coders or

517
00:21:23,030 --> 00:21:26,090
in the VMS with data races on the other

518
00:21:26,090 --> 00:21:28,850
hand smgs is a target language for see

519
00:21:28,850 --> 00:21:32,870
if it's all as encode see semantics are

520
00:21:32,870 --> 00:21:33,470
good enough

521
00:21:33,470 --> 00:21:34,730
right there are games that are going to

522
00:21:34,730 --> 00:21:35,929
do busy waiting their games they're

523
00:21:35,929 --> 00:21:38,720
going to do shared you know mutexes and

524
00:21:38,720 --> 00:21:40,490
condition variables and atomic

525
00:21:40,490 --> 00:21:43,700
instructions so if we can verify and

526
00:21:43,700 --> 00:21:45,169
this might require that use azum

527
00:21:45,169 --> 00:21:46,700
directed to mean something we can verify

528
00:21:46,700 --> 00:21:50,860
that these workers that are racing over

529
00:21:50,860 --> 00:21:53,480
data shared memory running on different

530
00:21:53,480 --> 00:21:54,950
cores giving you that great parallel

531
00:21:54,950 --> 00:21:56,900
speed up are all as them all the time

532
00:21:56,900 --> 00:21:58,730
then i think we can do it so that's

533
00:21:58,730 --> 00:22:00,049
that's what we're trying to do we're

534
00:22:00,049 --> 00:22:01,730
trying to keep data races in the bottle

535
00:22:01,730 --> 00:22:04,250
of the Asmodeus only workers and i think

536
00:22:04,250 --> 00:22:05,690
that's a fair extension to do and i

537
00:22:05,690 --> 00:22:07,220
think it's going to happen it is not

538
00:22:07,220 --> 00:22:09,380
something we have get persuaded others

539
00:22:09,380 --> 00:22:12,530
in the standards bodies to believe in

540
00:22:12,530 --> 00:22:14,690
but it seems like a shorter evolutionary

541
00:22:14,690 --> 00:22:16,070
step than anything else you can think of

542
00:22:16,070 --> 00:22:18,110
like adding general threads to

543
00:22:18,110 --> 00:22:19,760
javascript is just not going to happen I

544
00:22:19,760 --> 00:22:23,809
guarantee it and then we'll make sure we

545
00:22:23,809 --> 00:22:26,150
don't let these data races leak out so

546
00:22:26,150 --> 00:22:28,880
this leads me to what informed the

547
00:22:28,880 --> 00:22:31,610
abstract my talk which is I had this

548
00:22:31,610 --> 00:22:33,740
sort of depressing feeling when i wrote

549
00:22:33,740 --> 00:22:35,090
that abstract that we were going to have

550
00:22:35,090 --> 00:22:37,370
a race like the one between John Henry

551
00:22:37,370 --> 00:22:39,429
and the steam-powered hammer that

552
00:22:39,429 --> 00:22:42,230
JavaScript hand coders heroic people who

553
00:22:42,230 --> 00:22:45,260
really helped co-evolved the language in

554
00:22:45,260 --> 00:22:47,659
the libraries who've made all this great

555
00:22:47,659 --> 00:22:49,760
progress possible as much or more than

556
00:22:49,760 --> 00:22:52,789
the vm implementers in my opinion would

557
00:22:52,789 --> 00:22:54,260
be like John Henry they'd be like

558
00:22:54,260 --> 00:22:56,179
hammering away and this this this

559
00:22:56,179 --> 00:22:58,880
compiler this set of VMs or automations

560
00:22:58,880 --> 00:23:01,010
for compiling programming languages

561
00:23:01,010 --> 00:23:03,860
would be hammering away and John Henry

562
00:23:03,860 --> 00:23:06,049
the human coder would would win but then

563
00:23:06,049 --> 00:23:07,280
his heart would give out and that would

564
00:23:07,280 --> 00:23:09,580
be it and then we be in this this modern

565
00:23:09,580 --> 00:23:12,980
postmodern or maybe matrix e dystopia of

566
00:23:12,980 --> 00:23:15,500
compilers I still worry about this you

567
00:23:15,500 --> 00:23:18,650
hear about things like opencl as a sort

568
00:23:18,650 --> 00:23:21,220
of bastard language derived from c99

569
00:23:21,220 --> 00:23:23,659
being pushed this web CL and it's

570
00:23:23,659 --> 00:23:25,700
supposed to let you program you know GPU

571
00:23:25,700 --> 00:23:27,909
sounds good it's got all this crazy

572
00:23:27,909 --> 00:23:31,100
storage class qualifiers you put on data

573
00:23:31,100 --> 00:23:33,620
to say whether it's in you know nearby

574
00:23:33,620 --> 00:23:35,150
or far away it's a global memory it's

575
00:23:35,150 --> 00:23:37,549
really slow programming the GPU is not

576
00:23:37,549 --> 00:23:40,250
easy and if we all wrote open Taylor

577
00:23:40,250 --> 00:23:41,600
Webb CL I think the world would be a

578
00:23:41,600 --> 00:23:43,100
worse place you know view source

579
00:23:43,100 --> 00:23:45,010
wouldn't mean as much there'd be

580
00:23:45,010 --> 00:23:48,450
co-chairing there be sort of more like a

581
00:23:48,450 --> 00:23:52,210
world of applets or Swift's or you know

582
00:23:52,210 --> 00:23:54,760
binaries from the Windows desktop era I

583
00:23:54,760 --> 00:23:57,130
don't think we can stop this but I

584
00:23:57,130 --> 00:23:59,350
actually got less depressed as I thought

585
00:23:59,350 --> 00:24:01,510
about more I think it's still an open

586
00:24:01,510 --> 00:24:04,530
race John Henry's heart hasn't given out

587
00:24:04,530 --> 00:24:09,880
you guys have to help John live I think

588
00:24:09,880 --> 00:24:12,310
it can be done and it isn't just that

589
00:24:12,310 --> 00:24:14,080
JavaScript has this incumbent advantage

590
00:24:14,080 --> 00:24:16,000
I that that's part of it and that's you

591
00:24:16,000 --> 00:24:17,410
know fair or unfair that's just the way

592
00:24:17,410 --> 00:24:19,090
it is Java scripts there in all browsers

593
00:24:19,090 --> 00:24:20,980
even if there are compilers generating

594
00:24:20,980 --> 00:24:23,710
azum code it'll always be good to load

595
00:24:23,710 --> 00:24:25,150
some javascript fast and go through the

596
00:24:25,150 --> 00:24:29,740
dynamic jits javascript and the web

597
00:24:29,740 --> 00:24:31,270
browser the whole client side of the web

598
00:24:31,270 --> 00:24:33,520
even though jess on the server it's not

599
00:24:33,520 --> 00:24:35,380
the same as native code you don't need

600
00:24:35,380 --> 00:24:37,000
to write everything as you did in the

601
00:24:37,000 --> 00:24:38,310
old days you don't need you know

602
00:24:38,310 --> 00:24:40,300
millions and millions of lines of code

603
00:24:40,300 --> 00:24:42,340
to do cool applications you have a

604
00:24:42,340 --> 00:24:45,130
network you have clouds you have GPU

605
00:24:45,130 --> 00:24:46,510
clouds as I talked about on my blog

606
00:24:46,510 --> 00:24:48,730
recently even if you're offline you're

607
00:24:48,730 --> 00:24:50,560
not going to take your whole server no

608
00:24:50,560 --> 00:24:52,600
sequel database into your local memory

609
00:24:52,600 --> 00:24:54,220
you might do something like that with

610
00:24:54,220 --> 00:24:56,080
navigation controller alex russell and

611
00:24:56,080 --> 00:24:57,520
others working on but it's going to be a

612
00:24:57,520 --> 00:24:59,140
subset it's going to run in javascript

613
00:24:59,140 --> 00:25:01,300
so there's still this sort of novelty

614
00:25:01,300 --> 00:25:02,770
and asymmetry with the web and with

615
00:25:02,770 --> 00:25:04,020
javascript that i think makes it

616
00:25:04,020 --> 00:25:06,520
something that will continue to endure

617
00:25:06,520 --> 00:25:08,620
even when there is compiled code for

618
00:25:08,620 --> 00:25:10,090
games though you have million line code

619
00:25:10,090 --> 00:25:11,890
bases they have to be written in c++

620
00:25:11,890 --> 00:25:13,240
because that's the language to go

621
00:25:13,240 --> 00:25:16,900
fastest metal on you know ps4 or xbox

622
00:25:16,900 --> 00:25:19,780
makes sense so I think we will have both

623
00:25:19,780 --> 00:25:23,200
compiled and JavaScript hand coded code

624
00:25:23,200 --> 00:25:25,780
for a long time to come and that makes

625
00:25:25,780 --> 00:25:28,330
me say you knew it was coming i'm going

626
00:25:28,330 --> 00:25:31,210
to say almost bet on something but you

627
00:25:31,210 --> 00:25:33,670
know people object we're in this

628
00:25:33,670 --> 00:25:35,350
evolutionary regime it wasn't all

629
00:25:35,350 --> 00:25:37,540
planned i didn't plan this right i had

630
00:25:37,540 --> 00:25:38,890
put in bitwise operators because i'm a

631
00:25:38,890 --> 00:25:39,970
see hacker i thought they might be

632
00:25:39,970 --> 00:25:41,380
useful i couldn't justify taking them

633
00:25:41,380 --> 00:25:44,170
out of the grammar and it just I knew

634
00:25:44,170 --> 00:25:45,220
the grammar by heart so I just

635
00:25:45,220 --> 00:25:47,380
implemented the whole thing and it

636
00:25:47,380 --> 00:25:51,640
turned out to be useful and so you know

637
00:25:51,640 --> 00:25:53,590
this Pelican don't make fun of it for

638
00:25:53,590 --> 00:25:56,380
looking like a urinal it it's a happy

639
00:25:56,380 --> 00:26:01,000
beautiful creature you know that this is

640
00:26:01,000 --> 00:26:02,800
this actually isn't isn't isn't the

641
00:26:02,800 --> 00:26:04,150
animal it just looks like a monkey but

642
00:26:04,150 --> 00:26:06,790
it's a sponge and I don't think this

643
00:26:06,790 --> 00:26:08,740
actually really fits the WTF evolution

644
00:26:08,740 --> 00:26:11,920
site the tumblr sites meme but it's

645
00:26:11,920 --> 00:26:14,170
funny but I'm going to close as I

646
00:26:14,170 --> 00:26:30,870
usually do always bet on Jas thanks

