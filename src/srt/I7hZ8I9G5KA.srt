1
00:00:10,130 --> 00:00:12,800

okay since we were so nice to wait for

2
00:00:12,800 --> 00:00:15,050
me I will actually do tell you how I met

3
00:00:15,050 --> 00:00:17,180
Brandon it was about seven and a half

4
00:00:17,180 --> 00:00:20,930
years ago or so and I wasn't like in

5
00:00:20,930 --> 00:00:22,550
academia as you heard of a PhD in

6
00:00:22,550 --> 00:00:26,480
computer science and my entire career

7
00:00:26,480 --> 00:00:28,220
was really going towards being a

8
00:00:28,220 --> 00:00:29,840
professor so I've worked all my life

9
00:00:29,840 --> 00:00:31,730
being a professor I'm in two different

10
00:00:31,730 --> 00:00:33,920
schools I got every degree available in

11
00:00:33,920 --> 00:00:35,720
my field and I was trying to write

12
00:00:35,720 --> 00:00:38,420
compilers and back then in the beginning

13
00:00:38,420 --> 00:00:40,730
I was writing Java compilers and then

14
00:00:40,730 --> 00:00:42,440
add the idea to write a JavaScript

15
00:00:42,440 --> 00:00:45,650
compiler and the entire academic field

16
00:00:45,650 --> 00:00:47,870
that I've worked for thought that it's a

17
00:00:47,870 --> 00:00:50,750
really dumb idea I submitted paper after

18
00:00:50,750 --> 00:00:52,760
paper showing how we can make JavaScript

19
00:00:52,760 --> 00:00:56,150
go really fast and everyone told me that

20
00:00:56,150 --> 00:00:57,770
I'm solving the wrong problem that

21
00:00:57,770 --> 00:00:59,600
problem was already solved someone

22
00:00:59,600 --> 00:01:02,600
invented java and typed languages all

23
00:01:02,600 --> 00:01:04,189
you had to do is use Java instead of

24
00:01:04,189 --> 00:01:05,840
JavaScript and then you wouldn't need

25
00:01:05,840 --> 00:01:08,420
compilers for JavaScript so I couldn't

26
00:01:08,420 --> 00:01:10,100
convince anyone in my own field in

27
00:01:10,100 --> 00:01:12,950
academia to do javascript compilation i

28
00:01:12,950 --> 00:01:15,049
ran into brandon this was all the time

29
00:01:15,049 --> 00:01:18,140
when chrome was about to come out and we

30
00:01:18,140 --> 00:01:19,700
knew that performance would kind of heat

31
00:01:19,700 --> 00:01:22,549
up in the web and brandon hired me to

32
00:01:22,549 --> 00:01:24,079
missoula to write a compiler for

33
00:01:24,079 --> 00:01:26,299
javascript and we together released one

34
00:01:26,299 --> 00:01:28,009
the the first commercially available

35
00:01:28,009 --> 00:01:30,380
JavaScript compiler a couple days before

36
00:01:30,380 --> 00:01:33,649
actually chrome came out so that's how

37
00:01:33,649 --> 00:01:36,079
my Brendan and it was meant to be a very

38
00:01:36,079 --> 00:01:38,240
short stay I was originally planned to

39
00:01:38,240 --> 00:01:40,100
come up for three months the estimated

40
00:01:40,100 --> 00:01:41,630
you can write a compiler for javascript

41
00:01:41,630 --> 00:01:43,789
in three months and somehow ended up

42
00:01:43,789 --> 00:01:46,340
never leaving all right but now let's

43
00:01:46,340 --> 00:01:49,780
talk about Java and JavaScript some more

44
00:01:49,780 --> 00:01:54,380
my talk today is going to explore why we

45
00:01:54,380 --> 00:01:57,200
are doing Java and JavaScript but also I

46
00:01:57,200 --> 00:01:58,670
one will be a little bit technical and

47
00:01:58,670 --> 00:02:00,229
show you a little bit of the details of

48
00:02:00,229 --> 00:02:02,719
Java and show you how you can implement

49
00:02:02,719 --> 00:02:04,700
Java in JavaScript and some in some

50
00:02:04,700 --> 00:02:07,780
interesting things emerge if you do that

51
00:02:07,780 --> 00:02:10,729
first of all let me explain why we would

52
00:02:10,729 --> 00:02:12,410
do this why would anyone in the year

53
00:02:12,410 --> 00:02:15,140
2014 try to write a Java VM for

54
00:02:15,140 --> 00:02:18,290
JavaScript Java v almost successfully

55
00:02:18,290 --> 00:02:20,540
removed from the web stack today it's

56
00:02:20,540 --> 00:02:21,950
very very rare that you're running

57
00:02:21,950 --> 00:02:23,640
across Java applets

58
00:02:23,640 --> 00:02:25,680
mostly banks I think that use it still

59
00:02:25,680 --> 00:02:31,170
for security and login mechanisms their

60
00:02:31,170 --> 00:02:33,420
reasons to you this year you might know

61
00:02:33,420 --> 00:02:37,110
that we started bringing smartphones to

62
00:02:37,110 --> 00:02:39,680
market about a year ago firefox OS and

63
00:02:39,680 --> 00:02:42,090
firefox OS is targeting parts of the

64
00:02:42,090 --> 00:02:44,970
world that have a lot of people who

65
00:02:44,970 --> 00:02:46,140
currently have a feature phone and

66
00:02:46,140 --> 00:02:47,640
they're looking to get their first

67
00:02:47,640 --> 00:02:50,160
smartphone so device we are seeing here

68
00:02:50,160 --> 00:02:51,750
it's actually a device we launched about

69
00:02:51,750 --> 00:02:54,030
two months ago in India the price with

70
00:02:54,030 --> 00:02:56,340
this device is around 30 US dollars so

71
00:02:56,340 --> 00:02:58,709
it's about the cost of like a lunch in

72
00:02:58,709 --> 00:03:00,000
San Francisco you can get a smartphone

73
00:03:00,000 --> 00:03:02,100
and this thing is completed powered by

74
00:03:02,100 --> 00:03:04,320
html5 so everything you can see in this

75
00:03:04,320 --> 00:03:05,880
phone everything that runs on the phone

76
00:03:05,880 --> 00:03:08,970
all the apps the UI itself everything is

77
00:03:08,970 --> 00:03:13,500
written by html5 in html5 one problem we

78
00:03:13,500 --> 00:03:16,070
run into is that it's over the top

79
00:03:16,070 --> 00:03:18,750
messaging apps like Watsa are very

80
00:03:18,750 --> 00:03:21,570
popular around the world and it differs

81
00:03:21,570 --> 00:03:23,730
a little bit where what is popular but

82
00:03:23,730 --> 00:03:25,590
you can see that the parts of the world

83
00:03:25,590 --> 00:03:27,810
very particularly focusing on is Firefox

84
00:03:27,810 --> 00:03:31,290
OS such as here in Latin but also I Asia

85
00:03:31,290 --> 00:03:33,510
in those parts of the world there's

86
00:03:33,510 --> 00:03:35,670
specific messaging apps that are really

87
00:03:35,670 --> 00:03:38,910
popular and it's very hard to convince a

88
00:03:38,910 --> 00:03:41,489
maker of this messaging app to make an

89
00:03:41,489 --> 00:03:43,680
appt for html5 in some of these cases

90
00:03:43,680 --> 00:03:45,870
because there's not a lot of devices out

91
00:03:45,870 --> 00:03:48,150
there where today you can only bring

92
00:03:48,150 --> 00:03:50,940
html5 content to so an Android you can

93
00:03:50,940 --> 00:03:53,190
run an html5 app but you can also run an

94
00:03:53,190 --> 00:03:55,290
Android app so these guys have all

95
00:03:55,290 --> 00:03:58,440
written android apps for us there's no

96
00:03:58,440 --> 00:04:00,480
Android in our stack there's no iOS

97
00:04:00,480 --> 00:04:03,090
there's only the web and html5 so we

98
00:04:03,090 --> 00:04:05,280
needed somehow away to get these apps to

99
00:04:05,280 --> 00:04:08,220
run in our platform in some cases we

100
00:04:08,220 --> 00:04:10,560
were able to convince them that html5 is

101
00:04:10,560 --> 00:04:11,760
the future and they should write an

102
00:04:11,760 --> 00:04:14,459
html5 app for the platform line for

103
00:04:14,459 --> 00:04:16,769
example did that but a couple other guys

104
00:04:16,769 --> 00:04:18,510
didn't do that and if you look at this

105
00:04:18,510 --> 00:04:20,340
graph this data is about a year old but

106
00:04:20,340 --> 00:04:22,520
it shows that in some parts of the world

107
00:04:22,520 --> 00:04:25,110
some of these messaging apps are very

108
00:04:25,110 --> 00:04:27,060
very popular and if you don't have them

109
00:04:27,060 --> 00:04:28,590
on your phone nobody's going to buy it

110
00:04:28,590 --> 00:04:31,200
look down here for example in many parts

111
00:04:31,200 --> 00:04:33,720
of Latin if you don't have what's up

112
00:04:33,720 --> 00:04:35,370
it's really difficult to explain to

113
00:04:35,370 --> 00:04:36,870
someone why they would want to buy your

114
00:04:36,870 --> 00:04:39,480
so we needed a way to have what's up on

115
00:04:39,480 --> 00:04:41,760
this device even if what's up was not

116
00:04:41,760 --> 00:04:44,250
willing to make an appt an html5 just

117
00:04:44,250 --> 00:04:46,650
yet because when we started last year we

118
00:04:46,650 --> 00:04:50,700
had we started with 0 users so there's

119
00:04:50,700 --> 00:04:53,220
basic two things you can do one you can

120
00:04:53,220 --> 00:04:55,830
go ahead and try to just write your own

121
00:04:55,830 --> 00:04:58,020
wats up implementation or line

122
00:04:58,020 --> 00:05:00,420
implementation we did that and some of

123
00:05:00,420 --> 00:05:02,070
those who can get in the marketplace but

124
00:05:02,070 --> 00:05:04,200
people often ask specifically for what's

125
00:05:04,200 --> 00:05:06,150
up so to go in a store and want to buy a

126
00:05:06,150 --> 00:05:09,480
phone this what's up or is lying or his

127
00:05:09,480 --> 00:05:13,020
y ver and in these cases people in the

128
00:05:13,020 --> 00:05:14,610
store would say well it doesn't have

129
00:05:14,610 --> 00:05:17,670
what's up but the moment you start a

130
00:05:17,670 --> 00:05:19,110
sentence with it doesn't have what's up

131
00:05:19,110 --> 00:05:21,120
the person basically media doesn't want

132
00:05:21,120 --> 00:05:22,980
to phone anymore so to solve this

133
00:05:22,980 --> 00:05:24,510
problem somehow we have to get what's up

134
00:05:24,510 --> 00:05:28,380
onto our phone without relying on them

135
00:05:28,380 --> 00:05:30,600
making a wats up version until the

136
00:05:30,600 --> 00:05:33,240
enough users that people right naturally

137
00:05:33,240 --> 00:05:35,490
software for html5 as well that's kind

138
00:05:35,490 --> 00:05:36,720
of the whole idea what Mozilla is all

139
00:05:36,720 --> 00:05:38,790
about right we want to try to make html5

140
00:05:38,790 --> 00:05:41,670
as successful mobile as it's today on a

141
00:05:41,670 --> 00:05:45,390
desktop it gets even a little bit worse

142
00:05:45,390 --> 00:05:48,240
because the main competition for Firefox

143
00:05:48,240 --> 00:05:50,490
OS phones are these things future phones

144
00:05:50,490 --> 00:05:53,760
so for the price range of the very

145
00:05:53,760 --> 00:05:56,010
entry-level Firefox OS devices that's

146
00:05:56,010 --> 00:05:57,720
kind of the competition you can get some

147
00:05:57,720 --> 00:06:00,360
like Nokia feature phone with a dart pad

148
00:06:00,360 --> 00:06:02,730
in the small screen these things

149
00:06:02,730 --> 00:06:04,680
actually many of these messaging apps

150
00:06:04,680 --> 00:06:06,540
are available so this makes the

151
00:06:06,540 --> 00:06:07,980
situation for us a little bit more

152
00:06:07,980 --> 00:06:10,740
tricky because on the thing we compete

153
00:06:10,740 --> 00:06:12,510
with which is so much worse and hardware

154
00:06:12,510 --> 00:06:14,280
and it doesn't have proper web

155
00:06:14,280 --> 00:06:15,450
experience doesn't have a touch screen

156
00:06:15,450 --> 00:06:18,420
but it has whatsapp so people go in a

157
00:06:18,420 --> 00:06:20,010
store and I'm on a thing with what's up

158
00:06:20,010 --> 00:06:22,260
and then they get this here and not the

159
00:06:22,260 --> 00:06:25,200
smartphone at the same time though this

160
00:06:25,200 --> 00:06:27,330
is actually also a nice solution because

161
00:06:27,330 --> 00:06:29,310
as I said these things run these

162
00:06:29,310 --> 00:06:31,140
messaging apps so the idea we were

163
00:06:31,140 --> 00:06:33,030
looking at how can we take these

164
00:06:33,030 --> 00:06:35,400
messaging apps that are designed for

165
00:06:35,400 --> 00:06:37,710
these feature phones and run them on

166
00:06:37,710 --> 00:06:42,120
Firefox OS these things of course run

167
00:06:42,120 --> 00:06:43,740
Java all right in case you didn't know

168
00:06:43,740 --> 00:06:45,990
that if you ever have to install Java

169
00:06:45,990 --> 00:06:47,370
and I hope nobody here is that

170
00:06:47,370 --> 00:06:49,590
unfortunate when you install that it

171
00:06:49,590 --> 00:06:50,610
tells you that this Oh

172
00:06:50,610 --> 00:06:52,919
three billion devices or three billion

173
00:06:52,919 --> 00:06:54,990
phones running java I'm not sure it's

174
00:06:54,990 --> 00:06:56,219
still true today but it's probably

175
00:06:56,219 --> 00:06:58,050
roughly the right ballpark there's

176
00:06:58,050 --> 00:06:59,460
literally billions of phones out there

177
00:06:59,460 --> 00:07:01,379
anything that's not a smartphone today

178
00:07:01,379 --> 00:07:04,469
tends to run Java inside of it and it

179
00:07:04,469 --> 00:07:05,939
runs a very specific version of Java

180
00:07:05,939 --> 00:07:10,229
that's called j2me and I will kind of

181
00:07:10,229 --> 00:07:12,240
explain where that fits in many of you

182
00:07:12,240 --> 00:07:14,159
have probably never seen this that's not

183
00:07:14,159 --> 00:07:15,599
a problem it's just this is all stuff

184
00:07:15,599 --> 00:07:17,280
this is like I pulled this we can see

185
00:07:17,280 --> 00:07:19,259
how bad the phones are this is like a 14

186
00:07:19,259 --> 00:07:21,539
year old picture so this is what some

187
00:07:21,539 --> 00:07:23,729
thought the world would look like in the

188
00:07:23,729 --> 00:07:26,819
future like 14 years ago so basically

189
00:07:26,819 --> 00:07:29,460
idea was that everything is Java all the

190
00:07:29,460 --> 00:07:31,860
way from Java cards this is this is sim

191
00:07:31,860 --> 00:07:33,539
cards new phone for example another on

192
00:07:33,539 --> 00:07:36,389
the way right side here and then there's

193
00:07:36,389 --> 00:07:38,759
this lightweight versions of Java this

194
00:07:38,759 --> 00:07:41,009
is a micro edition or limited device

195
00:07:41,009 --> 00:07:42,779
edition of Java and then here's the

196
00:07:42,779 --> 00:07:45,469
grown-up job on desktop a nun service of

197
00:07:45,469 --> 00:07:47,340
course today this totally looks

198
00:07:47,340 --> 00:07:49,110
different right so the only place where

199
00:07:49,110 --> 00:07:51,389
Java really survived is in sim cards

200
00:07:51,389 --> 00:07:53,460
that's still javo today and then on a

201
00:07:53,460 --> 00:07:55,289
very far end here in enterprise and

202
00:07:55,289 --> 00:07:56,969
servers there's still some Java in the

203
00:07:56,969 --> 00:07:58,800
middle of it is small is dead the

204
00:07:58,800 --> 00:08:00,210
particular piece we care about is this

205
00:08:00,210 --> 00:08:03,419
one here the limited configuration of

206
00:08:03,419 --> 00:08:05,479
Java that runs on these feature phones

207
00:08:05,479 --> 00:08:09,060
the vm that that was built for that is

208
00:08:09,060 --> 00:08:11,490
called kvm or the killer x 3m that meant

209
00:08:11,490 --> 00:08:12,750
to express that these things are

210
00:08:12,750 --> 00:08:14,310
designed to run this relatively little

211
00:08:14,310 --> 00:08:15,719
memory that you have available in his

212
00:08:15,719 --> 00:08:19,919
future phones so there's a couple

213
00:08:19,919 --> 00:08:22,199
different ways how we can go and

214
00:08:22,199 --> 00:08:26,699
implement a Java VM in our phone to

215
00:08:26,699 --> 00:08:28,050
explain that of this architecture

216
00:08:28,050 --> 00:08:30,659
diagram here or Firefox OS I have no

217
00:08:30,659 --> 00:08:32,039
idea what the Japanese characters mean

218
00:08:32,039 --> 00:08:34,050
in case you wonder I just found this and

219
00:08:34,050 --> 00:08:35,610
its really cool graphics I also don't

220
00:08:35,610 --> 00:08:38,190
have no idea what the ice cone means but

221
00:08:38,190 --> 00:08:39,719
it was really kind of funny and I like

222
00:08:39,719 --> 00:08:41,940
the picture so I decided to use this it

223
00:08:41,940 --> 00:08:43,409
does show the necessary things I have to

224
00:08:43,409 --> 00:08:44,850
show so just ignore the Japanese

225
00:08:44,850 --> 00:08:46,380
characters and ignore the ice cream cone

226
00:08:46,380 --> 00:08:49,410
for a moment so we have it at the bottom

227
00:08:49,410 --> 00:08:51,899
we have gonk which is our version of

228
00:08:51,899 --> 00:08:53,339
Linux and a couple other low-level

229
00:08:53,339 --> 00:08:55,410
things that are really boring and on top

230
00:08:55,410 --> 00:08:57,360
of that is gecko gecko is mozillas

231
00:08:57,360 --> 00:08:58,890
rendering engine that's the thing that

232
00:08:58,890 --> 00:09:00,690
displays the web and then on top of

233
00:09:00,690 --> 00:09:04,259
gecko des Gaia Gaia is this html5

234
00:09:04,259 --> 00:09:05,819
experience that we talked about so all

235
00:09:05,819 --> 00:09:07,529
the things that you see in Firefox OS

236
00:09:07,529 --> 00:09:09,989
are all implemented in html5 and that's

237
00:09:09,989 --> 00:09:13,410
what we call Gaia so the simplest way to

238
00:09:13,410 --> 00:09:14,850
implement this would be of course to

239
00:09:14,850 --> 00:09:17,729
take a Java VM symbolized here to the

240
00:09:17,729 --> 00:09:19,589
inventor of Java and you could just kind

241
00:09:19,589 --> 00:09:21,929
of like stick that on top of gong next

242
00:09:21,929 --> 00:09:23,669
to gecko and basically just kind of veg

243
00:09:23,669 --> 00:09:26,489
it into our phone home and then we could

244
00:09:26,489 --> 00:09:29,089
run messaging things on top of that of

245
00:09:29,089 --> 00:09:31,410
course this is bad at least for two

246
00:09:31,410 --> 00:09:35,669
reasons first of all Java has a really

247
00:09:35,669 --> 00:09:37,759
bad track record with security um

248
00:09:37,759 --> 00:09:40,410
they're still finding really fundamental

249
00:09:40,410 --> 00:09:42,749
bugs in Java and they often really bad

250
00:09:42,749 --> 00:09:44,399
because they affect all browsers at the

251
00:09:44,399 --> 00:09:46,769
same time so if you do this if you take

252
00:09:46,769 --> 00:09:48,959
a Java VM and kind of like stick it into

253
00:09:48,959 --> 00:09:51,689
our system since the Java VM would be

254
00:09:51,689 --> 00:09:53,910
sitting directly on top of Linux and the

255
00:09:53,910 --> 00:09:56,939
OS core we would basically create a

256
00:09:56,939 --> 00:09:59,939
second surface for vulnerabilities there

257
00:09:59,939 --> 00:10:01,229
could be like additional bugs in the

258
00:10:01,229 --> 00:10:03,299
Java VM and they would create additional

259
00:10:03,299 --> 00:10:06,239
room for the phone to be broken into so

260
00:10:06,239 --> 00:10:07,799
that's a really bad idea to kind of put

261
00:10:07,799 --> 00:10:09,660
it in addition to the rendering engine

262
00:10:09,660 --> 00:10:10,709
you basically have twice as much

263
00:10:10,709 --> 00:10:13,789
opportunity for something to go wrong

264
00:10:13,789 --> 00:10:16,739
and in the second reason of course is

265
00:10:16,739 --> 00:10:18,929
that it would be really bad karma to put

266
00:10:18,929 --> 00:10:20,879
another Java VM into the vet stack right

267
00:10:20,879 --> 00:10:22,499
so we got to the point where you don't

268
00:10:22,499 --> 00:10:25,289
want a neat job on a desktop and this

269
00:10:25,289 --> 00:10:26,549
feature phones over the next couple

270
00:10:26,549 --> 00:10:29,369
years going out of fashion java will

271
00:10:29,369 --> 00:10:32,069
also go out of fashion with it so at

272
00:10:32,069 --> 00:10:34,230
this point putting a Java VM into a

273
00:10:34,230 --> 00:10:36,209
web-based and standards-based an

274
00:10:36,209 --> 00:10:38,369
html5-based phone it seems like a really

275
00:10:38,369 --> 00:10:40,589
bad idea so we decided not to go that

276
00:10:40,589 --> 00:10:44,910
route so of course what that leaves us

277
00:10:44,910 --> 00:10:46,859
is this then is to take our little

278
00:10:46,859 --> 00:10:48,989
diagram here with a Japanese characters

279
00:10:48,989 --> 00:10:52,169
in the ice cream cone and simply take a

280
00:10:52,169 --> 00:10:55,259
Java VM and put it on top of the entire

281
00:10:55,259 --> 00:10:58,039
system so we simply avoid a nap in html5

282
00:10:58,039 --> 00:11:03,509
that implement the Java VM and that app

283
00:11:03,509 --> 00:11:05,789
knows how to download the messaging app

284
00:11:05,789 --> 00:11:08,039
itself and I can run this whole thing on

285
00:11:08,039 --> 00:11:11,819
an existing phone the really nice part

286
00:11:11,819 --> 00:11:14,220
of this is that at the time that we

287
00:11:14,220 --> 00:11:15,929
started this which was about four or

288
00:11:15,929 --> 00:11:17,759
five months ago we already had a large

289
00:11:17,759 --> 00:11:19,919
number of phones out in the field that

290
00:11:19,919 --> 00:11:21,689
all don't have the original version of

291
00:11:21,689 --> 00:11:24,329
some of these messaging apps if we do it

292
00:11:24,329 --> 00:11:26,220
this way since we're not using any

293
00:11:26,220 --> 00:11:28,859
privileged html5 capabilities you're not

294
00:11:28,859 --> 00:11:30,809
kind of trying to bypass the platform in

295
00:11:30,809 --> 00:11:33,869
any way we can actually make an appt an

296
00:11:33,869 --> 00:11:36,569
html5 web app like this and just put it

297
00:11:36,569 --> 00:11:38,069
in a marketplace where people can

298
00:11:38,069 --> 00:11:40,799
download it and it can use this let me

299
00:11:40,799 --> 00:11:42,749
sort having to buy a new phone so this

300
00:11:42,749 --> 00:11:44,189
is very nice because we address the

301
00:11:44,189 --> 00:11:48,839
existing on set of phones as well all

302
00:11:48,839 --> 00:11:50,909
right the the downside of it of course

303
00:11:50,909 --> 00:11:52,679
is now we have to write a Java VM in

304
00:11:52,679 --> 00:11:55,739
JavaScript that's very exciting as I

305
00:11:55,739 --> 00:11:58,529
said my background is in writing

306
00:11:58,529 --> 00:12:00,359
compilers that's what i did in academia

307
00:12:00,359 --> 00:12:05,159
before brennan kind of freed me from

308
00:12:05,159 --> 00:12:07,589
academia let's put this way and my

309
00:12:07,589 --> 00:12:09,029
entire background net revolves in Java

310
00:12:09,029 --> 00:12:10,919
compilers before i started to JavaScript

311
00:12:10,919 --> 00:12:12,509
compiler so this is one of the reasons

312
00:12:12,509 --> 00:12:14,519
that i found this project particular

313
00:12:14,519 --> 00:12:15,689
interesting because i have done both

314
00:12:15,689 --> 00:12:17,819
extensively i have written several java

315
00:12:17,819 --> 00:12:19,679
VMs and i have written several

316
00:12:19,679 --> 00:12:21,600
implementations of java spoken powders I

317
00:12:21,600 --> 00:12:24,689
never really try to write a Java VM on

318
00:12:24,689 --> 00:12:26,489
top of JavaScript so that seemed very

319
00:12:26,489 --> 00:12:31,289
appealing to me so for the next couple

320
00:12:31,289 --> 00:12:33,239
of slides I will dive a little bit into

321
00:12:33,239 --> 00:12:35,100
technical details and explain to you at

322
00:12:35,100 --> 00:12:36,869
the high level of how Java works and

323
00:12:36,869 --> 00:12:39,779
show you some of the problems that i ran

324
00:12:39,779 --> 00:12:42,539
into trying to build a Java VM that's

325
00:12:42,539 --> 00:12:44,909
really ready to run production level

326
00:12:44,909 --> 00:12:47,999
code on a device like this don't worry

327
00:12:47,999 --> 00:12:49,769
too much if you don't see on understand

328
00:12:49,769 --> 00:12:51,119
some of the details for example there

329
00:12:51,119 --> 00:12:53,249
will be no quiz after my talk on the

330
00:12:53,249 --> 00:12:55,079
details of this slide this is merely

331
00:12:55,079 --> 00:12:56,959
meant to kind of highlight some of the

332
00:12:56,959 --> 00:12:59,100
concepts need to understand so we can

333
00:12:59,100 --> 00:13:00,959
understand the next slide so in this

334
00:13:00,959 --> 00:13:02,579
slide here really the only thing you

335
00:13:02,579 --> 00:13:05,279
should memorize is that Java is built

336
00:13:05,279 --> 00:13:07,859
from class files every Java program that

337
00:13:07,859 --> 00:13:09,809
you get consists of a large number of

338
00:13:09,809 --> 00:13:12,350
class files and each class file

339
00:13:12,350 --> 00:13:15,389
represents one class and these things

340
00:13:15,389 --> 00:13:18,119
are stored in a binary format it's

341
00:13:18,119 --> 00:13:19,769
basically an array of bytes that

342
00:13:19,769 --> 00:13:21,480
contains information about the class

343
00:13:21,480 --> 00:13:24,689
itself it contains the fields and the

344
00:13:24,689 --> 00:13:26,730
methods of a class

345
00:13:26,730 --> 00:13:29,130
the actual code which is sort of the

346
00:13:29,130 --> 00:13:31,620
bytecode the bytecode you can think of

347
00:13:31,620 --> 00:13:34,199
as a sequence of bytes that explains

348
00:13:34,199 --> 00:13:36,720
what instruction the vm should take and

349
00:13:36,720 --> 00:13:39,180
the vm goes step-by-step through these

350
00:13:39,180 --> 00:13:42,180
by code instructions so really all you

351
00:13:42,180 --> 00:13:43,980
have to do to run a Java program is you

352
00:13:43,980 --> 00:13:46,139
have to find a way how you can parse

353
00:13:46,139 --> 00:13:48,630
these class files and then you write an

354
00:13:48,630 --> 00:13:51,029
interpreter for this language this java

355
00:13:51,029 --> 00:13:53,760
bytecode language and then you run that

356
00:13:53,760 --> 00:13:56,100
interpreter over the code that you find

357
00:13:56,100 --> 00:13:58,410
in these classes and once you have one

358
00:13:58,410 --> 00:14:01,320
class let's your starting class it will

359
00:14:01,320 --> 00:14:03,630
call methods it can call methods in the

360
00:14:03,630 --> 00:14:05,519
same class or it can call to other

361
00:14:05,519 --> 00:14:07,680
classes whenever it calls another class

362
00:14:07,680 --> 00:14:09,870
you have to go and find the class file

363
00:14:09,870 --> 00:14:12,180
for the other class so that's that's the

364
00:14:12,180 --> 00:14:15,660
other than in time magic behind Java now

365
00:14:15,660 --> 00:14:19,199
as I said javac on Java programs consist

366
00:14:19,199 --> 00:14:22,430
of a large number of this class files a

367
00:14:22,430 --> 00:14:24,720
popular messaging app like what's up or

368
00:14:24,720 --> 00:14:26,370
viber is often hundreds of different

369
00:14:26,370 --> 00:14:28,949
classes in addition to that you also

370
00:14:28,949 --> 00:14:30,899
have library classes which are often

371
00:14:30,899 --> 00:14:33,449
thousands of classes it would be of

372
00:14:33,449 --> 00:14:35,399
course kind of awkward to have to carry

373
00:14:35,399 --> 00:14:37,019
around a thousand files if you're

374
00:14:37,019 --> 00:14:39,000
installing a drama program so what they

375
00:14:39,000 --> 00:14:43,319
came up this is jar files a jar file is

376
00:14:43,319 --> 00:14:47,430
a java java like name for a zip file so

377
00:14:47,430 --> 00:14:49,350
it turns out jar fights really are like

378
00:14:49,350 --> 00:14:51,300
zip files they are exactly structured

379
00:14:51,300 --> 00:14:53,069
the same in there basically just a zip

380
00:14:53,069 --> 00:14:56,279
archive miss all the Java class files

381
00:14:56,279 --> 00:14:57,899
inside of that and if you want to

382
00:14:57,899 --> 00:14:59,730
distribute a Java app all you do is you

383
00:14:59,730 --> 00:15:01,620
give someone a jar file and then the vm

384
00:15:01,620 --> 00:15:03,959
can go and read all that stuff out of

385
00:15:03,959 --> 00:15:07,410
the jar file the first problem we run

386
00:15:07,410 --> 00:15:10,019
into is that as i explained what you

387
00:15:10,019 --> 00:15:11,610
want to do is we want to write an app

388
00:15:11,610 --> 00:15:14,130
that knows how to run a Java program and

389
00:15:14,130 --> 00:15:16,380
it will get that actual Java program

390
00:15:16,380 --> 00:15:18,449
from whoever is distributing the Java

391
00:15:18,449 --> 00:15:21,420
program not from us so the first step we

392
00:15:21,420 --> 00:15:23,819
have to make sure of is that this Java

393
00:15:23,819 --> 00:15:26,130
VM that we are writing can read this

394
00:15:26,130 --> 00:15:27,810
original jar files so we need to be able

395
00:15:27,810 --> 00:15:32,910
to parse zip files fortunately that's

396
00:15:32,910 --> 00:15:34,620
something I had to do before so we did

397
00:15:34,620 --> 00:15:36,899
PDF ojs a couple years ago to display

398
00:15:36,899 --> 00:15:40,050
PDF documents as html5 and there

399
00:15:40,050 --> 00:15:41,820
Oh as well the first problem we have to

400
00:15:41,820 --> 00:15:43,950
solve is that PDF documents are

401
00:15:43,950 --> 00:15:46,470
basically zip files as well so you can

402
00:15:46,470 --> 00:15:47,790
if you can see a mean here like

403
00:15:47,790 --> 00:15:49,320
everything out there is a fob basically

404
00:15:49,320 --> 00:15:52,019
and we had actually implemented for PDF

405
00:15:52,019 --> 00:15:54,269
ojs a zip file reader lets up on github

406
00:15:54,269 --> 00:15:57,630
and I'd lying around there for like the

407
00:15:57,630 --> 00:15:59,220
last two years and we didn't touch it

408
00:15:59,220 --> 00:16:03,029
since then so I took zip file dodge is

409
00:16:03,029 --> 00:16:05,040
my word al-ilah parser for class file so

410
00:16:05,040 --> 00:16:08,010
kind of see how this goes and should

411
00:16:08,010 --> 00:16:09,480
work great right we have again parse

412
00:16:09,480 --> 00:16:11,279
class files now we can read the files

413
00:16:11,279 --> 00:16:15,720
and it totally didn't work at all that

414
00:16:15,720 --> 00:16:17,910
was somewhat unexpected so I spent a

415
00:16:17,910 --> 00:16:20,640
good afternoon trying to find out why

416
00:16:20,640 --> 00:16:22,380
the class files I was getting out of the

417
00:16:22,380 --> 00:16:27,180
jar files did not make any sense and it

418
00:16:27,180 --> 00:16:31,110
turns out that if you read the

419
00:16:31,110 --> 00:16:33,740
specification of zip files which I did

420
00:16:33,740 --> 00:16:37,410
it's a very painful process I hope you

421
00:16:37,410 --> 00:16:39,000
never have to do that it's really it

422
00:16:39,000 --> 00:16:43,730
sucks the specification says that any

423
00:16:43,730 --> 00:16:47,550
zeros at the end of a stream you don't

424
00:16:47,550 --> 00:16:49,649
have to store so if you're storing a

425
00:16:49,649 --> 00:16:51,450
compressed file and the last couple

426
00:16:51,450 --> 00:16:53,820
things in the file are zeros you can

427
00:16:53,820 --> 00:16:56,670
leave out those zeros the program that

428
00:16:56,670 --> 00:16:58,560
parses the zip file is supposed to know

429
00:16:58,560 --> 00:17:00,660
that there's something missing just add

430
00:17:00,660 --> 00:17:04,470
an 0 and I somewhat didn't read this

431
00:17:04,470 --> 00:17:05,790
right the first time we wrote this

432
00:17:05,790 --> 00:17:07,770
implementation so what the code

433
00:17:07,770 --> 00:17:09,600
originally did is if you're running out

434
00:17:09,600 --> 00:17:14,100
of bytes in your typed array and you get

435
00:17:14,100 --> 00:17:15,480
an undefined back you raise an exception

436
00:17:15,480 --> 00:17:17,579
so this is the error of your running

437
00:17:17,579 --> 00:17:20,040
into and the fix of course is very easy

438
00:17:20,040 --> 00:17:22,800
you simply read data from a byte array

439
00:17:22,800 --> 00:17:25,800
and then we just or a 0 in there this is

440
00:17:25,800 --> 00:17:27,179
a trick we will use a little bit later

441
00:17:27,179 --> 00:17:28,650
on a slide as well what this basically

442
00:17:28,650 --> 00:17:32,280
does it it it forces that to be an

443
00:17:32,280 --> 00:17:36,150
integer number and undefined is the

444
00:17:36,150 --> 00:17:37,770
equivalent of the integer number 0 so

445
00:17:37,770 --> 00:17:39,540
whenever we read past the end of this

446
00:17:39,540 --> 00:17:41,730
byte stream then we will start reading

447
00:17:41,730 --> 00:17:43,350
back zeros which is exactly what the

448
00:17:43,350 --> 00:17:46,200
specification calls for the neat part is

449
00:17:46,200 --> 00:17:49,919
that we ship this bug in PDF no Jas for

450
00:17:49,919 --> 00:17:52,890
years so people have looked at like

451
00:17:52,890 --> 00:17:53,510
billions

452
00:17:53,510 --> 00:17:55,700
PDF documents and nobody notices that

453
00:17:55,700 --> 00:17:57,770
this was wrong this must be because the

454
00:17:57,770 --> 00:18:00,500
implementation of jar files and of PDF

455
00:18:00,500 --> 00:18:02,330
readers is separate so the PDF readers

456
00:18:02,330 --> 00:18:03,980
seemed or generators don't seem to

457
00:18:03,980 --> 00:18:06,320
generate this kind of optimization with

458
00:18:06,320 --> 00:18:08,510
zero at the end so since then we

459
00:18:08,510 --> 00:18:11,380
actually fix that in in Firefox as well

460
00:18:11,380 --> 00:18:15,350
all right next step so I had now a way

461
00:18:15,350 --> 00:18:17,990
to read your files after some pain and I

462
00:18:17,990 --> 00:18:21,530
had a way to parse class files the next

463
00:18:21,530 --> 00:18:23,300
step of course is VM we have to go and

464
00:18:23,300 --> 00:18:25,250
get something it will interpret that

465
00:18:25,250 --> 00:18:26,810
byte code and run the actual Java

466
00:18:26,810 --> 00:18:29,240
program for us the most natural way of

467
00:18:29,240 --> 00:18:30,770
doing that these days would be of course

468
00:18:30,770 --> 00:18:33,440
to take and scripting and scripting is

469
00:18:33,440 --> 00:18:37,730
this C++ or C C++ compiler that takes

470
00:18:37,730 --> 00:18:41,150
existing C++ code and it emits through

471
00:18:41,150 --> 00:18:43,940
llvm and a couple other steps JavaScript

472
00:18:43,940 --> 00:18:46,790
from that all the last year actually we

473
00:18:46,790 --> 00:18:48,590
also did an extension of that called

474
00:18:48,590 --> 00:18:50,930
SMGs which I think Brendan will show in

475
00:18:50,930 --> 00:18:53,150
his talk in a little bit that makes it

476
00:18:53,150 --> 00:18:54,530
possible to make this really efficient

477
00:18:54,530 --> 00:18:56,780
so if you do this path if you go from C

478
00:18:56,780 --> 00:18:59,510
C++ down to JavaScript you can get

479
00:18:59,510 --> 00:19:00,680
really really close to native

480
00:19:00,680 --> 00:19:03,290
performance so is this work this would

481
00:19:03,290 --> 00:19:04,700
be great because all i have to do is

482
00:19:04,700 --> 00:19:08,420
take kvm which is written in c and i

483
00:19:08,420 --> 00:19:10,630
could compile that and i would have a vm

484
00:19:10,630 --> 00:19:13,130
in my browser or am I rendering engine

485
00:19:13,130 --> 00:19:16,550
in theory that's really great and you

486
00:19:16,550 --> 00:19:18,020
should always reuse code if you can

487
00:19:18,020 --> 00:19:20,540
however in this case I couldn't find a

488
00:19:20,540 --> 00:19:23,330
license for kvm and I'm serious there's

489
00:19:23,330 --> 00:19:24,710
no license they put on coat there

490
00:19:24,710 --> 00:19:26,480
they're saying that there's no license

491
00:19:26,480 --> 00:19:28,160
and didn't have a license for it so i

492
00:19:28,160 --> 00:19:29,840
started calling up some old friends from

493
00:19:29,840 --> 00:19:32,480
sun and there's really no license out

494
00:19:32,480 --> 00:19:33,890
there so for some reason is out there

495
00:19:33,890 --> 00:19:36,080
there's no license right now to use it

496
00:19:36,080 --> 00:19:38,180
and i couldn't find anyone left at

497
00:19:38,180 --> 00:19:41,030
Oracle who knows how they could slap and

498
00:19:41,030 --> 00:19:42,860
open-source license on to it so I ended

499
00:19:42,860 --> 00:19:45,110
up basically not be able to use kvm

500
00:19:45,110 --> 00:19:46,730
because it's not allowed you can only

501
00:19:46,730 --> 00:19:48,380
use it for research purposes you cannot

502
00:19:48,380 --> 00:19:50,600
use it for any other purpose so this was

503
00:19:50,600 --> 00:19:52,700
very sad because there's essentially no

504
00:19:52,700 --> 00:19:54,710
other open source project that

505
00:19:54,710 --> 00:19:57,470
implements this specific flavor of the

506
00:19:57,470 --> 00:19:59,900
vm there's a couple open-source VMs that

507
00:19:59,900 --> 00:20:01,460
implement a more heavyweight complete

508
00:20:01,460 --> 00:20:04,040
java VMS but nothing implements this

509
00:20:04,040 --> 00:20:07,040
limited configuration at kvm needs

510
00:20:07,040 --> 00:20:09,260
so one of the reasons I'm here today

511
00:20:09,260 --> 00:20:11,000
with you is because son didn't put a

512
00:20:11,000 --> 00:20:16,450
license on kvm 14 years ago I all right

513
00:20:16,450 --> 00:20:22,790
um so divided a vm i went to github and

514
00:20:22,790 --> 00:20:24,860
try to find who else try to do this and

515
00:20:24,860 --> 00:20:26,060
it turns out a whole bunch of people

516
00:20:26,060 --> 00:20:28,040
have tried to write Java VM sin

517
00:20:28,040 --> 00:20:30,410
JavaScript and everyone tends to do that

518
00:20:30,410 --> 00:20:33,460
for about two months before they give up

519
00:20:33,460 --> 00:20:35,090
so I looked at all the different

520
00:20:35,090 --> 00:20:36,500
implementations that were completely

521
00:20:36,500 --> 00:20:38,930
incomplete and the one I like the best

522
00:20:38,930 --> 00:20:42,800
is called no JVM I liked it because the

523
00:20:42,800 --> 00:20:44,060
code structure was gonna be very nice

524
00:20:44,060 --> 00:20:47,450
and neat or maybe just because his style

525
00:20:47,450 --> 00:20:50,420
match my random style very well but

526
00:20:50,420 --> 00:20:52,130
anyway this was the one that I started

527
00:20:52,130 --> 00:20:54,920
with I'd had our classified parser and a

528
00:20:54,920 --> 00:20:56,900
bunch of different other pieces that I

529
00:20:56,900 --> 00:20:58,310
was able to be used so if this actually

530
00:20:58,310 --> 00:20:59,840
was able to get the first hello world

531
00:20:59,840 --> 00:21:03,380
program to work I very quickly realized

532
00:21:03,380 --> 00:21:05,170
that the way that they implemented

533
00:21:05,170 --> 00:21:09,260
natives is a really bad idea so what is

534
00:21:09,260 --> 00:21:11,990
the native and drama as you probably

535
00:21:11,990 --> 00:21:14,420
know Java is a type-safe language so

536
00:21:14,420 --> 00:21:15,980
there's a lot of things you cannot do in

537
00:21:15,980 --> 00:21:18,020
Java you cannot poke around this memory

538
00:21:18,020 --> 00:21:20,180
addresses you cannot directly call a

539
00:21:20,180 --> 00:21:22,160
system call that would invoke some

540
00:21:22,160 --> 00:21:24,500
service from the operating system to do

541
00:21:24,500 --> 00:21:26,420
these things Java has to somehow paul

542
00:21:26,420 --> 00:21:29,180
into c code and this C code is what Java

543
00:21:29,180 --> 00:21:31,760
called native code it's basically in the

544
00:21:31,760 --> 00:21:33,620
vm a way to recognize that you're

545
00:21:33,620 --> 00:21:36,380
calling a special magic method this a

546
00:21:36,380 --> 00:21:38,870
specific name and that name is mapped to

547
00:21:38,870 --> 00:21:41,870
running a c function instead of trying

548
00:21:41,870 --> 00:21:45,100
to run actual javascript by core program

549
00:21:45,100 --> 00:21:50,420
the way that the author of this vm

550
00:21:50,420 --> 00:21:53,990
implemented all the java libraries is

551
00:21:53,990 --> 00:21:57,410
that he basically made every single java

552
00:21:57,410 --> 00:22:00,110
library method a native method so you

553
00:22:00,110 --> 00:22:01,700
would go ahead and JavaScript implement

554
00:22:01,700 --> 00:22:03,320
every single thing did you need in Java

555
00:22:03,320 --> 00:22:07,730
in JavaScript that again is a bad idea

556
00:22:07,730 --> 00:22:09,350
for a couple different reasons first of

557
00:22:09,350 --> 00:22:12,620
all there's a lot of stuff the Java

558
00:22:12,620 --> 00:22:14,960
library that you need for this phones

559
00:22:14,960 --> 00:22:16,640
that you're not very large is about one

560
00:22:16,640 --> 00:22:19,910
megabyte as a compressed jar file if you

561
00:22:19,910 --> 00:22:20,870
I'm

562
00:22:20,870 --> 00:22:23,390
Press that and because classify it's

563
00:22:23,390 --> 00:22:25,309
actually very compact there's actually a

564
00:22:25,309 --> 00:22:27,170
ton of code it's a couple of thousand

565
00:22:27,170 --> 00:22:29,990
classes and those classes have a lot of

566
00:22:29,990 --> 00:22:32,750
different implementation details my life

567
00:22:32,750 --> 00:22:34,340
is too short to like write all of that

568
00:22:34,340 --> 00:22:36,290
again in JavaScript 14 years later and

569
00:22:36,290 --> 00:22:38,900
again I was it kind of felt bad karma to

570
00:22:38,900 --> 00:22:40,400
redo all this work that was done 14

571
00:22:40,400 --> 00:22:42,290
years ago so of course a much better

572
00:22:42,290 --> 00:22:44,330
idea would be even though they cannot

573
00:22:44,330 --> 00:22:49,430
use the same vm that um son did 14 years

574
00:22:49,430 --> 00:22:51,440
ago we could at least use the same

575
00:22:51,440 --> 00:22:53,690
libraries maybe and this is very good

576
00:22:53,690 --> 00:22:57,050
lucky and I'll come back to in a second

577
00:22:57,050 --> 00:23:00,140
the second piece that the second reason

578
00:23:00,140 --> 00:23:02,870
it's a really bad idea to try to write a

579
00:23:02,870 --> 00:23:06,290
Java library in javascript is that even

580
00:23:06,290 --> 00:23:07,970
though the name is very similar and i'm

581
00:23:07,970 --> 00:23:09,230
sure brandon has a couple more jobs on

582
00:23:09,230 --> 00:23:12,290
this one to the name is very similar but

583
00:23:12,290 --> 00:23:13,940
semantically this languages are very

584
00:23:13,940 --> 00:23:17,690
very different so in Java for example if

585
00:23:17,690 --> 00:23:20,809
you invoke a method and give it an

586
00:23:20,809 --> 00:23:24,920
object that is null something very

587
00:23:24,920 --> 00:23:27,380
specific happens in Java and you're

588
00:23:27,380 --> 00:23:30,080
supposed to raise a Java exception so

589
00:23:30,080 --> 00:23:32,390
what the vm has to do basically it's not

590
00:23:32,390 --> 00:23:34,220
just throw an underlying javascript

591
00:23:34,220 --> 00:23:36,170
exception but the vm has to throw a java

592
00:23:36,170 --> 00:23:38,330
exception has to take a different path

593
00:23:38,330 --> 00:23:40,790
running bytecode and it has to give the

594
00:23:40,790 --> 00:23:43,190
program a chance to react properly to

595
00:23:43,190 --> 00:23:47,179
that null exception and because Java is

596
00:23:47,179 --> 00:23:48,790
so old and has gone through so many

597
00:23:48,790 --> 00:23:51,890
rewrites and so many as much cool that's

598
00:23:51,890 --> 00:23:54,920
written for it java applications tend to

599
00:23:54,920 --> 00:23:57,230
often really rely on these very subtle

600
00:23:57,230 --> 00:23:59,390
little details so when you're starting

601
00:23:59,390 --> 00:24:02,059
what's up for example it does rely on

602
00:24:02,059 --> 00:24:05,000
the proper handling of a null objective

603
00:24:05,000 --> 00:24:08,210
reference if you start v-chat like this

604
00:24:08,210 --> 00:24:10,850
it relies on an integer division by zero

605
00:24:10,850 --> 00:24:12,679
being thrown as an exception and being

606
00:24:12,679 --> 00:24:15,260
reported so it would be very difficult

607
00:24:15,260 --> 00:24:18,530
to rewrite all this JavaScript code or

608
00:24:18,530 --> 00:24:20,750
the Java code in JavaScript and make

609
00:24:20,750 --> 00:24:23,270
sure that every single step you maintain

610
00:24:23,270 --> 00:24:26,780
precisely the semantics of Java it would

611
00:24:26,780 --> 00:24:28,490
be of course much better if you can

612
00:24:28,490 --> 00:24:31,190
simply take the library code as Java and

613
00:24:31,190 --> 00:24:33,410
then they simply run that in a vm then

614
00:24:33,410 --> 00:24:34,620
you don't have to write the code

615
00:24:34,620 --> 00:24:36,300
and we have guaranteed to write

616
00:24:36,300 --> 00:24:40,590
semantics so as I said we got lucky here

617
00:24:40,590 --> 00:24:44,850
because son open sourced the library

618
00:24:44,850 --> 00:24:48,809
parts of Java just not the kvm itself so

619
00:24:48,809 --> 00:24:50,970
we could simply download from Sons site

620
00:24:50,970 --> 00:24:52,770
the entire source code of the library

621
00:24:52,770 --> 00:24:54,980
that you need for these phones to work

622
00:24:54,980 --> 00:24:56,970
that saved a ton of effort right there

623
00:24:56,970 --> 00:25:00,809
that's great all right let's talk a bit

624
00:25:00,809 --> 00:25:02,580
about the vm so now we have busy all the

625
00:25:02,580 --> 00:25:04,830
basic pieces we have we can redraw files

626
00:25:04,830 --> 00:25:08,640
you can look at class files we have the

627
00:25:08,640 --> 00:25:11,190
library stuff as bytecode not only in a

628
00:25:11,190 --> 00:25:15,480
vm that can actually run this code the

629
00:25:15,480 --> 00:25:17,940
vm itself is really straightforward as i

630
00:25:17,940 --> 00:25:20,760
said earlier java bytecode this is busy

631
00:25:20,760 --> 00:25:22,770
a sequence of bytes these instructions

632
00:25:22,770 --> 00:25:25,440
in their encoded there's a little bit

633
00:25:25,440 --> 00:25:27,960
less than 255 instructions they're

634
00:25:27,960 --> 00:25:30,030
numbered and there's a definition that

635
00:25:30,030 --> 00:25:33,630
says if you see zero in your byte stream

636
00:25:33,630 --> 00:25:35,850
that's a no op don't do anything let's

637
00:25:35,850 --> 00:25:37,860
go to the next instruction if you see

638
00:25:37,860 --> 00:25:41,250
one its and it pushes on now constant

639
00:25:41,250 --> 00:25:44,220
onto the Java stack and so on so the

640
00:25:44,220 --> 00:25:45,720
most trivial way of implementing this is

641
00:25:45,720 --> 00:25:47,730
simply you go ahead and you've read a

642
00:25:47,730 --> 00:25:50,700
little interpreter it grabs the current

643
00:25:50,700 --> 00:25:53,100
frame and it pulls out the stack and

644
00:25:53,100 --> 00:25:55,220
then it does operations on it you know

645
00:25:55,220 --> 00:26:01,920
infinitely spinning wildly it's

646
00:26:01,920 --> 00:26:04,200
interesting to look at two parts of this

647
00:26:04,200 --> 00:26:08,670
loop or this instruction execution the

648
00:26:08,670 --> 00:26:10,200
1i dough is showed briefly a couple

649
00:26:10,200 --> 00:26:13,620
slides earlier in Java you have strict

650
00:26:13,620 --> 00:26:15,360
typing so in Java actually have

651
00:26:15,360 --> 00:26:17,160
different by code instructions for

652
00:26:17,160 --> 00:26:19,470
adding two integers or adding two long

653
00:26:19,470 --> 00:26:22,170
integers integers are defined as 32-bit

654
00:26:22,170 --> 00:26:24,720
integers and lungs are defined 64-bit

655
00:26:24,720 --> 00:26:27,600
integers so for integer addition what

656
00:26:27,600 --> 00:26:29,070
you have to make sure is that when you

657
00:26:29,070 --> 00:26:31,020
add two numbers they're always

658
00:26:31,020 --> 00:26:33,800
guaranteed come out as an integer again

659
00:26:33,800 --> 00:26:37,050
now we could make sure that the number

660
00:26:37,050 --> 00:26:39,809
that goes in into stack pop on those two

661
00:26:39,809 --> 00:26:41,730
there are always integers however if you

662
00:26:41,730 --> 00:26:44,280
add two integers in JavaScript and its

663
00:26:44,280 --> 00:26:46,920
larger than a 32-bit integer what you

664
00:26:46,920 --> 00:26:49,380
get is a

665
00:26:49,380 --> 00:26:51,760
right this is overflow to the doubles so

666
00:26:51,760 --> 00:26:53,560
JavaScript doesn't have this weird case

667
00:26:53,560 --> 00:26:57,190
of Java where if you go over the

668
00:26:57,190 --> 00:26:59,020
definition range of an integer you can

669
00:26:59,020 --> 00:27:00,370
you kind of come back out on the other

670
00:27:00,370 --> 00:27:02,620
side of the world or like if you add one

671
00:27:02,620 --> 00:27:05,590
to the largest 32-bit integer then you

672
00:27:05,590 --> 00:27:08,710
get a negative number so that's really

673
00:27:08,710 --> 00:27:11,370
nice for javascript but in case of a

674
00:27:11,370 --> 00:27:14,410
Java VM we have to actually emulate the

675
00:27:14,410 --> 00:27:16,420
way java reacts here otherwise if some

676
00:27:16,420 --> 00:27:17,830
program relies on this it wouldn't work

677
00:27:17,830 --> 00:27:19,870
anymore use the same trick here if you

678
00:27:19,870 --> 00:27:22,750
or a number of a 0 you force it to be

679
00:27:22,750 --> 00:27:24,580
converted to an integer number and that

680
00:27:24,580 --> 00:27:25,960
way we can implement the integer

681
00:27:25,960 --> 00:27:28,150
semantics of JavaScript the second one

682
00:27:28,150 --> 00:27:30,670
is a long addition down there and that's

683
00:27:30,670 --> 00:27:32,950
actually bit harder because javascript

684
00:27:32,950 --> 00:27:36,070
cannot directly calculate 64-bit numbers

685
00:27:36,070 --> 00:27:38,530
you have only doubles and a part of the

686
00:27:38,530 --> 00:27:41,050
doubles is reserved for essentially

687
00:27:41,050 --> 00:27:43,590
telling the system where the period goes

688
00:27:43,590 --> 00:27:46,930
so as a result of that we are using

689
00:27:46,930 --> 00:27:51,280
geelong ojs which is the 64-bit math

690
00:27:51,280 --> 00:27:53,050
library that ships with a closure

691
00:27:53,050 --> 00:27:55,930
compiler so all longs that are generated

692
00:27:55,930 --> 00:27:57,430
on the stack evasive wrapped into those

693
00:27:57,430 --> 00:27:59,110
objects that allow you to do 64-bit

694
00:27:59,110 --> 00:28:02,110
computation fortunately on these feature

695
00:28:02,110 --> 00:28:05,140
phones 64-bit math is very rare so it's

696
00:28:05,140 --> 00:28:06,970
important to support it but it's not

697
00:28:06,970 --> 00:28:10,510
really a performance problem a more

698
00:28:10,510 --> 00:28:12,700
interesting instructions get filled and

699
00:28:12,700 --> 00:28:14,320
for those of you who don't like reading

700
00:28:14,320 --> 00:28:15,880
code I promise there's only two or three

701
00:28:15,880 --> 00:28:17,590
slides left before we go back to memes

702
00:28:17,590 --> 00:28:20,650
and things to laugh about I wanted to

703
00:28:20,650 --> 00:28:22,090
show a couple of more examples of stuff

704
00:28:22,090 --> 00:28:23,050
that's was really interesting to

705
00:28:23,050 --> 00:28:25,120
implement and as I said I've written

706
00:28:25,120 --> 00:28:27,870
several Java the ends at this point and

707
00:28:27,870 --> 00:28:29,830
implementing some of the more complex

708
00:28:29,830 --> 00:28:33,220
features of Java this time around in

709
00:28:33,220 --> 00:28:35,110
JavaScript turned out to be very very

710
00:28:35,110 --> 00:28:36,820
different from any other implementation

711
00:28:36,820 --> 00:28:38,710
that I've done a good example for this

712
00:28:38,710 --> 00:28:41,440
get feel what get filled does it gets

713
00:28:41,440 --> 00:28:44,490
the value of a field of a Java object

714
00:28:44,490 --> 00:28:46,900
basically what it does is it resolves

715
00:28:46,900 --> 00:28:50,140
the field into a slot into the object

716
00:28:50,140 --> 00:28:52,600
and then tries to read from that slot

717
00:28:52,600 --> 00:28:56,620
and the object the Java specification

718
00:28:56,620 --> 00:28:58,559
defines certain air

719
00:28:58,559 --> 00:29:00,330
conditions that can happen one example

720
00:29:00,330 --> 00:29:04,100
is if you give get filled and null

721
00:29:04,100 --> 00:29:07,110
object then it is supposed to throw an

722
00:29:07,110 --> 00:29:09,840
exception so as the interpreters running

723
00:29:09,840 --> 00:29:12,779
if object happens to be null then this

724
00:29:12,779 --> 00:29:14,460
race exceptional yield is going to be

725
00:29:14,460 --> 00:29:16,529
invoked so let's look at that for a

726
00:29:16,529 --> 00:29:19,049
second because that's so interesting the

727
00:29:19,049 --> 00:29:21,600
way we did that so what raise exception

728
00:29:21,600 --> 00:29:23,639
and yield does is essentially it raises

729
00:29:23,639 --> 00:29:25,169
an exception another show in a second

730
00:29:25,169 --> 00:29:27,299
what it does and after that it does a

731
00:29:27,299 --> 00:29:31,110
yield by throwing and Java Script

732
00:29:31,110 --> 00:29:33,629
exception so again we are trying to

733
00:29:33,629 --> 00:29:37,350
throw a Java exception by doing some

734
00:29:37,350 --> 00:29:39,179
code and then throwing a JavaScript

735
00:29:39,179 --> 00:29:41,429
exception if you can still follow me at

736
00:29:41,429 --> 00:29:44,399
this point your you re brave the reason

737
00:29:44,399 --> 00:29:46,830
we are doing this is that Java is fully

738
00:29:46,830 --> 00:29:49,710
synchronous language this is very

739
00:29:49,710 --> 00:29:51,330
different from JavaScript we're really

740
00:29:51,330 --> 00:29:53,159
one of the prime directives of

741
00:29:53,159 --> 00:29:55,350
javascript is try to run as little code

742
00:29:55,350 --> 00:29:57,539
as possible in your event loop and don't

743
00:29:57,539 --> 00:29:59,669
hog the event loop run small snippets of

744
00:29:59,669 --> 00:30:02,129
code in a lot of system to run events as

745
00:30:02,129 --> 00:30:06,450
well the way we implement this this

746
00:30:06,450 --> 00:30:08,970
discrepancy is that we have an outer

747
00:30:08,970 --> 00:30:10,980
loop that you can see here in context

748
00:30:10,980 --> 00:30:13,110
prototype execute and it's basically a

749
00:30:13,110 --> 00:30:15,840
loop where if the code that you run in

750
00:30:15,840 --> 00:30:18,389
vm execute throws this specific

751
00:30:18,389 --> 00:30:21,809
exception of vm pause or vm yield where

752
00:30:21,809 --> 00:30:23,879
this code does ability jumps up and goes

753
00:30:23,879 --> 00:30:25,860
back to the event handler returns to the

754
00:30:25,860 --> 00:30:27,210
event loop and then next time we come

755
00:30:27,210 --> 00:30:29,850
around we've a run code again so this is

756
00:30:29,850 --> 00:30:32,220
essentially how we implement the ability

757
00:30:32,220 --> 00:30:35,100
to take a job of thread and at any time

758
00:30:35,100 --> 00:30:36,749
we can d schedule it so the system can

759
00:30:36,749 --> 00:30:39,419
do something else and of course this is

760
00:30:39,419 --> 00:30:41,490
also how to implement multitasking Java

761
00:30:41,490 --> 00:30:43,830
a multi-threaded system all you have to

762
00:30:43,830 --> 00:30:45,600
do is basically several of these things

763
00:30:45,600 --> 00:30:46,889
post it and then you essentially have

764
00:30:46,889 --> 00:30:48,330
several threats that are running at the

765
00:30:48,330 --> 00:30:53,130
same time all right

766
00:30:53,130 --> 00:30:54,630
I promise that you will look at raise

767
00:30:54,630 --> 00:30:56,370
exception and don't very most of this is

768
00:30:56,370 --> 00:30:58,800
not interesting the only piece of really

769
00:30:58,800 --> 00:31:00,510
interesting is the very bottom of this

770
00:31:00,510 --> 00:31:02,760
if you look at the integer array the you

771
00:31:02,760 --> 00:31:04,260
and eight array that we are generating

772
00:31:04,260 --> 00:31:06,480
there what you're actually seeing there

773
00:31:06,480 --> 00:31:09,180
is that your hand assembling some byte

774
00:31:09,180 --> 00:31:12,330
code inside that method so when we are

775
00:31:12,330 --> 00:31:15,030
trying to raise an exception it actually

776
00:31:15,030 --> 00:31:17,430
turns out we cannot directly raise the

777
00:31:17,430 --> 00:31:19,620
exception instead they're generating a

778
00:31:19,620 --> 00:31:22,170
fake java method that we put onto our

779
00:31:22,170 --> 00:31:24,660
java stack that we implementing in

780
00:31:24,660 --> 00:31:27,900
javascript the reason you have to do

781
00:31:27,900 --> 00:31:29,970
that is that there are several steps

782
00:31:29,970 --> 00:31:33,300
necessary to throw an exception and each

783
00:31:33,300 --> 00:31:37,560
of these steps can fail individually the

784
00:31:37,560 --> 00:31:39,540
only way I can handle that for example

785
00:31:39,540 --> 00:31:41,540
the only way I can properly handle

786
00:31:41,540 --> 00:31:44,520
throwing an exception while throwing an

787
00:31:44,520 --> 00:31:47,910
exception is if I have a second method

788
00:31:47,910 --> 00:31:50,280
in between there so what for example can

789
00:31:50,280 --> 00:31:52,020
happen is let's say you're trying to

790
00:31:52,020 --> 00:31:54,420
throw a specific exception with a name

791
00:31:54,420 --> 00:31:58,020
acts and that name doesn't exist then in

792
00:31:58,020 --> 00:31:59,340
that case the vm would throw an

793
00:31:59,340 --> 00:32:01,890
exception telling you that a class could

794
00:32:01,890 --> 00:32:04,440
not be found and when you're throwing

795
00:32:04,440 --> 00:32:05,850
that exception you might want out of

796
00:32:05,850 --> 00:32:07,500
memory which case the vm is going to

797
00:32:07,500 --> 00:32:09,780
throw a lot of memory exception so you

798
00:32:09,780 --> 00:32:11,430
have to have this cascading the assault

799
00:32:11,430 --> 00:32:13,230
in essence this thing this is synthetic

800
00:32:13,230 --> 00:32:15,270
methods that we are throwing in between

801
00:32:15,270 --> 00:32:17,750
the stack this is very neat because on

802
00:32:17,750 --> 00:32:20,010
the simple structure of JavaScript

803
00:32:20,010 --> 00:32:21,320
allows us to do is very efficiently

804
00:32:21,320 --> 00:32:23,700
because we're using this UN day to race

805
00:32:23,700 --> 00:32:26,240
to actually store the stack frames I

806
00:32:26,240 --> 00:32:28,530
mentioned a couple minutes ago the

807
00:32:28,530 --> 00:32:31,350
concept of natives natives are in Java a

808
00:32:31,350 --> 00:32:34,140
way to call to the operating system or

809
00:32:34,140 --> 00:32:36,600
the underlying code in JavaScript of

810
00:32:36,600 --> 00:32:38,220
course there's no notion of that we

811
00:32:38,220 --> 00:32:41,550
simply call the Dom or or into functions

812
00:32:41,550 --> 00:32:42,930
that implement it in a JavaScript

813
00:32:42,930 --> 00:32:46,410
library so freely for this VM native

814
00:32:46,410 --> 00:32:48,720
methods are essentially implementations

815
00:32:48,720 --> 00:32:53,280
of code in JavaScript in throw cc or C++

816
00:32:53,280 --> 00:32:56,490
of course it is a very simple Vater

817
00:32:56,490 --> 00:32:59,010
implementers what we essentially do is

818
00:32:59,010 --> 00:33:00,930
when you're calling a method you supply

819
00:33:00,930 --> 00:33:03,360
the name in the bytecode and we have a

820
00:33:03,360 --> 00:33:05,250
little override list where we look into

821
00:33:05,250 --> 00:33:06,970
do we have a native

822
00:33:06,970 --> 00:33:09,429
his name and if the is so they execute

823
00:33:09,429 --> 00:33:12,070
that JavaScript code instead of trying

824
00:33:12,070 --> 00:33:14,380
to call a java method in interpreter you

825
00:33:14,380 --> 00:33:15,880
can see a couple of moment a shins here

826
00:33:15,880 --> 00:33:17,799
we essentially just calls on native

827
00:33:17,799 --> 00:33:20,049
JavaScript written code that implements

828
00:33:20,049 --> 00:33:24,850
those Java functions all right almost

829
00:33:24,850 --> 00:33:31,049
done one thing we did not expect is that

830
00:33:31,049 --> 00:33:34,270
just how slow this would be so and if

831
00:33:34,270 --> 00:33:35,919
you get under this this point we're

832
00:33:35,919 --> 00:33:37,870
about 100 times slower than the

833
00:33:37,870 --> 00:33:40,780
application running on the future phone

834
00:33:40,780 --> 00:33:45,159
and that was really unexpected because

835
00:33:45,159 --> 00:33:47,650
most of time if you look at Java it

836
00:33:47,650 --> 00:33:49,990
really runs a lot of the complex

837
00:33:49,990 --> 00:33:52,929
operations in native code the reason for

838
00:33:52,929 --> 00:33:55,030
this is that back when was Java was

839
00:33:55,030 --> 00:33:58,600
first written there were no comparison

840
00:33:58,600 --> 00:34:00,940
for java it's a lot of the lot of the

841
00:34:00,940 --> 00:34:02,470
drama programs could not do a lot of

842
00:34:02,470 --> 00:34:05,380
heavy computation in Java itself so the

843
00:34:05,380 --> 00:34:07,150
Java language started to provide a lot

844
00:34:07,150 --> 00:34:11,200
of native see implementations of very

845
00:34:11,200 --> 00:34:13,149
complex functionality to compensate for

846
00:34:13,149 --> 00:34:15,639
the fact that Java was so slow so we

847
00:34:15,639 --> 00:34:17,169
really expected that even if you have a

848
00:34:17,169 --> 00:34:20,349
slow vm for java you should be a little

849
00:34:20,349 --> 00:34:24,609
closer to usable than 100 x away it

850
00:34:24,609 --> 00:34:26,139
turns out that the main reason for this

851
00:34:26,139 --> 00:34:28,780
being this slow is that there's some

852
00:34:28,780 --> 00:34:30,760
very frequently called things in any

853
00:34:30,760 --> 00:34:33,159
programming language let's say comparing

854
00:34:33,159 --> 00:34:35,200
two strings this is called in java

855
00:34:35,200 --> 00:34:39,460
equals in java all these things are

856
00:34:39,460 --> 00:34:42,639
implemented in Java itself so if you're

857
00:34:42,639 --> 00:34:44,740
comparing two strings you have to call

858
00:34:44,740 --> 00:34:46,389
this function here and don't worry I

859
00:34:46,389 --> 00:34:47,859
will not try to read through this what

860
00:34:47,859 --> 00:34:49,629
this does all you have to remember is

861
00:34:49,629 --> 00:34:51,849
that there's like 80 bytes or so of

862
00:34:51,849 --> 00:34:53,619
instructions in here and I highlighted

863
00:34:53,619 --> 00:34:56,290
is read a loop that's inside of this so

864
00:34:56,290 --> 00:34:58,119
what this code does it has a whole bunch

865
00:34:58,119 --> 00:34:59,890
of checking with its video string and

866
00:34:59,890 --> 00:35:03,250
then it goes to that loop and it for

867
00:35:03,250 --> 00:35:04,900
every single character it individually

868
00:35:04,900 --> 00:35:06,790
compares whether it matches the other

869
00:35:06,790 --> 00:35:09,160
string or not and then returns true or

870
00:35:09,160 --> 00:35:11,650
false and of course each of these steps

871
00:35:11,650 --> 00:35:14,980
in this program or Java VM written

872
00:35:14,980 --> 00:35:18,550
JavaScript has to interpret so comparing

873
00:35:18,550 --> 00:35:20,650
two strings in this Java

874
00:35:20,650 --> 00:35:23,559
em with this role is horribly slow we

875
00:35:23,559 --> 00:35:26,410
did a low profile using using the dev

876
00:35:26,410 --> 00:35:27,910
tools and you could you need to see that

877
00:35:27,910 --> 00:35:30,010
most of the time was spent in five or

878
00:35:30,010 --> 00:35:33,970
six functions like this so a very easy

879
00:35:33,970 --> 00:35:35,980
way to fix that of course is to use the

880
00:35:35,980 --> 00:35:37,869
same mechanism we just solve as native

881
00:35:37,869 --> 00:35:39,880
methods a native method again is

882
00:35:39,880 --> 00:35:41,680
something that we implemented JavaScript

883
00:35:41,680 --> 00:35:44,140
instead of in Java so they can simply

884
00:35:44,140 --> 00:35:46,630
take shortcuts so I have a little native

885
00:35:46,630 --> 00:35:49,150
method that overrides the pure Java

886
00:35:49,150 --> 00:35:51,220
implementation and it goes ahead and

887
00:35:51,220 --> 00:35:52,779
simply check that it's a string and if

888
00:35:52,779 --> 00:35:54,849
so it has a string compare at a

889
00:35:54,849 --> 00:35:56,619
JavaScript level that's of course

890
00:35:56,619 --> 00:35:58,960
massively faster because the JavaScript

891
00:35:58,960 --> 00:36:01,119
vm in the browser knows how is that very

892
00:36:01,119 --> 00:36:02,470
efficiently you don't have to be like

893
00:36:02,470 --> 00:36:04,359
circle that interpreter loop all the

894
00:36:04,359 --> 00:36:07,630
time so after the dis work of course we

895
00:36:07,630 --> 00:36:10,289
expected things to get a lot better and

896
00:36:10,289 --> 00:36:13,630
it did get a lot better it got like ten

897
00:36:13,630 --> 00:36:16,660
times faster or so but it was still kind

898
00:36:16,660 --> 00:36:19,599
of painfully slow to use and the reason

899
00:36:19,599 --> 00:36:21,640
for that probably is that actually Java

900
00:36:21,640 --> 00:36:23,470
has advanced fight a bit since it's

901
00:36:23,470 --> 00:36:26,079
early days and today most of time when

902
00:36:26,079 --> 00:36:28,029
you run Java programs you actually also

903
00:36:28,029 --> 00:36:31,660
compile them over to an x86 or arm

904
00:36:31,660 --> 00:36:34,299
machine code so even on this simple

905
00:36:34,299 --> 00:36:36,309
feature phones this lecture compiler

906
00:36:36,309 --> 00:36:38,109
built in that takes the bytecode and

907
00:36:38,109 --> 00:36:39,369
then instead of just running an

908
00:36:39,369 --> 00:36:41,260
interpreter it generates machine code

909
00:36:41,260 --> 00:36:42,819
from the by code and then runs that

910
00:36:42,819 --> 00:36:44,740
machine code and since we still had an

911
00:36:44,740 --> 00:36:47,079
interpreter we were slower than the

912
00:36:47,079 --> 00:36:49,299
teacher phone systems to the point where

913
00:36:49,299 --> 00:36:54,309
the app was not really usable so the the

914
00:36:54,309 --> 00:36:55,779
next step of course is how to compile

915
00:36:55,779 --> 00:37:00,849
Java in JavaScript and this seemed like

916
00:37:00,849 --> 00:37:02,859
a really daunting task for anyone was

917
00:37:02,859 --> 00:37:05,020
written compilers so for those of you at

918
00:37:05,020 --> 00:37:07,960
the the the curse or privilege whichever

919
00:37:07,960 --> 00:37:09,520
way you want to see it to have written a

920
00:37:09,520 --> 00:37:12,160
compiler generating code in a compiler

921
00:37:12,160 --> 00:37:14,500
it's like the most painful part of

922
00:37:14,500 --> 00:37:16,390
compilers because machine code is so

923
00:37:16,390 --> 00:37:19,359
hard to read and very hard to target and

924
00:37:19,359 --> 00:37:21,490
it's also the most exciting thing to

925
00:37:21,490 --> 00:37:23,710
debug like this does you have not debug

926
00:37:23,710 --> 00:37:25,329
in your life until you have trying to

927
00:37:25,329 --> 00:37:26,890
debug some machine code that goes wrong

928
00:37:26,890 --> 00:37:28,990
on you you try to understand what the

929
00:37:28,990 --> 00:37:30,910
hell happens there in some like binary

930
00:37:30,910 --> 00:37:32,710
machine code you're looking at

931
00:37:32,710 --> 00:37:34,630
so they go to this point just seemed

932
00:37:34,630 --> 00:37:36,250
pretty scary quite honestly because

933
00:37:36,250 --> 00:37:39,490
every time I had done it before it was a

934
00:37:39,490 --> 00:37:42,960
really daunting task to deal with

935
00:37:42,960 --> 00:37:47,050
fortunately this is JavaScript right and

936
00:37:47,050 --> 00:37:49,300
it is it is not machine language it's

937
00:37:49,300 --> 00:37:51,880
not x86 and it's not armed and it's a

938
00:37:51,880 --> 00:37:53,320
lot easier to do this in JavaScript and

939
00:37:53,320 --> 00:37:55,869
this was almost unexpected for us if you

940
00:37:55,869 --> 00:37:58,089
look at the compiler that is in j2me

941
00:37:58,089 --> 00:38:01,270
DOJ's that is probably the smallest java

942
00:38:01,270 --> 00:38:04,540
compiler i've ever seen if you think

943
00:38:04,540 --> 00:38:06,580
about it for a moment what it does it

944
00:38:06,580 --> 00:38:08,140
takes a Java code and of course emits

945
00:38:08,140 --> 00:38:10,810
javascript code from it it all the

946
00:38:10,810 --> 00:38:11,859
sudden of course makes a lot of sense

947
00:38:11,859 --> 00:38:13,690
that it's a very small compiler because

948
00:38:13,690 --> 00:38:15,700
what you're doing is almost like an

949
00:38:15,700 --> 00:38:17,770
inversion javascript is actually a much

950
00:38:17,770 --> 00:38:19,720
more semantically rich language than

951
00:38:19,720 --> 00:38:21,339
Java and there's much more powerful

952
00:38:21,339 --> 00:38:23,140
primitives what we're doing is you're

953
00:38:23,140 --> 00:38:25,750
busy taking Java and we are lowering it

954
00:38:25,750 --> 00:38:29,740
to this much higher representation this

955
00:38:29,740 --> 00:38:32,230
is very easy because many things where

956
00:38:32,230 --> 00:38:35,820
you have to painfully assemble in on

957
00:38:35,820 --> 00:38:38,349
machine code instructions for Java are

958
00:38:38,349 --> 00:38:41,740
very very trivial to do in javascript we

959
00:38:41,740 --> 00:38:42,970
also harnessed a couple of other tricks

960
00:38:42,970 --> 00:38:45,030
to make this process particularly easy

961
00:38:45,030 --> 00:38:48,130
when you're trying to compile Java over

962
00:38:48,130 --> 00:38:51,430
to JavaScript we try to use edge as much

963
00:38:51,430 --> 00:38:55,240
of the JavaScript semantics itself so

964
00:38:55,240 --> 00:38:57,520
for example Java objects are represented

965
00:38:57,520 --> 00:39:00,580
through one JavaScript object they're

966
00:39:00,580 --> 00:39:01,869
not trying to implement our own garbage

967
00:39:01,869 --> 00:39:03,670
collector we are not trying to implement

968
00:39:03,670 --> 00:39:07,270
many other pieces of the Java VM but

969
00:39:07,270 --> 00:39:08,770
traditionally you have to implement in

970
00:39:08,770 --> 00:39:10,990
some native language so by making our

971
00:39:10,990 --> 00:39:12,580
Java implementation match very very

972
00:39:12,580 --> 00:39:14,470
closely what the JavaScript language

973
00:39:14,470 --> 00:39:16,420
does the actual compilation approach

974
00:39:16,420 --> 00:39:19,960
itself becomes really trivial so this

975
00:39:19,960 --> 00:39:21,040
what compilation looks like and this

976
00:39:21,040 --> 00:39:23,230
will look eerie familiar to you if you

977
00:39:23,230 --> 00:39:25,780
remember the execute loop it essentially

978
00:39:25,780 --> 00:39:27,820
does the same thing that the execute

979
00:39:27,820 --> 00:39:29,290
function did there's a compile function

980
00:39:29,290 --> 00:39:31,750
you go over the bike code in sequence

981
00:39:31,750 --> 00:39:34,270
and for every byte code operation you

982
00:39:34,270 --> 00:39:36,520
simply omit some code and code in this

983
00:39:36,520 --> 00:39:38,530
case is simply a string if we define up

984
00:39:38,530 --> 00:39:40,390
there and we concatenate into that

985
00:39:40,390 --> 00:39:43,270
string operations in JavaScript that

986
00:39:43,270 --> 00:39:45,250
basically emulate the stack nature of

987
00:39:45,250 --> 00:39:46,390
Java

988
00:39:46,390 --> 00:39:48,609
execute operations that Java is

989
00:39:48,609 --> 00:39:51,039
executing this turned out to be really a

990
00:39:51,039 --> 00:39:54,760
very easy way to compile code this part

991
00:39:54,760 --> 00:39:56,710
was really easy but was a lot less easy

992
00:39:56,710 --> 00:40:00,760
is actually trying to run that code we

993
00:40:00,760 --> 00:40:02,710
are running the stuff in an environment

994
00:40:02,710 --> 00:40:04,690
where content security policies are

995
00:40:04,690 --> 00:40:06,940
enforced and if you don't know what it

996
00:40:06,940 --> 00:40:08,529
is I recommend you go and read right

997
00:40:08,529 --> 00:40:09,549
after this talk because it's very

998
00:40:09,549 --> 00:40:13,059
important that you know what it is photo

999
00:40:13,059 --> 00:40:15,130
so you don't know yet CSP survey how you

1000
00:40:15,130 --> 00:40:19,119
can restrict web applications from doing

1001
00:40:19,119 --> 00:40:21,970
dangerous things NFL is one of those

1002
00:40:21,970 --> 00:40:23,440
things that pretty dangerous because if

1003
00:40:23,440 --> 00:40:25,750
you have stuff coming in from the user

1004
00:40:25,750 --> 00:40:28,299
and it somehow gets into Avelle that's

1005
00:40:28,299 --> 00:40:30,099
usually where things go wrong and some

1006
00:40:30,099 --> 00:40:32,200
someone is going to take over your code

1007
00:40:32,200 --> 00:40:34,329
and inject some code so we are in an

1008
00:40:34,329 --> 00:40:35,619
environment where we can actually not

1009
00:40:35,619 --> 00:40:38,170
use a vowel so we can compile it a Java

1010
00:40:38,170 --> 00:40:40,359
program just find a JavaScript but then

1011
00:40:40,359 --> 00:40:42,339
we cannot actually a valid because the

1012
00:40:42,339 --> 00:40:45,720
eval function itself is disallowed I

1013
00:40:45,720 --> 00:40:47,859
unfortunately don't have time to go all

1014
00:40:47,859 --> 00:40:49,930
the evil details but it takes to bypass

1015
00:40:49,930 --> 00:40:51,099
that but essentially what we are doing

1016
00:40:51,099 --> 00:40:54,490
is we are firing up a new iframe and you

1017
00:40:54,490 --> 00:40:56,170
load the code in that you I frame and

1018
00:40:56,170 --> 00:40:58,450
that iframe kind of post messages us

1019
00:40:58,450 --> 00:41:01,750
back and forth um as we execute code and

1020
00:41:01,750 --> 00:41:05,140
it actually even works so um this was in

1021
00:41:05,140 --> 00:41:06,940
surprising to me one of the other

1022
00:41:06,940 --> 00:41:09,099
authors Nick on this project came up

1023
00:41:09,099 --> 00:41:10,930
with this idea and it's pretty insane if

1024
00:41:10,930 --> 00:41:12,490
you really would like to see some fun

1025
00:41:12,490 --> 00:41:14,049
code or recommend you take a look at

1026
00:41:14,049 --> 00:41:18,369
that all right now we had a demo part of

1027
00:41:18,369 --> 00:41:21,160
this it seems that the convention is

1028
00:41:21,160 --> 00:41:22,990
when missoula comes to demo or at least

1029
00:41:22,990 --> 00:41:24,849
when a muscle as CTO comes to demo

1030
00:41:24,849 --> 00:41:27,519
something at a jsf conference you have

1031
00:41:27,519 --> 00:41:29,970
to show some sort of live demo and

1032
00:41:29,970 --> 00:41:31,930
Brandon already set the precedent that

1033
00:41:31,930 --> 00:41:33,839
it usually is a game that you're playing

1034
00:41:33,839 --> 00:41:37,059
there is no quake for j2me as far as i

1035
00:41:37,059 --> 00:41:39,849
know so i picked the second closest

1036
00:41:39,849 --> 00:41:42,369
thing I could find and this is a live

1037
00:41:42,369 --> 00:41:43,990
demo so if it doesn't work I'm very

1038
00:41:43,990 --> 00:41:50,799
sorry let's see where my bookmarks there

1039
00:41:50,799 --> 00:41:55,869
we go so this is the asteroids java game

1040
00:41:55,869 --> 00:41:58,000
that is common on these on these phones

1041
00:41:58,000 --> 00:42:00,330
and great there's a loose

1042
00:42:00,330 --> 00:42:03,600
is screwing here I cannot get to my

1043
00:42:03,600 --> 00:42:09,450
storage button see that's great slive

1044
00:42:09,450 --> 00:42:11,450
debugging here all right now it works

1045
00:42:11,450 --> 00:42:13,830
all right so I can go to menu here so

1046
00:42:13,830 --> 00:42:15,150
this is all the java stuff it's running

1047
00:42:15,150 --> 00:42:16,590
this is the interpreter loop running

1048
00:42:16,590 --> 00:42:18,900
here running this asteroid game this is

1049
00:42:18,900 --> 00:42:21,590
a jar file is that you an open source

1050
00:42:21,590 --> 00:42:24,810
j2me game you can find on the web GPL

1051
00:42:24,810 --> 00:42:26,730
it's really great if you have to get

1052
00:42:26,730 --> 00:42:28,620
back a vm if you have a program you have

1053
00:42:28,620 --> 00:42:30,900
the source code for find try to debug

1054
00:42:30,900 --> 00:42:32,100
with something that you only have to buy

1055
00:42:32,100 --> 00:42:35,280
quote for its really painful so here

1056
00:42:35,280 --> 00:42:36,960
this is this a touch events from the

1057
00:42:36,960 --> 00:42:40,560
browser that are sent over to the Java

1058
00:42:40,560 --> 00:42:42,720
VM and I can go ahead here and start

1059
00:42:42,720 --> 00:42:44,460
this everything you see here like this

1060
00:42:44,460 --> 00:42:46,950
this very ugly yellow you I this is all

1061
00:42:46,950 --> 00:42:49,020
rendered in Java unlike 14 year old Java

1062
00:42:49,020 --> 00:42:51,450
code that runs on these phones and I can

1063
00:42:51,450 --> 00:42:57,810
start this and then I'm live demo I can

1064
00:42:57,810 --> 00:42:59,700
I move my ship so this is unfortunate um

1065
00:42:59,700 --> 00:43:01,740
let's see if you if you can do this

1066
00:43:01,740 --> 00:43:06,060
we'll start this again no I cannot all

1067
00:43:06,060 --> 00:43:07,290
right I cannot tell you why I cannot

1068
00:43:07,290 --> 00:43:08,700
move my ship right now it worked in a

1069
00:43:08,700 --> 00:43:10,980
room there you can believe me or not but

1070
00:43:10,980 --> 00:43:12,750
in theory I would we give you like live

1071
00:43:12,750 --> 00:43:14,370
demo right now next time I'm definitely

1072
00:43:14,370 --> 00:43:17,040
record this not show this life alright

1073
00:43:17,040 --> 00:43:23,460
let's go back to our slides all right

1074
00:43:23,460 --> 00:43:25,650
before I don't have time first of all

1075
00:43:25,650 --> 00:43:27,030
thank you very much for listening to me

1076
00:43:27,030 --> 00:43:29,790
going on about Java and JavaScript and

1077
00:43:29,790 --> 00:43:31,950
VMS Whitney JavaScript I would like to

1078
00:43:31,950 --> 00:43:34,020
acknowledge a couple people that have

1079
00:43:34,020 --> 00:43:36,660
worked on this project as many of the

1080
00:43:36,660 --> 00:43:38,970
other projects that are started in the

1081
00:43:38,970 --> 00:43:41,220
past it's usually me who gets to do the

1082
00:43:41,220 --> 00:43:43,440
first fun couple of weeks and a bunch of

1083
00:43:43,440 --> 00:43:44,700
people have to come in who have to like

1084
00:43:44,700 --> 00:43:46,200
do months of hard work to actually make

1085
00:43:46,200 --> 00:43:48,300
it work so there's a whole bunch of

1086
00:43:48,300 --> 00:43:49,950
people for missoula and also outside

1087
00:43:49,950 --> 00:43:51,900
contributors to help the j2me get it to

1088
00:43:51,900 --> 00:43:53,790
the point where it can run java

1089
00:43:53,790 --> 00:43:56,220
applications and i recommend you look up

1090
00:43:56,220 --> 00:43:57,270
their names since you're interested in

1091
00:43:57,270 --> 00:43:58,710
the code for this it's all up on github

1092
00:43:58,710 --> 00:44:02,580
and check it out and run some j2me stuff

