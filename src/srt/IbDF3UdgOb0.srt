1
00:00:08,090 --> 00:00:11,700

welcome and Jason brief is a sort of

2
00:00:11,700 --> 00:00:14,219
strange confluences of people whose name

3
00:00:14,219 --> 00:00:17,190
starts with k andar Chris I think there

4
00:00:17,190 --> 00:00:19,260
are three of us it's really weird but

5
00:00:19,260 --> 00:00:21,090
there's Chris's eyes and Chris Walker

6
00:00:21,090 --> 00:00:23,910
and me which makes the mailing list a

7
00:00:23,910 --> 00:00:25,590
bit confusing but that which brings me

8
00:00:25,590 --> 00:00:28,609
to the point commonjs is a mailing list

9
00:00:28,609 --> 00:00:32,899
and a wiki and our Charter is to develop

10
00:00:32,899 --> 00:00:36,110
specifications for JavaScript ad hoc

11
00:00:36,110 --> 00:00:41,370
from from the grassroots for contexts on

12
00:00:41,370 --> 00:00:43,010
the browser and outside of the browser

13
00:00:43,010 --> 00:00:46,500
and beyond we started about two years

14
00:00:46,500 --> 00:00:48,840
ago by Kevin Dan goor with a blog post

15
00:00:48,840 --> 00:00:52,410
and there are first our first thing that

16
00:00:52,410 --> 00:00:54,030
we did was we constructed a module spec

17
00:00:54,030 --> 00:00:57,600
which was probably most noted because

18
00:00:57,600 --> 00:00:59,670
node implemented it pretty quickly on

19
00:00:59,670 --> 00:01:02,879
and it's certainly the the widest

20
00:01:02,879 --> 00:01:04,320
deployment of it it's but not the only

21
00:01:04,320 --> 00:01:07,680
there's also Narwhal gypsy whole bunch

22
00:01:07,680 --> 00:01:09,330
of server-side embeddings also in the

23
00:01:09,330 --> 00:01:13,369
browser for by a few so the perp the

24
00:01:13,369 --> 00:01:16,680
purpose for the group originally last

25
00:01:16,680 --> 00:01:18,030
year has been really quiet for common

26
00:01:18,030 --> 00:01:20,509
j/s the group was originally started

27
00:01:20,509 --> 00:01:22,350
because there were a whole bunch of

28
00:01:22,350 --> 00:01:24,840
server-side JavaScript frameworks that

29
00:01:24,840 --> 00:01:27,869
we're not really taking off and the

30
00:01:27,869 --> 00:01:30,329
Kevin's theory at the time was that the

31
00:01:30,329 --> 00:01:31,619
reason they weren't taking off was

32
00:01:31,619 --> 00:01:33,030
because it was kind of pointless to

33
00:01:33,030 --> 00:01:34,590
write JavaScript for any single one of

34
00:01:34,590 --> 00:01:38,329
these sort of somewhat cramped platforms

35
00:01:38,329 --> 00:01:40,470
because he really couldn't you could

36
00:01:40,470 --> 00:01:42,030
there was no escape route you couldn't

37
00:01:42,030 --> 00:01:44,250
go to a better system if you could if

38
00:01:44,250 --> 00:01:46,290
you found one there was no degree of

39
00:01:46,290 --> 00:01:48,149
interoperability they were just you just

40
00:01:48,149 --> 00:01:49,619
have to rewrite it every time you move

41
00:01:49,619 --> 00:01:52,140
to a new platform so he started the

42
00:01:52,140 --> 00:01:55,020
group to work on some of the basic

43
00:01:55,020 --> 00:01:56,040
standards that we would need for

44
00:01:56,040 --> 00:01:58,340
server-side in systems programming

45
00:01:58,340 --> 00:02:01,560
things like a module has a basis for

46
00:02:01,560 --> 00:02:05,369
everything packaging binary data file

47
00:02:05,369 --> 00:02:09,390
systems and IO within the so we worked

48
00:02:09,390 --> 00:02:10,860
pretty hard the first year to get

49
00:02:10,860 --> 00:02:13,740
file systems and binary and stuff like

50
00:02:13,740 --> 00:02:16,620
that worked out but we were going to go

51
00:02:16,620 --> 00:02:19,260
in the wrong direction and node sort of

52
00:02:19,260 --> 00:02:21,180
proved doubt that that we really need to

53
00:02:21,180 --> 00:02:23,220
look into a synchronous file systems in

54
00:02:23,220 --> 00:02:25,650
i/o before we start writing and actually

55
00:02:25,650 --> 00:02:27,420
get some asynchronous implementations in

56
00:02:27,420 --> 00:02:29,250
JavaScript before we start standardizing

57
00:02:29,250 --> 00:02:33,300
them and was it was an easy trap to fall

58
00:02:33,300 --> 00:02:36,480
into because i was there are so many

59
00:02:36,480 --> 00:02:38,459
well vetted synchronous file system API

60
00:02:38,459 --> 00:02:41,850
is on the server we figure is pretty

61
00:02:41,850 --> 00:02:43,920
pretty well researched prior art and so

62
00:02:43,920 --> 00:02:45,209
we just took those and found the best

63
00:02:45,209 --> 00:02:46,440
things of them and tried to make the

64
00:02:46,440 --> 00:02:48,930
very best synchronous file system API

65
00:02:48,930 --> 00:02:50,730
there could up that there could ever be

66
00:02:50,730 --> 00:02:53,820
and put it in JavaScript and I think

67
00:02:53,820 --> 00:02:55,290
that a lot of that work is still useful

68
00:02:55,290 --> 00:02:58,050
at this point but I'll get to that about

69
00:02:58,050 --> 00:03:00,690
promises and the second half of the

70
00:03:00,690 --> 00:03:05,190
presentation but yeah so the actual

71
00:03:05,190 --> 00:03:06,959
problem turned out to be that there

72
00:03:06,959 --> 00:03:08,760
weren't any JavaScript server-side

73
00:03:08,760 --> 00:03:10,590
implementations that were interesting

74
00:03:10,590 --> 00:03:12,300
enough to use that could differentiate

75
00:03:12,300 --> 00:03:14,940
themselves from from Java from other

76
00:03:14,940 --> 00:03:17,130
programming languages and implementation

77
00:03:17,130 --> 00:03:20,100
languages on the server side and the

78
00:03:20,100 --> 00:03:24,480
last year has really proven that out so

79
00:03:24,480 --> 00:03:26,790
what makes a good spec what are the

80
00:03:26,790 --> 00:03:28,440
things that common Jason come in here

81
00:03:28,440 --> 00:03:29,700
should be talking about and

82
00:03:29,700 --> 00:03:32,370
standardizing as a pretty pretty common

83
00:03:32,370 --> 00:03:34,769
question we get there there's for the

84
00:03:34,769 --> 00:03:38,160
last year we've really stepped back and

85
00:03:38,160 --> 00:03:39,810
let let things happen in the foreground

86
00:03:39,810 --> 00:03:41,940
which is just focused on some very core

87
00:03:41,940 --> 00:03:46,620
some very core proposals but but the

88
00:03:46,620 --> 00:03:48,239
Charter is very much the same we still

89
00:03:48,239 --> 00:03:49,799
need to get out there and have specs for

90
00:03:49,799 --> 00:03:51,420
the whole spectrum of things so that

91
00:03:51,420 --> 00:03:53,070
there can be there so that they're still

92
00:03:53,070 --> 00:03:54,750
can be an escape route and a degree of

93
00:03:54,750 --> 00:03:56,850
interoperability to the to the sense

94
00:03:56,850 --> 00:03:57,930
that it makes sense for there to be

95
00:03:57,930 --> 00:04:00,870
interoperability like if you have a

96
00:04:00,870 --> 00:04:04,200
package of code that has absolutely no

97
00:04:04,200 --> 00:04:07,200
dependence on Io it makes sense for

98
00:04:07,200 --> 00:04:09,720
there to be like a markdown package that

99
00:04:09,720 --> 00:04:11,190
just works in the browser and works in

100
00:04:11,190 --> 00:04:12,720
the works in the client and no

101
00:04:12,720 --> 00:04:16,350
difference so that yeah so working it in

102
00:04:16,350 --> 00:04:18,260
that way so what makes a good a good

103
00:04:18,260 --> 00:04:21,079
specification is a

104
00:04:21,079 --> 00:04:22,699
and it has to there have there has to be

105
00:04:22,699 --> 00:04:23,870
compelling reasons to write a spec

106
00:04:23,870 --> 00:04:26,000
because it's ten times harder to write a

107
00:04:26,000 --> 00:04:27,500
spec and get a whole bunch of people to

108
00:04:27,500 --> 00:04:30,020
agree on agree on it and it's not nearly

109
00:04:30,020 --> 00:04:33,500
as fun as hacking arguing with people is

110
00:04:33,500 --> 00:04:37,520
a real real pain so it really has to be

111
00:04:37,520 --> 00:04:39,349
worthwhile and what makes it my suspect

112
00:04:39,349 --> 00:04:41,360
worthwhile is if it builds a new

113
00:04:41,360 --> 00:04:43,310
ecosystem where a whole bunch of code

114
00:04:43,310 --> 00:04:45,370
can be written to be interoperable

115
00:04:45,370 --> 00:04:48,409
modules was a very obvious place for

116
00:04:48,409 --> 00:04:53,539
that basic asynchronous i/o by basic

117
00:04:53,539 --> 00:04:55,159
asynchronous programming constructs are

118
00:04:55,159 --> 00:04:57,500
another big one that that area hasn't

119
00:04:57,500 --> 00:04:59,509
settled so the so what makes a bad

120
00:04:59,509 --> 00:05:01,400
specification is specifying something

121
00:05:01,400 --> 00:05:03,440
that people don't agree on in the first

122
00:05:03,440 --> 00:05:04,430
place and there's a lot of room for

123
00:05:04,430 --> 00:05:08,990
experimentation so modules are sort of

124
00:05:08,990 --> 00:05:10,909
done ish and then we're moving on to

125
00:05:10,909 --> 00:05:13,789
packages packages are the next big thing

126
00:05:13,789 --> 00:05:17,000
that makes sense for common gs4 first

127
00:05:17,000 --> 00:05:19,789
sink for building new ecosystems of

128
00:05:19,789 --> 00:05:21,949
stuff so we have a stopgap proposal for

129
00:05:21,949 --> 00:05:25,669
packages called one point o this

130
00:05:25,669 --> 00:05:27,139
proposal doesn't really define any

131
00:05:27,139 --> 00:05:28,759
behavioral requirements it's sort of

132
00:05:28,759 --> 00:05:30,830
like I don't know if you've ever been in

133
00:05:30,830 --> 00:05:32,360
America we have the Liberty Bell it's

134
00:05:32,360 --> 00:05:33,979
this gigantic Bell that had a crack in

135
00:05:33,979 --> 00:05:35,690
it really early on and just kept on

136
00:05:35,690 --> 00:05:38,330
getting worse every winter and they

137
00:05:38,330 --> 00:05:40,279
drilled little hole a little hole at the

138
00:05:40,279 --> 00:05:41,719
end of the crack to relieve the pressure

139
00:05:41,719 --> 00:05:43,900
so that the crack wouldn't grow any more

140
00:05:43,900 --> 00:05:46,370
packages one point O is sort of like

141
00:05:46,370 --> 00:05:47,810
that and less about actually

142
00:05:47,810 --> 00:05:48,860
guaranteeing any degree of

143
00:05:48,860 --> 00:05:51,349
interoperability with packages in the

144
00:05:51,349 --> 00:05:53,089
skywriter talk upstairs they talked

145
00:05:53,089 --> 00:05:55,099
about just being able to give a common

146
00:05:55,099 --> 00:05:58,279
J's package and use it on the use it on

147
00:05:58,279 --> 00:06:00,409
the browser and the fact of the matter

148
00:06:00,409 --> 00:06:02,060
is that at the moment there are packages

149
00:06:02,060 --> 00:06:04,400
for Narwhal there are packages for NPM

150
00:06:04,400 --> 00:06:07,759
and their packages for for jet pack and

151
00:06:07,759 --> 00:06:09,830
bet on sky writer and none of them are

152
00:06:09,830 --> 00:06:11,979
actually interoperable but they do have

153
00:06:11,979 --> 00:06:15,589
the packages one point o in common which

154
00:06:15,589 --> 00:06:17,870
prevents them from diverging too much

155
00:06:17,870 --> 00:06:20,629
away from eventually of being able to

156
00:06:20,629 --> 00:06:22,129
specify their dependencies in a

157
00:06:22,129 --> 00:06:25,449
meaningful way the packages spec just

158
00:06:25,449 --> 00:06:28,389
reserves a bunch of names for things for

159
00:06:28,389 --> 00:06:31,159
metadata about packages so that

160
00:06:31,159 --> 00:06:33,030
eventually we can have an eco

161
00:06:33,030 --> 00:06:34,560
them that can analyze that data and use

162
00:06:34,560 --> 00:06:36,680
it for installers and stuff like that

163
00:06:36,680 --> 00:06:39,510
but Michael Rogers has been been pushing

164
00:06:39,510 --> 00:06:42,660
for for the last year on new packaging

165
00:06:42,660 --> 00:06:45,840
spec and there are three major proposals

166
00:06:45,840 --> 00:06:49,620
for extending packages for handling

167
00:06:49,620 --> 00:06:51,870
dependencies one of them is approached

168
00:06:51,870 --> 00:06:54,890
by NPM the four node by Isaac shooter

169
00:06:54,890 --> 00:06:59,490
there's another I wrote 12 years ago for

170
00:06:59,490 --> 00:07:01,610
a narwhal called tusk and it had a

171
00:07:01,610 --> 00:07:06,390
repository format as well and then there

172
00:07:06,390 --> 00:07:08,670
which is based off of this concept of

173
00:07:08,670 --> 00:07:11,070
overlays and then there's a third method

174
00:07:11,070 --> 00:07:12,930
but it's being presently promoted by

175
00:07:12,930 --> 00:07:15,150
chris's ID and as embodied and

176
00:07:15,150 --> 00:07:16,470
implemented through this node package

177
00:07:16,470 --> 00:07:21,210
called nodules so there are three major

178
00:07:21,210 --> 00:07:24,560
approaches there's overlays mappings and

179
00:07:24,560 --> 00:07:27,540
linking by version through a registry

180
00:07:27,540 --> 00:07:29,970
and none of them are really perfect and

181
00:07:29,970 --> 00:07:31,950
we still have a lot of a lot of room to

182
00:07:31,950 --> 00:07:35,160
experiment with these things let me

183
00:07:35,160 --> 00:07:37,380
describe some of the problems and

184
00:07:37,380 --> 00:07:38,760
benefits of each of these those

185
00:07:38,760 --> 00:07:42,210
approaches the the overlay approach is

186
00:07:42,210 --> 00:07:45,210
similar to Ruby that's what we used in

187
00:07:45,210 --> 00:07:48,840
narwhal and tusk and the the way it

188
00:07:48,840 --> 00:07:51,720
works is that it that the package

189
00:07:51,720 --> 00:07:53,430
manager is responsible for installing

190
00:07:53,430 --> 00:07:54,960
your packages and predictable locations

191
00:07:54,960 --> 00:07:57,690
and then Narwhal discovers all of those

192
00:07:57,690 --> 00:07:59,820
package locations upon initialization

193
00:07:59,820 --> 00:08:01,560
which takes an unreasonable amount of

194
00:08:01,560 --> 00:08:05,040
time in rhino anyway and the way it

195
00:08:05,040 --> 00:08:07,590
works is that it it goes into your main

196
00:08:07,590 --> 00:08:09,360
package directory and then does a

197
00:08:09,360 --> 00:08:12,690
breadth-first search of the packages

198
00:08:12,690 --> 00:08:14,370
directories of each package that is

199
00:08:14,370 --> 00:08:16,410
contained in that package transitively

200
00:08:16,410 --> 00:08:18,810
it discovers all of those packages and

201
00:08:18,810 --> 00:08:21,450
then looks at its dependency mapping and

202
00:08:21,450 --> 00:08:24,120
does a topological sort which linearize

203
00:08:24,120 --> 00:08:25,560
is all of the packages out and

204
00:08:25,560 --> 00:08:28,350
constructs a require paths array so that

205
00:08:28,350 --> 00:08:30,360
it knows so that are well knows where to

206
00:08:30,360 --> 00:08:32,250
search which directories to search for

207
00:08:32,250 --> 00:08:34,410
each of the each of the modules in all

208
00:08:34,410 --> 00:08:35,970
of the packages the problem with this

209
00:08:35,970 --> 00:08:38,160
approach is that it conflates the module

210
00:08:38,160 --> 00:08:40,350
name spaces of all of the installed

211
00:08:40,350 --> 00:08:42,720
packages than one of the advantages of

212
00:08:42,720 --> 00:08:44,700
the approach is that it really makes it

213
00:08:44,700 --> 00:08:45,880
easy to enjoy

214
00:08:45,880 --> 00:08:48,460
act engine specific code anywhere along

215
00:08:48,460 --> 00:08:50,950
the way and it also makes a really great

216
00:08:50,950 --> 00:08:52,840
composition mechanism if you have

217
00:08:52,840 --> 00:08:55,660
something like Django apps in JavaScript

218
00:08:55,660 --> 00:08:59,410
where you can have a media a media

219
00:08:59,410 --> 00:09:01,420
directory tree that can be searched for

220
00:09:01,420 --> 00:09:02,920
the most relevant stuff and you can

221
00:09:02,920 --> 00:09:04,240
stack it on top of each other and

222
00:09:04,240 --> 00:09:06,760
override lesser versions of that

223
00:09:06,760 --> 00:09:08,830
information that's the narwhal approach

224
00:09:08,830 --> 00:09:14,710
and it's 1 and n p.m. is the second one

225
00:09:14,710 --> 00:09:19,180
really and the way it works is that it

226
00:09:19,180 --> 00:09:21,340
creates symbolic links in a common

227
00:09:21,340 --> 00:09:22,840
directory so the difference in approach

228
00:09:22,840 --> 00:09:25,120
is that node does nothing at run time to

229
00:09:25,120 --> 00:09:26,860
discover anything about packages there's

230
00:09:26,860 --> 00:09:28,240
only a single directory that contains

231
00:09:28,240 --> 00:09:33,400
the entire module tree or a small number

232
00:09:33,400 --> 00:09:36,610
of them in a fixed require paths and the

233
00:09:36,610 --> 00:09:38,560
way the way it works is that the package

234
00:09:38,560 --> 00:09:41,790
manager is responsible for telling the

235
00:09:41,790 --> 00:09:45,070
entire system the names of every package

236
00:09:45,070 --> 00:09:46,930
and how to find them by using symbolic

237
00:09:46,930 --> 00:09:51,760
links so and and then thunk modules that

238
00:09:51,760 --> 00:09:55,390
alter the require paths as as you call

239
00:09:55,390 --> 00:09:57,970
through require which is a major

240
00:09:57,970 --> 00:10:00,090
disadvantage of the approaches that

241
00:10:00,090 --> 00:10:02,710
require behaves differently when called

242
00:10:02,710 --> 00:10:06,640
in different terms of the event loop so

243
00:10:06,640 --> 00:10:07,900
you really can't use that approach

244
00:10:07,900 --> 00:10:09,880
reliably when you have multiple versions

245
00:10:09,880 --> 00:10:14,950
of a particular package and ND recalling

246
00:10:14,950 --> 00:10:17,830
require at funny times which has largely

247
00:10:17,830 --> 00:10:19,000
not been a problem for the node

248
00:10:19,000 --> 00:10:36,180
community yet I'm sorry

249
00:10:36,190 --> 00:10:40,400
so Michael points out that that because

250
00:10:40,400 --> 00:10:42,710
requires synchronous during the context

251
00:10:42,710 --> 00:10:44,540
of the require call your required odds

252
00:10:44,540 --> 00:10:50,270
will be consistent I'll think about that

253
00:10:50,270 --> 00:10:54,020
a little bit more you just have to be

254
00:10:54,020 --> 00:10:55,820
very careful about anything where state

255
00:10:55,820 --> 00:10:58,340
is captured in your stack because it

256
00:10:58,340 --> 00:11:03,140
tends to vary from from turn to turn the

257
00:11:03,140 --> 00:11:05,570
other so the other disadvantage of this

258
00:11:05,570 --> 00:11:07,580
approach is that whenever you install a

259
00:11:07,580 --> 00:11:11,750
package well it establishes a race for

260
00:11:11,750 --> 00:11:14,210
naming packages there's a gold rush for

261
00:11:14,210 --> 00:11:16,100
the good names going on in the node

262
00:11:16,100 --> 00:11:19,730
community right now and ever and the

263
00:11:19,730 --> 00:11:21,920
collective consensus of everybody who's

264
00:11:21,920 --> 00:11:24,620
chosen a name is reserving names in your

265
00:11:24,620 --> 00:11:27,200
in every packages in every programs

266
00:11:27,200 --> 00:11:29,590
namespace effectively which makes for

267
00:11:29,590 --> 00:11:32,960
unpredictable unpredictable composition

268
00:11:32,960 --> 00:11:37,250
problems down the road possibly I really

269
00:11:37,250 --> 00:11:39,350
like the idea of having sovereignty at

270
00:11:39,350 --> 00:11:42,470
various layers of of naming conventions

271
00:11:42,470 --> 00:11:43,880
so that people in different roles have

272
00:11:43,880 --> 00:11:45,920
the ability to give names to things in

273
00:11:45,920 --> 00:11:48,050
their own scope so they have absolute

274
00:11:48,050 --> 00:11:51,380
control and one of the at I think of it

275
00:11:51,380 --> 00:11:54,920
as the the in a particular module your

276
00:11:54,920 --> 00:11:56,660
local scope should be sovereign to you

277
00:11:56,660 --> 00:11:59,090
you should not be you should not be

278
00:11:59,090 --> 00:12:00,650
subject to other people giving you other

279
00:12:00,650 --> 00:12:03,830
global variables in from from other

280
00:12:03,830 --> 00:12:05,570
modules you should have absolute control

281
00:12:05,570 --> 00:12:08,300
over the local variables in your scope

282
00:12:08,300 --> 00:12:10,940
similarly at the package layer where

283
00:12:10,940 --> 00:12:13,610
people are composing pieces of larger

284
00:12:13,610 --> 00:12:16,190
chunks of codes that have been produced

285
00:12:16,190 --> 00:12:19,940
by different developers you want to have

286
00:12:19,940 --> 00:12:22,100
sovereignty of earlier module namespace

287
00:12:22,100 --> 00:12:25,310
and ultimately you want to defer all of

288
00:12:25,310 --> 00:12:26,810
the responsible are all of the

289
00:12:26,810 --> 00:12:29,780
responsibility to for for naming things

290
00:12:29,780 --> 00:12:33,890
to IA na or just to urls in general so

291
00:12:33,890 --> 00:12:36,170
that you don't have to mediate conflicts

292
00:12:36,170 --> 00:12:39,200
and naming by talking to people who have

293
00:12:39,200 --> 00:12:41,990
authority you talk to get your domain

294
00:12:41,990 --> 00:12:44,410
and put it up it's at there's

295
00:12:44,410 --> 00:12:46,750
conflict but in any case so those are

296
00:12:46,750 --> 00:12:48,190
the major three approaches and we're

297
00:12:48,190 --> 00:12:49,959
still continuing experimentation with

298
00:12:49,959 --> 00:12:53,970
them I imagine at this point that what

299
00:12:53,970 --> 00:12:57,370
while it may seem like designed by

300
00:12:57,370 --> 00:13:00,009
committee sort of end result where you

301
00:13:00,009 --> 00:13:01,810
have little bits and pieces of each of

302
00:13:01,810 --> 00:13:03,100
these approaches I think each of them

303
00:13:03,100 --> 00:13:05,259
has their own merits and demerits and

304
00:13:05,259 --> 00:13:08,290
disadvantages so down the road I imagine

305
00:13:08,290 --> 00:13:12,160
that that the the packaging approach

306
00:13:12,160 --> 00:13:13,810
that we ultimately use will be a hybrid

307
00:13:13,810 --> 00:13:16,990
of these approaches where easy is simple

308
00:13:16,990 --> 00:13:22,079
and the long out problems are solvable

309
00:13:22,079 --> 00:13:24,639
so that's packages we also talked about

310
00:13:24,639 --> 00:13:28,209
binary in the first year we talked about

311
00:13:28,209 --> 00:13:30,310
binary in the context of making binary

312
00:13:30,310 --> 00:13:32,019
data types that resemble the rain string

313
00:13:32,019 --> 00:13:34,089
so that we could use to narrow City to

314
00:13:34,089 --> 00:13:36,009
our advantage and also because there are

315
00:13:36,009 --> 00:13:39,250
good security properties of strings you

316
00:13:39,250 --> 00:13:40,689
can give a string to somebody and

317
00:13:40,689 --> 00:13:43,870
they're guaranteed immutable by both the

318
00:13:43,870 --> 00:13:48,069
consumer and producer so we have that

319
00:13:48,069 --> 00:13:49,870
layer of abstraction for Strings and

320
00:13:49,870 --> 00:13:51,509
also it also was made to come

321
00:13:51,509 --> 00:13:53,860
accommodate older versions of browsers

322
00:13:53,860 --> 00:13:55,959
the idea was that people not browsers

323
00:13:55,959 --> 00:13:57,639
but older JavaScript engines the idea

324
00:13:57,639 --> 00:13:59,829
was that it could be implemented in pure

325
00:13:59,829 --> 00:14:02,380
JavaScript without involving the

326
00:14:02,380 --> 00:14:04,899
embedding which made it slightly of

327
00:14:04,899 --> 00:14:10,540
compromise with fast forward a year node

328
00:14:10,540 --> 00:14:12,399
has given us a buffer type so I went and

329
00:14:12,399 --> 00:14:14,199
took that and codified it and made some

330
00:14:14,199 --> 00:14:16,300
made some changes and revised the design

331
00:14:16,300 --> 00:14:19,389
and that's the binary F specification so

332
00:14:19,389 --> 00:14:22,240
node as essentially a command GS

333
00:14:22,240 --> 00:14:24,670
compliant buffer by virtue of being the

334
00:14:24,670 --> 00:14:28,449
inspiration of the spec and and and

335
00:14:28,449 --> 00:14:31,059
everybody else has one now now too now

336
00:14:31,059 --> 00:14:33,790
the neat thing about the the binary

337
00:14:33,790 --> 00:14:36,959
specs is that we have this more abstract

338
00:14:36,959 --> 00:14:40,449
byte string and byte array specification

339
00:14:40,449 --> 00:14:42,040
binary be and we have the buffer

340
00:14:42,040 --> 00:14:44,889
specification the more abstract one is

341
00:14:44,889 --> 00:14:47,559
easily implementable even including

342
00:14:47,559 --> 00:14:49,300
possibly campeon right semantics in

343
00:14:49,300 --> 00:14:51,370
terms of the lower level buffer the

344
00:14:51,370 --> 00:14:54,850
problem with buffer is there are a lot

345
00:14:54,850 --> 00:14:56,110
of problems with buffer if you ever

346
00:14:56,110 --> 00:14:57,310
introduced

347
00:14:57,310 --> 00:14:59,380
if you if you ever tried to use node in

348
00:14:59,380 --> 00:15:01,300
a secure way there's a buffers are

349
00:15:01,300 --> 00:15:04,050
they're never there never blanked out on

350
00:15:04,050 --> 00:15:06,100
initialization for because that would be

351
00:15:06,100 --> 00:15:08,020
a performance cost that note doesn't

352
00:15:08,020 --> 00:15:10,990
want to make but that means that if you

353
00:15:10,990 --> 00:15:13,060
have multiple distressful distrusting

354
00:15:13,060 --> 00:15:14,620
parties running in the same process

355
00:15:14,620 --> 00:15:16,480
through javascript which is a dream that

356
00:15:16,480 --> 00:15:19,990
is reliable I zabal through akma script

357
00:15:19,990 --> 00:15:23,800
five and harmony forward you won't be

358
00:15:23,800 --> 00:15:25,630
able to use buffers in those contexts

359
00:15:25,630 --> 00:15:28,529
because the there would be potential of

360
00:15:28,529 --> 00:15:31,720
binary garbage data linking into those

361
00:15:31,720 --> 00:15:35,200
contexts so that's binary but I really

362
00:15:35,200 --> 00:15:38,040
want to talk to you about promises today

363
00:15:38,040 --> 00:15:41,440
there's a there's a specification for

364
00:15:41,440 --> 00:15:43,270
problem bro there is a specification for

365
00:15:43,270 --> 00:15:45,040
promises long predating the entire

366
00:15:45,040 --> 00:15:48,370
common jsf effort by a fellow Tyler

367
00:15:48,370 --> 00:15:52,320
closed for a project called refs end and

368
00:15:52,320 --> 00:15:57,070
the queue API as he called it and I we

369
00:15:57,070 --> 00:16:00,970
carry forward is this really highly

370
00:16:00,970 --> 00:16:03,160
highly researched very carefully

371
00:16:03,160 --> 00:16:05,860
thought-out API for composing a

372
00:16:05,860 --> 00:16:08,500
synchronous asynchronous programs in

373
00:16:08,500 --> 00:16:11,970
reliable ways in the face of hazards

374
00:16:11,970 --> 00:16:14,830
distrust and all sorts of other all

375
00:16:14,830 --> 00:16:16,570
sorts of other other things so it's a

376
00:16:16,570 --> 00:16:18,339
really really robust way of dealing with

377
00:16:18,339 --> 00:16:21,790
asynchrony 80 so let me let me let me

378
00:16:21,790 --> 00:16:24,700
show you what oh I was going to talk

379
00:16:24,700 --> 00:16:27,120
about said exports don't have to do that

380
00:16:27,120 --> 00:16:30,760
or the module constructor or yeah we can

381
00:16:30,760 --> 00:16:34,570
come back to that this is a promise so

382
00:16:34,570 --> 00:16:36,640
the way whata promises is the

383
00:16:36,640 --> 00:16:38,680
unidirectional communication channel

384
00:16:38,680 --> 00:16:41,650
between a producer and a consumer

385
00:16:41,650 --> 00:16:43,660
possibly many producers possibly many

386
00:16:43,660 --> 00:16:47,290
consumers the way it works is that you

387
00:16:47,290 --> 00:16:50,110
construct vehic you defer a deferred a

388
00:16:50,110 --> 00:16:52,900
deferred is an object that contains a

389
00:16:52,900 --> 00:16:55,420
resolver and a promise and they are

390
00:16:55,420 --> 00:16:58,630
separate for a reason the idea is that

391
00:16:58,630 --> 00:17:01,180
you can give your promise is a

392
00:17:01,180 --> 00:17:01,940
capability

393
00:17:01,940 --> 00:17:04,890
to resolve the difference and the

394
00:17:04,890 --> 00:17:07,740
promises is it gives you the capability

395
00:17:07,740 --> 00:17:11,280
to observe that deference so you can

396
00:17:11,280 --> 00:17:12,449
give these two different people and they

397
00:17:12,449 --> 00:17:13,699
don't even have to like each other and

398
00:17:13,699 --> 00:17:16,140
and they're guaranteed to not be able to

399
00:17:16,140 --> 00:17:17,790
not be able to communicate in any other

400
00:17:17,790 --> 00:17:21,329
way then then the two objects that

401
00:17:21,329 --> 00:17:24,390
you've given and this leads to all sorts

402
00:17:24,390 --> 00:17:26,160
of interesting fun patterns like you can

403
00:17:26,160 --> 00:17:27,929
give the resolver to a bunch of people

404
00:17:27,929 --> 00:17:29,880
in the first the the first person to

405
00:17:29,880 --> 00:17:31,830
resolve it wins the race to resolve the

406
00:17:31,830 --> 00:17:35,549
thing and at all sorts of other patterns

407
00:17:35,549 --> 00:17:39,630
so more about deferred in this box in

408
00:17:39,630 --> 00:17:42,540
the middle I've disposed represents the

409
00:17:42,540 --> 00:17:46,010
two-state nature of a promise it has a

410
00:17:46,010 --> 00:17:48,870
before resolution state and a post

411
00:17:48,870 --> 00:17:51,690
resolution state before a resolution it

412
00:17:51,690 --> 00:17:54,299
its contents are a list of people who

413
00:17:54,299 --> 00:17:55,799
are interested in the value of the

414
00:17:55,799 --> 00:17:59,190
resolution and those by people I mean

415
00:17:59,190 --> 00:18:04,620
other promises so and then after the

416
00:18:04,620 --> 00:18:06,299
promise has been resolved it has a value

417
00:18:06,299 --> 00:18:08,549
and that value gets sent to all of the

418
00:18:08,549 --> 00:18:10,500
promises that are interested in that

419
00:18:10,500 --> 00:18:16,799
value and the promise in the resolver

420
00:18:16,799 --> 00:18:19,350
and these circles with the arrows on the

421
00:18:19,350 --> 00:18:21,450
inside are a sort of representation of a

422
00:18:21,450 --> 00:18:23,850
closure the idea is that if you have a

423
00:18:23,850 --> 00:18:26,280
reference coming out of the edge of a

424
00:18:26,280 --> 00:18:27,570
circle that's something that's a

425
00:18:27,570 --> 00:18:29,220
property of an object and an arrow

426
00:18:29,220 --> 00:18:31,799
coming from the inside is a property

427
00:18:31,799 --> 00:18:34,410
that is enclosed by the object that by

428
00:18:34,410 --> 00:18:36,240
the idea is that if you give an object

429
00:18:36,240 --> 00:18:38,730
to somebody else they have access to all

430
00:18:38,730 --> 00:18:40,080
of the capabilities that are on the

431
00:18:40,080 --> 00:18:41,669
surface of that object but not

432
00:18:41,669 --> 00:18:45,240
necessarily that they have to object all

433
00:18:45,240 --> 00:18:46,770
of the references inside of it so you

434
00:18:46,770 --> 00:18:51,549
can protect access to those things

435
00:18:51,559 --> 00:18:56,870
so here's a simple defer this is a this

436
00:18:56,870 --> 00:19:00,159
is an abstraction on the set timeout and

437
00:19:00,159 --> 00:19:02,690
it's really really simple the idea is

438
00:19:02,690 --> 00:19:05,570
you construct a deferred you call set

439
00:19:05,570 --> 00:19:07,639
timeout the callback is going to be the

440
00:19:07,639 --> 00:19:10,159
resolver and then you pass the time out

441
00:19:10,159 --> 00:19:11,330
as the second argument and then you

442
00:19:11,330 --> 00:19:13,399
return the promise so you've got the two

443
00:19:13,399 --> 00:19:16,639
parts the resolve is the resolver and

444
00:19:16,639 --> 00:19:19,730
the promise is a promise the what

445
00:19:19,730 --> 00:19:21,409
happens with resolve is it takes one

446
00:19:21,409 --> 00:19:23,600
argument in this case it's going to

447
00:19:23,600 --> 00:19:25,100
resolve to the value of undefined

448
00:19:25,100 --> 00:19:27,289
because set timeout is going to send

449
00:19:27,289 --> 00:19:29,419
done divine to it as its as its first

450
00:19:29,419 --> 00:19:33,619
argument so what this does is it returns

451
00:19:33,619 --> 00:19:34,999
a promise that will resolve after

452
00:19:34,999 --> 00:19:38,840
whatever time you provide and the way

453
00:19:38,840 --> 00:19:40,549
you observe the resolution of that

454
00:19:40,549 --> 00:19:43,220
promise is using a cute when he taught

455
00:19:43,220 --> 00:19:46,009
when was originally in the e programming

456
00:19:46,009 --> 00:19:50,659
language it was a clause it was more

457
00:19:50,659 --> 00:19:54,289
like a try-catch than a try-catch as an

458
00:19:54,289 --> 00:19:57,080
expression instead of just like instead

459
00:19:57,080 --> 00:19:58,820
of a function call but in JavaScript we

460
00:19:58,820 --> 00:20:02,749
can use a function call to do this it

461
00:20:02,749 --> 00:20:05,450
has it has a try claws and a catch

462
00:20:05,450 --> 00:20:07,639
clause effectively the way this works is

463
00:20:07,639 --> 00:20:11,330
that you pass a promise in or value as

464
00:20:11,330 --> 00:20:15,309
the as the argument to when and if it's

465
00:20:15,309 --> 00:20:19,999
if it's a if you give it a it treats it

466
00:20:19,999 --> 00:20:23,720
as a resolved promise so it will it will

467
00:20:23,720 --> 00:20:26,389
proceed almost immediately but not in

468
00:20:26,389 --> 00:20:28,399
the same turn if you give it a pure

469
00:20:28,399 --> 00:20:30,440
value which means that you can pass into

470
00:20:30,440 --> 00:20:32,840
when you can get just get a value from

471
00:20:32,840 --> 00:20:35,179
somebody else's API regardless of

472
00:20:35,179 --> 00:20:36,499
whether that API is returning you

473
00:20:36,499 --> 00:20:38,389
promises or values which makes for a

474
00:20:38,389 --> 00:20:41,899
really really clean level of abstraction

475
00:20:41,899 --> 00:20:44,980
where you can build a promise based API

476
00:20:44,980 --> 00:20:48,950
in terms of any API at all and the code

477
00:20:48,950 --> 00:20:54,519
is identical and the the first the first

478
00:20:54,519 --> 00:20:57,799
operand you get is a call back this is

479
00:20:57,799 --> 00:20:58,820
the call back that's going to be

480
00:20:58,820 --> 00:20:59,929
attached and it will

481
00:20:59,929 --> 00:21:01,730
deserve the resolution of the promise

482
00:21:01,730 --> 00:21:05,360
and it receives the fully resolved value

483
00:21:05,360 --> 00:21:09,860
is its argument from there you have the

484
00:21:09,860 --> 00:21:13,399
ability to return a new value so

485
00:21:13,399 --> 00:21:15,470
supposing that you were trying to to do

486
00:21:15,470 --> 00:21:18,619
a computation of some kind that depends

487
00:21:18,619 --> 00:21:20,840
on data from that there must be acquired

488
00:21:20,840 --> 00:21:22,970
asynchronously from somewhere you use a

489
00:21:22,970 --> 00:21:25,820
when block to observe the resolution of

490
00:21:25,820 --> 00:21:27,919
that promise perform your computation

491
00:21:27,919 --> 00:21:30,019
with that given value and then return

492
00:21:30,019 --> 00:21:34,490
that value to to whoever to whoever is

493
00:21:34,490 --> 00:21:36,619
asking to whoever who you are beholden

494
00:21:36,619 --> 00:21:38,809
to so if you're creating an asynchronous

495
00:21:38,809 --> 00:21:42,169
API all you have to do is use it in if

496
00:21:42,169 --> 00:21:44,090
you are both producing and consuming an

497
00:21:44,090 --> 00:21:45,559
asynchronous API you never have to use

498
00:21:45,559 --> 00:21:48,529
defer you just use Q dot when which will

499
00:21:48,529 --> 00:21:53,419
be most of the time and so you're

500
00:21:53,419 --> 00:21:55,820
consuming a and you're producing be the

501
00:21:55,820 --> 00:21:57,259
capital B is what you return to your

502
00:21:57,259 --> 00:21:59,749
consumer and that will be resolved with

503
00:21:59,749 --> 00:22:02,059
whatever you return from the from the

504
00:22:02,059 --> 00:22:10,159
inner block and the neat thing about

505
00:22:10,159 --> 00:22:12,889
promises is that they accurately model

506
00:22:12,889 --> 00:22:15,970
both returning from a function and

507
00:22:15,970 --> 00:22:19,369
throwing exceptions from a function and

508
00:22:19,369 --> 00:22:21,110
they do it in a single similar way to

509
00:22:21,110 --> 00:22:23,600
the way try-catch works in that you

510
00:22:23,600 --> 00:22:25,220
don't have to pay attention to the

511
00:22:25,220 --> 00:22:26,960
exception unless you are interested in

512
00:22:26,960 --> 00:22:30,740
the exception because if you do not

513
00:22:30,740 --> 00:22:34,220
provide a way to observe the rejection

514
00:22:34,220 --> 00:22:35,960
that rejection will be forwarded from

515
00:22:35,960 --> 00:22:38,600
your consumer from your producer to your

516
00:22:38,600 --> 00:22:42,049
consumer the way you do it was a

517
00:22:42,049 --> 00:22:43,789
constructive rejection it's just another

518
00:22:43,789 --> 00:22:46,340
promise q dot reject returns a promise

519
00:22:46,340 --> 00:22:49,369
that that embodies the knowledge that

520
00:22:49,369 --> 00:22:51,259
this promise has been rejected and you

521
00:22:51,259 --> 00:22:54,919
provide as as its as its argument any

522
00:22:54,919 --> 00:22:58,399
object you want strings are good that

523
00:22:58,399 --> 00:23:01,279
that tell you why the promise is being

524
00:23:01,279 --> 00:23:02,899
rejected sometimes it's interesting to

525
00:23:02,899 --> 00:23:04,490
provide additional metadata like my

526
00:23:04,490 --> 00:23:07,810
stack traces

527
00:23:07,820 --> 00:23:10,920
this is how you do error recovery with

528
00:23:10,920 --> 00:23:13,860
promises the qn receives as its second

529
00:23:13,860 --> 00:23:16,980
argument and airbag and it's not quite

530
00:23:16,980 --> 00:23:18,720
it's not quite an error back because

531
00:23:18,720 --> 00:23:21,650
it's it's responsible for either

532
00:23:21,650 --> 00:23:25,530
continuing to resolve the promise or to

533
00:23:25,530 --> 00:23:27,420
reject the promise so the value returned

534
00:23:27,420 --> 00:23:30,150
from the air back is going to be either

535
00:23:30,150 --> 00:23:31,980
your resolution or your continued

536
00:23:31,980 --> 00:23:34,110
rejection now you have an opportunity if

537
00:23:34,110 --> 00:23:35,730
you're rejecting it to construct a new

538
00:23:35,730 --> 00:23:40,980
rejection with more information or or to

539
00:23:40,980 --> 00:23:42,570
just use cute or reject and pass the

540
00:23:42,570 --> 00:23:45,770
reason through or provide a new value

541
00:23:45,770 --> 00:23:50,340
and if you omit the air back your the

542
00:23:50,340 --> 00:23:52,620
rejection reason from your producer will

543
00:23:52,620 --> 00:23:55,770
be forwarded to your consumer similarly

544
00:23:55,770 --> 00:23:58,470
if you omit the the call back the first

545
00:23:58,470 --> 00:24:01,080
argument the value that you've resolved

546
00:24:01,080 --> 00:24:03,960
to will be forwarded to your consumer so

547
00:24:03,960 --> 00:24:05,970
you can also use Q dot when to just

548
00:24:05,970 --> 00:24:10,170
attach air backs and not and to not

549
00:24:10,170 --> 00:24:15,630
attach callbacks this is how you use Q

550
00:24:15,630 --> 00:24:17,370
dot when in a calm count to do a

551
00:24:17,370 --> 00:24:19,460
compound computation suppose you're

552
00:24:19,460 --> 00:24:22,770
you're waiting for two different four to

553
00:24:22,770 --> 00:24:24,240
two different promises to resolve and

554
00:24:24,240 --> 00:24:26,610
these promises are potentially being

555
00:24:26,610 --> 00:24:30,210
resolved in parallel before before you

556
00:24:30,210 --> 00:24:32,070
call Q dot when you acquire promises for

557
00:24:32,070 --> 00:24:34,020
a and B so they're they're both off

558
00:24:34,020 --> 00:24:36,179
doing their job and then you use Q dot

559
00:24:36,179 --> 00:24:38,550
when nested to join those promises and

560
00:24:38,550 --> 00:24:40,200
then provide a computation based off of

561
00:24:40,200 --> 00:24:41,670
those two values so suppose you're going

562
00:24:41,670 --> 00:24:44,370
to a database and also making an HTTP

563
00:24:44,370 --> 00:24:47,010
request you can use this to get your

564
00:24:47,010 --> 00:24:50,730
database response in a and your HTTP

565
00:24:50,730 --> 00:24:52,500
response and be that performs some

566
00:24:52,500 --> 00:24:55,350
computation generate a new value or

567
00:24:55,350 --> 00:24:57,750
another promise the way the reason this

568
00:24:57,750 --> 00:25:00,210
works is that Q dot when in your

569
00:25:00,210 --> 00:25:01,830
callback all your air back you can

570
00:25:01,830 --> 00:25:04,290
return another promise to further defer

571
00:25:04,290 --> 00:25:06,780
so if you which is a pretty common

572
00:25:06,780 --> 00:25:08,220
pattern you're you're in your callback

573
00:25:08,220 --> 00:25:11,640
you're like oh I made progress but I'm

574
00:25:11,640 --> 00:25:15,980
not done yet you can you can then return

575
00:25:15,980 --> 00:25:18,679
promise to continue waiting and this is

576
00:25:18,679 --> 00:25:24,830
super super elegant some more

577
00:25:24,830 --> 00:25:26,690
complicated composition problems can be

578
00:25:26,690 --> 00:25:29,450
solved using our friend from computer

579
00:25:29,450 --> 00:25:33,470
science reduce I'm sorry these things

580
00:25:33,470 --> 00:25:35,000
can be really easily wrapped but I want

581
00:25:35,000 --> 00:25:37,520
to show you the guts because guts are

582
00:25:37,520 --> 00:25:41,480
cool in this particular case i'm using

583
00:25:41,480 --> 00:25:43,700
the reduce function who doesn't know how

584
00:25:43,700 --> 00:25:47,570
the reduce function works the reduce

585
00:25:47,570 --> 00:25:49,600
function works by taking an array of

586
00:25:49,600 --> 00:25:53,419
values and it tries to aggregate them to

587
00:25:53,419 --> 00:25:55,460
a single value using some function so

588
00:25:55,460 --> 00:25:58,309
the the trivial example of reduction is

589
00:25:58,309 --> 00:26:01,580
a sum so suppose it's important

590
00:26:01,580 --> 00:26:02,840
regardless of the order in which you

591
00:26:02,840 --> 00:26:06,710
resolve the you you can you combine the

592
00:26:06,710 --> 00:26:08,660
values in an array to construct it some

593
00:26:08,660 --> 00:26:11,840
it will always be the same Valte which

594
00:26:11,840 --> 00:26:13,790
isn't actually important but bear with

595
00:26:13,790 --> 00:26:16,429
me so if you take any two values from

596
00:26:16,429 --> 00:26:18,200
that and construct the sum you can take

597
00:26:18,200 --> 00:26:19,910
that out and then put the the sum in the

598
00:26:19,910 --> 00:26:21,410
array and eventually you'll be rude

599
00:26:21,410 --> 00:26:23,240
reduced down to a single value and

600
00:26:23,240 --> 00:26:25,429
that's what reduce returns reduce

601
00:26:25,429 --> 00:26:27,290
accepts as its arguments well if

602
00:26:27,290 --> 00:26:30,100
receives an array it except and a a

603
00:26:30,100 --> 00:26:33,530
function that takes the the so far

604
00:26:33,530 --> 00:26:36,410
accumulated value and also the value of

605
00:26:36,410 --> 00:26:37,910
interest at the point and then you

606
00:26:37,910 --> 00:26:40,250
return the new accumulated value it

607
00:26:40,250 --> 00:26:42,080
receives is an optional last argument a

608
00:26:42,080 --> 00:26:45,410
basis for the recursion although it is

609
00:26:45,410 --> 00:26:47,929
performed iteratively in the engine so

610
00:26:47,929 --> 00:26:49,880
the way this reduction method works is

611
00:26:49,880 --> 00:26:52,820
it's a supposing that you have an array

612
00:26:52,820 --> 00:26:56,299
of mixed values and promises what you

613
00:26:56,299 --> 00:26:58,910
can do is use this reduce method to wait

614
00:26:58,910 --> 00:27:00,980
for all of those promises to be resolved

615
00:27:00,980 --> 00:27:03,860
and then perform a computation on the on

616
00:27:03,860 --> 00:27:05,960
the aggregate values in this case it's a

617
00:27:05,960 --> 00:27:08,000
sum and the interesting thing about a

618
00:27:08,000 --> 00:27:11,330
reduce is it's strictly left to right so

619
00:27:11,330 --> 00:27:13,010
the way progress is going to be made by

620
00:27:13,010 --> 00:27:16,400
this particular pattern is all of

621
00:27:16,400 --> 00:27:17,929
supposing that there's a random

622
00:27:17,929 --> 00:27:20,000
distribution of resolutions and time as

623
00:27:20,000 --> 00:27:21,810
as you go through

624
00:27:21,810 --> 00:27:25,260
the game loop in turns you're going to

625
00:27:25,260 --> 00:27:26,670
get resolutions at different times and

626
00:27:26,670 --> 00:27:29,730
then whenever the the first two are

627
00:27:29,730 --> 00:27:31,710
resolved you're going to aggregate them

628
00:27:31,710 --> 00:27:34,410
and then when they're the third whenever

629
00:27:34,410 --> 00:27:35,640
the third is resolved you're going to

630
00:27:35,640 --> 00:27:37,770
aggregate it the fourth is already

631
00:27:37,770 --> 00:27:41,130
resolved but we wait until we have the

632
00:27:41,130 --> 00:27:44,190
accumulation of a and B and C 2 to

633
00:27:44,190 --> 00:27:47,460
accumulate them and the neat thing about

634
00:27:47,460 --> 00:27:50,130
promises is you can create various

635
00:27:50,130 --> 00:27:51,930
reducers for different scenarios you can

636
00:27:51,930 --> 00:27:53,970
create a left-to-right resolver you can

637
00:27:53,970 --> 00:27:55,890
/ left a right reducer you can do a

638
00:27:55,890 --> 00:27:57,510
right-to-left reducer you can do an

639
00:27:57,510 --> 00:27:59,640
opportunist to producer which reduces

640
00:27:59,640 --> 00:28:01,440
whenever values become depending on what

641
00:28:01,440 --> 00:28:03,390
the math is you can you can reduce out

642
00:28:03,390 --> 00:28:10,950
of order this is an M we're all really

643
00:28:10,950 --> 00:28:12,450
super familiar with procedural

644
00:28:12,450 --> 00:28:14,670
programming using continue and break and

645
00:28:14,670 --> 00:28:17,700
stuff like that so it's a using promises

646
00:28:17,700 --> 00:28:19,190
you do have to get a little clever with

647
00:28:19,190 --> 00:28:21,420
solving problems of how to do that kind

648
00:28:21,420 --> 00:28:26,700
of thing this is a solution for a break

649
00:28:26,700 --> 00:28:28,830
or a short circuiting reduction so the

650
00:28:28,830 --> 00:28:32,280
trick is that you want to continue you

651
00:28:32,280 --> 00:28:33,300
only want to continue making

652
00:28:33,300 --> 00:28:35,310
computations like searching the file

653
00:28:35,310 --> 00:28:37,200
system for for directories which was the

654
00:28:37,200 --> 00:28:40,050
case where this came up for me up to the

655
00:28:40,050 --> 00:28:41,580
point where you find the thing of

656
00:28:41,580 --> 00:28:43,080
interest and then you want to cut off

657
00:28:43,080 --> 00:28:45,630
the computation in this case the way the

658
00:28:45,630 --> 00:28:47,910
way to do this is to construct a chain

659
00:28:47,910 --> 00:28:52,380
of callbacks using reduce and the way

660
00:28:52,380 --> 00:28:55,200
the way this one works is I'm using the

661
00:28:55,200 --> 00:28:57,960
generic or a method to create an array

662
00:28:57,960 --> 00:29:00,210
of functions that perform some

663
00:29:00,210 --> 00:29:01,830
computation which in this case is just

664
00:29:01,830 --> 00:29:03,540
returning a letter of the alphabet and

665
00:29:03,540 --> 00:29:06,960
then I reduce from right to left and the

666
00:29:06,960 --> 00:29:10,350
reason for this is that I'm taking the

667
00:29:10,350 --> 00:29:12,630
rightmost function and making that the

668
00:29:12,630 --> 00:29:16,800
otherwise claws of a choice so in

669
00:29:16,800 --> 00:29:18,540
aggregate I'm creating essentially a

670
00:29:18,540 --> 00:29:21,090
linked list enclosures for functions to

671
00:29:21,090 --> 00:29:23,520
call next and then the function that

672
00:29:23,520 --> 00:29:25,440
comes out at the end is the first

673
00:29:25,440 --> 00:29:29,309
function I want to call so as if you

674
00:29:29,309 --> 00:29:32,669
if you follow this the otherwise call

675
00:29:32,669 --> 00:29:34,379
the basis for this is going to be

676
00:29:34,379 --> 00:29:36,210
rejection so if nothing if nothing

677
00:29:36,210 --> 00:29:38,940
returns a valuable value I'm going to

678
00:29:38,940 --> 00:29:42,059
get a rejection and for each of the each

679
00:29:42,059 --> 00:29:44,279
of the each of the components I'm going

680
00:29:44,279 --> 00:29:47,370
to get a letter of the alphabet and if

681
00:29:47,370 --> 00:29:48,330
the letter of the alphabet is

682
00:29:48,330 --> 00:29:49,830
uninteresting to me i'm going to call

683
00:29:49,830 --> 00:29:51,629
the otherwise function that was the

684
00:29:51,629 --> 00:29:54,090
accumulated the accumulated value and

685
00:29:54,090 --> 00:29:57,809
reduce and this this models the the

686
00:29:57,809 --> 00:30:02,220
order of execution this is how you do

687
00:30:02,220 --> 00:30:06,269
error recovery this is um I had this

688
00:30:06,269 --> 00:30:08,149
working at one point in our wall on node

689
00:30:08,149 --> 00:30:10,350
normal one note is not really going

690
00:30:10,350 --> 00:30:12,509
forward I'm in the process of

691
00:30:12,509 --> 00:30:14,580
translating all of that work into NPM

692
00:30:14,580 --> 00:30:16,409
packages like qu till which is done and

693
00:30:16,409 --> 00:30:18,899
qhttp which is sort of half done so I

694
00:30:18,899 --> 00:30:21,389
think that's one actually works the way

695
00:30:21,389 --> 00:30:24,299
this is an HTTP read retry loop so we're

696
00:30:24,299 --> 00:30:26,580
going to try to make a request several

697
00:30:26,580 --> 00:30:29,220
times there's going to be a constant

698
00:30:29,220 --> 00:30:32,220
time out between tries and you're going

699
00:30:32,220 --> 00:30:33,720
to type try and certain number of times

700
00:30:33,720 --> 00:30:41,159
before giving up and the you can also

701
00:30:41,159 --> 00:30:42,840
you can also model exponential back-off

702
00:30:42,840 --> 00:30:44,490
with this with without too much

703
00:30:44,490 --> 00:30:46,320
difficulty at all so the way this is

704
00:30:46,320 --> 00:30:48,330
working is I'm first going to call HTTP

705
00:30:48,330 --> 00:30:50,850
read on the URL this is going to issue

706
00:30:50,850 --> 00:30:53,879
an HTTP request and return a promise for

707
00:30:53,879 --> 00:30:56,220
the body of the response which may be

708
00:30:56,220 --> 00:31:00,029
rejected if it's not a 200 status and

709
00:31:00,029 --> 00:31:01,860
then I use Q dot when to wait for that

710
00:31:01,860 --> 00:31:04,230
content and I return it if it's good if

711
00:31:04,230 --> 00:31:08,429
there's an error I and there are no more

712
00:31:08,429 --> 00:31:11,129
times left I reject but if there are

713
00:31:11,129 --> 00:31:13,049
more times i'm going to further defer

714
00:31:13,049 --> 00:31:16,350
using my old delay thing from up top to

715
00:31:16,350 --> 00:31:19,499
wait the timeout and i'm not going to do

716
00:31:19,499 --> 00:31:22,619
another HTTP read retry with 11 fewer

717
00:31:22,619 --> 00:31:25,139
times and this looks recursive button an

718
00:31:25,139 --> 00:31:27,539
event loop you actually get a new stack

719
00:31:27,539 --> 00:31:29,159
each time you're on the body of a Q dot

720
00:31:29,159 --> 00:31:30,600
when let me tell you about some of the

721
00:31:30,600 --> 00:31:32,789
promises of Q dot win it I mean

722
00:31:32,789 --> 00:31:35,129
invariants no promises pardon I want to

723
00:31:35,129 --> 00:31:35,520
load

724
00:31:35,520 --> 00:31:38,400
my vocabulary too much q dot when

725
00:31:38,400 --> 00:31:40,770
guarantees that the inner callbacks are

726
00:31:40,770 --> 00:31:42,330
going to be called in a future turn of

727
00:31:42,330 --> 00:31:43,800
the event loop this is to prevent

728
00:31:43,800 --> 00:31:48,570
confusion logical confusion with in it

729
00:31:48,570 --> 00:31:50,520
permits you to do in one turn of the

730
00:31:50,520 --> 00:31:52,350
event loop to set up a whole bunch of

731
00:31:52,350 --> 00:31:54,170
things to happen in the future and

732
00:31:54,170 --> 00:31:56,490
guarantees that all of you all of the

733
00:31:56,490 --> 00:31:58,650
values in your lexical scope are going

734
00:31:58,650 --> 00:32:00,480
to be preserved for the duration of your

735
00:32:00,480 --> 00:32:02,310
turn you are in complete control of your

736
00:32:02,310 --> 00:32:04,980
of your values it also guarantees that

737
00:32:04,980 --> 00:32:07,890
the Q dot wind function guarantees that

738
00:32:07,890 --> 00:32:09,900
your callback in Arabic are only ever

739
00:32:09,900 --> 00:32:11,520
going to be called once and only one of

740
00:32:11,520 --> 00:32:13,200
them will be called so this is really

741
00:32:13,200 --> 00:32:16,140
resilient against many many hazards and

742
00:32:16,140 --> 00:32:21,750
malice even this is how you implement an

743
00:32:21,750 --> 00:32:25,530
HTTP request via xhr using promises I

744
00:32:25,530 --> 00:32:28,650
think everybody's done xhr is this

745
00:32:28,650 --> 00:32:33,480
pointed directly at we construct a

746
00:32:33,480 --> 00:32:37,320
response response deferral we

747
00:32:37,320 --> 00:32:40,470
constructed a row HTTP request we open

748
00:32:40,470 --> 00:32:41,280
it we set up the onreadystatechange

749
00:32:41,280 --> 00:32:44,820
andler and we resolved with the response

750
00:32:44,820 --> 00:32:46,500
text if it works we resolve with the

751
00:32:46,500 --> 00:32:50,610
rejection if it does not and we return

752
00:32:50,610 --> 00:32:52,260
the promise for the value and initiate

753
00:32:52,260 --> 00:32:53,910
HTTP request there's a little thing in

754
00:32:53,910 --> 00:32:56,370
here with the timeout equals set in and

755
00:32:56,370 --> 00:32:58,890
set timeout that that it that adds the

756
00:32:58,890 --> 00:33:02,520
set timeout semantics and it I think

757
00:33:02,520 --> 00:33:03,990
that one line really expresses the

758
00:33:03,990 --> 00:33:06,480
awesomeness of this API in one line I

759
00:33:06,480 --> 00:33:10,470
have implemented timeouts and because

760
00:33:10,470 --> 00:33:12,510
the promises guarantee that the first

761
00:33:12,510 --> 00:33:15,270
person to resolve the promise wins if

762
00:33:15,270 --> 00:33:17,820
it's rejected its rejected even if the

763
00:33:17,820 --> 00:33:20,430
HTTP avenge a request eventually manages

764
00:33:20,430 --> 00:33:22,980
to give you some data the timeouts out

765
00:33:22,980 --> 00:33:25,320
your your your promise we'll never be

766
00:33:25,320 --> 00:33:32,610
modified again this is a this is a

767
00:33:32,610 --> 00:33:34,200
demonstration of how promises can be

768
00:33:34,200 --> 00:33:38,370
used as currency so it even why that

769
00:33:38,370 --> 00:33:40,770
money has really freed up us freed us up

770
00:33:40,770 --> 00:33:43,080
from the barter of things promises have

771
00:33:43,080 --> 00:33:43,520
the

772
00:33:43,520 --> 00:33:50,560
to free us up from bartering reclose ok

773
00:33:50,560 --> 00:33:53,030
so our burning promises so if you have

774
00:33:53,030 --> 00:33:55,130
symmetric api's where responses and

775
00:33:55,130 --> 00:33:57,710
requests have a certain degree of

776
00:33:57,710 --> 00:33:59,060
symmetry these things can be passed

777
00:33:59,060 --> 00:34:01,340
around really easily so this is what

778
00:34:01,340 --> 00:34:04,130
happens here is that if you're issuing

779
00:34:04,130 --> 00:34:08,480
via the request API a request and the

780
00:34:08,480 --> 00:34:10,190
request is a promise and it returns a

781
00:34:10,190 --> 00:34:12,800
promise and this is completely

782
00:34:12,800 --> 00:34:15,140
asynchronous but looks very very

783
00:34:15,140 --> 00:34:20,300
synchronous I'm going to just skip this

784
00:34:20,300 --> 00:34:22,250
this is an hd2 PQ and promises there's a

785
00:34:22,250 --> 00:34:24,350
really cool promise implementation I

786
00:34:24,350 --> 00:34:27,110
mean there's a right really cool promise

787
00:34:27,110 --> 00:34:29,720
trick you can do where you can create a

788
00:34:29,720 --> 00:34:31,940
queue of promises and you can actually

789
00:34:31,940 --> 00:34:33,409
pop things off of the queue before

790
00:34:33,409 --> 00:34:35,330
they're resolved and it just construct

791
00:34:35,330 --> 00:34:39,110
this it's really cool look into it this

792
00:34:39,110 --> 00:34:40,669
is the implementation it works in

793
00:34:40,669 --> 00:34:43,490
browsers it works in node works on

794
00:34:43,490 --> 00:34:47,090
Narwhal it's really small there's no

795
00:34:47,090 --> 00:34:49,280
reason not to use it it really

796
00:34:49,280 --> 00:34:51,140
simplifies complicated asynchronous code

797
00:34:51,140 --> 00:34:52,580
both on the server and the client I

798
00:34:52,580 --> 00:34:56,870
really encourage its use you can get it

799
00:34:56,870 --> 00:35:00,440
on github with my alliterative name and

800
00:35:00,440 --> 00:35:03,170
cue as the project name you can also NPM

801
00:35:03,170 --> 00:35:07,850
install q it's there then I was going to

802
00:35:07,850 --> 00:35:09,320
show you some stuff from a utility

803
00:35:09,320 --> 00:35:10,880
library i created a qu till it's in

804
00:35:10,880 --> 00:35:13,040
progress this does shallow resolution of

805
00:35:13,040 --> 00:35:15,320
an array so it gets its implies you

806
00:35:15,320 --> 00:35:16,640
don't have to do use reduce you can just

807
00:35:16,640 --> 00:35:18,710
use the shallow resolver to take an

808
00:35:18,710 --> 00:35:20,270
array of promises and get a promise for

809
00:35:20,270 --> 00:35:23,150
an array instead and this can do a deep

810
00:35:23,150 --> 00:35:25,670
resolution which you have a whole tree

811
00:35:25,670 --> 00:35:27,460
of objects that may include promises and

812
00:35:27,460 --> 00:35:30,560
shameless plug since May I've been

813
00:35:30,560 --> 00:35:32,570
making a map of middle-earth it's like

814
00:35:32,570 --> 00:35:35,840
Google Maps it's really cool and because

815
00:35:35,840 --> 00:35:37,790
it wasn't awesome enough I also did in

816
00:35:37,790 --> 00:35:47,080
elvish and have a good day

