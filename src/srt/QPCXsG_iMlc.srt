1
00:00:21,619 --> 00:00:22,630
I'd like to open with a quote.

2
00:00:22,630 --> 00:00:28,250
I read a book the other day, about speaking
in public, and it said something about opening

3
00:00:28,250 --> 00:00:30,740
with a quote.

4
00:00:30,740 --> 00:00:33,070
Okay.

5
00:00:33,070 --> 00:00:34,070
It wasn't
actually a book.

6
00:00:34,070 --> 00:00:35,870
It was a web page.

7
00:00:35,870 --> 00:00:38,260
It was called...

8
00:00:38,260 --> 00:00:43,370
Top ten things you should
never do while giving a talk.

9
00:00:43,370 --> 00:00:45,340
But I'm going to open with a quote anyway.

10
00:00:45,340 --> 00:00:48,290
Because this is where it all started.

11
00:00:48,290 --> 00:00:56,670
We are about to study the idea of a
computational process.

12
00:00:56,670 --> 00:00:58,780
Computational processes are abstract beings
that

13
00:00:58,780 --> 00:01:01,010
inhabit computers.

14
00:01:01,010 --> 00:01:05,740
As they evolve, processes manipulate other
abstract things,

15
00:01:05,740 --> 00:01:07,600
called data.

16
00:01:07,600 --> 00:01:11,050
The evolution of a process is directed by
a pattern of rules

17
00:01:11,050 --> 00:01:13,110
called a program.

18
00:01:13,110 --> 00:01:15,759
People create programs to direct processes.

19
00:01:15,759 --> 00:01:21,310
In effect, we
conjure the spirits of the computer with our

20
00:01:21,310 --> 00:01:23,000
spells.

21
00:01:23,000 --> 00:01:26,009
So when I first read
that, two years ago, it was like something

22
00:01:26,009 --> 00:01:30,899
that had been misaligned suddenly
snapped into place.

23
00:01:30,899 --> 00:01:36,649
This idea that the code that we write, the
artifact that we're creating, and

24
00:01:36,649 --> 00:01:41,979
the process that unfurls in the system as
that is being evaluated are two

25
00:01:41,979 --> 00:01:42,979
separate things.

26
00:01:42,979 --> 00:01:44,240
This is so simple.

27
00:01:44,240 --> 00:01:46,830
It's such a fundamental idea.

28
00:01:46,830 --> 00:01:50,789
But it's so
easy to overlook.

29
00:01:50,789 --> 00:01:57,069
If our code is directing the evolution of
a process, then in

30
00:01:57,069 --> 00:02:01,600
many ways it's a lot like the DNA in a cell,
directing the evolution of that

31
00:02:01,600 --> 00:02:02,600
cell.

32
00:02:02,600 --> 00:02:06,320
But DNA is really the most boring part of
the cell.

33
00:02:06,320 --> 00:02:11,210
It just sits there,
curled up into little balls, being read, right?

34
00:02:11,210 --> 00:02:15,390
And all around it, there's
this fantastic machinery that's involved in

35
00:02:15,390 --> 00:02:20,400
finding pieces of the DNA in a
massively parallel way and unwrapping it and

36
00:02:20,400 --> 00:02:25,480
parsing it and opening it up and
copying pieces out of it into RNA, jotting

37
00:02:25,480 --> 00:02:31,010
it down, and RNA goes into the rest
of the cell and causes effects.

38
00:02:31,010 --> 00:02:35,410
Some of it gets pulled into ribosomes, which
are these amazing molecular machines that

39
00:02:35,410 --> 00:02:40,191
kind of ratchet in a little bit of
RNA and poop out a little bit of amino acid

40
00:02:40,191 --> 00:02:45,069
at the top, and they find the
right amino acids to match that sequence of

41
00:02:45,069 --> 00:02:50,670
codons in the RNA and then they
make this protein, which is like a data structure,

42
00:02:50,670 --> 00:02:52,290
that has active sites.

43
00:02:52,290 --> 00:02:53,930
It's
like an object in JavaScript.

44
00:02:53,930 --> 00:02:55,550
And it causes effects on other things.

45
00:02:55,550 --> 00:02:57,750
And we
can keep pushing this biological metaphor.

46
00:02:57,750 --> 00:03:03,549
But the point is that there's a
party going on in there, and we weren't invited.

47
00:03:03,549 --> 00:03:08,700
I want to go to that party.

48
00:03:08,700 --> 00:03:12,280
So this talk is a series of three steps.

49
00:03:12,280 --> 00:03:15,359
Of me
trying to find a path.

50
00:03:15,359 --> 00:03:18,379
To understand what's happening in this process,
as it's

51
00:03:18,379 --> 00:03:19,379
evolving.

52
00:03:19,379 --> 00:03:21,269
Step one is data.

53
00:03:21,269 --> 00:03:25,709
Our data structures in JavaScript are becoming
increasingly sophisticated.

54
00:03:25,709 --> 00:03:28,389
This is in response to our applications that
we're

55
00:03:28,389 --> 00:03:32,790
developing, becoming increasingly sophisticated,
and there's a lot of

56
00:03:32,790 --> 00:03:36,329
information added in asynchronous processes.

57
00:03:36,329 --> 00:03:40,450
And when we share mutable state
and asynchronous processes we have exactly

58
00:03:40,450 --> 00:03:44,019
the same problem that people in
other communities have when they share mutable

59
00:03:44,019 --> 00:03:47,030
state between threads in a
multi-threading environment.

60
00:03:47,030 --> 00:03:53,219
So now we've got things here, thing A, and
some

61
00:03:53,219 --> 00:03:58,150
other piece of code over here, thing B, and
these two things are communicating

62
00:03:58,150 --> 00:03:59,739
through a communication channel.

63
00:03:59,739 --> 00:04:01,810
Sharing messages back and forth.

64
00:04:01,810 --> 00:04:03,860
But if
they're also sharing mutable state, they're

65
00:04:03,860 --> 00:04:06,389
communicating through that too.

66
00:04:06,389 --> 00:04:09,750
And that communication happens instantly and
it bypasses the communication

67
00:04:09,750 --> 00:04:14,120
passageways of your application.

68
00:04:14,120 --> 00:04:17,769
So that means you have this spooky action
at a distance going on, when you're

69
00:04:17,769 --> 00:04:19,200
dealing with mutable state.

70
00:04:19,200 --> 00:04:20,200
Right?

71
00:04:20,200 --> 00:04:21,220
And it's...

72
00:04:21,220 --> 00:04:23,220
All right.

73
00:04:23,220 --> 00:04:24,220
So...

74
00:04:24,220 --> 00:04:27,250
We have
persistent data structures that help us have

75
00:04:27,250 --> 00:04:31,360
immutable data so we can reason
about our processes and our programs in a

76
00:04:31,360 --> 00:04:33,460
more effective fashion.

77
00:04:33,460 --> 00:04:35,500
And they do
that in a performant way, rather than having

78
00:04:35,500 --> 00:04:39,699
to deep copy everything like you
would if you were making immutable data yourself.

79
00:04:39,699 --> 00:04:44,080
So we're looking at two of
those, immutable JS and Mori, from a particular

80
00:04:44,080 --> 00:04:45,530
perspective.

81
00:04:45,530 --> 00:04:47,990
So you have to
know a little bit about (inaudible) trees.

82
00:04:47,990 --> 00:04:48,990
Or tris.

83
00:04:48,990 --> 00:04:50,310
Who says try?

84
00:04:50,310 --> 00:04:51,699
Who says
tree?

85
00:04:51,699 --> 00:04:53,580
Either way is fine.

86
00:04:53,580 --> 00:04:55,910
You're both right.

87
00:04:55,910 --> 00:05:00,400
As long as people understand what
you're saying.

88
00:05:00,400 --> 00:05:04,330
I'll try to say tri, because it disambiguates
better.

89
00:05:04,330 --> 00:05:11,389
But a
tri is a tree.

90
00:05:11,389 --> 00:05:16,620
This is just a super high level surface topology
of a

91
00:05:16,620 --> 00:05:17,620
(inaudible).

92
00:05:17,620 --> 00:05:19,410
They're really interesting data structures.

93
00:05:19,410 --> 00:05:22,270
We put all of our
values down at the bottom and use pieces of

94
00:05:22,270 --> 00:05:24,700
the key to walk down to that
value.

95
00:05:24,700 --> 00:05:28,479
We're going to hash those keys first, so we
can pull an unlimited

96
00:05:28,479 --> 00:05:29,720
number of bytes out of them.

97
00:05:29,720 --> 00:05:32,990
If we hit the end of the hash we rehash.

98
00:05:32,990 --> 00:05:36,350
So it
gives us consistent and unlimited hash lengths,

99
00:05:36,350 --> 00:05:37,840
so we can deal with conflicts.

100
00:05:37,840 --> 00:05:43,409
Because if two things have the same key or
the same piece of the hash of the

101
00:05:43,409 --> 00:05:46,550
key, then we have to go to the next piece
of the hash.

102
00:05:46,550 --> 00:05:49,800
So we're going to take
pieces of the hash, five bits at a time, and

103
00:05:49,800 --> 00:05:51,120
use that to walk down the street.

104
00:05:51,120 --> 00:05:54,570
Those five bits give us 32 possible values.

105
00:05:54,570 --> 00:05:59,940
So we're going to have an array of
32 possible values, up to 32 values, as the

106
00:05:59,940 --> 00:06:02,470
child of a particular node.

107
00:06:02,470 --> 00:06:06,050
And
that's going to dereference into its children.

108
00:06:06,050 --> 00:06:11,650
So the things you have to remember from that
are: 32 and hashing.

109
00:06:11,650 --> 00:06:13,169
Hashing
gives us good distribution properties.

110
00:06:13,169 --> 00:06:17,479
We would rather have shallow, wide
trees.

111
00:06:17,479 --> 00:06:21,240
We don't want deep trees, because depth increases
our space usage and

112
00:06:21,240 --> 00:06:26,199
also our time usage.

113
00:06:26,199 --> 00:06:29,509
So we're going to put these two libraries
under a

114
00:06:29,509 --> 00:06:30,509
microscope.

115
00:06:30,509 --> 00:06:32,449
We're going to use a thing called underscore,
which is kind of

116
00:06:32,449 --> 00:06:36,439
like a data structure oscilloscope or something.

117
00:06:36,439 --> 00:06:38,330
And this is slightly the
wrong aspect ratio.

118
00:06:38,330 --> 00:06:41,229
So you're not seeing all of the slides.

119
00:06:41,229 --> 00:06:42,229
That just says...

120
00:06:42,229 --> 00:06:44,900
Full history of the data structure down there.

121
00:06:44,900 --> 00:06:46,100
Okay.

122
00:06:46,100 --> 00:06:51,680
So these are the joys of AV confusion.

123
00:06:51,680 --> 00:06:52,680
Which was...

124
00:06:52,680 --> 00:06:53,680
Yeah, my fault, not
theirs.

125
00:06:53,680 --> 00:06:56,270
They did an excellent job of recovering from
that.

126
00:06:56,270 --> 00:06:58,680
So we're going to
write out our data structure as a single long

127
00:06:58,680 --> 00:06:59,710
list.

128
00:06:59,710 --> 00:07:00,740
Right?

129
00:07:00,740 --> 00:07:03,100
We're going to take
all of the numbers in it, and for each number

130
00:07:03,100 --> 00:07:05,379
in it, we're going to generate a
pixel.

131
00:07:05,379 --> 00:07:07,379
That pixel will be colored according to that
number.

132
00:07:07,379 --> 00:07:10,900
We're going to
take that line of pixels, turn it on its side

133
00:07:10,900 --> 00:07:16,240
and make a column, and every
time we make a new version of this data structure,

134
00:07:16,240 --> 00:07:18,150
we're going to move
everything over and put the new column in

135
00:07:18,150 --> 00:07:21,419
place, so we can see the history of
it.

136
00:07:21,419 --> 00:07:27,740
So let's cross our fingers and see if we can
see what that looks like.

137
00:07:27,740 --> 00:07:29,670
Here we
are...

138
00:07:29,670 --> 00:07:31,960
Oh, man.

139
00:07:31,960 --> 00:07:32,960
Aspect ratios!

140
00:07:32,960 --> 00:07:33,990
All right.

141
00:07:33,990 --> 00:07:37,669
So everything is kind of up in this
corner.

142
00:07:37,669 --> 00:07:39,319
But that's cool.

143
00:07:39,319 --> 00:07:40,389
We can zoom here.

144
00:07:40,389 --> 00:07:42,430
This is the power of zoom.

145
00:07:42,430 --> 00:07:43,849
All
right.

146
00:07:43,849 --> 00:07:49,580
So what we've done here is to start putting
in some numbers.

147
00:07:49,580 --> 00:07:51,100
We see
this triangle shape.

148
00:07:51,100 --> 00:07:52,100
That's what we're expecting.

149
00:07:52,100 --> 00:07:54,860
Because every single tick,
we're adding a new number, enqueuing a new

150
00:07:54,860 --> 00:07:55,860
number.

151
00:07:55,860 --> 00:07:59,039
We see random numbers here.

152
00:07:59,039 --> 00:08:01,889
Those correlate to the numbers that we've
added.

153
00:08:01,889 --> 00:08:05,349
So it just stays in place in
this queue.

154
00:08:05,349 --> 00:08:09,819
The secondary feature we can pick out here
is these shaded areas,

155
00:08:09,819 --> 00:08:13,120
which are shaded...

156
00:08:13,120 --> 00:08:17,490
They're less light, because they are down
an extra level.

157
00:08:17,490 --> 00:08:20,430
So the lightness is corresponding to our depth
in the tree.

158
00:08:20,430 --> 00:08:23,120
This area is down
an extra level, so we can see it fills up

159
00:08:23,120 --> 00:08:24,759
with 32 things.

160
00:08:24,759 --> 00:08:27,370
And then those get
added to the main data structure.

161
00:08:27,370 --> 00:08:29,889
And we start a new nursery at that point.

162
00:08:29,889 --> 00:08:32,590
Everybody on board so far?

163
00:08:32,590 --> 00:08:35,440
So both
of these -- and I've cleverly code named them

164
00:08:35,440 --> 00:08:40,140
blue and red -- because this is
not a performance comparison between Mori

165
00:08:40,140 --> 00:08:41,870
and immutable JS.

166
00:08:41,870 --> 00:08:45,290
It's just -- we're
going to use these as a way of understanding

167
00:08:45,290 --> 00:08:49,690
what's happening in the process
and in the program by looking at the data.

168
00:08:49,690 --> 00:08:53,470
Additionally, even if you figure
out which is which, which is not very hard,

169
00:08:53,470 --> 00:08:56,960
after I hit a couple more buttons
-- I'm using older versions of them.

170
00:08:56,960 --> 00:09:00,630
So it's not an effective performance
comparison.

171
00:09:00,630 --> 00:09:02,450
So we start taking numbers off.

172
00:09:02,450 --> 00:09:07,889
They look more or less the same,
but suddenly we see a really big difference.

173
00:09:07,889 --> 00:09:14,150
Here in the blue zone, we have a
data structure that is the same size.

174
00:09:14,150 --> 00:09:15,170
Right?

175
00:09:15,170 --> 00:09:18,839
Here it was growing and here it's
the same size every tick.

176
00:09:18,839 --> 00:09:21,740
And what we're doing every single tick is
pushing on

177
00:09:21,740 --> 00:09:24,271
a number and dequeuing a number off of this
end.

178
00:09:24,271 --> 00:09:27,740
And we can see it's actually
happening in the data structure.

179
00:09:27,740 --> 00:09:28,740
Right?

180
00:09:28,740 --> 00:09:32,640
There's a couple of strange little
places in here, like this little blip here,

181
00:09:32,640 --> 00:09:34,670
that occurs about six ticks in.

182
00:09:34,670 --> 00:09:36,470
I
have no idea why but it's there every single

183
00:09:36,470 --> 00:09:38,399
time -- I haven't looked at the
code for either of these.

184
00:09:38,399 --> 00:09:41,010
The point is to understand it by looking at
the

185
00:09:41,010 --> 00:09:42,010
pictures.

186
00:09:42,010 --> 00:09:45,910
So this is a traditional queue, other than
the fact that we still have our

187
00:09:45,910 --> 00:09:47,579
nurseries going.

188
00:09:47,579 --> 00:09:51,430
Shifting off of one end and pushing onto the
other end.

189
00:09:51,430 --> 00:09:55,420
There's probably some performance implications
here, because shift or unshift,

190
00:09:55,420 --> 00:09:59,020
whichever one we use, in JavaScript is not
a very fast function.

191
00:09:59,020 --> 00:10:01,990
Over here
we're doing something completely different.

192
00:10:01,990 --> 00:10:07,269
In particular, we can see that a
whole new triangle has emerged, and we're

193
00:10:07,269 --> 00:10:09,889
keeping the old data up here.

194
00:10:09,889 --> 00:10:13,110
So
what we infer from this is that rather than

195
00:10:13,110 --> 00:10:16,010
destroying things as we dequeue
them, we're keeping pointers.

196
00:10:16,010 --> 00:10:17,860
And in fact, we can see these pointers here
in

197
00:10:17,860 --> 00:10:19,470
this middle section.

198
00:10:19,470 --> 00:10:23,860
We're keeping pointers into this data and
we're floating

199
00:10:23,860 --> 00:10:26,209
a counter to the end of it.

200
00:10:26,209 --> 00:10:27,950
As we dequeue things.

201
00:10:27,950 --> 00:10:32,639
And then when we hit the end of the old kind
of master section or new growth

202
00:10:32,639 --> 00:10:36,610
section, we're dropping everything.

203
00:10:36,610 --> 00:10:41,120
And this new growth section down here
becomes a new old one, and it starts getting

204
00:10:41,120 --> 00:10:43,420
dequeued, and we start over again
here.

205
00:10:43,420 --> 00:10:46,760
Does that kind of make sense so far?

206
00:10:46,760 --> 00:10:50,630
So what we understand at this point
is that there's a massive difference between

207
00:10:50,630 --> 00:10:53,110
these two libraries and how they
handle queues.

208
00:10:53,110 --> 00:10:55,820
In particular, there may be some performance
implications for

209
00:10:55,820 --> 00:10:57,470
that difference.

210
00:10:57,470 --> 00:11:00,240
We understand this not by looking at the code,
but just by

211
00:11:00,240 --> 00:11:01,400
looking at these pictures.

212
00:11:01,400 --> 00:11:04,070
Let me show you another example.

213
00:11:04,070 --> 00:11:07,550
We're going to
start throwing random numbers in here.

214
00:11:07,550 --> 00:11:11,560
So we'll take a number and we'll give
it a key that is the number with the letter

215
00:11:11,560 --> 00:11:15,160
pre-pended, and insert this into
the map.

216
00:11:15,160 --> 00:11:18,970
So what do we immediately see when we're looking
at this?

217
00:11:18,970 --> 00:11:21,710
We
immediately see that this blue side is about

218
00:11:21,710 --> 00:11:26,000
twice as tall as the red side
over here.

219
00:11:26,000 --> 00:11:30,899
And so we can start to think that maybe there's
some spatial implications

220
00:11:30,899 --> 00:11:31,899
here.

221
00:11:31,899 --> 00:11:32,899
Right?

222
00:11:32,899 --> 00:11:34,960
That our space usage is a little bit stronger
over here.

223
00:11:34,960 --> 00:11:39,480
Let's
turn on another way of looking at this.

224
00:11:39,480 --> 00:11:41,230
So this is a flattened tree view.

225
00:11:41,230 --> 00:11:43,770
What
we're going to do is take our tree with all

226
00:11:43,770 --> 00:11:48,269
of its levels, and we're going to
flatten every single level.

227
00:11:48,269 --> 00:11:49,589
And then we're going to turn the whole thing
on

228
00:11:49,589 --> 00:11:51,180
its side.

229
00:11:51,180 --> 00:11:54,860
So if we look over here, we can see that we
have our initial node

230
00:11:54,860 --> 00:11:59,130
here, this blue is a pointer to the secondary
node here, this points to an

231
00:11:59,130 --> 00:12:04,540
array of 32 pointers, each point to a dereference
column here, and then those

232
00:12:04,540 --> 00:12:08,260
point to this array over here, and so on.

233
00:12:08,260 --> 00:12:10,209
But just from eyeballing this...

234
00:12:10,209 --> 00:12:13,820
I don't know how much of this you can
actually see...

235
00:12:13,820 --> 00:12:20,230
We can see that these are adding new key value
pairs in very

236
00:12:20,230 --> 00:12:21,370
different ways.

237
00:12:21,370 --> 00:12:22,850
This one is a lot more compact.

238
00:12:22,850 --> 00:12:27,390
So this reconfirms our
intuition that we saw just from looking at

239
00:12:27,390 --> 00:12:28,759
the sizes.

240
00:12:28,759 --> 00:12:34,430
Let's try, instead of
adding these randomly, adding them...

241
00:12:34,430 --> 00:12:36,040
Hang on.

242
00:12:36,040 --> 00:12:37,660
Come on.

243
00:12:37,660 --> 00:12:38,730
You can do it.

244
00:12:38,730 --> 00:12:40,390
All
right.

245
00:12:40,390 --> 00:12:46,120
Apparently the reload button is not actually
the reload button.

246
00:12:46,120 --> 00:12:48,130
Borrowed laptop issues.

247
00:12:48,130 --> 00:12:50,690
All right.

248
00:12:50,690 --> 00:12:54,170
What's happening here?

249
00:12:54,170 --> 00:12:57,759
Now we're loading in
numbers sequentially, instead of randomly.

250
00:12:57,759 --> 00:13:01,329
And something that we started to
see toward the end of this one becomes very

251
00:13:01,329 --> 00:13:02,970
clear.

252
00:13:02,970 --> 00:13:05,680
We're seeing this banding effect.

253
00:13:05,680 --> 00:13:09,899
Whereas these colors are well distributed,
these colors are patterned in a very particular

254
00:13:09,899 --> 00:13:10,899
way.

255
00:13:10,899 --> 00:13:12,650
And what that's telling
us -- if we look here, we can see the same

256
00:13:12,650 --> 00:13:13,650
story.

257
00:13:13,650 --> 00:13:18,130
This one, even though we're
adding them sequentially, is well populated.

258
00:13:18,130 --> 00:13:19,460
It's fairly dense.

259
00:13:19,460 --> 00:13:25,370
Over here, we
see something that has these increasing sort

260
00:13:25,370 --> 00:13:30,430
of harmonic oscillations that are
going on in the number of collisions.

261
00:13:30,430 --> 00:13:36,440
So this tells us that the hashing
algorithm that blue is using is not distributing

262
00:13:36,440 --> 00:13:40,660
values or keys as well as the
hashing algorithm that red is using.

263
00:13:40,660 --> 00:13:43,600
In fact, we're getting very bad hashing
behavior out of this.

264
00:13:43,600 --> 00:13:47,279
It's probably modulo or something like that.

265
00:13:47,279 --> 00:13:49,670
Oh, dear.

266
00:13:49,670 --> 00:13:52,890
Fortunately, that was actually the end of
the conclusions that we were going

267
00:13:52,890 --> 00:13:53,890
to draw from that.

268
00:13:53,890 --> 00:13:59,930
So what we've learned so far is that you should
always

269
00:13:59,930 --> 00:14:03,350
bring a backup laptop when you're giving a
talk.

270
00:14:03,350 --> 00:14:08,240
And the second thing that
we've learned is that we can make observations

271
00:14:08,240 --> 00:14:11,610
about a piece of code without
ever looking at that code at all.

272
00:14:11,610 --> 00:14:13,500
So we've learned something about these two
libraries.

273
00:14:13,500 --> 00:14:15,279
But we didn't have to look at any code.

274
00:14:15,279 --> 00:14:21,519
And that's important,
because it doesn't matter how good or poorly

275
00:14:21,519 --> 00:14:24,490
written that code was.

276
00:14:24,490 --> 00:14:26,190
Right?

277
00:14:26,190 --> 00:14:27,260
It
could be obfuscated.

278
00:14:27,260 --> 00:14:28,550
Both of these are well written libraries.

279
00:14:28,550 --> 00:14:30,420
But it doesn't
matter.

280
00:14:30,420 --> 00:14:40,920
For example, if a library is the framework
we're using or that someone

281
00:14:40,920 --> 00:14:44,610
else is using, we have to take over maintenance
of that code, there's hundreds

282
00:14:44,610 --> 00:14:48,250
of thousands of lines in the framework, so
we could read the entire thing to

283
00:14:48,250 --> 00:14:53,551
understand how it works, or we could try to
go in the back door and try to

284
00:14:53,551 --> 00:14:58,240
develop our intuitions by actually observing
the process unfolding.

285
00:14:58,240 --> 00:14:59,899
So one
problem that we saw...

286
00:14:59,899 --> 00:15:02,940
Or I guess we didn't see, but we should have
seen --

287
00:15:02,940 --> 00:15:04,709
was that there was limited screen real estate.

288
00:15:04,709 --> 00:15:05,709
We had the opposite problem.

289
00:15:05,709 --> 00:15:09,220
There was way too much screen real estate.

290
00:15:09,220 --> 00:15:14,890
So fitting everything in can be an
issue.

291
00:15:14,890 --> 00:15:16,980
Sorry?

292
00:15:16,980 --> 00:15:22,170
Will that actually work with images?

293
00:15:22,170 --> 00:15:23,170
It works!

294
00:15:23,170 --> 00:15:24,699
That's so great.

295
00:15:24,699 --> 00:15:27,170
Thank
you!

296
00:15:27,170 --> 00:15:29,540
Cool.

297
00:15:29,540 --> 00:15:33,220
So we have some issues with the amount of
available space to us.

298
00:15:33,220 --> 00:15:35,209
So
we could, for example, look at a single line

299
00:15:35,209 --> 00:15:40,779
of code, and observe this line of
code, or we could observe the entire code

300
00:15:40,779 --> 00:15:41,779
base.

301
00:15:41,779 --> 00:15:42,779
Right?

302
00:15:42,779 --> 00:15:43,990
And watch the entire
process unfolding.

303
00:15:43,990 --> 00:15:47,100
So we can kind of pick a place along this
continuum that

304
00:15:47,100 --> 00:15:48,279
we're interested in.

305
00:15:48,279 --> 00:15:51,180
We could also, on the temporal dimension,
look at a

306
00:15:51,180 --> 00:15:53,490
single operation at a time.

307
00:15:53,490 --> 00:15:57,670
Or we could look at the entire process unfolding
in realtime.

308
00:15:57,670 --> 00:16:01,980
And so we have really good tools for this
end of the spectrum.

309
00:16:01,980 --> 00:16:05,220
For looking at a single operation, one at
a time.

310
00:16:05,220 --> 00:16:06,220
Right?

311
00:16:06,220 --> 00:16:08,209
Step-through
debuggers work great for this.

312
00:16:08,209 --> 00:16:10,959
And they give us a street level view of what's
happening.

313
00:16:10,959 --> 00:16:11,959
Right?

314
00:16:11,959 --> 00:16:15,130
We're taking -- we're walking through the
town of our process.

315
00:16:15,130 --> 00:16:18,839
But they
don't give us the 10,000-foot view of what's

316
00:16:18,839 --> 00:16:25,120
happening all at once, so we can
develop our intuitions about it, and we don't

317
00:16:25,120 --> 00:16:26,800
have very good tools for that
right now.

318
00:16:26,800 --> 00:16:28,870
So that's what's on the left hand of the slide.

319
00:16:28,870 --> 00:16:33,050
On the right hand
is some mathematics that ostensibly proves

320
00:16:33,050 --> 00:16:36,880
that the information we have is
greater than the information we would like

321
00:16:36,880 --> 00:16:41,660
to have, but really it's a ham
handed way of trying to work the '80s theme

322
00:16:41,660 --> 00:16:44,890
into my presentation.

323
00:16:44,890 --> 00:16:49,950
All right.

324
00:16:49,950 --> 00:16:52,480
So...

325
00:16:52,480 --> 00:16:54,060
What we're going to do...

326
00:16:54,060 --> 00:16:56,940
Because JavaScript is huge -- the ES5 spec
is

327
00:16:56,940 --> 00:17:01,050
over 250 pages, and because we write huge
applications in it, we're going to

328
00:17:01,050 --> 00:17:04,410
punt a little on this problem and we're going
to start with a system where we

329
00:17:04,410 --> 00:17:09,310
can see everything at full granularity, with
the entire process, all at the

330
00:17:09,310 --> 00:17:10,589
same time.

331
00:17:10,589 --> 00:17:11,589
Okay?

332
00:17:11,589 --> 00:17:14,690
So that means we're going to have to design
a language.

333
00:17:14,690 --> 00:17:16,069
We
have some design constraints for this.

334
00:17:16,069 --> 00:17:20,120
We're going to keep it very simple, so
we have an 8-bit architecture.

335
00:17:20,120 --> 00:17:24,760
Our memory is going to be 256 bytes.

336
00:17:24,760 --> 00:17:26,650
And we
would like to introduce random programs, because

337
00:17:26,650 --> 00:17:30,750
the whole idea is to gain
intuition about the process that's unfolding

338
00:17:30,750 --> 00:17:33,630
from a program without actually
understanding the program.

339
00:17:33,630 --> 00:17:35,220
If we understand the program, then we don't
need to

340
00:17:35,220 --> 00:17:36,390
do that.

341
00:17:36,390 --> 00:17:37,390
Right?

342
00:17:37,390 --> 00:17:38,390
So we need random programs.

343
00:17:38,390 --> 00:17:39,940
So that means we're going to fuzz the compiler.

344
00:17:39,940 --> 00:17:42,010
We
would like there not to be any compile time

345
00:17:42,010 --> 00:17:43,010
errors when we do this.

346
00:17:43,010 --> 00:17:45,820
We would
like there not to be any runtime errors.

347
00:17:45,820 --> 00:17:50,250
And I will throw in an additional
constraint that we want all of our programs

348
00:17:50,250 --> 00:17:51,980
to terminate.

349
00:17:51,980 --> 00:17:54,850
This sounds easy,
right?

350
00:17:54,850 --> 00:17:55,850
Sure.

351
00:17:55,850 --> 00:17:58,380
Oh my gosh.

352
00:17:58,380 --> 00:18:00,760
It's so tiny.

353
00:18:00,760 --> 00:18:01,960
Woo!

354
00:18:01,960 --> 00:18:04,350
All right.

355
00:18:04,350 --> 00:18:10,260
So here is a program in
our language, and this, over on the right,

356
00:18:10,260 --> 00:18:14,890
is supposed to be the JSConf
Pegasus, but...

357
00:18:14,890 --> 00:18:16,450
My pixel art skills are not very good.

358
00:18:16,450 --> 00:18:20,900
It looks more like a
flying aardvark with a Tommy gun or something.

359
00:18:20,900 --> 00:18:22,380
(laughter)

360
00:18:22,380 --> 00:18:25,350
>> All right.

361
00:18:25,350 --> 00:18:27,900
So if we run this, we can see that it's some
type of

362
00:18:27,900 --> 00:18:30,800
image-blurring program.

363
00:18:30,800 --> 00:18:33,420
And just so you know that...

364
00:18:33,420 --> 00:18:34,950
Really?

365
00:18:34,950 --> 00:18:36,480
Okay.

366
00:18:36,480 --> 00:18:45,610
Did I get
bounced off the subnet?

367
00:18:45,610 --> 00:18:50,000
Is that why I can't refresh?

368
00:18:50,000 --> 00:18:51,000
Agh!

369
00:18:51,000 --> 00:18:52,140
Thank you.

370
00:18:52,140 --> 00:18:53,270
Okay.

371
00:18:53,270 --> 00:18:54,400
So...

372
00:18:54,400 --> 00:18:56,590
I was going to show you that we could edit
the program and it would

373
00:18:56,590 --> 00:18:57,590
still work.

374
00:18:57,590 --> 00:18:58,590
You'll have to take my word for that.

375
00:18:58,590 --> 00:19:01,799
That's the magic of live
demos.

376
00:19:01,799 --> 00:19:03,350
So that's great.

377
00:19:03,350 --> 00:19:06,050
But we're not seeing individual steps.

378
00:19:06,050 --> 00:19:08,380
So we want to
go back and be able to actually see things

379
00:19:08,380 --> 00:19:10,169
at a granular level.

380
00:19:10,169 --> 00:19:14,190
So now we can
see the stack, we can see the return stack.

381
00:19:14,190 --> 00:19:15,630
These are the two...

382
00:19:15,630 --> 00:19:17,510
This is the
entire process unfolding.

383
00:19:17,510 --> 00:19:18,799
We see the memory.

384
00:19:18,799 --> 00:19:19,809
We see the code.

385
00:19:19,809 --> 00:19:22,820
We see where
we're at in the code, thanks to this highlight.

386
00:19:22,820 --> 00:19:26,429
And we see the full variable
structure right here.

387
00:19:26,429 --> 00:19:27,429
So this is everything.

388
00:19:27,429 --> 00:19:31,210
If we took a picture of this, we
could replicate this process at this moment

389
00:19:31,210 --> 00:19:34,809
perfectly, and we could step
through and see that it is in fact doing some

390
00:19:34,809 --> 00:19:36,580
things as we step through.

391
00:19:36,580 --> 00:19:40,559
But
in zooming into this level, we've lost our

392
00:19:40,559 --> 00:19:44,350
ability to see things unfold in
realtime.

393
00:19:44,350 --> 00:19:47,830
So now we're back to the step-through debugger
zone.

394
00:19:47,830 --> 00:19:51,470
So what we can do is...

395
00:19:51,470 --> 00:19:56,140
We have a connection between code, which,
when it gets

396
00:19:56,140 --> 00:20:01,000
compiled down, all of these codes over here
-- or these commands over here --

397
00:20:01,000 --> 00:20:03,650
get pushed down into numbers.

398
00:20:03,650 --> 00:20:06,270
So we can actually make an array of numbers
out

399
00:20:06,270 --> 00:20:07,750
of our code.

400
00:20:07,750 --> 00:20:08,750
And that's exactly what happens.

401
00:20:08,750 --> 00:20:12,650
It gets compiled down to a
machine code, which is an array of bytes.

402
00:20:12,650 --> 00:20:15,600
So at the machine code level, we
have an array of bytes, and our memory is

403
00:20:15,600 --> 00:20:16,600
an array of bytes.

404
00:20:16,600 --> 00:20:20,190
We have a sort of
trivial form of homoiconicity, where your

405
00:20:20,190 --> 00:20:24,460
code and your data is the same
thing.

406
00:20:24,460 --> 00:20:32,870
It's the same type of data structure as you
typically operate on.

407
00:20:32,870 --> 00:20:36,660
Machine code always has a trivial form of
homoiconicity, but in our case, we

408
00:20:36,660 --> 00:20:42,909
have a similar trick up our sleeves, which
is that our memory is being mapped

409
00:20:42,909 --> 00:20:48,309
to an image, so there's an isomorphism between
the memory structure and the

410
00:20:48,309 --> 00:20:56,070
image, and there's also an isomorphism between
the code and an image, or icon.

411
00:20:56,070 --> 00:21:00,179
So maybe our homoiconicity is not so trivial
after all.

412
00:21:00,179 --> 00:21:02,779
That was a really
involved joke.

413
00:21:02,779 --> 00:21:05,470
All right.

414
00:21:05,470 --> 00:21:07,910
So we can look at this as an image instead.

415
00:21:07,910 --> 00:21:09,500
Which is where things
start to get fun.

416
00:21:09,500 --> 00:21:11,150
So this is our program running...

417
00:21:11,150 --> 00:21:15,390
Again, we could take a
snapshot and reform our entire process at

418
00:21:15,390 --> 00:21:16,390
a moment in time.

419
00:21:16,390 --> 00:21:19,220
You can see the
read head is this kind of white square here

420
00:21:19,220 --> 00:21:21,440
that's jumping through this
subroutine.

421
00:21:21,440 --> 00:21:26,289
And you can see that it is in fact performing
this image blur on

422
00:21:26,289 --> 00:21:28,059
our memory.

423
00:21:28,059 --> 00:21:29,330
So...

424
00:21:29,330 --> 00:21:30,330
That's great.

425
00:21:30,330 --> 00:21:32,890
But what we're really interested in is random
programs.

426
00:21:32,890 --> 00:21:36,000
And I can't reload this, and it's stuck in
a really silly loop.

427
00:21:36,000 --> 00:21:37,250
Are
we good?

428
00:21:37,250 --> 00:21:38,780
Oh, yes.

429
00:21:38,780 --> 00:21:39,780
Nice.

430
00:21:39,780 --> 00:21:40,780
Okay.

431
00:21:40,780 --> 00:21:42,140
So we're watching an entirely random program.

432
00:21:42,140 --> 00:21:46,090
All the colored spots correlate to different
kinds of op codes.

433
00:21:46,090 --> 00:21:49,530
This is an
exit, so it's the beginning of the subroutine,

434
00:21:49,530 --> 00:21:54,049
and this is a jump, so it's
jumping to the next subroutine when it hits

435
00:21:54,049 --> 00:21:55,240
that.

436
00:21:55,240 --> 00:22:00,929
The grey areas correlate to numbers that serve
as constants in our program,

437
00:22:00,929 --> 00:22:03,890
and what can we infer about this?

438
00:22:03,890 --> 00:22:06,130
It's actually hard to infer much of anything
from this system.

439
00:22:06,130 --> 00:22:11,320
We can see that this square is blinking a
lot, and that

440
00:22:11,320 --> 00:22:15,279
we're going to take a little while before
we end, because we've got 200

441
00:22:15,279 --> 00:22:19,610
counting down on a return stack.

442
00:22:19,610 --> 00:22:21,429
So what we're doing here is...

443
00:22:21,429 --> 00:22:23,250
We're applying
the program to itself.

444
00:22:23,250 --> 00:22:25,970
We put a copy of it in memory, and we have
it modify

445
00:22:25,970 --> 00:22:28,570
itself.

446
00:22:28,570 --> 00:22:31,440
And then when it's done, when it terminates,
we're going to take the

447
00:22:31,440 --> 00:22:33,600
modified version and run that against itself.

448
00:22:33,600 --> 00:22:39,140
And we're going to keep doing
this until our program doesn't do anything

449
00:22:39,140 --> 00:22:40,140
interesting.

450
00:22:40,140 --> 00:22:41,450
Well, this one is
certainly doing something interesting -- down

451
00:22:41,450 --> 00:22:43,500
here, at least.

452
00:22:43,500 --> 00:22:48,419
Or we find a cycle where program A, applied
to A, gives us program B, which,

453
00:22:48,419 --> 00:22:50,840
when applied to B, gives us program A again.

454
00:22:50,840 --> 00:22:54,770
And then we will be very happy
and have champagne or something.

455
00:22:54,770 --> 00:22:57,470
All right.

456
00:22:57,470 --> 00:22:58,820
So...

457
00:22:58,820 --> 00:23:00,000
This was a nice experiment.

458
00:23:00,000 --> 00:23:02,980
But it's a little hard to infer much about
these programs, because the

459
00:23:02,980 --> 00:23:05,420
language is a little obscure.

460
00:23:05,420 --> 00:23:10,140
And because we haven't looked at these pictures
long enough.

461
00:23:10,140 --> 00:23:11,790
What if we could do this with JavaScript?

462
00:23:11,790 --> 00:23:15,380
That's the $25,000
question.

463
00:23:15,380 --> 00:23:24,049
So what if we could look at the interpreter
for this in JavaScript?

464
00:23:24,049 --> 00:23:26,980
So I was hoping to not have to do this.

465
00:23:26,980 --> 00:23:29,780
But I have to do this.

466
00:23:29,780 --> 00:23:35,630
So we'll take
this over here.

467
00:23:35,630 --> 00:23:39,270
And we will do this and we will do this.

468
00:23:39,270 --> 00:23:40,270
Oh, good.

469
00:23:40,270 --> 00:23:41,270
Okay.

470
00:23:41,270 --> 00:23:42,270
All
right.

471
00:23:42,270 --> 00:23:43,270
Everyone cross your fingers.

472
00:23:43,270 --> 00:23:44,270
Take a deep breath.

473
00:23:44,270 --> 00:23:46,590
And we'll see if we
can make this work.

474
00:23:46,590 --> 00:23:49,430
All right.

475
00:23:49,430 --> 00:23:55,029
So what we'd like to see is our virtual machine
for this little language that we've written,

476
00:23:55,029 --> 00:23:58,559
running in realtime, in
JavaScript.

477
00:23:58,559 --> 00:24:03,610
And over on the left, that's exactly what
we're seeing.

478
00:24:03,610 --> 00:24:05,570
So we're
back to the step-through on the right.

479
00:24:05,570 --> 00:24:07,620
We're stepping through, one step at a
time.

480
00:24:07,620 --> 00:24:11,170
But as we step through, we're seeing three
columns over here, which

481
00:24:11,170 --> 00:24:12,390
correlate to three files.

482
00:24:12,390 --> 00:24:15,330
This is the core virtual machine.

483
00:24:15,330 --> 00:24:16,920
This is the
renderer.

484
00:24:16,920 --> 00:24:21,970
And this is the index HTML.

485
00:24:21,970 --> 00:24:23,520
Can you see that?

486
00:24:23,520 --> 00:24:26,200
Can anyone see that at
all?

487
00:24:26,200 --> 00:24:27,380
You can?

488
00:24:27,380 --> 00:24:29,760
It's visible?

489
00:24:29,760 --> 00:24:30,940
Okay.

490
00:24:30,940 --> 00:24:32,130
Cool.

491
00:24:32,130 --> 00:24:38,480
So as we step through, there's going
to be lots of flashing colors here.

492
00:24:38,480 --> 00:24:44,100
We can see different parts of this program
being evaluated.

493
00:24:44,100 --> 00:24:46,179
So this is the actual underlying virtual machine.

494
00:24:46,179 --> 00:24:51,900
This, for example, is the
draw function.

495
00:24:51,900 --> 00:24:54,809
And it's longer than you would expect, and
it's also very, very

496
00:24:54,809 --> 00:24:55,809
hot.

497
00:24:55,809 --> 00:24:58,240
So this is forming a heat map.

498
00:24:58,240 --> 00:25:00,460
Because there's a tiny little virtual DOM
inside here.

499
00:25:00,460 --> 00:25:03,809
So I just call it 256 times a tick.

500
00:25:03,809 --> 00:25:07,419
But the point of this isn't
to be a profiler.

501
00:25:07,419 --> 00:25:08,419
Right?

502
00:25:08,419 --> 00:25:09,580
We already have really good profilers for
finding hot

503
00:25:09,580 --> 00:25:11,000
spots in our code.

504
00:25:11,000 --> 00:25:14,980
The point of this is to -- at a 10,000-foot
view --

505
00:25:14,980 --> 00:25:20,500
understand the process that's unfolding from
our code.

506
00:25:20,500 --> 00:25:23,170
And...

507
00:25:23,170 --> 00:25:26,020
So another
interesting thing that we can do is not just

508
00:25:26,020 --> 00:25:30,150
watch this in realtime, which we
can do a little more effectively if we speed

509
00:25:30,150 --> 00:25:34,960
this up -- we can also slow it
down and watch it happening essentially a

510
00:25:34,960 --> 00:25:36,539
tick at a time.

511
00:25:36,539 --> 00:25:39,820
So we can see the
process...

512
00:25:39,820 --> 00:25:41,790
We can see the underlying engine kind of flowing
through.

513
00:25:41,790 --> 00:25:45,700
And
unfortunately this code is not very interesting.

514
00:25:45,700 --> 00:25:50,460
Because it's calling the draw
function 256 times.

515
00:25:50,460 --> 00:25:52,779
But we can rewind and try to...

516
00:25:52,779 --> 00:25:54,409
We can rewind...

517
00:25:54,409 --> 00:25:57,070
Maybe we can rewind.

518
00:25:57,070 --> 00:26:00,390
We can't rewind.

519
00:26:00,390 --> 00:26:01,500
(laughter)

520
00:26:01,500 --> 00:26:02,600
>> Uh...

521
00:26:02,600 --> 00:26:03,710
Really?

522
00:26:03,710 --> 00:26:04,820
Okay.

523
00:26:04,820 --> 00:26:07,210
So this isn't very interesting for me, this
particular

524
00:26:07,210 --> 00:26:08,799
piece of code, because I wrote it.

525
00:26:08,799 --> 00:26:11,210
So I understand exactly what's happening
here.

526
00:26:11,210 --> 00:26:15,080
If we look at something else, though, something
bigger, like, for

527
00:26:15,080 --> 00:26:18,740
example, a framework of some kind that we're
not familiar with -- this one is

528
00:26:18,740 --> 00:26:22,270
Agility JS.

529
00:26:22,270 --> 00:26:26,580
And then if we do this magical thing that
may or may not work...

530
00:26:26,580 --> 00:26:27,580
Okay, good.

531
00:26:27,580 --> 00:26:31,800
So I'm using fondue under the hood, which
is an instrumentation

532
00:26:31,800 --> 00:26:42,460
library 
written for Theseus, which is a debugger for

533
00:26:42,460 --> 00:26:44,710
brackets.

534
00:26:44,710 --> 00:26:48,649
Typing and
talking simultaneously are surprisingly difficult

535
00:26:48,649 --> 00:26:51,220
things to do well.

536
00:26:51,220 --> 00:26:52,330
Okay.

537
00:26:52,330 --> 00:26:53,580
Flashy lights!

538
00:26:53,580 --> 00:26:54,580
Woo.

539
00:26:54,580 --> 00:26:56,029
All right.

540
00:26:56,029 --> 00:26:58,039
So what are we really looking at here?

541
00:26:58,039 --> 00:27:03,940
What we're seeing unfold before us is...

542
00:27:03,940 --> 00:27:14,169
The entire process that's inside of
Agility JS, as it's handling the things that

543
00:27:14,169 --> 00:27:25,210
we clicked over here -- so if we
click this, for example --

544
00:27:25,210 --> 00:27:26,920
and then we...

545
00:27:26,920 --> 00:27:27,920
No.

546
00:27:27,920 --> 00:27:28,920
Okay.

547
00:27:28,920 --> 00:27:31,710
So I should slow this down
a little.

548
00:27:31,710 --> 00:27:34,490
Okay.

549
00:27:34,490 --> 00:27:39,159
So we can observe at a high level the functions
that are being

550
00:27:39,159 --> 00:27:56,950
called and the flow of functions as they're
being called.

551
00:27:56,950 --> 00:27:58,530
So this shows us
something about the process.

552
00:27:58,530 --> 00:28:00,480
And we can draw some inference from it.

553
00:28:00,480 --> 00:28:02,570
But there's more that we need.

554
00:28:02,570 --> 00:28:04,809
What
we'd really like to see is the data that's

555
00:28:04,809 --> 00:28:06,850
flowing through here as well.

556
00:28:06,850 --> 00:28:11,400
And
we'd like those data flow pathways to be highlighted.

557
00:28:11,400 --> 00:28:16,560
We want to be able to
sort of pour data in some input of our program,

558
00:28:16,560 --> 00:28:21,600
and watch as it trickles
through the function calls and invocations,

559
00:28:21,600 --> 00:28:25,350
and watch it as it pools up in
some place and stays there for a while.

560
00:28:25,350 --> 00:28:28,679
See how it interfaces with other data
that's flowing through.

561
00:28:28,679 --> 00:28:34,019
We want to be able to understand the applications
that

562
00:28:34,019 --> 00:28:38,519
we're working with at the level of the process
that they're evolving.

563
00:28:38,519 --> 00:28:42,070
And we
want this because reading code is very slow,

564
00:28:42,070 --> 00:28:44,970
and it requires that we have an
interpreter in our head.

565
00:28:44,970 --> 00:28:48,590
And if we can do this effectively, then we
can understand -- for example,

566
00:28:48,590 --> 00:28:51,820
frameworks that we've never used -- at an
intuitive level, without ever

567
00:28:51,820 --> 00:28:55,720
actually having used them or read their code
or their documentation.

568
00:28:55,720 --> 00:28:57,960
So I want
this for the programs that I'm writing, and

569
00:28:57,960 --> 00:29:00,860
I also want it for the programs
that I'm reading.

570
00:29:00,860 --> 00:29:02,990
And if you want it too, then I think we should
work together

571
00:29:02,990 --> 00:29:03,990
on this.

572
00:29:03,990 --> 00:29:05,210
I think we should make this happen.

573
00:29:05,210 --> 00:29:08,840
I think we should get this -- not
this, but something like this -- into dev

574
00:29:08,840 --> 00:29:09,929
tools.

575
00:29:09,929 --> 00:29:12,659
So we have it available for
everything that we're doing.

576
00:29:12,659 --> 00:29:16,940
Let's augment our vision.

577
00:29:16,940 --> 00:29:20,809
Let's let the computer
do the hard work of helping us understand

578
00:29:20,809 --> 00:29:24,050
what it is we're working with.

579
00:29:24,050 --> 00:29:27,420
Let's
go to that party.

