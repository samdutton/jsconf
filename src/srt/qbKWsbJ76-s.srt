1
00:00:10,630 --> 00:00:21,420

you

2
00:00:21,430 --> 00:00:23,620
hi right I'm going to be talking about

3
00:00:23,620 --> 00:00:27,610
promises and generators so a lot of

4
00:00:27,610 --> 00:00:29,260
stuff I'm talking about it's very new so

5
00:00:29,260 --> 00:00:31,630
it's very experimental it's getting into

6
00:00:31,630 --> 00:00:33,460
the latest browsers but you're going to

7
00:00:33,460 --> 00:00:35,050
have to enable some flags so if you're

8
00:00:35,050 --> 00:00:36,820
in Firefox nightly I believe this has

9
00:00:36,820 --> 00:00:39,370
just been added it's in Chrome with a

10
00:00:39,370 --> 00:00:41,410
flat if you go to the flags and you can

11
00:00:41,410 --> 00:00:43,780
use it in node with the - - harmony

12
00:00:43,780 --> 00:00:47,320
generators flag and mice the slides are

13
00:00:47,320 --> 00:00:48,489
available for this so if you want to

14
00:00:48,489 --> 00:00:49,690
follow along or whatever you can get

15
00:00:49,690 --> 00:00:53,680
grab those now so I'm going to start off

16
00:00:53,680 --> 00:00:55,600
not really talking about promises not

17
00:00:55,600 --> 00:00:56,920
really talking about asynchronous stuff

18
00:00:56,920 --> 00:00:58,510
at all but talking about how you

19
00:00:58,510 --> 00:01:00,910
represent a sequence so if you've got a

20
00:01:00,910 --> 00:01:02,530
sequence of numbers so here we're

21
00:01:02,530 --> 00:01:05,680
talking about the integers this function

22
00:01:05,680 --> 00:01:08,020
returns the first n integers as an array

23
00:01:08,020 --> 00:01:10,420
and that's really nice for representing

24
00:01:10,420 --> 00:01:13,149
finite sequences arrays work great for

25
00:01:13,149 --> 00:01:14,860
that but the integers aren't really a

26
00:01:14,860 --> 00:01:16,930
finite sequence really they're an

27
00:01:16,930 --> 00:01:19,060
infinite sequence but we can't have this

28
00:01:19,060 --> 00:01:21,160
function returning an infinite sequence

29
00:01:21,160 --> 00:01:23,560
as an array if we try and do that just

30
00:01:23,560 --> 00:01:25,240
replace the condition there with true

31
00:01:25,240 --> 00:01:27,490
this is trying to create an infinitely

32
00:01:27,490 --> 00:01:29,650
long array so this count function is

33
00:01:29,650 --> 00:01:31,659
just never going to return we're never

34
00:01:31,659 --> 00:01:33,520
going to get into that for loop and

35
00:01:33,520 --> 00:01:35,350
we're never going to log any output I

36
00:01:35,350 --> 00:01:37,869
should just note that for oov there is a

37
00:01:37,869 --> 00:01:39,880
new construct but it just loops over the

38
00:01:39,880 --> 00:01:42,420
items in an array or in a sequence or it

39
00:01:42,420 --> 00:01:44,320
supports a much wider range of

40
00:01:44,320 --> 00:01:46,630
collections than say using a for a

41
00:01:46,630 --> 00:01:51,490
traditional for loop so the next version

42
00:01:51,490 --> 00:01:54,310
of JavaScript has built-in support for

43
00:01:54,310 --> 00:01:57,280
these infinite collections and they it

44
00:01:57,280 --> 00:01:59,830
works using it by making the function

45
00:01:59,830 --> 00:02:03,040
lazy and only only executing as far as

46
00:02:03,040 --> 00:02:04,720
it needs to to return the values that

47
00:02:04,720 --> 00:02:07,540
are actually used so what happens with

48
00:02:07,540 --> 00:02:09,759
this count function is that the function

49
00:02:09,759 --> 00:02:12,850
is executed only when we request the

50
00:02:12,850 --> 00:02:14,860
value so initially when you call count

51
00:02:14,860 --> 00:02:17,230
none of the code inside the body is

52
00:02:17,230 --> 00:02:20,799
executed then the for loop requests the

53
00:02:20,799 --> 00:02:23,950
first value from count and at that point

54
00:02:23,950 --> 00:02:27,070
it executes as far as that first yield

55
00:02:27,070 --> 00:02:29,680
keyword and when it gets to that first

56
00:02:29,680 --> 00:02:32,230
yield keyword it returns that value and

57
00:02:32,230 --> 00:02:34,680
we get to use it in the for loop

58
00:02:34,680 --> 00:02:37,379
but it pauses the function so it saves

59
00:02:37,379 --> 00:02:39,420
the entire execution state of that

60
00:02:39,420 --> 00:02:42,959
function and then when we ask for the

61
00:02:42,959 --> 00:02:45,329
second value it resumes that function

62
00:02:45,329 --> 00:02:47,579
from where the yield keyword was and

63
00:02:47,579 --> 00:02:50,510
continues around the loop a second time

64
00:02:50,510 --> 00:02:53,099
so this is really useful for infinite

65
00:02:53,099 --> 00:02:55,650
sequences like this function represents

66
00:02:55,650 --> 00:02:58,709
all of the integers and we can still get

67
00:02:58,709 --> 00:03:01,349
back to the semantics we had before we

68
00:03:01,349 --> 00:03:03,239
can just write a simple take function

69
00:03:03,239 --> 00:03:06,269
that takes any infinite sequence and

70
00:03:06,269 --> 00:03:09,060
takes the first n items out of that

71
00:03:09,060 --> 00:03:11,069
sequence and this would work for

72
00:03:11,069 --> 00:03:13,950
integers but you could equally pass the

73
00:03:13,950 --> 00:03:16,139
Fibonacci sequence as an infinite

74
00:03:16,139 --> 00:03:19,139
sequence and because it's because of the

75
00:03:19,139 --> 00:03:20,909
lazy nature of it we could pull off the

76
00:03:20,909 --> 00:03:23,010
first 5 items the first 10 items as

77
00:03:23,010 --> 00:03:26,129
needed and we can reuse this and we

78
00:03:26,129 --> 00:03:27,780
could have more complicated conditions

79
00:03:27,780 --> 00:03:29,819
as well it doesn't have to be the first

80
00:03:29,819 --> 00:03:32,639
n items it could be all the items up

81
00:03:32,639 --> 00:03:34,079
until an item that matches some

82
00:03:34,079 --> 00:03:37,260
condition for example so that's really

83
00:03:37,260 --> 00:03:40,709
powerful for maths and sequences and

84
00:03:40,709 --> 00:03:42,989
things and later I'm going to show you

85
00:03:42,989 --> 00:03:44,310
how it can be really useful for

86
00:03:44,310 --> 00:03:48,510
asynchronous programming as well so to

87
00:03:48,510 --> 00:03:49,799
get back to the original point of

88
00:03:49,799 --> 00:03:51,689
asynchronous programming I'm going to

89
00:03:51,689 --> 00:03:54,120
follow through a simple example say we

90
00:03:54,120 --> 00:03:56,189
want to write a function that reads a

91
00:03:56,189 --> 00:03:59,129
file and passes it as JSON and returns

92
00:03:59,129 --> 00:04:01,650
the result it's a fairly simple thing

93
00:04:01,650 --> 00:04:03,930
and it's a task that I'm sure many of

94
00:04:03,930 --> 00:04:05,040
you have had to do at some point

95
00:04:05,040 --> 00:04:06,720
especially if you're writing server-side

96
00:04:06,720 --> 00:04:08,729
code would you write jar if you write

97
00:04:08,729 --> 00:04:10,259
client-side code you can think of this

98
00:04:10,259 --> 00:04:11,939
as just making a web request and then

99
00:04:11,939 --> 00:04:15,030
parsing that is JSON nothing I'm talking

100
00:04:15,030 --> 00:04:19,019
about is really specific to note the so

101
00:04:19,019 --> 00:04:20,699
this function is really about as simple

102
00:04:20,699 --> 00:04:22,770
as it can can be to accomplish this

103
00:04:22,770 --> 00:04:25,560
functionality it takes a filename it

104
00:04:25,560 --> 00:04:29,070
reads that file with utf-8 encoding so

105
00:04:29,070 --> 00:04:31,409
it gets a string back and then it passes

106
00:04:31,409 --> 00:04:34,560
it as JSON and returns the result if at

107
00:04:34,560 --> 00:04:36,659
any point one of these methods froze an

108
00:04:36,659 --> 00:04:38,789
error if the read file operation froze

109
00:04:38,789 --> 00:04:41,669
an error or the JSON pars operation

110
00:04:41,669 --> 00:04:43,650
frozen error then it's going to bubble

111
00:04:43,650 --> 00:04:45,750
up the stack and we can handle that at

112
00:04:45,750 --> 00:04:48,030
some top level where we know

113
00:04:48,030 --> 00:04:49,350
or information about how we should

114
00:04:49,350 --> 00:04:51,870
handle it so all of the errors propagate

115
00:04:51,870 --> 00:04:54,810
nicely the results return nicely and

116
00:04:54,810 --> 00:04:59,010
it's a really simple function to read so

117
00:04:59,010 --> 00:05:01,320
we we can make that asynchronous if we

118
00:05:01,320 --> 00:05:03,120
don't make it asynchronous it's going to

119
00:05:03,120 --> 00:05:05,130
block the program and nothing else is

120
00:05:05,130 --> 00:05:06,630
going to happen if it's a client side

121
00:05:06,630 --> 00:05:08,940
app and you do synchronous i/o then

122
00:05:08,940 --> 00:05:10,680
you're going to be freezing the

123
00:05:10,680 --> 00:05:11,940
application nothing's going to happen

124
00:05:11,940 --> 00:05:14,100
for a while if you're doing a server and

125
00:05:14,100 --> 00:05:16,500
you do synchronous i/o then you're not

126
00:05:16,500 --> 00:05:17,970
going to be handling any other requests

127
00:05:17,970 --> 00:05:19,800
for a while so you're going to

128
00:05:19,800 --> 00:05:21,990
effectively the this server will appear

129
00:05:21,990 --> 00:05:25,380
to be down to everyone else so we can

130
00:05:25,380 --> 00:05:27,510
make this asynchronous just by taking a

131
00:05:27,510 --> 00:05:30,300
callback so we add a second argument to

132
00:05:30,300 --> 00:05:32,400
the read JSON function that's callback

133
00:05:32,400 --> 00:05:35,040
and we then also pass a function to our

134
00:05:35,040 --> 00:05:38,520
FS read file we then say if there's an

135
00:05:38,520 --> 00:05:41,460
error we call back with the error and if

136
00:05:41,460 --> 00:05:43,530
there's not then we call back with null

137
00:05:43,530 --> 00:05:46,110
as our error argument and the result as

138
00:05:46,110 --> 00:05:48,930
the second argument this isn't a lot

139
00:05:48,930 --> 00:05:52,530
more complicated than then the first

140
00:05:52,530 --> 00:05:55,410
function we wrote but I wanted to show

141
00:05:55,410 --> 00:05:57,240
you today that this isn't sufficient

142
00:05:57,240 --> 00:05:59,700
this code is a long way off a complete

143
00:05:59,700 --> 00:06:02,820
implementation of read a Sun and we can

144
00:06:02,820 --> 00:06:05,940
do better so this is conflating the

145
00:06:05,940 --> 00:06:08,190
input with the output it's kind of a

146
00:06:08,190 --> 00:06:09,930
subtle point and it might not seem like

147
00:06:09,930 --> 00:06:11,940
it's important but it turns out to have

148
00:06:11,940 --> 00:06:15,180
lots of effects down the line so we're

149
00:06:15,180 --> 00:06:17,010
going from our really simple model of

150
00:06:17,010 --> 00:06:19,380
having arguments as inputs to functions

151
00:06:19,380 --> 00:06:22,500
and some return value as the result to

152
00:06:22,500 --> 00:06:25,140
now having this additional argument that

153
00:06:25,140 --> 00:06:27,960
represents how to how to send the result

154
00:06:27,960 --> 00:06:30,630
back that callback isn't really an input

155
00:06:30,630 --> 00:06:32,310
to the function it's just part of the

156
00:06:32,310 --> 00:06:36,840
mechanics it's relies on pure convention

157
00:06:36,840 --> 00:06:39,060
that we that we passed the error is the

158
00:06:39,060 --> 00:06:41,730
first as the first argument and the

159
00:06:41,730 --> 00:06:43,410
result as the second argument and that

160
00:06:43,410 --> 00:06:45,030
we don't do weird things like call the

161
00:06:45,030 --> 00:06:48,450
call back multiple times so that can be

162
00:06:48,450 --> 00:06:51,360
real problem later down the line it also

163
00:06:51,360 --> 00:06:53,220
won't work with control flow primitives

164
00:06:53,220 --> 00:06:55,230
it's really difficult to do an

165
00:06:55,230 --> 00:06:57,390
asynchronous operation in the middle of

166
00:06:57,390 --> 00:06:59,420
a for loop using this kind of technique

167
00:06:59,420 --> 00:07:01,590
it's just not going to work you're going

168
00:07:01,590 --> 00:07:01,960
to

169
00:07:01,960 --> 00:07:04,870
you can't pause the for-loop while

170
00:07:04,870 --> 00:07:07,830
executing this asynchronous function

171
00:07:07,830 --> 00:07:10,900
this currently doesn't handle errors so

172
00:07:10,900 --> 00:07:13,120
this has a major flaw if I try and read

173
00:07:13,120 --> 00:07:15,970
a JSON file that turns out not to be

174
00:07:15,970 --> 00:07:19,300
valid JSON that exists so the filesystem

175
00:07:19,300 --> 00:07:22,449
read succeeds or the web requests if we

176
00:07:22,449 --> 00:07:25,270
were on the client but where the

177
00:07:25,270 --> 00:07:27,940
json.parse bit fails and frozen error

178
00:07:27,940 --> 00:07:31,180
that error can't be caught anywhere it's

179
00:07:31,180 --> 00:07:33,539
going to be thrown into the global scope

180
00:07:33,539 --> 00:07:37,150
because we're not handling it so that's

181
00:07:37,150 --> 00:07:39,639
simple to fix we just have to use a

182
00:07:39,639 --> 00:07:43,479
try-catch so now we've wrapped the the

183
00:07:43,479 --> 00:07:45,190
bit that does the JSON parsing in a

184
00:07:45,190 --> 00:07:47,650
try-catch and if there's an error we

185
00:07:47,650 --> 00:07:50,860
call the callback with an error this

186
00:07:50,860 --> 00:07:52,150
still conflates the input with the

187
00:07:52,150 --> 00:07:54,280
output it still won't work with control

188
00:07:54,280 --> 00:07:55,930
flow primitives but it does handle

189
00:07:55,930 --> 00:07:58,090
errors in JSON path so we've got a bit

190
00:07:58,090 --> 00:08:00,550
of a win there we have a might a

191
00:08:00,550 --> 00:08:03,069
slightly subtle of floor though we're

192
00:08:03,069 --> 00:08:06,520
handling errors in the callback twice so

193
00:08:06,520 --> 00:08:11,259
if if the filesystem Reedus succeeds the

194
00:08:11,259 --> 00:08:14,250
JSON path succeeds we call the callback

195
00:08:14,250 --> 00:08:16,620
but then that callback frozen error

196
00:08:16,620 --> 00:08:18,610
we're going to callback call the

197
00:08:18,610 --> 00:08:20,620
callback again when really what we

198
00:08:20,620 --> 00:08:22,889
should do is just crash the application

199
00:08:22,889 --> 00:08:25,449
so if you can you can see this in action

200
00:08:25,449 --> 00:08:28,599
if we were to do a read JSON with a

201
00:08:28,599 --> 00:08:30,729
callback which froze an error and

202
00:08:30,729 --> 00:08:33,760
increment some integer each time so you

203
00:08:33,760 --> 00:08:35,260
can see here that n should be

204
00:08:35,260 --> 00:08:37,300
incremented once but will actually get

205
00:08:37,300 --> 00:08:40,300
incremented twice and this seems like a

206
00:08:40,300 --> 00:08:42,789
slightly obscure example but this could

207
00:08:42,789 --> 00:08:44,829
manifest itself with additional log

208
00:08:44,829 --> 00:08:46,570
messages if you're logging the error or

209
00:08:46,570 --> 00:08:48,730
really weird behavior if you're actually

210
00:08:48,730 --> 00:08:50,290
doing something with these errors and

211
00:08:50,290 --> 00:08:58,420
handling them properly so we can fix

212
00:08:58,420 --> 00:09:00,940
that all we need to do is make sure that

213
00:09:00,940 --> 00:09:03,730
we're not calling the callback inside of

214
00:09:03,730 --> 00:09:08,500
the try catch so this code makes sure

215
00:09:08,500 --> 00:09:10,240
that the only thing we do inside the try

216
00:09:10,240 --> 00:09:12,850
catch is pars the JSON and then we

217
00:09:12,850 --> 00:09:15,220
actually call the callback outside of

218
00:09:15,220 --> 00:09:18,600
the try catch now this fixes the bug

219
00:09:18,600 --> 00:09:20,650
we're still conflating the input with

220
00:09:20,650 --> 00:09:22,420
output we're still not working with

221
00:09:22,420 --> 00:09:24,459
control flow primitives but we are at

222
00:09:24,459 --> 00:09:26,829
least handling errors now this was a

223
00:09:26,829 --> 00:09:29,470
this this code might seem like a weird

224
00:09:29,470 --> 00:09:31,240
bug you might think I'd never write code

225
00:09:31,240 --> 00:09:34,660
like that but a very popular library

226
00:09:34,660 --> 00:09:38,199
Jade has had this exact bug for several

227
00:09:38,199 --> 00:09:39,970
years and it was only fixed about a

228
00:09:39,970 --> 00:09:43,060
month ago so these these bugs are

229
00:09:43,060 --> 00:09:44,980
happening in real code I'm not making

230
00:09:44,980 --> 00:09:49,480
these up and it's afoot so now we've got

231
00:09:49,480 --> 00:09:51,520
this fixed function this this function

232
00:09:51,520 --> 00:09:53,650
works it's an implementation of read

233
00:09:53,650 --> 00:09:55,600
JSON as I'd expect to see it in a

234
00:09:55,600 --> 00:10:00,100
typical nodejs program but it's a far

235
00:10:00,100 --> 00:10:02,410
cry from that simple function we started

236
00:10:02,410 --> 00:10:05,170
with this is the real semantics we want

237
00:10:05,170 --> 00:10:07,060
to express we want to express these

238
00:10:07,060 --> 00:10:09,640
semantics and just the additional bit of

239
00:10:09,640 --> 00:10:11,680
information that the file system reads

240
00:10:11,680 --> 00:10:14,140
should be asynchronous so we need

241
00:10:14,140 --> 00:10:16,000
something simpler we don't want to talk

242
00:10:16,000 --> 00:10:17,410
about error handling because the error

243
00:10:17,410 --> 00:10:19,480
handling we're asking for should be the

244
00:10:19,480 --> 00:10:24,060
default anyway so imagine for the moment

245
00:10:24,060 --> 00:10:27,850
the asynchronous methods still return

246
00:10:27,850 --> 00:10:29,709
values asynchronous functions are still

247
00:10:29,709 --> 00:10:34,150
going to return something these values

248
00:10:34,150 --> 00:10:35,650
obviously won't be something we can use

249
00:10:35,650 --> 00:10:37,240
directly because they're going to have

250
00:10:37,240 --> 00:10:39,910
to return this value synchronously but

251
00:10:39,910 --> 00:10:41,529
they're going to execute asynchronously

252
00:10:41,529 --> 00:10:42,880
so we don't know what that value

253
00:10:42,880 --> 00:10:45,760
represents yet but we can somehow await

254
00:10:45,760 --> 00:10:48,459
it we can somehow say tell me when this

255
00:10:48,459 --> 00:10:51,339
value is is settled tell me when we know

256
00:10:51,339 --> 00:10:55,180
what this value actually represents so

257
00:10:55,180 --> 00:10:57,880
we have such a value in JavaScript it's

258
00:10:57,880 --> 00:10:59,589
called a promise there are a number of

259
00:10:59,589 --> 00:11:02,140
implementations of it Q is extremely

260
00:11:02,140 --> 00:11:03,850
popular I maintain my own promise

261
00:11:03,850 --> 00:11:06,040
library called promise and PM installed

262
00:11:06,040 --> 00:11:09,680
promise if you're using node and

263
00:11:09,690 --> 00:11:12,490
so promis represents the result of an

264
00:11:12,490 --> 00:11:14,800
asynchronous operation it can be in one

265
00:11:14,800 --> 00:11:17,140
of three states loosely so it can be

266
00:11:17,140 --> 00:11:19,720
pending or it can be fulfilled or it can

267
00:11:19,720 --> 00:11:22,900
be rejected so every promise starts out

268
00:11:22,900 --> 00:11:25,600
pending and then transitions into either

269
00:11:25,600 --> 00:11:27,220
fulfilled or rejected

270
00:11:27,220 --> 00:11:29,410
and once it's transitioned into one of

271
00:11:29,410 --> 00:11:32,110
those states it's immutable it'll never

272
00:11:32,110 --> 00:11:34,540
change back to being pending it'll never

273
00:11:34,540 --> 00:11:36,640
go from fulfilled to reject it or reject

274
00:11:36,640 --> 00:11:39,670
it to fulfilled so we can implement read

275
00:11:39,670 --> 00:11:43,090
file in to return a promise based on the

276
00:11:43,090 --> 00:11:47,980
built in nodejs FS read file function so

277
00:11:47,980 --> 00:11:49,930
we start by saying we're going to return

278
00:11:49,930 --> 00:11:52,590
a new promise and we give the promise

279
00:11:52,590 --> 00:11:54,850
constructor a function that represents

280
00:11:54,850 --> 00:11:56,860
the asynchronous work we're going to do

281
00:11:56,860 --> 00:11:59,860
and that function gets given a full film

282
00:11:59,860 --> 00:12:03,370
function and a reject function and we

283
00:12:03,370 --> 00:12:05,560
use those inside the method to control

284
00:12:05,560 --> 00:12:08,350
the result of the promise so we do the

285
00:12:08,350 --> 00:12:10,720
read file operation and if the refile

286
00:12:10,720 --> 00:12:13,480
operation fails we reject the resulting

287
00:12:13,480 --> 00:12:16,330
promise and if the read file operation

288
00:12:16,330 --> 00:12:18,310
succeeds we fulfill the resulting

289
00:12:18,310 --> 00:12:20,960
promise

290
00:12:20,970 --> 00:12:24,460
so having built that we can use the done

291
00:12:24,460 --> 00:12:27,960
method to await the result of a promise

292
00:12:27,960 --> 00:12:30,520
so this is how we could build our read

293
00:12:30,520 --> 00:12:34,150
JSON function so this read JSON function

294
00:12:34,150 --> 00:12:36,970
again returns a new promise with these

295
00:12:36,970 --> 00:12:39,280
fulfill and the reject parameters

296
00:12:39,280 --> 00:12:42,670
available it does the read file and when

297
00:12:42,670 --> 00:12:45,820
that's done it tries to fulfill with the

298
00:12:45,820 --> 00:12:49,690
JSON with a JSON pars result failing

299
00:12:49,690 --> 00:12:51,960
that it rejects with the exception and

300
00:12:51,960 --> 00:12:54,820
if the read file operation fails it

301
00:12:54,820 --> 00:12:57,130
rejects with the exception so done takes

302
00:12:57,130 --> 00:13:00,790
two arguments the first of which is an

303
00:13:00,790 --> 00:13:04,180
unfulfilled callback and the latter is

304
00:13:04,180 --> 00:13:11,950
an unregenerate of waiting for the

305
00:13:11,950 --> 00:13:16,420
promise to fulfill it doesn't complete

306
00:13:16,420 --> 00:13:18,040
the input with the output anymore we're

307
00:13:18,040 --> 00:13:20,200
now returning this value so you can see

308
00:13:20,200 --> 00:13:22,720
the arguments through for both the read

309
00:13:22,720 --> 00:13:23,110
file

310
00:13:23,110 --> 00:13:26,019
and the read JSON functions are back how

311
00:13:26,019 --> 00:13:27,880
they should be they're just the input

312
00:13:27,880 --> 00:13:30,160
read file takes a filename and in

313
00:13:30,160 --> 00:13:33,339
encoding and read JSON just takes the

314
00:13:33,339 --> 00:13:35,350
filename we don't have that additional

315
00:13:35,350 --> 00:13:37,930
parameter it's still not going to work

316
00:13:37,930 --> 00:13:39,430
with control flow primitives that

317
00:13:39,430 --> 00:13:42,730
requires language support it does still

318
00:13:42,730 --> 00:13:44,440
require a lot of extra work to handle

319
00:13:44,440 --> 00:13:46,510
errors so we've still got that try-catch

320
00:13:46,510 --> 00:13:49,240
in there which is a bit pointless it's

321
00:13:49,240 --> 00:13:51,820
nothing to do with our hand our actual

322
00:13:51,820 --> 00:13:55,779
application business logic so we really

323
00:13:55,779 --> 00:13:57,850
want to get that out we have at least

324
00:13:57,850 --> 00:13:59,410
made a slight win though

325
00:13:59,410 --> 00:14:01,750
and the this double handling of the

326
00:14:01,750 --> 00:14:03,940
callbacks is how it is dealt with for us

327
00:14:03,940 --> 00:14:08,490
the promise libraries all promise not

328
00:14:08,490 --> 00:14:11,170
not to throw an exception when you call

329
00:14:11,170 --> 00:14:13,149
fulfill which means we're not double

330
00:14:13,149 --> 00:14:14,589
handling any errors we don't need to

331
00:14:14,589 --> 00:14:18,040
worry about that at least we can do

332
00:14:18,040 --> 00:14:20,890
better when you start it out I bet many

333
00:14:20,890 --> 00:14:23,709
of you used for each when you when you

334
00:14:23,709 --> 00:14:26,230
had one array and need another ray that

335
00:14:26,230 --> 00:14:28,540
was based on that first array and I bet

336
00:14:28,540 --> 00:14:30,850
most of you now use map in a lot of

337
00:14:30,850 --> 00:14:32,560
cases where you'd have used for each

338
00:14:32,560 --> 00:14:35,350
when you start it out so map lets you

339
00:14:35,350 --> 00:14:37,630
transform each of the items in an array

340
00:14:37,630 --> 00:14:39,760
and get a new array without having to

341
00:14:39,760 --> 00:14:41,820
manually construct that array yourself

342
00:14:41,820 --> 00:14:45,550
we have a similar system in promises so

343
00:14:45,550 --> 00:14:48,459
done just lets you extract the value of

344
00:14:48,459 --> 00:14:51,100
a promise but we have a method called

345
00:14:51,100 --> 00:14:53,410
then which lets you transform the

346
00:14:53,410 --> 00:14:56,260
promise into a new promise that's based

347
00:14:56,260 --> 00:15:00,310
on that first promise so using that we

348
00:15:00,310 --> 00:15:03,730
can rewrite our asynchronous read JSON

349
00:15:03,730 --> 00:15:07,240
function just as read file filename

350
00:15:07,240 --> 00:15:12,459
encoding then json dot parse so here

351
00:15:12,459 --> 00:15:14,829
what we're doing is the then method is

352
00:15:14,829 --> 00:15:17,860
creating a new promise based on the

353
00:15:17,860 --> 00:15:19,930
previous promise so if the previous

354
00:15:19,930 --> 00:15:22,899
promise is rejected then by default this

355
00:15:22,899 --> 00:15:25,329
new promise this child promise gets

356
00:15:25,329 --> 00:15:27,730
rejected as well so that propagation

357
00:15:27,730 --> 00:15:29,350
happens automatically we don't need to

358
00:15:29,350 --> 00:15:31,990
handle that anymore and the unfulfilled

359
00:15:31,990 --> 00:15:35,319
if there if unfulfilled so that the

360
00:15:35,319 --> 00:15:36,180
first method

361
00:15:36,180 --> 00:15:38,040
the pastor then is a non fulfilled

362
00:15:38,040 --> 00:15:40,980
handler if that if that method frozen

363
00:15:40,980 --> 00:15:42,839
error then we reject the resulting

364
00:15:42,839 --> 00:15:44,610
promise that happens automatically for

365
00:15:44,610 --> 00:15:45,930
us so we don't need this try-catch

366
00:15:45,930 --> 00:15:48,450
anymore and if the if that method

367
00:15:48,450 --> 00:15:50,910
returns a value then that's used as the

368
00:15:50,910 --> 00:15:52,709
result that's what the promise is

369
00:15:52,709 --> 00:15:55,110
resolved with so we don't need any messy

370
00:15:55,110 --> 00:15:57,600
callback stuff anymore we're just

371
00:15:57,600 --> 00:16:00,779
dealing with the pure simple business

372
00:16:00,779 --> 00:16:04,020
logic now here we have a function that

373
00:16:04,020 --> 00:16:06,029
takes a single argument and passes that

374
00:16:06,029 --> 00:16:07,620
single argument to another function and

375
00:16:07,620 --> 00:16:09,540
returns the result so we can simplify

376
00:16:09,540 --> 00:16:11,370
that a little bit by just passing

377
00:16:11,370 --> 00:16:14,339
json.parse directly note that I'm not

378
00:16:14,339 --> 00:16:16,470
calling JSON docpods there I'm passing

379
00:16:16,470 --> 00:16:20,190
it as a function as the argument this

380
00:16:20,190 --> 00:16:21,450
doesn't conflate the input with the

381
00:16:21,450 --> 00:16:23,430
output we're returning a promise from

382
00:16:23,430 --> 00:16:26,279
all of our functions it still won't work

383
00:16:26,279 --> 00:16:28,980
with control flow primitives yet but it

384
00:16:28,980 --> 00:16:30,990
handles errors and it handles them

385
00:16:30,990 --> 00:16:32,790
really gracefully we haven't added any

386
00:16:32,790 --> 00:16:35,550
extra code to handle those errors they

387
00:16:35,550 --> 00:16:37,380
just bubble up the stack just like they

388
00:16:37,380 --> 00:16:40,709
would in synchronous code so we can

389
00:16:40,709 --> 00:16:44,060
still do better though this is still

390
00:16:44,060 --> 00:16:46,860
this is still a really simple example it

391
00:16:46,860 --> 00:16:48,420
doesn't have any for loops in it it

392
00:16:48,420 --> 00:16:50,490
doesn't have try-catch it doesn't have

393
00:16:50,490 --> 00:16:52,890
while we want to be able to get back the

394
00:16:52,890 --> 00:16:55,170
ability to use those control flux

395
00:16:55,170 --> 00:16:58,080
control flow structures to manage our

396
00:16:58,080 --> 00:17:02,160
code so what if we could await a promise

397
00:17:02,160 --> 00:17:03,480
somehow what if we could pause a

398
00:17:03,480 --> 00:17:06,929
function mid execution and wait for the

399
00:17:06,929 --> 00:17:09,839
promise to resolve well as way as I

400
00:17:09,839 --> 00:17:11,160
mentioned at the beginning of the talk

401
00:17:11,160 --> 00:17:13,709
we have a method for pausing a function

402
00:17:13,709 --> 00:17:16,230
mid execution because that's what yield

403
00:17:16,230 --> 00:17:21,809
does so with an async helper we can make

404
00:17:21,809 --> 00:17:24,870
yield effectively wait for a promise to

405
00:17:24,870 --> 00:17:28,500
resolve and return the result so at the

406
00:17:28,500 --> 00:17:29,640
top there you can see our original

407
00:17:29,640 --> 00:17:33,720
synchronous JSON function and at the

408
00:17:33,720 --> 00:17:36,420
bottom you can see our asynchronous JSON

409
00:17:36,420 --> 00:17:38,460
function and you can see all that

410
00:17:38,460 --> 00:17:41,370
changes is that we add the keyword we

411
00:17:41,370 --> 00:17:43,860
add the async function the async wrapper

412
00:17:43,860 --> 00:17:47,100
the star which denotes a generator

413
00:17:47,100 --> 00:17:47,880
function

414
00:17:47,880 --> 00:17:50,130
and they yield to tell us that we're

415
00:17:50,130 --> 00:17:51,390
going to wait for that promise to

416
00:17:51,390 --> 00:17:54,720
resolve this doesn't complete the input

417
00:17:54,720 --> 00:17:57,210
with the output this will work with

418
00:17:57,210 --> 00:18:00,150
control flow primitives this handles

419
00:18:00,150 --> 00:18:02,610
errors and it remains looking

420
00:18:02,610 --> 00:18:05,100
asynchronous it has just enough clues in

421
00:18:05,100 --> 00:18:08,040
there but I can read this code and know

422
00:18:08,040 --> 00:18:09,210
instantly that it's going to be doing

423
00:18:09,210 --> 00:18:11,790
something asynchronous we have the async

424
00:18:11,790 --> 00:18:13,650
keyword that tells us that function is

425
00:18:13,650 --> 00:18:15,060
the function as a whole is asynchronous

426
00:18:15,060 --> 00:18:18,450
and we have the yield keyword telling us

427
00:18:18,450 --> 00:18:20,220
exactly where that asynchrony is going

428
00:18:20,220 --> 00:18:24,540
to happen so we can use this to do

429
00:18:24,540 --> 00:18:27,090
things like a sequence of operations we

430
00:18:27,090 --> 00:18:29,430
can read one file then read another file

431
00:18:29,430 --> 00:18:32,130
just by doing multiple yields and then

432
00:18:32,130 --> 00:18:34,740
we can use the result because promises

433
00:18:34,740 --> 00:18:36,930
are first-class values we can fairly

434
00:18:36,930 --> 00:18:39,570
easily do the same thing in parallel

435
00:18:39,570 --> 00:18:42,240
just by starting in both operations and

436
00:18:42,240 --> 00:18:44,880
storing the promise that for each of

437
00:18:44,880 --> 00:18:47,730
those operations in turn and then having

438
00:18:47,730 --> 00:18:50,580
started both operations we then wait for

439
00:18:50,580 --> 00:18:52,590
them one at a time which leads to the

440
00:18:52,590 --> 00:18:55,020
actual IO happening in parallel and

441
00:18:55,020 --> 00:18:58,050
since the IO bit is the slow bit that's

442
00:18:58,050 --> 00:19:02,880
really what we want like I said it

443
00:19:02,880 --> 00:19:05,340
worked with control flow it with the

444
00:19:05,340 --> 00:19:08,070
normal control flow structures so we can

445
00:19:08,070 --> 00:19:10,170
do this inside a try-catch if we have

446
00:19:10,170 --> 00:19:13,380
some asynchronous get key method we can

447
00:19:13,380 --> 00:19:15,960
put it inside a try-catch and have some

448
00:19:15,960 --> 00:19:20,580
handler in the catch block we can use it

449
00:19:20,580 --> 00:19:23,040
inside for loops say we have an upload

450
00:19:23,040 --> 00:19:25,650
method to upload a document and we want

451
00:19:25,650 --> 00:19:27,420
to upload multiple documents one at a

452
00:19:27,420 --> 00:19:30,060
time we can just loop over the documents

453
00:19:30,060 --> 00:19:32,190
and upload them one at a time a

454
00:19:32,190 --> 00:19:35,520
synchronously so the result of this is a

455
00:19:35,520 --> 00:19:37,410
is a promise so this function is a

456
00:19:37,410 --> 00:19:39,540
function that returns a promise it's

457
00:19:39,540 --> 00:19:42,000
asynchronous in its own right and it's

458
00:19:42,000 --> 00:19:43,740
using these asynchronous methods

459
00:19:43,740 --> 00:19:46,440
internally if we wanted to do a parallel

460
00:19:46,440 --> 00:19:49,080
one one option would be to start off all

461
00:19:49,080 --> 00:19:52,620
the operations in one at a time and then

462
00:19:52,620 --> 00:19:54,330
wait for them all to complete one at a

463
00:19:54,330 --> 00:19:57,690
time there are helper methods in most

464
00:19:57,690 --> 00:19:59,190
promise libraries that mean that there

465
00:19:59,190 --> 00:20:02,210
are easier ways you could do this

466
00:20:02,210 --> 00:20:04,049
so I want to talk about how it works

467
00:20:04,049 --> 00:20:06,960
under the hood like initially that can

468
00:20:06,960 --> 00:20:09,240
look like a lot like magic I don't know

469
00:20:09,240 --> 00:20:11,580
my my first reaction to this is that

470
00:20:11,580 --> 00:20:14,010
seems like a lot of magic but it's

471
00:20:14,010 --> 00:20:18,120
actually relatively simple so yield of

472
00:20:18,120 --> 00:20:21,179
some expression is itself an expression

473
00:20:21,179 --> 00:20:25,770
yield evaluates to something and a

474
00:20:25,770 --> 00:20:28,260
generator can be manually operated using

475
00:20:28,260 --> 00:20:30,870
the next method so you can take a

476
00:20:30,870 --> 00:20:33,510
generator and rolling using a four of

477
00:20:33,510 --> 00:20:36,510
loop to loop through it you can manually

478
00:20:36,510 --> 00:20:38,700
say give me the next value

479
00:20:38,700 --> 00:20:40,799
give me the next value give me the next

480
00:20:40,799 --> 00:20:44,790
value so say we have a simple generator

481
00:20:44,790 --> 00:20:48,330
here this generator yields ten asserts

482
00:20:48,330 --> 00:20:51,450
that the result of yielding 10 is 32 and

483
00:20:51,450 --> 00:20:56,160
then returns 42 we can execute this

484
00:20:56,160 --> 00:21:00,090
manually first of all we call demo which

485
00:21:00,090 --> 00:21:03,000
instantiates the generator this returns

486
00:21:03,000 --> 00:21:06,540
an iterator or generator and we can call

487
00:21:06,540 --> 00:21:09,059
next on it and that moves the point the

488
00:21:09,059 --> 00:21:11,640
control flow pointer to that first yield

489
00:21:11,640 --> 00:21:15,570
expression it returns us the thing

490
00:21:15,570 --> 00:21:17,520
that's been yielded which in this case

491
00:21:17,520 --> 00:21:20,760
is the ten and something that a Tanner

492
00:21:20,760 --> 00:21:24,090
and a done property that tells us that

493
00:21:24,090 --> 00:21:26,429
it's not finished yet there are there

494
00:21:26,429 --> 00:21:28,549
are potentially more values to yield

495
00:21:28,549 --> 00:21:31,260
it's not the end of a function and it's

496
00:21:31,260 --> 00:21:34,620
not a return keyword we can then use d

497
00:21:34,620 --> 00:21:38,940
dot next again to move to carry on but

498
00:21:38,940 --> 00:21:41,820
if we like we can feed it a value to

499
00:21:41,820 --> 00:21:45,120
return from that yield so by fielding it

500
00:21:45,120 --> 00:21:48,480
by feeding it that 30 to there we're

501
00:21:48,480 --> 00:21:50,400
able to inject that value into the

502
00:21:50,400 --> 00:21:52,950
function and that becomes the value of

503
00:21:52,950 --> 00:21:55,650
res inside the function hence the assert

504
00:21:55,650 --> 00:21:59,700
path since the result we then get is 42

505
00:21:59,700 --> 00:22:01,650
which is the result from the return and

506
00:22:01,650 --> 00:22:05,250
the done property is true because it's

507
00:22:05,250 --> 00:22:08,730
the last operation if we call D dot next

508
00:22:08,730 --> 00:22:10,320
again it's going to throw because that

509
00:22:10,320 --> 00:22:13,440
function is done it's finished so we

510
00:22:13,440 --> 00:22:15,110
can't carry on using it

511
00:22:15,110 --> 00:22:18,600
now generators were created with this

512
00:22:18,600 --> 00:22:20,970
use case in mind as one of the possible

513
00:22:20,970 --> 00:22:23,670
use cases and as a result we have this

514
00:22:23,670 --> 00:22:29,040
really helpful method afro now fro takes

515
00:22:29,040 --> 00:22:30,840
an error it doesn't have to be an error

516
00:22:30,840 --> 00:22:33,150
you can pass it like 10 if you want to

517
00:22:33,150 --> 00:22:34,830
but I'd strongly recommend you use

518
00:22:34,830 --> 00:22:35,400
errors

519
00:22:35,400 --> 00:22:37,590
whenever you're throwing things throwing

520
00:22:37,590 --> 00:22:39,210
errors gives you stack traces throwing

521
00:22:39,210 --> 00:22:43,260
anything else doesn't so we can use

522
00:22:43,260 --> 00:22:46,470
yield inside a try/catch and we can make

523
00:22:46,470 --> 00:22:49,680
that yield throw to invoke the catch

524
00:22:49,680 --> 00:22:53,280
operation so again we start by calling

525
00:22:53,280 --> 00:22:56,700
demo instantiating the generator we then

526
00:22:56,700 --> 00:22:59,100
call next to move it to that first yield

527
00:22:59,100 --> 00:23:01,590
we get back the result that's yielded so

528
00:23:01,590 --> 00:23:03,450
that's the 10 and the fact that it's not

529
00:23:03,450 --> 00:23:08,100
done we can then call throw and throw an

530
00:23:08,100 --> 00:23:10,800
error into the generator so that will

531
00:23:10,800 --> 00:23:13,260
cause the yield expression to

532
00:23:13,260 --> 00:23:16,260
effectively throw that error and cause

533
00:23:16,260 --> 00:23:19,650
the catch block to be executed so that

534
00:23:19,650 --> 00:23:22,500
allows us on the one hand to represent

535
00:23:22,500 --> 00:23:24,630
fulfilling so this is promises being

536
00:23:24,630 --> 00:23:27,120
fulfilled by injecting values into the

537
00:23:27,120 --> 00:23:29,580
yield and we can represent promises

538
00:23:29,580 --> 00:23:32,010
being rejected by injecting insect

539
00:23:32,010 --> 00:23:34,170
exceptions that are thrown into the

540
00:23:34,170 --> 00:23:37,170
yield so we can put this all together

541
00:23:37,170 --> 00:23:39,510
and we get this surprisingly simple

542
00:23:39,510 --> 00:23:42,360
function so this is a function wrapper

543
00:23:42,360 --> 00:23:44,280
it returns a function when given a

544
00:23:44,280 --> 00:23:47,040
function first thing it does is call

545
00:23:47,040 --> 00:23:49,370
that function to return a generator and

546
00:23:49,370 --> 00:23:51,450
that's going to be a generator that's

547
00:23:51,450 --> 00:23:54,360
effectively an an a lazy sequence of

548
00:23:54,360 --> 00:23:58,350
promises so we start by moving to the

549
00:23:58,350 --> 00:24:00,990
first yield we get the first promise

550
00:24:00,990 --> 00:24:03,030
that's yielded and we attempt to handle

551
00:24:03,030 --> 00:24:07,740
it so handling it says if it's done then

552
00:24:07,740 --> 00:24:09,600
it must be like a return keyword or the

553
00:24:09,600 --> 00:24:11,550
end of a function so just return the

554
00:24:11,550 --> 00:24:14,670
result otherwise we've been yielded a

555
00:24:14,670 --> 00:24:16,260
promise we've been given a promise that

556
00:24:16,260 --> 00:24:18,930
the function wants us to resolve and

557
00:24:18,930 --> 00:24:22,260
give back the result of so we call then

558
00:24:22,260 --> 00:24:27,150
on that promise and if it's if that

559
00:24:27,150 --> 00:24:28,830
promise is fulfilled

560
00:24:28,830 --> 00:24:30,780
we call generator dot next with that

561
00:24:30,780 --> 00:24:33,510
result which lets us inject the

562
00:24:33,510 --> 00:24:35,430
fulfilled result back into the function

563
00:24:35,430 --> 00:24:37,890
and then we handle the next iteration

564
00:24:37,890 --> 00:24:41,390
the next yield the next yield keyword if

565
00:24:41,390 --> 00:24:45,000
the promise is rejected it's very much

566
00:24:45,000 --> 00:24:47,850
the same story but we're throw so we're

567
00:24:47,850 --> 00:24:50,400
now injecting that exception that throw

568
00:24:50,400 --> 00:24:53,480
into the function as it's running and

569
00:24:53,480 --> 00:24:56,490
continuing where we left off and if the

570
00:24:56,490 --> 00:24:58,260
function inside doesn't have a try-catch

571
00:24:58,260 --> 00:24:59,910
then that'll bubble out as an error if

572
00:24:59,910 --> 00:25:02,640
it does have a try-catch though it'll

573
00:25:02,640 --> 00:25:05,220
just get handled and and it can carry on

574
00:25:05,220 --> 00:25:06,510
and there it might it might have a

575
00:25:06,510 --> 00:25:07,980
try-catch that then awaits other

576
00:25:07,980 --> 00:25:14,100
promises later on so generators are a

577
00:25:14,100 --> 00:25:16,800
big win I don't think anyone I haven't

578
00:25:16,800 --> 00:25:19,050
seen many people denying that they're

579
00:25:19,050 --> 00:25:20,880
fantastically useful for controlling

580
00:25:20,880 --> 00:25:24,120
your asynchronous code but there are

581
00:25:24,120 --> 00:25:25,950
people who dispute that generator that

582
00:25:25,950 --> 00:25:28,050
promises are the right tool for the job

583
00:25:28,050 --> 00:25:30,660
for interacting with generators so I

584
00:25:30,660 --> 00:25:32,670
want to give you some examples of some

585
00:25:32,670 --> 00:25:33,690
of the other things that people have

586
00:25:33,690 --> 00:25:35,400
done to try and manage their

587
00:25:35,400 --> 00:25:37,380
asynchronous code I'm only going to give

588
00:25:37,380 --> 00:25:39,900
you examples that work with the native

589
00:25:39,900 --> 00:25:42,330
control flow structures because I'm not

590
00:25:42,330 --> 00:25:43,380
really interested in anything that

591
00:25:43,380 --> 00:25:46,470
doesn't but I haven't chosen difficult

592
00:25:46,470 --> 00:25:48,030
or bad examples I just want to give you

593
00:25:48,030 --> 00:25:49,590
a feel for what else is out there

594
00:25:49,590 --> 00:25:51,330
and why I think they're not really

595
00:25:51,330 --> 00:25:55,470
sufficient so streamline has been around

596
00:25:55,470 --> 00:25:58,440
for a very long time streamline lets you

597
00:25:58,440 --> 00:25:59,910
replace all of your callbacks with the

598
00:25:59,910 --> 00:26:01,860
underscore character and then act as if

599
00:26:01,860 --> 00:26:03,440
all your sync functions are synchronous

600
00:26:03,440 --> 00:26:06,600
now this is fantastically clever but it

601
00:26:06,600 --> 00:26:10,440
does this by read by compiling your your

602
00:26:10,440 --> 00:26:13,260
code into some monstrosity that actually

603
00:26:13,260 --> 00:26:15,840
handles this so that cross-compilation

604
00:26:15,840 --> 00:26:17,940
needs to really ugly code and really

605
00:26:17,940 --> 00:26:20,250
ugly behavior and it has a few other

606
00:26:20,250 --> 00:26:22,500
issues so it works for control flow

607
00:26:22,500 --> 00:26:24,450
primitives like I say that's great

608
00:26:24,450 --> 00:26:26,810
it handles error propagation properly

609
00:26:26,810 --> 00:26:29,100
but it's conflating the input with the

610
00:26:29,100 --> 00:26:30,530
output again again we've got this

611
00:26:30,530 --> 00:26:31,770
parameter

612
00:26:31,770 --> 00:26:33,720
there's not really a parameter it's just

613
00:26:33,720 --> 00:26:35,340
about how we return the result

614
00:26:35,340 --> 00:26:36,840
that's the underscore we have to pass

615
00:26:36,840 --> 00:26:38,520
everywhere that's not too much of an

616
00:26:38,520 --> 00:26:39,050
issue

617
00:26:39,050 --> 00:26:41,670
it also looks entirely synchronous

618
00:26:41,670 --> 00:26:42,120
though

619
00:26:42,120 --> 00:26:44,400
when you read that as a JavaScript

620
00:26:44,400 --> 00:26:46,860
developer its natural to assume that the

621
00:26:46,860 --> 00:26:48,990
function there is synchronous there's no

622
00:26:48,990 --> 00:26:50,880
keywords that imply that this is doing

623
00:26:50,880 --> 00:26:54,270
anything asynchronous and that to me is

624
00:26:54,270 --> 00:26:56,880
a huge problem for maintainability and

625
00:26:56,880 --> 00:26:59,700
it compiles to pretty ugly code and like

626
00:26:59,700 --> 00:27:01,830
it or not sooner or later you're going

627
00:27:01,830 --> 00:27:03,630
to end up trying to debug that code and

628
00:27:03,630 --> 00:27:05,039
that is not code you want to be

629
00:27:05,039 --> 00:27:09,690
debugging so suspend this is probably

630
00:27:09,690 --> 00:27:12,000
one of the most ingenious libraries I've

631
00:27:12,000 --> 00:27:16,260
seen in the last year so this is a way

632
00:27:16,260 --> 00:27:19,320
of using pure callbacks nodejs style

633
00:27:19,320 --> 00:27:22,919
callbacks with generators so it gives

634
00:27:22,919 --> 00:27:25,440
you a callback to use everywhere let's

635
00:27:25,440 --> 00:27:29,279
this resume you pass resume to any of

636
00:27:29,279 --> 00:27:31,799
your asynchronous operations that you

637
00:27:31,799 --> 00:27:35,850
want to yield on you then yield and it

638
00:27:35,850 --> 00:27:39,000
yields until resume is called now this

639
00:27:39,000 --> 00:27:39,750
is very clever

640
00:27:39,750 --> 00:27:41,640
it works for control flow primitives

641
00:27:41,640 --> 00:27:43,590
that handles errors it's conflating the

642
00:27:43,590 --> 00:27:45,809
input with output but it has a really

643
00:27:45,809 --> 00:27:48,779
major flaw it's really not doing what it

644
00:27:48,779 --> 00:27:51,720
looks like it's doing so FS dot read

645
00:27:51,720 --> 00:27:54,059
file is still the nodejs style read file

646
00:27:54,059 --> 00:27:57,179
here it returns undefined so you're

647
00:27:57,179 --> 00:27:59,789
yielding undefined and waiting for that

648
00:27:59,789 --> 00:28:03,120
resume to be called so if I put the FS

649
00:28:03,120 --> 00:28:05,250
read file on the previous line and

650
00:28:05,250 --> 00:28:08,960
yielded some random value say 10 or 42

651
00:28:08,960 --> 00:28:11,549
it would have exactly the same behavior

652
00:28:11,549 --> 00:28:14,850
the yield value is ignored what that

653
00:28:14,850 --> 00:28:17,340
means is that when you refactor it you

654
00:28:17,340 --> 00:28:19,620
get really surprising results you can't

655
00:28:19,620 --> 00:28:21,929
do parallel operation for example you

656
00:28:21,929 --> 00:28:24,860
can't say read this file and store the

657
00:28:24,860 --> 00:28:27,809
pending operation read this file store

658
00:28:27,809 --> 00:28:29,520
that pending operation and then yield on

659
00:28:29,520 --> 00:28:31,289
each one because then you've got a race

660
00:28:31,289 --> 00:28:34,309
to see which one calls resume first

661
00:28:34,309 --> 00:28:37,440
because it's the ordering of calls to

662
00:28:37,440 --> 00:28:39,960
resume that determines which yield goes

663
00:28:39,960 --> 00:28:45,110
with which resume so for me that that

664
00:28:45,110 --> 00:28:47,640
cleverness there is too much cleverness

665
00:28:47,640 --> 00:28:49,529
it's not doing what it looks like it's

666
00:28:49,529 --> 00:28:51,419
doing and therefore I wouldn't want to

667
00:28:51,419 --> 00:28:54,090
use that

668
00:28:54,100 --> 00:28:57,130
next library it's very popular by its by

669
00:28:57,130 --> 00:29:01,690
Vision Media TJ it's called Co so the

670
00:29:01,690 --> 00:29:04,150
idea here is your asynchronous

671
00:29:04,150 --> 00:29:07,120
operations also become lazy they return

672
00:29:07,120 --> 00:29:09,180
a function that takes a call back and

673
00:29:09,180 --> 00:29:12,820
then you yield that function that takes

674
00:29:12,820 --> 00:29:15,340
a call back as its only parameter and Co

675
00:29:15,340 --> 00:29:17,200
will handle calling that function for

676
00:29:17,200 --> 00:29:19,930
you this works with control flow

677
00:29:19,930 --> 00:29:20,620
primitives

678
00:29:20,620 --> 00:29:23,080
it handles errors it can't do parallel

679
00:29:23,080 --> 00:29:25,990
operation as easily because it's lazy so

680
00:29:25,990 --> 00:29:28,300
you can't just start those operations

681
00:29:28,300 --> 00:29:29,860
and then yield on them because they

682
00:29:29,860 --> 00:29:32,290
won't actually start until you yield on

683
00:29:32,290 --> 00:29:32,650
them

684
00:29:32,650 --> 00:29:34,900
you also can't share or cache the

685
00:29:34,900 --> 00:29:36,790
asynchronous operation so I frequently

686
00:29:36,790 --> 00:29:41,650
cash promises as part of like database

687
00:29:41,650 --> 00:29:43,840
reads and things caching these won't

688
00:29:43,840 --> 00:29:45,310
help because you'll end up still

689
00:29:45,310 --> 00:29:47,140
executing the function and you another

690
00:29:47,140 --> 00:29:49,060
time for every time you ask for the

691
00:29:49,060 --> 00:29:52,210
value back so it's a neat abstraction

692
00:29:52,210 --> 00:29:54,490
it's one of the best of the of the worst

693
00:29:54,490 --> 00:29:56,950
but I still wouldn't wouldn't recommend

694
00:29:56,950 --> 00:29:59,230
it I'd still say promises are a lot more

695
00:29:59,230 --> 00:30:01,720
useful a lot more powerful also this

696
00:30:01,720 --> 00:30:03,820
offers you know help today

697
00:30:03,820 --> 00:30:06,820
so using this method offers you no help

698
00:30:06,820 --> 00:30:09,340
when you don't have generators it's only

699
00:30:09,340 --> 00:30:12,130
a help when you've got generators so to

700
00:30:12,130 --> 00:30:16,090
wrap up promises let us turn this read

701
00:30:16,090 --> 00:30:19,270
json function which is 90% error

702
00:30:19,270 --> 00:30:23,230
handling into a read json function that

703
00:30:23,230 --> 00:30:25,150
just has the business logic and that

704
00:30:25,150 --> 00:30:27,640
simple then method to indicate that

705
00:30:27,640 --> 00:30:29,880
we're doing something a synchronous

706
00:30:29,880 --> 00:30:33,070
generators let us turn this nested read

707
00:30:33,070 --> 00:30:36,430
file operation with with multiple calls

708
00:30:36,430 --> 00:30:38,170
to then which is about as simple as I

709
00:30:38,170 --> 00:30:40,210
can write that that specific code in

710
00:30:40,210 --> 00:30:43,090
promises into something that looks a lot

711
00:30:43,090 --> 00:30:45,550
more like what we're used to seeing the

712
00:30:45,550 --> 00:30:47,560
multiple operations one on each line

713
00:30:47,560 --> 00:30:50,170
with no need no need for indentation

714
00:30:50,170 --> 00:30:52,450
just to create that that asynchronous

715
00:30:52,450 --> 00:30:54,270
control flow

716
00:30:54,270 --> 00:30:56,530
I've been Forbes Lindsay thank you for

717
00:30:56,530 --> 00:30:57,850
listening you can find me on Twitter

718
00:30:57,850 --> 00:31:00,040
github I have a blog I maintain loads of

719
00:31:00,040 --> 00:31:01,810
open source projects I work at Red Gate

720
00:31:01,810 --> 00:31:03,490
and the slides are online if you want to

721
00:31:03,490 --> 00:31:10,570
grab them thank you

722
00:31:10,580 --> 00:31:20,310
you

