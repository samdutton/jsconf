1
00:00:09,200 --> 00:00:12,800
Hi, I'm James.

2
00:00:12,800 --> 00:00:15,690
I'm here to talk to you about breaking changes.

3
00:00:15,690 --> 00:00:20,270
To provide a bit of context and introduce
myself, I am the creator of and maintainer

4
00:00:20,270 --> 00:00:27,490
of the this set of MPM packages that provide
WebSocket messaging, various layers of that

5
00:00:27,490 --> 00:00:28,490
protocol.

6
00:00:28,490 --> 00:00:30,590
They're widely used by different projects.

7
00:00:30,590 --> 00:00:36,429
They generate about eight million downloads
a week between them, and I've been maintaining

8
00:00:36,429 --> 00:00:41,000
these pretty much since Node was released,
so since early 2010.

9
00:00:41,000 --> 00:00:45,750
So this is a reflection of my experience as
an open-source maintainer of seeing things

10
00:00:45,750 --> 00:00:49,389
change over time, and what the effects of
that are.

11
00:00:49,389 --> 00:00:51,309
An additional bit of context.

12
00:00:51,309 --> 00:00:55,409
This talk should not be construed as a complaint
about how things work.

13
00:00:55,409 --> 00:00:59,929
We should be really grateful for all the software
that we get for free that lets us do loads

14
00:00:59,929 --> 00:01:00,929
of amazing stuff.

15
00:01:00,929 --> 00:01:07,570
I'm trying to reflect on again my own experience
rather than bashing anybody else and saying

16
00:01:07,570 --> 00:01:08,570
you're doing this wrong.

17
00:01:08,570 --> 00:01:12,780
It's how can we reflect and improve what we
are doing?

18
00:01:12,780 --> 00:01:18,950
Okay, so, with that out of the way, what do
we mean by "breaking"?

19
00:01:18,950 --> 00:01:26,100
Consider this module at the top that has a
method called "get", and it takes a URL and

20
00:01:26,100 --> 00:01:33,340
makes an HTTP request of the URL and invokes
a callback with a status code which I've hard-coded

21
00:01:33,340 --> 00:01:35,270
here as a number.

22
00:01:35,270 --> 00:01:40,830
Let's say we change that number 404 and replace
it with the string 404.

23
00:01:40,830 --> 00:01:42,780
Do we think that is breaking change or not?

24
00:01:42,780 --> 00:01:45,370
To answer that, we have to look at some use
cases.

25
00:01:45,370 --> 00:01:50,070
If something is calling this function, and
it's using the weaker quality operator to

26
00:01:50,070 --> 00:01:54,800
compare the numbers, that will keep working,
because, in JavaScript, a number is week weakly

27
00:01:54,800 --> 00:01:56,390
equal to its string representation.

28
00:01:56,390 --> 00:02:02,270
However, if we're using stricter quality,
this code will now break because numbers and

29
00:02:02,270 --> 00:02:06,100
strings are never strictly equal to each other,
so, if we have this code, we consider the

30
00:02:06,100 --> 00:02:09,789
change to the HTTP module to have broken our
programme.

31
00:02:09,789 --> 00:02:17,250
Another example: this module contains a method
that takes the name of a table and it runs

32
00:02:17,250 --> 00:02:21,780
a query to count the number of records in
that table, and then it invokes your callback

33
00:02:21,780 --> 00:02:26,540
with the count which again I've hard-coded,
and in the something about this module.

34
00:02:26,540 --> 00:02:29,739
This is structural usual identical to the
other module that I just showed you.

35
00:02:29,739 --> 00:02:32,409
All I've done is replace some of the names.

36
00:02:32,409 --> 00:02:37,310
The actual programmatic structure in terms
of what the compiler cares about is the same

37
00:02:37,310 --> 00:02:43,569
as the HTTP module, so, if we believe that
that breaking change compatibility is purely

38
00:02:43,569 --> 00:02:47,639
a function of the source code itself, then
we have to give the same answer for the HTTP

39
00:02:47,639 --> 00:02:49,920
module and this one.

40
00:02:49,920 --> 00:02:51,530
Let's look at some use cases.

41
00:02:51,530 --> 00:02:56,349
So, say somebody is counting the number of
records in tables and then subtracting them,

42
00:02:56,349 --> 00:03:02,360
for example, to work out the number of remaining
tickets left for a conference, now, in JavaScript,

43
00:03:02,360 --> 00:03:07,269
the subtraction operator coerces strings to
number so you get arithmetic sub extraction

44
00:03:07,269 --> 00:03:11,629
and the same result you had before.

45
00:03:11,629 --> 00:03:18,670
If you're adding them together, the plus operator
has an overloaded meeting, performing numbers

46
00:03:18,670 --> 00:03:21,260
and concatenate strings together.

47
00:03:21,260 --> 00:03:27,730
If something was a number and now a string,
we get the string concatenation of those two

48
00:03:27,730 --> 00:03:31,090
values, so this value no longer — programme
does the same thing, and the author of this

49
00:03:31,090 --> 00:03:34,730
programme would consider it broken by the
changes made.

50
00:03:34,730 --> 00:03:42,230
So, yeah, we would have to make an explicit
change here to account for the fact that the

51
00:03:42,230 --> 00:03:46,939
database module has changed how it represents
the results to us by explicitly converting

52
00:03:46,939 --> 00:03:48,769
the strings back to numbers again.

53
00:03:48,769 --> 00:03:55,419
So, what we've seen here is that the meaning
of values in programmes is not, like, fully

54
00:03:55,419 --> 00:03:56,419
contained within themselves.

55
00:03:56,419 --> 00:04:02,769
It is not to do with what their type is, like
a number can be used for several different

56
00:04:02,769 --> 00:04:06,540
purposes, it depends how you're using it that
determines whether changing it would be a

57
00:04:06,540 --> 00:04:07,790
problem.

58
00:04:07,790 --> 00:04:15,069
So, what we've seen is that, rather than just
beak a number, like something having one type,

59
00:04:15,069 --> 00:04:17,579
it actually has a set of characteristic traits.

60
00:04:17,579 --> 00:04:21,230
A Java programmer might call these "interfacers".

61
00:04:21,230 --> 00:04:25,380
Haskell users might call them type classes,
but the idea is that a value of a certain

62
00:04:25,380 --> 00:04:29,630
type can be used for different operations,
and it's which of those operations that you're

63
00:04:29,630 --> 00:04:33,630
using which determines their true meaning.

64
00:04:33,630 --> 00:04:37,780
So we've seen a couple of these already, like
a number might be used for its identity, like

65
00:04:37,780 --> 00:04:42,730
an HTTP status code is not like an arithmetic
number, it's a machine-readable label for

66
00:04:42,730 --> 00:04:44,200
something.

67
00:04:44,200 --> 00:04:47,280
But numbers also have arithmetic properties.

68
00:04:47,280 --> 00:04:52,130
You might want to do maths with them, addition
and subtraction, and so on.

69
00:04:52,130 --> 00:04:56,100
So that is a little bit of an example of why
the complexity even exists in very simple

70
00:04:56,100 --> 00:04:57,480
values like numbers.

71
00:04:57,480 --> 00:04:58,700
What about objects?

72
00:04:58,700 --> 00:05:00,351
What happens when we change the interfaces
to those?

73
00:05:00,351 --> 00:05:05,280
Let's say we have a function that returns
an object that convince some information about

74
00:05:05,280 --> 00:05:08,670
— that returns some information about the
returns of the conference, in fact, this talk

75
00:05:08,670 --> 00:05:10,250
in this conference.

76
00:05:10,250 --> 00:05:14,360
It contains a title, date, and a presenter,
all of which are strings.

77
00:05:14,360 --> 00:05:20,010
Now, adding a new field to this object is
probably not a problem.

78
00:05:20,010 --> 00:05:25,010
Any programme that is using this will probably
just ignore the fact that the new field exists,

79
00:05:25,010 --> 00:05:26,010
right?

80
00:05:26,010 --> 00:05:30,430
It won't be relying on it, so this object
gaping a few field won't disrupt any existing

81
00:05:30,430 --> 00:05:31,530
code.

82
00:05:31,530 --> 00:05:38,280
However, if we remove a field, like the title
object — sorry, the title property — some

83
00:05:38,280 --> 00:05:42,150
code that is using this function will now
probably break, so, for example, if we are

84
00:05:42,150 --> 00:05:47,170
calling get hook info and putting the title
attribute of the result into a string, we

85
00:05:47,170 --> 00:05:52,280
will now get a string containing undefined,
and this is a case where JavaScript doesn't

86
00:05:52,280 --> 00:05:54,060
alert you to the fact that it has made a mistake.

87
00:05:54,060 --> 00:05:58,290
You don't get an error if you access an attribute
that doesn't exist, you get the value undefined,

88
00:05:58,290 --> 00:05:59,810
and that shows up in the spring.

89
00:05:59,810 --> 00:06:04,820
The programme hasn't broken in the sense that
it is crashing, but it is clearly not doing

90
00:06:04,820 --> 00:06:07,400
what was intended.

91
00:06:07,400 --> 00:06:11,040
A user will notice that something weird has
happened here.

92
00:06:11,040 --> 00:06:15,740
Likewise, changing the types of existing fields
is likely to break existing programmes.

93
00:06:15,740 --> 00:06:22,030
So, for example, if we were calling get hook
info and then split the date field on dashes

94
00:06:22,030 --> 00:06:26,310
to break the date into its component parts,
that will no longer work because a date object

95
00:06:26,310 --> 00:06:28,960
doesn't have a split method.

96
00:06:28,960 --> 00:06:34,360
So, in broad terms, adding new fields to an
object is fine.

97
00:06:34,360 --> 00:06:38,010
The existing callers will just ignore that
new field.

98
00:06:38,010 --> 00:06:42,720
Removing a field might break things as we've
seen, and JavaScript won't alert you to that

99
00:06:42,720 --> 00:06:43,720
problem.

100
00:06:43,720 --> 00:06:46,180
And changing the type of existing fields can
also break things.

101
00:06:46,180 --> 00:06:49,930
Sometimes, you will get an error because you're
using a method that doesn't exist, but sometimes,

102
00:06:49,930 --> 00:06:53,280
the programme will silently do the wrong thing.

103
00:06:53,280 --> 00:06:55,260
But it's not quite as simple as that.

104
00:06:55,260 --> 00:06:59,940
JavaScript being a small language has overloaded
the few abstractions that it has with several

105
00:06:59,940 --> 00:07:01,560
different meanings.

106
00:07:01,560 --> 00:07:07,590
There are multiple different ideas and computation
that is are overloaded on to the same thing

107
00:07:07,590 --> 00:07:12,240
in JavaScript, and, one of those things is
object.

108
00:07:12,240 --> 00:07:18,650
We use object to represent the computational
idea of maps, of records, of object-orientated

109
00:07:18,650 --> 00:07:23,900
style objects, and several other things, so
what do these terms mean?

110
00:07:23,900 --> 00:07:26,340
We are using this one thing object for a lot
of different functions.

111
00:07:26,340 --> 00:07:30,050
We need to think about the different ways
in which it's used.

112
00:07:30,050 --> 00:07:37,880
So a map is an open-ended collection of key
value pairs and, typically, the programme

113
00:07:37,880 --> 00:07:42,680
doesn't care about what specific keys are
in the object, it is just data, and it gets

114
00:07:42,680 --> 00:07:45,410
processed, like whatever is there is processed.

115
00:07:45,410 --> 00:07:49,770
Typically, if your programme is iterating
over an object and owing what is — and programming

116
00:07:49,770 --> 00:07:52,650
what it contains, it uses a map.

117
00:07:52,650 --> 00:07:58,610
A record is a fixed set of known fields where
the field can have different types and the

118
00:07:58,610 --> 00:08:03,190
programme usually cares about specific fields
within an object, so the proxy pass to react

119
00:08:03,190 --> 00:08:05,320
component are a good example of this.

120
00:08:05,320 --> 00:08:09,420
You don't just iterate over them and do the
same thing over the fields, you normally pick

121
00:08:09,420 --> 00:08:13,820
out the specific fields and put them in specific
places in your UI.

122
00:08:13,820 --> 00:08:19,770
An object-orientated programming kind of object
is bit like an extension of a record.

123
00:08:19,770 --> 00:08:23,890
It is a computational value that combines
state with behaviour, so it's like a record

124
00:08:23,890 --> 00:08:29,760
where some of the fields are functions that
access the record's other data fields.

125
00:08:29,760 --> 00:08:34,150
So the image value that I used in the previous
example here is a good example of that, that

126
00:08:34,150 --> 00:08:39,240
image.url bit comes from a class that takes
a name, and it has a method that those how

127
00:08:39,240 --> 00:08:43,650
to calculate the URL for the particular size
of an image.

128
00:08:43,650 --> 00:08:49,180
Typically, adding new methods to an OAP style
object is fine which enables polymorphism,

129
00:08:49,180 --> 00:08:54,250
which means that one function can work with
lots of different kind of objects as long

130
00:08:54,250 --> 00:08:56,840
as they have a method in common.

131
00:08:56,840 --> 00:09:06,580
Its rivel in JavaScript is an example of this
adding now fields to other things like records

132
00:09:06,580 --> 00:09:08,000
can cause problems.

133
00:09:08,000 --> 00:09:15,550
So, for example, if you add a field to your
web pack could be config that it doesn't recognise,

134
00:09:15,550 --> 00:09:18,890
you would get an error.

135
00:09:18,890 --> 00:09:22,290
It checks everything that your object includes,
and, if it don't recognise it, it gets an

136
00:09:22,290 --> 00:09:24,820
error.

137
00:09:24,820 --> 00:09:30,360
The kind of programme that web pack is, it
indicates an error on the part of the user

138
00:09:30,360 --> 00:09:35,190
if it includes data that should not be there
— it usually indicates a typo, or a field

139
00:09:35,190 --> 00:09:39,570
that is no longer supported if you've upgraded
from 3 to 4.

140
00:09:39,570 --> 00:09:43,630
So it's not always the case that adding new
fields to something keeps your programme working.

141
00:09:43,630 --> 00:09:49,140
In some cases, it will break them, and that's
done for ergonomic reasons to help the user

142
00:09:49,140 --> 00:09:51,600
use the programme correctly.

143
00:09:51,600 --> 00:09:56,090
Likewise, if you're inserting something in
a database, if you trying to I to save an

144
00:09:56,090 --> 00:10:01,740
object to a table, should that be silently
ignored if it doesn't have a property?

145
00:10:01,740 --> 00:10:05,070
Should that be silently ignored?

146
00:10:05,070 --> 00:10:12,080
ORMs typically include explicit instructions
for these properties get saved to the database

147
00:10:12,080 --> 00:10:19,320
and these don't and the user has to decide
which things belong in which category.

148
00:10:19,320 --> 00:10:25,260
So that's a little bit about — we've seen
how primitive values like numbers can contain

149
00:10:25,260 --> 00:10:29,250
quite a lot of complexity, and, likewise,
something like object can take on a lot of

150
00:10:29,250 --> 00:10:34,240
different computational meanings, and so changing
it has different effects in different circumstances.

151
00:10:34,240 --> 00:10:42,050
But another thing that causes programmes to
break is just the concepts we are expressing

152
00:10:42,050 --> 00:10:44,240
are too complicated.

153
00:10:44,240 --> 00:10:50,660
One example of this was the recent proposal
to add the flat method to the array prototype,

154
00:10:50,660 --> 00:10:55,490
and a lot of people petitioned TC39 not to
do this because it would conflict with another

155
00:10:55,490 --> 00:10:58,230
implementation already out in the wild.

156
00:10:58,230 --> 00:10:59,830
Why would this be a problem?

157
00:10:59,830 --> 00:11:07,810
It's partly for sort of logistical reasons,
like, TC39 is responsible for the environment

158
00:11:07,810 --> 00:11:11,340
that exists in the browser, right, so we as
developers don't have control over that, our

159
00:11:11,340 --> 00:11:15,520
code gets deployed into all these browsers,
and it has to deal with whatever is there,

160
00:11:15,520 --> 00:11:16,520
right?

161
00:11:16,520 --> 00:11:19,570
It's not like one of our dependencies where
we choose which version it is.

162
00:11:19,570 --> 00:11:24,510
Anything in the browser affects the code runs
and we don't have direct control over it.

163
00:11:24,510 --> 00:11:30,020
TC39 changing things in a way that conflicts
with our code can cause problems.

164
00:11:30,020 --> 00:11:33,850
Why does that conflict even exist in the first
place?

165
00:11:33,850 --> 00:11:38,300
If we were talking about a fairly simple function,
it is quite likely that TC39's definition

166
00:11:38,300 --> 00:11:43,090
would agree with the one the community had
already adopted, and we wouldn't have a problem.

167
00:11:43,090 --> 00:11:48,860
But the thing with the flattened method is
that it is extremely conceptually complicated.

168
00:11:48,860 --> 00:11:50,910
Here's one potential implementation of it.

169
00:11:50,910 --> 00:11:57,690
So, we implement flatten by introducing starting
with an empty list and concatenating the array

170
00:11:57,690 --> 00:11:58,690
together.

171
00:11:58,690 --> 00:12:05,000
The way this works is that it is will combine
any array inside the outer array and flatten

172
00:12:05,000 --> 00:12:07,760
the array to one level deep.

173
00:12:07,760 --> 00:12:12,370
You might decide you want your array flattened
infinitely deep, and this won't do that.

174
00:12:12,370 --> 00:12:19,650
Or you might care about other collections,
like iterable collections like strings, or

175
00:12:19,650 --> 00:12:24,320
a set that is already present in the outer
array — what is the effect of null?

176
00:12:24,320 --> 00:12:26,420
What does it mean to combine these values?

177
00:12:26,420 --> 00:12:31,310
There is a broad set of decisions to be made
here about what this function even means.

178
00:12:31,310 --> 00:12:36,160
And that means there is a broad spates of
different implementations of it.

179
00:12:36,160 --> 00:12:40,260
If you put two implementations of this function
in the same programme, they're likely to disagree

180
00:12:40,260 --> 00:12:41,980
with each other.

181
00:12:41,980 --> 00:12:46,779
And so, one way that you can avoid breaking
things is to avoid using functions that are

182
00:12:46,779 --> 00:12:47,880
this complicated.

183
00:12:47,880 --> 00:12:51,279
Often, if you have something and you want
to flatten is to one level deep, you want

184
00:12:51,279 --> 00:12:53,040
to use FlatMap instead.

185
00:12:53,040 --> 00:12:59,200
If you know your arbitrarily deep, you might
want to use an interpreter.

186
00:12:59,200 --> 00:13:03,260
If you don't know how deeply nested your structure
is, you have a deeper design problem that

187
00:13:03,260 --> 00:13:04,899
needs fixing.

188
00:13:04,899 --> 00:13:10,830
Yes, there is a lot of complexity inherent
in this method which means it's hard to make

189
00:13:10,830 --> 00:13:13,170
it into operate.

190
00:13:13,170 --> 00:13:16,960
We saw a similar thing with the buffer constructor
in node which was taking several different

191
00:13:16,960 --> 00:13:22,070
types of values and giving a different behaviour
depending on the type, and it was easy to

192
00:13:22,070 --> 00:13:26,500
parse a number instead of a string and then
get different behaviour and this caused security

193
00:13:26,500 --> 00:13:31,550
errors in some WebSocket implementations where
you could make the server expose unsanitised

194
00:13:31,550 --> 00:13:34,770
memory to you.

195
00:13:34,770 --> 00:13:39,180
We fixed that by turning into several different
methods that made it explicit, like the user

196
00:13:39,180 --> 00:13:42,730
would make it explicit what behaviour they
wanted: either they want a buffer that contains

197
00:13:42,730 --> 00:13:47,580
the byte data for a string or they want a
buffer that is a fixed size of memory, and

198
00:13:47,580 --> 00:13:48,670
now you've made it unambiguous.

199
00:13:48,670 --> 00:13:53,720
The user is saying what they want.

200
00:13:53,720 --> 00:13:57,250
So it's not just about the return values that
our programmes have, and how things are consuming

201
00:13:57,250 --> 00:13:58,250
them.

202
00:13:58,250 --> 00:14:02,710
There's an implicit contract between any function
and the things it takes in terms of of what

203
00:14:02,710 --> 00:14:04,850
properties it expects them to have.

204
00:14:04,850 --> 00:14:08,390
So, take this contains function.

205
00:14:08,390 --> 00:14:12,130
This takes a list and a value, and it returns
a count of the number of times that value

206
00:14:12,130 --> 00:14:14,070
appears in the list.

207
00:14:14,070 --> 00:14:21,690
It does that by initialising a counter to
zero, and then using a for-of-loop iterating

208
00:14:21,690 --> 00:14:26,140
over the counter.

209
00:14:26,140 --> 00:14:30,390
This works fine with arrays, as you would
expect, but because it uses a for-of loop,

210
00:14:30,390 --> 00:14:32,890
it use any kind of iterable value.

211
00:14:32,890 --> 00:14:38,980
If somebody is using this with a set, it will
only one a 0 or a 1 with the set because sets

212
00:14:38,980 --> 00:14:44,310
only contain one of each value but that is
good to determine truthiness whether something

213
00:14:44,310 --> 00:14:48,880
exists in the set or not.

214
00:14:48,880 --> 00:14:53,050
Say the author of the contains function decides
to change it, their assumption is that it

215
00:14:53,050 --> 00:14:56,410
is only being used with arrays, so they will
use an array method.

216
00:14:56,410 --> 00:15:03,200
They use it using the filter method using
values value to the input, and then return

217
00:15:03,200 --> 00:15:04,580
the length of the result.

218
00:15:04,580 --> 00:15:07,610
So this continues to to work with arrays just
fine.

219
00:15:07,610 --> 00:15:12,540
But now it blows up when you give it a set,
because sets don't implement the filter method.

220
00:15:12,540 --> 00:15:18,310
We get a slightly unobvious error here like
the word "filter" doesn't correspond to anything

221
00:15:18,310 --> 00:15:23,020
the user has said here, it's an error being
thrown by the internals, but the programme

222
00:15:23,020 --> 00:15:31,899
is rejecting an input that it previously accepted
and that is because the author assumed that

223
00:15:31,899 --> 00:15:38,000
people would only use it with one kind of
value, but they never made that explicit.

224
00:15:38,000 --> 00:15:43,700
So, we should also consider side effects when
looking at our programmes.

225
00:15:43,700 --> 00:15:50,370
JavaScript being an imperative language, our
programmes don't just call functions and returns

226
00:15:50,370 --> 00:15:51,660
values, they also have side effects.

227
00:15:51,660 --> 00:15:55,930
For example, here's a function that adds a
dependency to your package.json by reading

228
00:15:55,930 --> 00:16:00,240
the file, parsing it, adding a dependency
and copying back to list.

229
00:16:00,240 --> 00:16:06,279
If we add a console log line, is that breaking
change?

230
00:16:06,279 --> 00:16:14,700
If it is embedded in a programme that expects
to output JSON output, adding this log line

231
00:16:14,700 --> 00:16:16,810
will make that programme fail.

232
00:16:16,810 --> 00:16:23,700
Likewise, if you have an event emitter, you
might decide to add a new value to the data

233
00:16:23,700 --> 00:16:27,690
that is emitted with an event, and JavaScript
lets you call functions with more arguments

234
00:16:27,690 --> 00:16:31,030
than they were expecting, so this ought to
be fine, right?

235
00:16:31,030 --> 00:16:36,980
Turns out somebody is using a vary added function
and expects the values to be the same time

236
00:16:36,980 --> 00:16:41,459
and processed in the same way.

237
00:16:41,459 --> 00:16:46,910
I could go on with these sorts of examples
all day, but the core theme here is that JavaScript

238
00:16:46,910 --> 00:16:51,610
doesn't make it particularly easy for you
to write code that works and keeps working.

239
00:16:51,610 --> 00:16:55,769
It is permissive, works with code that you
expect to throw you an error.

240
00:16:55,769 --> 00:17:00,340
When it gives an error message, it isn't helpful
and doesn't identify which bit of the programme

241
00:17:00,340 --> 00:17:06,179
is incorrect, and you have no way of telling
the compiler how you expect people to use

242
00:17:06,179 --> 00:17:07,179
your programme.

243
00:17:07,179 --> 00:17:10,920
The compiler can't tell you and you've done
something that will break those.

244
00:17:10,920 --> 00:17:14,020
Enough complaining.

245
00:17:14,020 --> 00:17:19,390
What can we actually do?

246
00:17:19,390 --> 00:17:24,829
One popular answer to this problem is semantic
versions, or Sam very for short, which is

247
00:17:24,829 --> 00:17:30,780
that you format your version numbers as three
separate numbers where ink submitting the

248
00:17:30,780 --> 00:17:34,550
front one means you've made an backwards incompatible
change.

249
00:17:34,550 --> 00:17:39,780
Second one is a new feature in a backwards
compatible way, and changing the last number

250
00:17:39,780 --> 00:17:41,300
means you've made a bug fix.

251
00:17:41,300 --> 00:17:46,260
As we've seen, compatibility doesn't hinge
on the module itself but on the context in

252
00:17:46,260 --> 00:17:48,490
which the module is being used.

253
00:17:48,490 --> 00:17:54,390
SemVer has conceptual limitations in that
sense but also practical ones.

254
00:17:54,390 --> 00:17:57,780
It is hard to express fine-grained information.

255
00:17:57,780 --> 00:18:05,140
Like you might have released a breaking change
but you haven't — like all the functions

256
00:18:05,140 --> 00:18:08,940
that I happen to be using from your package
are still fine, so I can't tell from the version

257
00:18:08,940 --> 00:18:09,940
number whether it has saved the upgrade.

258
00:18:09,940 --> 00:18:12,490
— whether it is safe to upgrade.

259
00:18:12,490 --> 00:18:17,230
You can see it playing out in the ecosystem
that a lot of time I've seen breaking changes

260
00:18:17,230 --> 00:18:21,429
in production, they show newspaper bug fixes
releases.

261
00:18:21,429 --> 00:18:29,640
Last year, we had a denial of service vulnerability,
and at the end of 2016, the sdlib library

262
00:18:29,640 --> 00:18:42,490
released since 2009, which gives you an idea
— and that contained a change that meant

263
00:18:42,490 --> 00:18:46,190
previously valid configuration values that
are required by the WebSocket compression

264
00:18:46,190 --> 00:18:48,980
protocol were now illegal and it would throw
errors on them.

265
00:18:48,980 --> 00:18:56,040
In April the following year, Node.js released
4.8.2 and 6.10.2 which bundled this version

266
00:18:56,040 --> 00:18:58,950
of sdlib and broke WebSocket servers.

267
00:18:58,950 --> 00:19:07,960
In August, when we were releasing the new
libraries, we discovered this issue, reported

268
00:19:07,960 --> 00:19:14,670
it to the Node project, and Miles from the
Node project reported this issue to sdlib.

269
00:19:14,670 --> 00:19:21,220
This is not necessarily a bug in sdlib, it
is sdlib's intention that these values are

270
00:19:21,220 --> 00:19:22,830
not legal and you should not use they will.

271
00:19:22,830 --> 00:19:25,929
They didn't know that this would break stuff
to do with the WebSocket protocol.

272
00:19:25,929 --> 00:19:31,500
A month later after figuring out the possible
solutions, the fact that we would have to

273
00:19:31,500 --> 00:19:37,770
deviate from the spec to make the programmes
stop crashing and written everything up, deflate

274
00:19:37,770 --> 00:19:42,650
reels cache, and a month after that Node.js
released versions four, six, and eight in

275
00:19:42,650 --> 00:19:47,410
a paper over the problem.

276
00:19:47,410 --> 00:19:52,600
This gives you some idea of the time it takes
for these changes to propagate through the

277
00:19:52,600 --> 00:19:53,600
system.

278
00:19:53,600 --> 00:19:56,620
Everyone is working with imperfect information
and we have to figure out what is going on,

279
00:19:56,620 --> 00:19:57,960
and that takes time.

280
00:19:57,960 --> 00:20:02,929
When you're changing a system, you don't have
to look at the meaning of the programme like

281
00:20:02,929 --> 00:20:08,511
on its own, you have to think about the effect
on the ecosystem of the community for the

282
00:20:08,511 --> 00:20:10,700
information of that change to spread.

283
00:20:10,700 --> 00:20:14,450
If you make too much change too quickly, you
end up leaving everybody behind and you end

284
00:20:14,450 --> 00:20:17,790
up not upgrading your software.

285
00:20:17,790 --> 00:20:24,650
Another approach to breaking change is try
to never break anything which sound like an

286
00:20:24,650 --> 00:20:25,730
extreme position.

287
00:20:25,730 --> 00:20:31,410
I'm not sure any of us would ever manage to
live by this standard.

288
00:20:31,410 --> 00:20:34,480
But, it is a constraint that people try and
live to.

289
00:20:34,480 --> 00:20:40,240
We saw Ryan yesterday say it's my fault, and
I'm very sorry, unfortunately, it is impossible

290
00:20:40,240 --> 00:20:41,520
to undo now.

291
00:20:41,520 --> 00:20:43,840
This is the world we live in.

292
00:20:43,840 --> 00:20:47,140
Too much stuff depends on our code, and we
can't change it.

293
00:20:47,140 --> 00:20:51,820
It is what I try to live by in my software
and partly to do with how the maintenance

294
00:20:51,820 --> 00:20:53,990
works.

295
00:20:53,990 --> 00:20:57,330
There's two main reasons why I try to work
this way.

296
00:20:57,330 --> 00:21:00,270
The first is I'm not in direct contact with
all of my users.

297
00:21:00,270 --> 00:21:04,390
If I want to change something that's hard
for me to inform the largest is people using

298
00:21:04,390 --> 00:21:07,940
this code that I'm going to change it and
they might need to update something.

299
00:21:07,940 --> 00:21:14,220
Most of the people running my code don't know
they're doing so.

300
00:21:14,220 --> 00:21:20,020
So, my modules are typically embedded as transitive
dependencies inside other things that people

301
00:21:20,020 --> 00:21:26,090
are using, so there are two or three levels
of intermediaries of the end-user and my code,

302
00:21:26,090 --> 00:21:30,460
so, if I break something, there are several
other authors and projects that would have

303
00:21:30,460 --> 00:21:36,240
to paper over that for the end-user to see
any benefit from it.

304
00:21:36,240 --> 00:21:41,230
Because I do a open source in my spare time,
I don't have a predictable amount of bandwidth

305
00:21:41,230 --> 00:21:46,740
for switching problems so it's more valuable
for me to keep things stable rather than release

306
00:21:46,740 --> 00:21:51,320
stuff that might break things and have no
visibility when I might be able to do with

307
00:21:51,320 --> 00:21:52,320
that later.

308
00:21:52,320 --> 00:21:55,760
I take a similar approach to my dependencies.

309
00:21:55,760 --> 00:22:00,860
I leave them open-ended rather than pinning
them with the carat or tilde operator.

310
00:22:00,860 --> 00:22:07,059
I don't want to be a bottleneck on people
getting an upgrade to the things that I'm

311
00:22:07,059 --> 00:22:13,049
depending on.. and I'm taking a risk here
that these things might not be stable, but

312
00:22:13,049 --> 00:22:14,510
that's countered by other measures.

313
00:22:14,510 --> 00:22:16,720
I'm conservative with the things that I depend
on.

314
00:22:16,720 --> 00:22:22,309
I will typically try and adopt something and
live with it for a few months and get an understanding

315
00:22:22,309 --> 00:22:28,230
how it behaves over time before I release
it to my users.

316
00:22:28,230 --> 00:22:29,669
All this hinges on communication.

317
00:22:29,669 --> 00:22:33,270
All of this stuff is — we've seen a lot
of talks at this conference about how we communicate

318
00:22:33,270 --> 00:22:35,500
with each other.

319
00:22:35,500 --> 00:22:42,559
The core message that I want you to take away
from this is that compatibility isn't an objective

320
00:22:42,559 --> 00:22:47,730
technocratic thing about the code itself,
it's about the tact that we all have imperfect

321
00:22:47,730 --> 00:22:52,610
information about the author and the user
and the software know different things about

322
00:22:52,610 --> 00:22:59,650
the software, and that means that the author's
intent and the user's usage will deviate.

323
00:22:59,650 --> 00:23:05,240
The best ways that we can try to avoid things
breaking is by affecting how people use our

324
00:23:05,240 --> 00:23:07,120
software, in how we communicate with them.

325
00:23:07,120 --> 00:23:11,130
We can partly do that through the code that
we write, so, JavaScript is still a small

326
00:23:11,130 --> 00:23:15,190
language but grown a few things recently to
express yourself better.

327
00:23:15,190 --> 00:23:18,490
It might be more appropriate rather than using
a plain array to use a set that might be the

328
00:23:18,490 --> 00:23:20,740
might help you be more specific about your
meaning.

329
00:23:20,740 --> 00:23:25,530
Instead of using a plain old object it might
be appropriate to use a map for the distinctions

330
00:23:25,530 --> 00:23:30,160
we saw earlier.

331
00:23:30,160 --> 00:23:32,961
If you want to think about the operators and
functions that you're using, if you know you're

332
00:23:32,961 --> 00:23:38,290
doing string concatenation, rather than using
the plus operator, which is ambiguous, consider

333
00:23:38,290 --> 00:23:44,929
using templates or the join method which tells
people you know you're doing string concatenation.

334
00:23:44,929 --> 00:23:48,800
You can try as avoid brittle idioms in the
language that make it likely you will have

335
00:23:48,800 --> 00:23:49,800
to change your mind later.

336
00:23:49,800 --> 00:23:56,950
If a programme is growing a long list of parameters,
and you keep adding more things to it, that

337
00:23:56,950 --> 00:24:00,170
makes the callers to those functions a bit
cryptic, like what do true and false and zero

338
00:24:00,170 --> 00:24:01,170
mean?

339
00:24:01,170 --> 00:24:02,539
I don't really know.

340
00:24:02,539 --> 00:24:05,080
Every time you add a new parameter, it gets
more complicated.

341
00:24:05,080 --> 00:24:11,470
A nicer way to do this is object destructuring
and simulating named arguments and you can

342
00:24:11,470 --> 00:24:12,770
give them default values.

343
00:24:12,770 --> 00:24:17,410
That makes the function easier to change and
makes the caller clearer about what it is

344
00:24:17,410 --> 00:24:18,410
doing.

345
00:24:18,410 --> 00:24:20,680
A really good example of this is callback.

346
00:24:20,680 --> 00:24:25,510
If you want to add a new parameter to callback
function, that parameter needs to go before

347
00:24:25,510 --> 00:24:31,510
the callback, and you need to do some mending-up
at the top of your method to account for callers

348
00:24:31,510 --> 00:24:33,820
that aren't passing that new parameter yet.

349
00:24:33,820 --> 00:24:37,500
It is much easier to do this if your function
returns a promise because the parameter list

350
00:24:37,500 --> 00:24:43,169
hasn't been polluted by this extra parameter
that needs to be at the end, so it's much

351
00:24:43,169 --> 00:24:46,690
easier just to add a new parameter there with
a default value and not to have to add any

352
00:24:46,690 --> 00:24:48,780
of that extra stuff.

353
00:24:48,780 --> 00:24:50,980
Think about the error design.

354
00:24:50,980 --> 00:24:54,179
Errors should be a way that help users write
code that works.

355
00:24:54,179 --> 00:24:58,440
They should not be a Carey thing but there
to help people.

356
00:24:58,440 --> 00:25:03,040
Things throwing errors when you're making
a mistake is good for you.

357
00:25:03,040 --> 00:25:06,669
For example, rather than the cryptic error
we saw later about filter not existing when

358
00:25:06,669 --> 00:25:11,770
we parsed in a set, we can put an assertion
on the top of our method that I expect this

359
00:25:11,770 --> 00:25:12,809
to be used with an array.

360
00:25:12,809 --> 00:25:16,840
If not, I will give you a method that tells
you that is what I expected.

361
00:25:16,840 --> 00:25:21,299
So you can spot the bug in this code.

362
00:25:21,299 --> 00:25:23,580
It's probably not very obvious.

363
00:25:23,580 --> 00:25:30,170
The bug is that bytes has be to an integer
but not on a number divisible by eight.

364
00:25:30,170 --> 00:25:32,800
Sometimes, we will parse a fractional value
here.

365
00:25:32,800 --> 00:25:36,670
This worked fine until Node 9.

366
00:25:36,670 --> 00:25:42,590
The crypto-library rounded the number down,
but the programme that was using this it didn't

367
00:25:42,590 --> 00:25:47,280
matter too much because it was asking for
a lot more random data than it really needed,

368
00:25:47,280 --> 00:25:50,200
so the number being rounded down slightly
wasn't a problem.

369
00:25:50,200 --> 00:25:54,360
Then in node 10, we got an error, key element
is out of range.

370
00:25:54,360 --> 00:25:56,500
This error is slightly unhelpful.

371
00:25:56,500 --> 00:26:01,270
The error that the number is not an integer,
not that this that it is out of range, but

372
00:26:01,270 --> 00:26:03,390
crashing a programme that previously worked.

373
00:26:03,390 --> 00:26:08,750
When you're adding errors to a library later
in its life, think about should that error

374
00:26:08,750 --> 00:26:11,660
get to crash the programmes currently using
it?

375
00:26:11,660 --> 00:26:14,380
Is there a better way to communicate that
failure to the user?

376
00:26:14,380 --> 00:26:18,440
It is quite common for people to dig around
in the console and look at the properties

377
00:26:18,440 --> 00:26:20,180
tab to figure out how to use them.

378
00:26:20,180 --> 00:26:25,730
One convention we have in JavaScript is if
you're accessing a lot of things with underscores,

379
00:26:25,730 --> 00:26:28,220
that's a signal that you're doing something
private.

380
00:26:28,220 --> 00:26:34,040
That's not something the language enforces
for you but it's a way that you can signal

381
00:26:34,040 --> 00:26:40,660
to the user I didn't mean for you to use this,
and it will probably break later.

382
00:26:40,660 --> 00:26:44,120
The final thing that we have to rely on is
documentation.

383
00:26:44,120 --> 00:26:47,370
Documentation should help people use the code
in the way that you intended.

384
00:26:47,370 --> 00:26:54,990
Often, people land on Google and even if you
have like really good documentation, arriving

385
00:26:54,990 --> 00:26:58,620
at pros that — prose that requires a lot
of context will give meme more questions than

386
00:26:58,620 --> 00:26:59,690
they arrive with.

387
00:26:59,690 --> 00:27:05,650
I could be going what's a driver object, should
the you shall object be a strict?

388
00:27:05,650 --> 00:27:07,080
How do I put this stuff together?

389
00:27:07,080 --> 00:27:14,280
It would help people to give a self-contained
example and once they understand the basic

390
00:27:14,280 --> 00:27:20,450
concepts, more ready to dive into your API
details and add things in more detail.

391
00:27:20,450 --> 00:27:24,890
And finally, we have testing.

392
00:27:24,890 --> 00:27:31,340
So, testing is a huge topic but I can't possibly
cover in the minute I have remaining, but

393
00:27:31,340 --> 00:27:37,020
one thing that I often see of people advise
with testing that you should not test your

394
00:27:37,020 --> 00:27:38,020
dependencies.

395
00:27:38,020 --> 00:27:39,020
Don't test third-party code.

396
00:27:39,020 --> 00:27:40,620
That's a really good idea.

397
00:27:40,620 --> 00:27:42,370
You can do that.

398
00:27:42,370 --> 00:27:46,530
What it does is validate your assumptions
and tells you where they're no longer true.

399
00:27:46,530 --> 00:27:52,020
Me as the user of the contains function we
saw earlier, I can say it works with sets.

400
00:27:52,020 --> 00:27:57,790
One day when the author changes it, that will
step working, I will get an error, and then

401
00:27:57,790 --> 00:28:03,300
immediately know that the reason my application
is failing is because the dependency no longer

402
00:28:03,300 --> 00:28:04,300
true.

403
00:28:04,300 --> 00:28:06,650
So, what have we learned?

404
00:28:06,650 --> 00:28:14,620
We've learned that compatibility is not pure
a function of the source code but the context

405
00:28:14,620 --> 00:28:16,020
which it's used.

406
00:28:16,020 --> 00:28:21,200
We've learned that context is constructed
by how people use your programme, something

407
00:28:21,200 --> 00:28:26,490
you don't have control over, and finally,
that you can influence that context by how

408
00:28:26,490 --> 00:28:29,900
you communicate with the users, and how you
tell them if the software is supposed to be

409
00:28:29,900 --> 00:28:31,460
used.

410
00:28:31,460 --> 00:28:32,460
Thank you very much.

