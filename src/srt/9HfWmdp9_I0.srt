1
00:00:18,610 --> 00:00:21,170

so I'm Peter and I'm going to talk to

2
00:00:21,170 --> 00:00:22,870
you about a recompiling JavaScript

3
00:00:22,870 --> 00:00:26,480
without restarting it I'm a Dutch

4
00:00:26,480 --> 00:00:29,450
JavaScript developer I you might have

5
00:00:29,450 --> 00:00:31,820
heard me from JS 1k I organize that and

6
00:00:31,820 --> 00:00:34,310
I build a variety of tools JavaScript

7
00:00:34,310 --> 00:00:36,410
related tools I work for a company

8
00:00:36,410 --> 00:00:38,480
called surf Lee they do remote desktop

9
00:00:38,480 --> 00:00:40,220
in your browser but that's not what I'm

10
00:00:40,220 --> 00:00:43,370
going to talk about today so first we

11
00:00:43,370 --> 00:00:47,840
start with a demo and so we're going to

12
00:00:47,840 --> 00:00:52,220
start with reloading oh dear Lord no so

13
00:00:52,220 --> 00:00:54,080
we're going to start with Riaan abling

14
00:00:54,080 --> 00:01:04,140
endings

15
00:01:04,150 --> 00:01:09,980
it's really exciting I know it's like

16
00:01:09,990 --> 00:01:12,630
and there we go I hope there we go all

17
00:01:12,630 --> 00:01:16,320
right so on the right inside you see a

18
00:01:16,320 --> 00:01:18,540
small animation basically right the

19
00:01:18,540 --> 00:01:21,299
point is that it turns and it moves and

20
00:01:21,299 --> 00:01:23,220
whenever I edit anything even like

21
00:01:23,220 --> 00:01:25,680
adding a space it's going to restart

22
00:01:25,680 --> 00:01:28,670
this code there's a loop down here

23
00:01:28,670 --> 00:01:31,289
sorry's not intended i seems i forgot

24
00:01:31,289 --> 00:01:33,539
that if i change it it will it will

25
00:01:33,539 --> 00:01:35,340
reload the code and will restart from

26
00:01:35,340 --> 00:01:38,549
scratch so now let's look at how that

27
00:01:38,549 --> 00:01:43,289
will look if you recompile it apparently

28
00:01:43,289 --> 00:01:49,979
took crashes Wow all right so it doesn't

29
00:01:49,979 --> 00:02:08,630
cool um okay sure no problem

30
00:02:08,640 --> 00:02:12,610
so let's open it comes all try bigger

31
00:02:12,610 --> 00:02:16,239
and bigger and all right so it's going

32
00:02:16,239 --> 00:02:18,220
to repeat repeating and whenever it's

33
00:02:18,220 --> 00:02:20,590
going to start it's going to do foo I'm

34
00:02:20,590 --> 00:02:22,030
sorry I had a visual thing and it's

35
00:02:22,030 --> 00:02:25,480
apparently not working so whenever I

36
00:02:25,480 --> 00:02:28,239
want to change it now it's not going to

37
00:02:28,239 --> 00:02:30,190
print foo and if it would fool it would

38
00:02:30,190 --> 00:02:31,720
print food and the program what if we

39
00:02:31,720 --> 00:02:33,580
started as you can see in the console

40
00:02:33,580 --> 00:02:36,849
it's a well printing out the new stuff I

41
00:02:36,849 --> 00:02:39,370
can do pretty much anything even like

42
00:02:39,370 --> 00:02:44,950
closures but that's let's just quit

43
00:02:44,950 --> 00:02:51,700
twice something quickly such a pity oh

44
00:02:51,700 --> 00:02:56,440
well okay so no fancy demo there let's

45
00:02:56,440 --> 00:02:58,720
continue with the slide basically what

46
00:02:58,720 --> 00:03:00,610
it is is it's compiling JavaScript on

47
00:03:00,610 --> 00:03:03,220
the fly while maintaining access to

48
00:03:03,220 --> 00:03:05,680
closures which is something that's not

49
00:03:05,680 --> 00:03:08,769
that trivial to do obviously no restart

50
00:03:08,769 --> 00:03:10,569
of the application is required so if

51
00:03:10,569 --> 00:03:12,760
you're like building a game then you

52
00:03:12,760 --> 00:03:14,680
wouldn't have to go through your Start

53
00:03:14,680 --> 00:03:16,900
menus and whatever to see your change up

54
00:03:16,900 --> 00:03:19,720
and running immediately it's the library

55
00:03:19,720 --> 00:03:22,030
of this is a lazy evaluation so it's

56
00:03:22,030 --> 00:03:23,680
compiling once and it's only going to

57
00:03:23,680 --> 00:03:25,829
really compile when you change it and

58
00:03:25,829 --> 00:03:28,569
it's a generic approach meaning that it

59
00:03:28,569 --> 00:03:29,410
will work with pretty much any

60
00:03:29,410 --> 00:03:31,120
JavaScript there are obviously some

61
00:03:31,120 --> 00:03:33,569
limitations but i'll cover those later

62
00:03:33,569 --> 00:03:36,549
so when I talk about compiling in

63
00:03:36,549 --> 00:03:38,440
JavaScript what do I mean when you have

64
00:03:38,440 --> 00:03:40,030
a function you're actually compiling

65
00:03:40,030 --> 00:03:42,160
JavaScript because you're preparing code

66
00:03:42,160 --> 00:03:43,870
to be ran so when you're creating a

67
00:03:43,870 --> 00:03:45,760
function to be invoked later you're

68
00:03:45,760 --> 00:03:47,200
actually compiling javascript so that's

69
00:03:47,200 --> 00:03:49,269
what I mean when I say compiling in

70
00:03:49,269 --> 00:03:53,170
JavaScript all right so I'm going to do

71
00:03:53,170 --> 00:03:55,000
this live coding thing it's gonna be

72
00:03:55,000 --> 00:03:57,519
awesome I'm sure just like the previous

73
00:03:57,519 --> 00:04:02,550
demos so this

74
00:04:02,550 --> 00:04:05,860
this one so we have a simple set

75
00:04:05,860 --> 00:04:08,319
interval and it's printing hello JS calm

76
00:04:08,319 --> 00:04:11,080
and add a forgotten five on the

77
00:04:11,080 --> 00:04:17,060
millisecond and so that's what it does

78
00:04:17,070 --> 00:04:19,720
now in the first step because i'm going

79
00:04:19,720 --> 00:04:21,160
to recompile those functions is I'm

80
00:04:21,160 --> 00:04:25,120
going to wrap those functions so i'm

81
00:04:25,120 --> 00:04:26,139
going to create a new function called

82
00:04:26,139 --> 00:04:33,010
well you know and it's going to return

83
00:04:33,010 --> 00:04:37,479
that function and I just sliced out so

84
00:04:37,479 --> 00:04:40,000
this is the same as I had before you

85
00:04:40,000 --> 00:04:53,059
know what I should probably

86
00:04:53,069 --> 00:04:59,510
so this is the original code that were I

87
00:04:59,520 --> 00:05:02,500
press a button

88
00:05:02,500 --> 00:05:06,430
I shouldn't be pressing buttons okay so

89
00:05:06,430 --> 00:05:08,980
whatever um so this is the first step

90
00:05:08,980 --> 00:05:12,430
and of course it still works still does

91
00:05:12,430 --> 00:05:14,260
the same thing except I sliced out the

92
00:05:14,260 --> 00:05:16,350
way that the function is being passed on

93
00:05:16,350 --> 00:05:19,480
so the next step would be to actually

94
00:05:19,480 --> 00:05:21,340
compile the function and how do we

95
00:05:21,340 --> 00:05:22,710
compile function in JavaScript

96
00:05:22,710 --> 00:05:28,210
dynamically evil evil is evil so let's

97
00:05:28,210 --> 00:05:30,430
just use the semantically more

98
00:05:30,430 --> 00:05:33,250
appropriate way to do it through

99
00:05:33,250 --> 00:05:41,800
function so we're going to do like that

100
00:05:41,800 --> 00:05:44,260
and that should return the same function

101
00:05:44,260 --> 00:05:47,430
that we had before so let's try it out

102
00:05:47,430 --> 00:05:51,040
still working all right okay so let's

103
00:05:51,040 --> 00:05:56,919
abstract is a bit I putting it in a

104
00:05:56,919 --> 00:05:58,750
global variable so that we can access it

105
00:05:58,750 --> 00:06:05,200
later so this is still the same things

106
00:06:05,200 --> 00:06:07,510
before just a bit of abstraction and

107
00:06:07,510 --> 00:06:13,690
still works all right so let's make this

108
00:06:13,690 --> 00:06:18,400
into a function ID parameter a subpoena

109
00:06:18,400 --> 00:06:21,400
passed on 0 because it's still the first

110
00:06:21,400 --> 00:06:27,280
function in disarray still works now are

111
00:06:27,280 --> 00:06:28,660
we able to recompile at this point

112
00:06:28,660 --> 00:06:31,030
because basically all we'd have to do is

113
00:06:31,030 --> 00:06:33,040
change this right because this is being

114
00:06:33,040 --> 00:06:37,240
evaluated and executed so let's just see

115
00:06:37,240 --> 00:06:40,140
if that works

116
00:06:40,150 --> 00:06:42,070
since we have a global we can accept

117
00:06:42,070 --> 00:06:51,160
access it Oh capital it doesn't work off

118
00:06:51,160 --> 00:06:53,050
why does it doesn't why is it not

119
00:06:53,050 --> 00:06:56,770
working this function get function is

120
00:06:56,770 --> 00:07:04,450
only being invoked once it's not being

121
00:07:04,450 --> 00:07:06,100
repetitively being invoked so when I

122
00:07:06,100 --> 00:07:08,410
change this this isn't being picked up

123
00:07:08,410 --> 00:07:14,130
so I need to do is I need to return a

124
00:07:14,130 --> 00:07:21,490
function that does a recompilation so

125
00:07:21,490 --> 00:07:24,640
now we can see that is recompiling but

126
00:07:24,640 --> 00:07:28,570
not executing so in order to fix that we

127
00:07:28,570 --> 00:07:30,340
can recompile we compile and we

128
00:07:30,340 --> 00:07:31,810
immediately invoke all right that's what

129
00:07:31,810 --> 00:07:34,270
these these are going to do so now we

130
00:07:34,270 --> 00:07:35,800
can see it as compiling and printing

131
00:07:35,800 --> 00:07:39,880
alright so now is it going to work if i

132
00:07:39,880 --> 00:07:44,230
try to recompile yes so this is

133
00:07:44,230 --> 00:07:46,180
recompilation as its most basic

134
00:07:46,180 --> 00:07:49,330
primitive form you're changing a runtime

135
00:07:49,330 --> 00:07:52,540
you know without actually restoring the

136
00:07:52,540 --> 00:07:56,500
code not at sea we need to properly in

137
00:07:56,500 --> 00:07:57,970
focus because if we're going to do

138
00:07:57,970 --> 00:08:01,570
arguments then this is not going to work

139
00:08:01,570 --> 00:08:04,270
in fact what are other things that might

140
00:08:04,270 --> 00:08:06,550
go wrong here I mean if you're looking

141
00:08:06,550 --> 00:08:08,560
at recompilation in this approach what

142
00:08:08,560 --> 00:08:09,970
kind of code if we're looking for

143
00:08:09,970 --> 00:08:11,920
generic support what kind of code might

144
00:08:11,920 --> 00:08:18,310
not work anybody all right good thing I

145
00:08:18,310 --> 00:08:21,430
put a few up so function arguments are

146
00:08:21,430 --> 00:08:23,530
not going to work because they're simply

147
00:08:23,530 --> 00:08:25,780
being ignored right now closures aren't

148
00:08:25,780 --> 00:08:27,010
going to work because you don't have

149
00:08:27,010 --> 00:08:29,350
access to it and that's probably like

150
00:08:29,350 --> 00:08:30,930
the prime thing in this whole approach

151
00:08:30,930 --> 00:08:33,370
function declarations don't return a

152
00:08:33,370 --> 00:08:36,700
value so if you would wrap those or

153
00:08:36,700 --> 00:08:39,190
replace those then that would be pretty

154
00:08:39,190 --> 00:08:41,290
much dead code named function

155
00:08:41,290 --> 00:08:42,850
expressions are a special case because

156
00:08:42,850 --> 00:08:45,430
the name of the names function

157
00:08:45,430 --> 00:08:48,910
expression is it's handled in a slightly

158
00:08:48,910 --> 00:08:50,740
different way and of course there's

159
00:08:50,740 --> 00:08:51,880
performance because if you're going to

160
00:08:51,880 --> 00:08:53,590
repetitively

161
00:08:53,590 --> 00:08:55,630
to evil code it's going to hurt your

162
00:08:55,630 --> 00:08:58,600
performance so let's try to fix those

163
00:08:58,600 --> 00:09:02,650
cases first four arguments so arguments

164
00:09:02,650 --> 00:09:04,840
is quite simple we're going to change

165
00:09:04,840 --> 00:09:09,690
this structure into a set of objects I

166
00:09:09,690 --> 00:09:17,440
shouldn't be typing objects

167
00:09:17,450 --> 00:09:21,270
alright so it's going to be arks and

168
00:09:21,270 --> 00:09:22,920
then function accepts multiple

169
00:09:22,920 --> 00:09:24,660
parameters and only the last one is

170
00:09:24,660 --> 00:09:29,330
supposed to be body so let's do args and

171
00:09:29,330 --> 00:09:31,980
change this with body let's just still

172
00:09:31,980 --> 00:09:33,180
work and still do the same thing as

173
00:09:33,180 --> 00:09:35,640
before note that we're just passing on 1

174
00:09:35,640 --> 00:09:39,420
arcs as a string that we were going to

175
00:09:39,420 --> 00:09:42,120
fix it later now it's still working

176
00:09:42,120 --> 00:09:46,680
hello Jess calm so arguments let's say

177
00:09:46,680 --> 00:09:50,550
we take a new demo I of course prepared

178
00:09:50,550 --> 00:09:56,460
a few of those so let's try to use this

179
00:09:56,460 --> 00:09:58,890
example this is it of course still a

180
00:09:58,890 --> 00:10:02,490
simple example and it's going to

181
00:10:02,490 --> 00:10:06,570
repetitively print ad or call a log

182
00:10:06,570 --> 00:10:09,510
function which is an alias which has one

183
00:10:09,510 --> 00:10:11,970
argument text so if we're going to

184
00:10:11,970 --> 00:10:13,410
replace that the same way as we did

185
00:10:13,410 --> 00:10:17,870
before we need to slice out the body

186
00:10:17,870 --> 00:10:21,390
copy that into our data structure as

187
00:10:21,390 --> 00:10:23,940
before we're going to add a text

188
00:10:23,940 --> 00:10:30,660
parameter then we have get function 0

189
00:10:30,660 --> 00:10:32,100
because it's the first function that is

190
00:10:32,100 --> 00:10:34,440
going to exist in this data array and

191
00:10:34,440 --> 00:10:38,220
then the second object has no arguments

192
00:10:38,220 --> 00:10:47,100
I mean function and so they did i do

193
00:10:47,100 --> 00:10:51,700
everything on

194
00:10:51,710 --> 00:10:55,110
alright so now we have basically to get

195
00:10:55,110 --> 00:10:59,750
function calls and ergo going to return

196
00:10:59,750 --> 00:11:02,340
well the functions are generated through

197
00:11:02,340 --> 00:11:04,650
whatever is in disarray so let's see if

198
00:11:04,650 --> 00:11:12,150
this works it doesn't work and why

199
00:11:12,150 --> 00:11:18,300
doesn't it work anyway to see that look

200
00:11:18,300 --> 00:11:21,270
at these two characters what's missing

201
00:11:21,270 --> 00:11:25,230
here the actual arguments so remember

202
00:11:25,230 --> 00:11:26,670
that this function is a function is

203
00:11:26,670 --> 00:11:28,800
being returned and being invoked where

204
00:11:28,800 --> 00:11:30,060
the original function would have been

205
00:11:30,060 --> 00:11:32,130
invoked all right so if you look at the

206
00:11:32,130 --> 00:11:34,680
original code I've replaced this

207
00:11:34,680 --> 00:11:38,190
function basically with this function

208
00:11:38,190 --> 00:11:40,440
and so that's being invoked and in order

209
00:11:40,440 --> 00:11:42,570
to pass on the arguments as originally

210
00:11:42,570 --> 00:11:45,270
intended I need to change this piece of

211
00:11:45,270 --> 00:11:50,390
multi snippet to the standard apply

212
00:11:50,390 --> 00:11:53,150
context and then

213
00:11:53,150 --> 00:11:58,700
array.prototype.slice.call arguments 0

214
00:11:58,700 --> 00:12:01,830
or whatever way you want to do this so

215
00:12:01,830 --> 00:12:03,840
in a nutshell this now is going to

216
00:12:03,840 --> 00:12:06,810
invoke this generated function as if it

217
00:12:06,810 --> 00:12:09,570
was invoked originally same context same

218
00:12:09,570 --> 00:12:11,370
arguments as far as a running code is

219
00:12:11,370 --> 00:12:14,790
concerned nothing changes and now it

220
00:12:14,790 --> 00:12:18,780
should work Go Go okay so now we can

221
00:12:18,780 --> 00:12:23,520
still update this so we have data 0 is

222
00:12:23,520 --> 00:12:27,810
this text or this body and let's try to

223
00:12:27,810 --> 00:12:30,030
change that I say just depending some

224
00:12:30,030 --> 00:12:39,929
kind of argument

225
00:12:39,939 --> 00:12:47,619
and it's failing because oh no wait it's

226
00:12:47,619 --> 00:12:50,889
in quotes oh because I'm not quoting it

227
00:12:50,889 --> 00:12:56,319
huh ya know all right now I know why dis

228
00:12:56,319 --> 00:12:58,509
isn't working so I change the data

229
00:12:58,509 --> 00:13:01,929
structure and now it so I've changed a

230
00:13:01,929 --> 00:13:05,079
runtime from hello text and just

231
00:13:05,079 --> 00:13:06,970
appended II Foo without restarting the

232
00:13:06,970 --> 00:13:11,379
application so arguments are preserved

233
00:13:11,379 --> 00:13:13,629
and we can mess with that alright so

234
00:13:13,629 --> 00:13:16,929
that's one step so then if we have had

235
00:13:16,929 --> 00:13:19,899
arguments the next step would be

236
00:13:19,899 --> 00:13:23,259
closures alright so we have we fix for

237
00:13:23,259 --> 00:13:24,789
function arguments let's look at the

238
00:13:24,789 --> 00:13:28,299
closures closures is going to be dis

239
00:13:28,299 --> 00:13:39,650
snippet of example let's put it up here

240
00:13:39,660 --> 00:13:43,800
so we are going to have a function

241
00:13:43,800 --> 00:13:45,930
that's going to repeat whatever is being

242
00:13:45,930 --> 00:13:50,850
passed on so this function will be

243
00:13:50,850 --> 00:13:52,920
called below and then set interval will

244
00:13:52,920 --> 00:13:55,500
repetitively log out whatever is being

245
00:13:55,500 --> 00:13:58,230
passed on so note that text in here is a

246
00:13:58,230 --> 00:14:00,900
closure over the text that's being

247
00:14:00,900 --> 00:14:03,720
passed on so if I just going to replace

248
00:14:03,720 --> 00:14:06,300
it as I did before which I don't think i

249
00:14:06,300 --> 00:14:07,470
need to replace the first one because

250
00:14:07,470 --> 00:14:10,290
it's still locked text so that's remains

251
00:14:10,290 --> 00:14:14,280
the same except for the function let me

252
00:14:14,280 --> 00:14:16,440
for the argument because that's now in

253
00:14:16,440 --> 00:14:20,910
the second function which is the whole

254
00:14:20,910 --> 00:14:22,560
so this is like the second function now

255
00:14:22,560 --> 00:14:36,020
it's going to wrap this get function

256
00:14:36,030 --> 00:14:41,830
alright so now let's see if this works

257
00:14:41,840 --> 00:14:45,300
nope because text isn't isn't defined

258
00:14:45,300 --> 00:14:47,940
and the reason it's not defined does

259
00:14:47,940 --> 00:14:50,220
anybody can anybody figure it out like

260
00:14:50,220 --> 00:14:53,280
right now why text would not be defined

261
00:14:53,280 --> 00:15:01,710
there okay so yeah its function I heard

262
00:15:01,710 --> 00:15:03,750
somebody say it over there function is

263
00:15:03,750 --> 00:15:06,570
actually a indirect evil all right so it

264
00:15:06,570 --> 00:15:08,430
only has access to the global scope if

265
00:15:08,430 --> 00:15:10,980
you look at direct evil and indirectly

266
00:15:10,980 --> 00:15:12,570
availed the main difference at least in

267
00:15:12,570 --> 00:15:15,240
this context is that direct evil will

268
00:15:15,240 --> 00:15:17,480
have access to the lexical scopes and

269
00:15:17,480 --> 00:15:19,790
because we're using function over here

270
00:15:19,790 --> 00:15:24,060
it's not working so let's change this to

271
00:15:24,060 --> 00:15:27,600
evil so we're going to change evil we

272
00:15:27,600 --> 00:15:31,640
need to add the function boilerplate now

273
00:15:31,640 --> 00:15:40,170
arguments body closing parts and the

274
00:15:40,170 --> 00:15:45,150
rest remains the same sorry all right so

275
00:15:45,150 --> 00:15:47,640
let's see if this works now it still

276
00:15:47,640 --> 00:15:56,610
doesn't work what did we forget so evil

277
00:15:56,610 --> 00:15:59,190
is lexical scope so even though we're

278
00:15:59,190 --> 00:16:02,160
doing direct evil right now it's not

279
00:16:02,160 --> 00:16:04,650
going to be able to access text because

280
00:16:04,650 --> 00:16:07,590
text doesn't exist in this function it

281
00:16:07,590 --> 00:16:08,850
doesn't exist in this function and

282
00:16:08,850 --> 00:16:10,980
doesn't exist in global scope so that's

283
00:16:10,980 --> 00:16:13,260
why at this point it's still throwing a

284
00:16:13,260 --> 00:16:16,830
failure so in order to solve this we're

285
00:16:16,830 --> 00:16:20,190
going to do something like this let me

286
00:16:20,190 --> 00:16:22,170
just give me a second

287
00:16:22,170 --> 00:16:24,930
well let's do it in order so we're going

288
00:16:24,930 --> 00:16:31,500
to add a compiler let me just do this on

289
00:16:31,500 --> 00:16:46,480
anyone

290
00:16:46,490 --> 00:16:49,040
okay the rest pretty much remains to be

291
00:16:49,040 --> 00:16:53,660
the same thing here and leistes and then

292
00:16:53,660 --> 00:16:55,700
whenever they get function we pass on

293
00:16:55,700 --> 00:17:02,690
this compiler as an argument and this

294
00:17:02,690 --> 00:17:05,449
requires now a argument because I mean

295
00:17:05,449 --> 00:17:09,620
this Cole is this you know the best song

296
00:17:09,620 --> 00:17:11,929
so rather than evil we're going to use

297
00:17:11,929 --> 00:17:14,480
this compiler to compile stuff and in

298
00:17:14,480 --> 00:17:16,160
global scope we just pass on evil

299
00:17:16,160 --> 00:17:18,980
because we don't care about direct or

300
00:17:18,980 --> 00:17:22,130
indirect from global okay so is it going

301
00:17:22,130 --> 00:17:25,189
to work now I certainly hope so all

302
00:17:25,189 --> 00:17:27,140
right okay so at least it's working now

303
00:17:27,140 --> 00:17:28,610
so let's see if we can actually change

304
00:17:28,610 --> 00:17:31,730
the closure because this text over here

305
00:17:31,730 --> 00:17:33,770
is a closure remember that this function

306
00:17:33,770 --> 00:17:35,780
doesn't have a closure a text argument

307
00:17:35,780 --> 00:17:41,000
so let's just try to change it not

308
00:17:41,000 --> 00:17:43,760
remove it change it and see if we can

309
00:17:43,760 --> 00:17:52,540
mess with it so body equals dot

310
00:17:52,550 --> 00:17:59,060
and it works so we're able to we're able

311
00:17:59,060 --> 00:18:01,820
to recompile code now even though there

312
00:18:01,820 --> 00:18:04,160
were closures in there so it maintained

313
00:18:04,160 --> 00:18:08,540
access to those scopes so we fixed

314
00:18:08,540 --> 00:18:12,380
closures now the next part is function

315
00:18:12,380 --> 00:18:14,090
declarations of function declarations

316
00:18:14,090 --> 00:18:17,630
require a preprocessor step so if we

317
00:18:17,630 --> 00:18:21,500
have like a function foo then what we

318
00:18:21,500 --> 00:18:23,360
actually need to do is rewrite this too

319
00:18:23,360 --> 00:18:25,400
VAR foo is function they're equivalent

320
00:18:25,400 --> 00:18:27,170
and the only other thing you need to

321
00:18:27,170 --> 00:18:28,520
take into account is that you need to

322
00:18:28,520 --> 00:18:31,790
move this line to the top of the scope

323
00:18:31,790 --> 00:18:33,350
because that's basically what javascript

324
00:18:33,350 --> 00:18:36,260
does as well so jobs will hoist those

325
00:18:36,260 --> 00:18:38,060
function declarations and you can just

326
00:18:38,060 --> 00:18:40,250
use any kind of parser to rewrite this

327
00:18:40,250 --> 00:18:42,410
this part and make it equivalent in

328
00:18:42,410 --> 00:18:45,140
terms of JavaScript semantics so that's

329
00:18:45,140 --> 00:18:47,450
the for me at least that's a very simple

330
00:18:47,450 --> 00:18:49,130
trivial way of getting rid of the

331
00:18:49,130 --> 00:18:52,280
function declaration problem use a

332
00:18:52,280 --> 00:18:55,520
parser for named function expressions

333
00:18:55,520 --> 00:18:58,870
it's slightly more complex so you'd have

334
00:18:58,870 --> 00:19:14,330
sorry so you'd have like this case

335
00:19:14,340 --> 00:19:16,049
actually it's not set into it so the

336
00:19:16,049 --> 00:19:18,299
right way of doing the you know the

337
00:19:18,299 --> 00:19:20,400
paint loops with with timers if you were

338
00:19:20,400 --> 00:19:23,580
going to use timers anyways would not be

339
00:19:23,580 --> 00:19:26,070
set interval but set set timeout and you

340
00:19:26,070 --> 00:19:30,480
do like and of course this would be like

341
00:19:30,480 --> 00:19:32,669
the you know computer depending on

342
00:19:32,669 --> 00:19:34,620
whatever okay it doesn't matter so this

343
00:19:34,620 --> 00:19:40,830
is how you would do your paint loop and

344
00:19:40,830 --> 00:19:44,039
then the problem with this approach in

345
00:19:44,039 --> 00:19:46,409
terms of recompiling is that you don't

346
00:19:46,409 --> 00:19:48,480
get to change repeat any more so that

347
00:19:48,480 --> 00:19:51,210
value of repeat is is just being

348
00:19:51,210 --> 00:19:52,770
executed over be just being assigned

349
00:19:52,770 --> 00:19:56,250
once on top of that of course name names

350
00:19:56,250 --> 00:19:58,049
of names function expressions have more

351
00:19:58,049 --> 00:20:00,690
weird semantics but that's the main the

352
00:20:00,690 --> 00:20:03,450
main point the main problem here so what

353
00:20:03,450 --> 00:20:05,429
we do here is we're going to rewrite the

354
00:20:05,429 --> 00:20:07,890
name function expression as well and so

355
00:20:07,890 --> 00:20:20,529
rather than this we're going to do a

356
00:20:20,539 --> 00:20:22,320
actually we're going to rattle in the

357
00:20:22,320 --> 00:20:25,190
function so

358
00:20:25,200 --> 00:20:27,830
so we're going to do this and then this

359
00:20:27,830 --> 00:20:33,779
would be the actual code and then we're

360
00:20:33,779 --> 00:20:38,429
going to return this function so we're

361
00:20:38,429 --> 00:20:40,980
going to basically rewrite rewrite this

362
00:20:40,980 --> 00:20:43,860
and that way we get rid of the named

363
00:20:43,860 --> 00:20:45,539
function expression while maintaining

364
00:20:45,539 --> 00:20:47,700
the runtime semantics of a name function

365
00:20:47,700 --> 00:20:50,279
expression and this way we can actually

366
00:20:50,279 --> 00:20:52,620
use our recompilation stuff so let's

367
00:20:52,620 --> 00:20:55,529
quickly try this just to prove that it

368
00:20:55,529 --> 00:21:03,179
does work sorry so we'd have this and

369
00:21:03,179 --> 00:21:18,680
then we're going to wrap this body again

370
00:21:18,690 --> 00:21:20,910
there are no arguments to this function

371
00:21:20,910 --> 00:21:22,350
and the name we don't need anymore

372
00:21:22,350 --> 00:21:23,820
because that's going to be abstracted

373
00:21:23,820 --> 00:21:29,220
away in our rewrite right I should have

374
00:21:29,220 --> 00:21:46,010
written it first all right

375
00:21:46,020 --> 00:21:48,270
so this is a rewritten part of the set

376
00:21:48,270 --> 00:21:50,820
timeout and now I need a rabbit I can

377
00:21:50,820 --> 00:21:52,380
still maintain the first part i guess

378
00:21:52,380 --> 00:21:57,960
and then use get function 0 this is

379
00:21:57,960 --> 00:22:00,980
still the first first function up here I

380
00:22:00,980 --> 00:22:04,020
think this is good and then we're going

381
00:22:04,020 --> 00:22:06,660
to wrap the new function as well of

382
00:22:06,660 --> 00:22:09,780
course and so it's going to be good

383
00:22:09,780 --> 00:22:14,580
function one of course we need to pass

384
00:22:14,580 --> 00:22:25,359
on a compiler

385
00:22:25,369 --> 00:22:29,149
and of course the compiler here as well

386
00:22:29,149 --> 00:22:33,840
and I no arguments I think this will

387
00:22:33,840 --> 00:22:42,600
work I hope anyways let's see if it

388
00:22:42,600 --> 00:22:48,240
works doesn't work does it need to be

389
00:22:48,240 --> 00:22:56,769
invoked a measly now

390
00:22:56,779 --> 00:22:59,220
all right well I guess you're just going

391
00:22:59,220 --> 00:23:01,320
to have to assume or take my word for it

392
00:23:01,320 --> 00:23:03,840
that works I don't think I'm going to be

393
00:23:03,840 --> 00:23:05,429
able to solve that any like right now

394
00:23:05,429 --> 00:23:08,220
anyways that the solution does work

395
00:23:08,220 --> 00:23:09,299
because the semantics should be

396
00:23:09,299 --> 00:23:12,960
equivalent alright so we've solved the

397
00:23:12,960 --> 00:23:17,330
name function expressions and then for

398
00:23:17,330 --> 00:23:20,279
ya for performance we can actually

399
00:23:20,279 --> 00:23:26,999
extend a postpone it so let me refer so

400
00:23:26,999 --> 00:23:28,379
that we had it well it was before I

401
00:23:28,379 --> 00:23:32,159
think this was working yeah okay so and

402
00:23:32,159 --> 00:23:37,740
we can change that to this yeah so what

403
00:23:37,740 --> 00:23:42,570
we do is instead of compiling it every

404
00:23:42,570 --> 00:23:45,869
time in this step basically we cash the

405
00:23:45,869 --> 00:23:47,539
function that's being that's being

406
00:23:47,539 --> 00:23:51,539
invoked and then we check whether it's

407
00:23:51,539 --> 00:23:53,220
up to date so we're going to add a

408
00:23:53,220 --> 00:23:55,850
closure or actually to closures I guess

409
00:23:55,850 --> 00:23:59,509
that's the function and Nesta version

410
00:23:59,509 --> 00:24:09,480
we're going to do a version check

411
00:24:09,490 --> 00:24:15,640
no not evil to our local version and

412
00:24:15,640 --> 00:24:17,200
then we're going to check whether

413
00:24:17,200 --> 00:24:18,640
function exists is all for like the

414
00:24:18,640 --> 00:24:21,460
first time and if it doesn't or if

415
00:24:21,460 --> 00:24:24,370
either of the cases isn't true whatever

416
00:24:24,370 --> 00:24:30,010
then we're going to compile it catch the

417
00:24:30,010 --> 00:24:33,160
function let's see we need to move this

418
00:24:33,160 --> 00:24:48,340
away sorry update the version I think

419
00:24:48,340 --> 00:24:52,420
this is fine and then apply return funk

420
00:24:52,420 --> 00:25:05,310
apply now only to do is update d sorry

421
00:25:05,320 --> 00:25:07,360
I'm gonna end yeah that's correct so

422
00:25:07,360 --> 00:25:11,470
sorry and I need to add the version to

423
00:25:11,470 --> 00:25:21,900
the data object which can be just like a

424
00:25:21,910 --> 00:25:24,130
alright so now it's only going to update

425
00:25:24,130 --> 00:25:27,340
the compilation and we can sort of prove

426
00:25:27,340 --> 00:25:33,160
that I suppose by just by checking in

427
00:25:33,160 --> 00:25:35,680
here and so this this step should only

428
00:25:35,680 --> 00:25:37,630
be invoked now so the actual calling of

429
00:25:37,630 --> 00:25:40,930
eval should only be cold now when the

430
00:25:40,930 --> 00:25:45,580
code has changed I'm not sure what does

431
00:25:45,580 --> 00:25:48,370
twice right now but whatever but as you

432
00:25:48,370 --> 00:25:51,240
can see it doesn't compile now and so

433
00:25:51,240 --> 00:25:53,530
what we can do now is we can change the

434
00:25:53,530 --> 00:25:55,240
body of the code and it doesn't

435
00:25:55,240 --> 00:25:57,370
recompile because it doesn't see a new

436
00:25:57,370 --> 00:26:04,300
version so as soon as we do dad and it

437
00:26:04,300 --> 00:26:06,310
can be anything I mean it can be foo if

438
00:26:06,310 --> 00:26:07,720
it doesn't really matter just doesn't

439
00:26:07,720 --> 00:26:09,940
need to be the same as before and now

440
00:26:09,940 --> 00:26:11,980
you can see recompile and it actually

441
00:26:11,980 --> 00:26:14,560
recompile so it's the sort of lazy

442
00:26:14,560 --> 00:26:18,940
evaluation and still you know rii

443
00:26:18,940 --> 00:26:23,320
compiling ok so that was the last part

444
00:26:23,320 --> 00:26:27,430
of the the main issues I just lied for

445
00:26:27,430 --> 00:26:30,160
this also so direct the first is direct

446
00:26:30,160 --> 00:26:32,920
in evil the trick the main trick to this

447
00:26:32,920 --> 00:26:35,350
approach is basically a indirect direct

448
00:26:35,350 --> 00:26:39,210
evil all right you're cashing a function

449
00:26:39,210 --> 00:26:41,620
well that's what we're doing in this in

450
00:26:41,620 --> 00:26:46,390
this moment in this part right we are

451
00:26:46,390 --> 00:26:49,600
creating a function on any scope of our

452
00:26:49,600 --> 00:26:52,120
new functions and that makes the dollar

453
00:26:52,120 --> 00:26:55,210
sign compiler variable available on any

454
00:26:55,210 --> 00:26:57,820
scope and that's why we can do the get

455
00:26:57,820 --> 00:27:00,910
function compiler here which basically

456
00:27:00,910 --> 00:27:03,730
just returns this function and because

457
00:27:03,730 --> 00:27:06,550
this is a direct evil at that point it's

458
00:27:06,550 --> 00:27:07,750
going to have access to all the

459
00:27:07,750 --> 00:27:09,190
variables and that's why I closures are

460
00:27:09,190 --> 00:27:11,560
working there's actually one problem

461
00:27:11,560 --> 00:27:13,450
with this snippet of code can anybody

462
00:27:13,450 --> 00:27:17,830
see what what's what's going to happen

463
00:27:17,830 --> 00:27:21,260
at runtime at some point

464
00:27:21,270 --> 00:27:25,380
I doubt Douglas Gophers going to use

465
00:27:25,380 --> 00:27:28,860
this at all all right so what happens if

466
00:27:28,860 --> 00:27:37,460
we do if we compile this and we do s

467
00:27:37,460 --> 00:27:43,170
that's what's going to do it's going to

468
00:27:43,170 --> 00:27:44,970
see that variable because it has access

469
00:27:44,970 --> 00:27:46,920
to the closures and because we're adding

470
00:27:46,920 --> 00:27:48,690
a new function it's actually kind of

471
00:27:48,690 --> 00:27:50,850
adding a new scope and if we declare

472
00:27:50,850 --> 00:27:52,230
variables in that scope they're going to

473
00:27:52,230 --> 00:27:55,100
show up in this recompiling step so

474
00:27:55,100 --> 00:27:57,630
changing the version we can now see that

475
00:27:57,630 --> 00:27:59,670
has actually printing out the vlog so

476
00:27:59,670 --> 00:28:01,200
we're polluting the scope of course

477
00:28:01,200 --> 00:28:02,640
we're also gluttonous cope with a

478
00:28:02,640 --> 00:28:04,980
compiler function but it's a something

479
00:28:04,980 --> 00:28:06,720
that I can't fix for this one you can

480
00:28:06,720 --> 00:28:09,060
fix it by simply removing his argument

481
00:28:09,060 --> 00:28:10,470
and saying art I mean you're already

482
00:28:10,470 --> 00:28:13,800
using evil right so might as well these

483
00:28:13,800 --> 00:28:18,720
arguments all right so now it works and

484
00:28:18,720 --> 00:28:21,510
if we change it to that it's going to

485
00:28:21,510 --> 00:28:24,030
cry because as is no longer available of

486
00:28:24,030 --> 00:28:25,650
course we can still print out say

487
00:28:25,650 --> 00:28:28,710
compiler but that's again you know used

488
00:28:28,710 --> 00:28:30,800
like Greek letters or something I know

489
00:28:30,800 --> 00:28:34,890
as this is undefined and I was just

490
00:28:34,890 --> 00:28:36,750
going to print out that that a compiler

491
00:28:36,750 --> 00:28:39,120
function but this is the so medicine

492
00:28:39,120 --> 00:28:41,550
main trick create a function that has a

493
00:28:41,550 --> 00:28:43,800
direct evil and maintains access to the

494
00:28:43,800 --> 00:28:50,690
local scopes yeah

495
00:28:50,700 --> 00:28:57,340
so basically recap it's a approach that

496
00:28:57,340 --> 00:28:59,860
works generically it works for pretty

497
00:28:59,860 --> 00:29:02,230
much any kind of code you can recompile

498
00:29:02,230 --> 00:29:04,000
you can change it on the fly if you seen

499
00:29:04,000 --> 00:29:06,370
Brett Victor's talk inventing on

500
00:29:06,370 --> 00:29:08,289
principle he does is like you know at

501
00:29:08,289 --> 00:29:10,450
some point he does a this loop and he

502
00:29:10,450 --> 00:29:12,399
changed it and he changes the number of

503
00:29:12,399 --> 00:29:14,919
iterations to I don't know whatever to

504
00:29:14,919 --> 00:29:16,389
change the number of leaves in the tree

505
00:29:16,389 --> 00:29:17,919
and first time I saw that I was like

506
00:29:17,919 --> 00:29:20,200
it's not possible you can't do that and

507
00:29:20,200 --> 00:29:22,120
then later I had to disprove myself of

508
00:29:22,120 --> 00:29:25,149
course because it's possible it's just

509
00:29:25,149 --> 00:29:29,620
you know it takes magic bit of magic so

510
00:29:29,620 --> 00:29:32,169
on every scope you inject a new function

511
00:29:32,169 --> 00:29:34,389
compiler function which has a direct

512
00:29:34,389 --> 00:29:37,210
evil and by which you have direct access

513
00:29:37,210 --> 00:29:39,190
to all the Scopes which maintains access

514
00:29:39,190 --> 00:29:41,679
to closures and know that makes it work

515
00:29:41,679 --> 00:29:43,870
and inside that you have some rewriting

516
00:29:43,870 --> 00:29:45,519
magic for like function declarations and

517
00:29:45,519 --> 00:29:47,590
other nasty things that might screw this

518
00:29:47,590 --> 00:29:54,639
up so some open issues the bigs the

519
00:29:54,639 --> 00:29:56,049
biggest problem here is inserting new

520
00:29:56,049 --> 00:29:57,820
functions because you're mapping

521
00:29:57,820 --> 00:30:00,549
function is one on one right and I have

522
00:30:00,549 --> 00:30:04,330
the library where I did it you know I

523
00:30:04,330 --> 00:30:06,009
abstracted everything away so you can

524
00:30:06,009 --> 00:30:07,929
just as you can sort as you can see in

525
00:30:07,929 --> 00:30:10,899
the Recon powder demo that doesn't

526
00:30:10,899 --> 00:30:14,440
really work you can you know you can

527
00:30:14,440 --> 00:30:16,210
type here and it will replace all the

528
00:30:16,210 --> 00:30:17,559
codes but it's going to assume that

529
00:30:17,559 --> 00:30:19,450
these functions are going to be a

530
00:30:19,450 --> 00:30:21,490
certain order so if you add a new

531
00:30:21,490 --> 00:30:25,120
function you know injected some how it's

532
00:30:25,120 --> 00:30:27,970
going to trip up simply because it's

533
00:30:27,970 --> 00:30:30,639
going to run to put this body actually

534
00:30:30,639 --> 00:30:33,639
no this body into this body and so

535
00:30:33,639 --> 00:30:36,009
that's it's something that I don't think

536
00:30:36,009 --> 00:30:37,809
it's very easy to solve I've try to you

537
00:30:37,809 --> 00:30:39,279
know I've tried to do a diff the

538
00:30:39,279 --> 00:30:41,139
different help will be only so far

539
00:30:41,139 --> 00:30:43,570
because there might be changes that are

540
00:30:43,570 --> 00:30:46,750
spread on multiple parts in the code and

541
00:30:46,750 --> 00:30:48,009
in that case you don't know which

542
00:30:48,009 --> 00:30:50,710
functions to replace so that's like the

543
00:30:50,710 --> 00:30:52,929
biggest problem with this approach but

544
00:30:52,929 --> 00:30:54,070
as long as you're not as certain any new

545
00:30:54,070 --> 00:30:55,860
functions everything's going to be fine

546
00:30:55,860 --> 00:30:58,330
the minor issue is of course the

547
00:30:58,330 --> 00:31:00,480
variable clashes that I explained before

548
00:31:00,480 --> 00:31:02,950
and it's actually very hard to explain

549
00:31:02,950 --> 00:31:04,300
people's don't see

550
00:31:04,300 --> 00:31:08,380
to get that you can't really go ahead

551
00:31:08,380 --> 00:31:10,870
and change the global code right I mean

552
00:31:10,870 --> 00:31:13,530
if there's no way that if I would a

553
00:31:13,530 --> 00:31:16,270
runtime at least if I will do this for

554
00:31:16,270 --> 00:31:20,980
flu is bar and run and run time I would

555
00:31:20,980 --> 00:31:23,260
recompile this and to say it is like gee

556
00:31:23,260 --> 00:31:25,750
it won't be picked up because it's only

557
00:31:25,750 --> 00:31:33,110
picked up by code that's really valuable

558
00:31:33,120 --> 00:31:35,550
backs that are going to be reevaluated

559
00:31:35,550 --> 00:31:39,280
actually re invoked at some point any

560
00:31:39,280 --> 00:31:41,020
other code which includes any global

561
00:31:41,020 --> 00:31:43,270
code it's it's not going to work or at

562
00:31:43,270 --> 00:31:44,800
least it's not going to be useful it's

563
00:31:44,800 --> 00:31:45,670
going to work but it's not gonna do

564
00:31:45,670 --> 00:31:48,970
anything so it that seems to be hard to

565
00:31:48,970 --> 00:31:52,180
get across unfortunately so the code is

566
00:31:52,180 --> 00:31:55,360
going to be available on github as usual

567
00:31:55,360 --> 00:31:59,500
I will push it later if github allows me

568
00:31:59,500 --> 00:32:02,170
to and otherwise I'll you know slides

569
00:32:02,170 --> 00:32:05,950
will be in there as well and yeah so are

570
00:32:05,950 --> 00:32:08,280
there any questions I have like zero

571
00:32:08,280 --> 00:32:11,910
minutes left so that should be fine okay

572
00:32:11,910 --> 00:32:30,549
otherwise I'll be out there and ya thang

