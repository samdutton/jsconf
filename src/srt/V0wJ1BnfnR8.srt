1
00:00:08,090 --> 00:00:10,650

hello everyone thanks for being here

2
00:00:10,650 --> 00:00:14,009
today at this truck so before diving in

3
00:00:14,009 --> 00:00:16,139
the wondrous world of polyfills I'd like

4
00:00:16,139 --> 00:00:17,910
the times to take some time to introduce

5
00:00:17,910 --> 00:00:20,939
myself I'm Leah vero as you can see

6
00:00:20,939 --> 00:00:23,010
there are three times it's a Greek name

7
00:00:23,010 --> 00:00:25,949
I live in Greece I'm a front-end

8
00:00:25,949 --> 00:00:29,310
developer I love CSS and JavaScript but

9
00:00:29,310 --> 00:00:30,599
don't worry I'm not going to start

10
00:00:30,599 --> 00:00:34,680
singing now and these are the places you

11
00:00:34,680 --> 00:00:39,000
can find me on the web so many people

12
00:00:39,000 --> 00:00:41,610
know me from for my CSS research and

13
00:00:41,610 --> 00:00:43,469
they were asking me yesterday if it's

14
00:00:43,469 --> 00:00:46,440
going to be a talk about CSS and I was

15
00:00:46,440 --> 00:00:49,079
like dude it's a JavaScript conference

16
00:00:49,079 --> 00:00:52,469
it's I'm not going to speak about CSS so

17
00:00:52,469 --> 00:00:54,780
no it's not about CSS polyfills purple

18
00:00:54,780 --> 00:00:56,969
and Polly fields are to CSS about what

19
00:00:56,969 --> 00:00:59,820
4k is the sushi you can use it to eat

20
00:00:59,820 --> 00:01:01,500
sushi but it's not really a very good

21
00:01:01,500 --> 00:01:04,799
idea and it's not meant for that purpose

22
00:01:04,799 --> 00:01:08,790
so what our polyfills boy feels is a

23
00:01:08,790 --> 00:01:12,600
term coined by Remy sharp last year but

24
00:01:12,600 --> 00:01:15,420
it caught up really quickly and it

25
00:01:15,420 --> 00:01:19,350
actually comes from this product on the

26
00:01:19,350 --> 00:01:23,640
cover that's a UK product and it's used

27
00:01:23,640 --> 00:01:26,310
in the UK to cover up holes and gaps in

28
00:01:26,310 --> 00:01:30,360
cracks in walls and he thought that it's

29
00:01:30,360 --> 00:01:33,240
a proper term for describing what Polly

30
00:01:33,240 --> 00:01:35,850
filles du in a browser because that's

31
00:01:35,850 --> 00:01:37,350
essentially what they do they cover up

32
00:01:37,350 --> 00:01:40,920
holes and gaps in browser support his

33
00:01:40,920 --> 00:01:45,450
official definition for that was that a

34
00:01:45,450 --> 00:01:50,610
polyfill is a piece of code or plugin

35
00:01:50,610 --> 00:01:52,829
for example chrome frame could be

36
00:01:52,829 --> 00:01:54,720
considered a kind of polyfill that

37
00:01:54,720 --> 00:01:56,549
provides the technology the cue the

38
00:01:56,549 --> 00:01:58,530
developer expect the browser to provide

39
00:01:58,530 --> 00:02:01,649
natively or as Paul Irish poet it's

40
00:02:01,649 --> 00:02:03,810
assume that mimics a future API by

41
00:02:03,810 --> 00:02:05,780
providing for buck functionality to all

42
00:02:05,780 --> 00:02:08,770
browsers so if that sounds a bit unclear

43
00:02:08,770 --> 00:02:13,670
I'm pretty sure almost all of you have

44
00:02:13,670 --> 00:02:16,640
done this thing at some point this is

45
00:02:16,640 --> 00:02:19,700
three lines of code or five depending on

46
00:02:19,700 --> 00:02:22,370
how you count them but they essentially

47
00:02:22,370 --> 00:02:24,550
have all the elements of a good polyfill

48
00:02:24,550 --> 00:02:27,950
they have featured a firstly detect if

49
00:02:27,950 --> 00:02:31,190
the feature is present is stream

50
00:02:31,190 --> 00:02:33,230
available in strengths and if it's not

51
00:02:33,230 --> 00:02:35,209
they go ahead and implement the feature

52
00:02:35,209 --> 00:02:38,060
and just this is a very simple feature

53
00:02:38,060 --> 00:02:40,790
some one line is enough and then after

54
00:02:40,790 --> 00:02:42,709
that body feels included the end

55
00:02:42,709 --> 00:02:45,050
developer can use it as if it was

56
00:02:45,050 --> 00:02:47,630
provided natively and they can do that

57
00:02:47,630 --> 00:02:49,640
thing without being aware that the

58
00:02:49,640 --> 00:02:52,340
polyfill actually exists and that's one

59
00:02:52,340 --> 00:02:55,370
of the best advantages of polyfills you

60
00:02:55,370 --> 00:02:57,769
don't have to learn a new API for

61
00:02:57,769 --> 00:03:02,090
example jquery is a script that helps us

62
00:03:02,090 --> 00:03:05,060
do some tasks that in which support is a

63
00:03:05,060 --> 00:03:08,180
bit flaky for example some I all that

64
00:03:08,180 --> 00:03:11,000
uses a touch event modern browsers you

65
00:03:11,000 --> 00:03:14,260
even listening jquery covers up this

66
00:03:14,260 --> 00:03:18,170
inconsistency but you before using it

67
00:03:18,170 --> 00:03:20,450
you have to learn in your api it has a

68
00:03:20,450 --> 00:03:22,310
whole documentation which you have to

69
00:03:22,310 --> 00:03:23,750
learn before you're able to take

70
00:03:23,750 --> 00:03:25,730
advantage of it Polly fields are not

71
00:03:25,730 --> 00:03:27,799
that jQuery is not a polyfill to an API

72
00:03:27,799 --> 00:03:30,769
wrapper with Polly fills you don't need

73
00:03:30,769 --> 00:03:32,720
to learn anything you just the spec and

74
00:03:32,720 --> 00:03:36,019
then after polyfill is included you can

75
00:03:36,019 --> 00:03:38,540
move on user spec as if the

76
00:03:38,540 --> 00:03:40,640
functionality was provided natively and

77
00:03:40,640 --> 00:03:43,880
after some years pass you can just

78
00:03:43,880 --> 00:03:47,390
remove the polyfill and your code still

79
00:03:47,390 --> 00:03:49,430
works there's no dependency on the

80
00:03:49,430 --> 00:03:51,500
polyfill it's just there to bridge the

81
00:03:51,500 --> 00:03:55,579
gap between today and the specs because

82
00:03:55,579 --> 00:03:57,739
sometimes we have amazing innovative

83
00:03:57,739 --> 00:04:00,739
specs that just aren't supported yet and

84
00:04:00,739 --> 00:04:02,180
we want to use them

85
00:04:02,180 --> 00:04:05,239
that's what police those are for so how

86
00:04:05,239 --> 00:04:07,730
can you make your own polyfill there's

87
00:04:07,730 --> 00:04:09,950
like ways with so in that very simple

88
00:04:09,950 --> 00:04:13,250
example of trim there are three basic

89
00:04:13,250 --> 00:04:15,769
steps the first step is feature

90
00:04:15,769 --> 00:04:18,139
detection is this feature already

91
00:04:18,139 --> 00:04:20,479
present because if it is we don't need

92
00:04:20,479 --> 00:04:22,430
to do anything we just use the native

93
00:04:22,430 --> 00:04:24,770
implementation if the native

94
00:04:24,770 --> 00:04:26,509
implementation is buggy and we need to

95
00:04:26,509 --> 00:04:28,039
fix it somehow that's not really a

96
00:04:28,039 --> 00:04:32,120
polyfill if it's not present we go to

97
00:04:32,120 --> 00:04:35,020
the second step which is implementation

98
00:04:35,020 --> 00:04:37,970
this is the most clever part most tricky

99
00:04:37,970 --> 00:04:40,160
part where you actually have to think of

100
00:04:40,160 --> 00:04:42,949
a way to emulate the functionality

101
00:04:42,949 --> 00:04:45,500
that's missing in some cases it simple

102
00:04:45,500 --> 00:04:48,229
like in the new xmas script methods for

103
00:04:48,229 --> 00:04:50,030
strings and raise that these are the

104
00:04:50,030 --> 00:04:52,310
simplest body fills in some cases it's

105
00:04:52,310 --> 00:04:54,830
very tricky like for example in CSS boy

106
00:04:54,830 --> 00:04:57,520
feels these are the hardest of all and

107
00:04:57,520 --> 00:04:59,810
after you've done you're done with your

108
00:04:59,810 --> 00:05:03,289
code and you've implemented the feature

109
00:05:03,289 --> 00:05:07,130
the third part is distribution you have

110
00:05:07,130 --> 00:05:09,020
your amazing code you're proud of it but

111
00:05:09,020 --> 00:05:11,150
other people need to be able to find it

112
00:05:11,150 --> 00:05:14,479
and use it and you you need to publish

113
00:05:14,479 --> 00:05:18,349
it somewhere and in format that's easy

114
00:05:18,349 --> 00:05:20,780
for them to use and you need to actually

115
00:05:20,780 --> 00:05:23,810
let people know by including it in the

116
00:05:23,810 --> 00:05:26,630
different lists of polyfills that are

117
00:05:26,630 --> 00:05:30,620
available so let's talk a bit about the

118
00:05:30,620 --> 00:05:32,449
first part that's feature detection I

119
00:05:32,449 --> 00:05:34,940
think this is one of the most important

120
00:05:34,940 --> 00:05:37,520
parts of polyfills because if you do

121
00:05:37,520 --> 00:05:40,190
that right you save on lots of

122
00:05:40,190 --> 00:05:42,169
performance if if you the feature is

123
00:05:42,169 --> 00:05:44,870
already present and you move ahead and

124
00:05:44,870 --> 00:05:47,720
implement it again that's a waste you

125
00:05:47,720 --> 00:05:50,479
don't need that waste you need to

126
00:05:50,479 --> 00:05:51,979
actually rely on the feature if it is

127
00:05:51,979 --> 00:05:56,780
there so the two main strategies we use

128
00:05:56,780 --> 00:06:00,860
when featured the texting are a check if

129
00:06:00,860 --> 00:06:03,099
something exists this is the simplest

130
00:06:03,099 --> 00:06:06,620
feature detection method you just

131
00:06:06,620 --> 00:06:08,930
if an API is there for properties their

132
00:06:08,930 --> 00:06:11,360
function is there and if it is you

133
00:06:11,360 --> 00:06:14,000
assume that the feature is present this

134
00:06:14,000 --> 00:06:15,889
is much better for performance because

135
00:06:15,889 --> 00:06:17,750
you just check existence of a property

136
00:06:17,750 --> 00:06:20,900
and it's much much simpler code usually

137
00:06:20,900 --> 00:06:22,880
it's just one line but sometimes it

138
00:06:22,880 --> 00:06:25,190
doesn't work sometimes there are false

139
00:06:25,190 --> 00:06:27,199
positives or sometimes it's just not

140
00:06:27,199 --> 00:06:29,020
possible to detect a feature by

141
00:06:29,020 --> 00:06:32,300
detecting if something exists which

142
00:06:32,300 --> 00:06:35,540
brings us to the second core idea trying

143
00:06:35,540 --> 00:06:37,880
something and then trying to check if it

144
00:06:37,880 --> 00:06:41,210
worked that's much more reliable because

145
00:06:41,210 --> 00:06:43,039
you actually check the functionality you

146
00:06:43,039 --> 00:06:44,750
don't assume that just because it's

147
00:06:44,750 --> 00:06:48,160
there it works but it's also much more

148
00:06:48,160 --> 00:06:52,220
verbose code it's much bigger and it's

149
00:06:52,220 --> 00:06:54,620
much slower than just checking if

150
00:06:54,620 --> 00:06:56,870
something is there but sometimes it's

151
00:06:56,870 --> 00:06:59,990
the only way and the third method is a

152
00:06:59,990 --> 00:07:02,300
combination of the previous two you

153
00:07:02,300 --> 00:07:04,850
first try something and then you check

154
00:07:04,850 --> 00:07:06,889
did it actually work was something

155
00:07:06,889 --> 00:07:11,240
created so let's try and see how we can

156
00:07:11,240 --> 00:07:15,680
detect a few common CSS HTML and

157
00:07:15,680 --> 00:07:17,870
JavaScript features that we commonly

158
00:07:17,870 --> 00:07:22,940
need the first way which uses the which

159
00:07:22,940 --> 00:07:24,830
uses the first core idea taking if

160
00:07:24,830 --> 00:07:27,310
something exists is checking about

161
00:07:27,310 --> 00:07:30,470
JavaScript API support like for example

162
00:07:30,470 --> 00:07:33,470
is local storage on window is geo

163
00:07:33,470 --> 00:07:36,169
location in the navigator object or is

164
00:07:36,169 --> 00:07:40,039
query selector and document as you can

165
00:07:40,039 --> 00:07:42,830
see that's really easy really small we

166
00:07:42,830 --> 00:07:47,410
just use one line of code for every API

167
00:07:47,410 --> 00:07:50,389
checking if CSS properties are supported

168
00:07:50,389 --> 00:07:52,729
is about as straight forward we just

169
00:07:52,729 --> 00:07:54,710
create a dummy element and we check if

170
00:07:54,710 --> 00:07:57,050
the property is in the style object in

171
00:07:57,050 --> 00:07:59,270
actual cases you shouldn't create a new

172
00:07:59,270 --> 00:08:01,910
element every time I'm just creating in

173
00:08:01,910 --> 00:08:03,530
your element here just to make it

174
00:08:03,530 --> 00:08:05,009
simpler but in

175
00:08:05,009 --> 00:08:06,599
actually use cases you should cash it

176
00:08:06,599 --> 00:08:08,610
because it's not really a good idea to

177
00:08:08,610 --> 00:08:10,559
just create one every time its

178
00:08:10,559 --> 00:08:12,330
properties function is called or maybe

179
00:08:12,330 --> 00:08:13,800
you should also catch the results

180
00:08:13,800 --> 00:08:16,169
because if it's supported it will always

181
00:08:16,169 --> 00:08:20,189
be supported another method of checking

182
00:08:20,189 --> 00:08:23,339
whether CSS properties are supported is

183
00:08:23,339 --> 00:08:25,740
by using the second core idea which is

184
00:08:25,740 --> 00:08:29,219
especially useful if you want to check

185
00:08:29,219 --> 00:08:31,459
multiple versions of that property like

186
00:08:31,459 --> 00:08:35,399
multiple prefixes so you can still

187
00:08:35,399 --> 00:08:37,500
follow the previous method but you will

188
00:08:37,500 --> 00:08:39,389
need to come up case your property and

189
00:08:39,389 --> 00:08:41,579
you will need to create two camelcase

190
00:08:41,579 --> 00:08:43,560
versions of your property because for

191
00:08:43,560 --> 00:08:46,050
example border-radius that's without a

192
00:08:46,050 --> 00:08:48,209
prefix is camel case to board the radius

193
00:08:48,209 --> 00:08:50,790
without and the first B is this lower

194
00:08:50,790 --> 00:08:53,730
case most border radius is camel cast

195
00:08:53,730 --> 00:08:57,110
with a capital m and then the bees also

196
00:08:57,110 --> 00:09:01,139
uppercase so in this method we I trade

197
00:09:01,139 --> 00:09:03,990
over all the prefixes we get the prefix

198
00:09:03,990 --> 00:09:07,079
version of the property and then we set

199
00:09:07,079 --> 00:09:09,630
the CSS text of the dummy element to a

200
00:09:09,630 --> 00:09:11,670
declaration that uses that property and

201
00:09:11,670 --> 00:09:14,430
because inherit is supported by every

202
00:09:14,430 --> 00:09:17,550
CSS property it should get accepted if

203
00:09:17,550 --> 00:09:19,649
the property is supported it should

204
00:09:19,649 --> 00:09:22,560
accept inherit so then we try to get the

205
00:09:22,560 --> 00:09:25,050
value of that property and if there's a

206
00:09:25,050 --> 00:09:27,389
value we returned that version of the

207
00:09:27,389 --> 00:09:28,709
property because we know that property

208
00:09:28,709 --> 00:09:31,050
is supported if none of these prefix

209
00:09:31,050 --> 00:09:33,959
properties are supported then in this

210
00:09:33,959 --> 00:09:36,480
case we return undefined in if the

211
00:09:36,480 --> 00:09:38,069
function was more correct it should

212
00:09:38,069 --> 00:09:43,800
return node checking CSS values requires

213
00:09:43,800 --> 00:09:45,930
a bit of a test there's nothing we can

214
00:09:45,930 --> 00:09:48,839
check existence for so we actually need

215
00:09:48,839 --> 00:09:52,860
to apply the property we just choose any

216
00:09:52,860 --> 00:09:55,470
rgba value it would work and actually

217
00:09:55,470 --> 00:09:57,540
that method is not just for our GBA it

218
00:09:57,540 --> 00:09:59,610
applies for any kind of CSS property for

219
00:09:59,610 --> 00:10:03,329
calc for hsla for mozilla before L

220
00:10:03,329 --> 00:10:05,850
for the element function anything so you

221
00:10:05,850 --> 00:10:08,369
just choose one value that uses this

222
00:10:08,369 --> 00:10:10,829
feature and then you check was there an

223
00:10:10,829 --> 00:10:14,429
error is there did the property keep its

224
00:10:14,429 --> 00:10:16,559
value because browsers just ditch

225
00:10:16,559 --> 00:10:19,319
anything in CSS that doesn't work if you

226
00:10:19,319 --> 00:10:20,970
provide an invalid property it gets

227
00:10:20,970 --> 00:10:22,379
dropped if you provide an invalid value

228
00:10:22,379 --> 00:10:25,259
it gets dropped so if it actually kept

229
00:10:25,259 --> 00:10:29,939
that value it means it's supported CSS

230
00:10:29,939 --> 00:10:32,459
selectors are also a bit tricky you need

231
00:10:32,459 --> 00:10:34,889
to create a new style element you just

232
00:10:34,889 --> 00:10:36,809
create a simple row by using that

233
00:10:36,809 --> 00:10:38,759
selector it's an empty roll it doesn't

234
00:10:38,759 --> 00:10:40,410
need to create it doesn't need to

235
00:10:40,410 --> 00:10:43,739
contain any declarations just the just

236
00:10:43,739 --> 00:10:45,929
as long as it uses the selector and we

237
00:10:45,929 --> 00:10:47,249
append it to the document because

238
00:10:47,249 --> 00:10:48,839
otherwise if it's just in the dome

239
00:10:48,839 --> 00:10:53,149
hyperspace it won't it won't get applied

240
00:10:53,149 --> 00:10:56,610
so then we check it was an errand

241
00:10:56,610 --> 00:10:59,489
created in this case I actually attract

242
00:10:59,489 --> 00:11:01,649
if there's a first CSS role you could

243
00:11:01,649 --> 00:11:03,540
just check the length of CSS rules it

244
00:11:03,540 --> 00:11:07,049
it's the same thing and we clean up

245
00:11:07,049 --> 00:11:08,970
after all cells but by removing the

246
00:11:08,970 --> 00:11:11,009
element we don't need we don't want to

247
00:11:11,009 --> 00:11:12,959
leave it in the document and mess up

248
00:11:12,959 --> 00:11:16,079
with the end-users code and we return

249
00:11:16,079 --> 00:11:19,730
the result if it was there or not

250
00:11:19,730 --> 00:11:22,739
detecting HTML elements is really hard

251
00:11:22,739 --> 00:11:25,110
to do in a generic way this could be a

252
00:11:25,110 --> 00:11:26,759
very optimistic thought because if you

253
00:11:26,759 --> 00:11:29,309
read the dome specification it says that

254
00:11:29,309 --> 00:11:31,049
every element that's not supported

255
00:11:31,049 --> 00:11:33,299
should inherit from the HTML unknown

256
00:11:33,299 --> 00:11:36,209
element interface however browsers arms

257
00:11:36,209 --> 00:11:39,089
aren't expected to expose these

258
00:11:39,089 --> 00:11:41,339
interfaces there it's not required as

259
00:11:41,339 --> 00:11:42,929
long as they use them internally and

260
00:11:42,929 --> 00:11:46,799
also some browsers don't even follow the

261
00:11:46,799 --> 00:11:49,290
spec and they don't use that at all for

262
00:11:49,290 --> 00:11:51,989
in some browsers it in here unknown

263
00:11:51,989 --> 00:11:53,970
elements inherit from the HTML element

264
00:11:53,970 --> 00:11:57,779
interface it's really inconsistent so we

265
00:11:57,779 --> 00:12:01,079
can't do that it's it's nice but it

266
00:12:01,079 --> 00:12:06,899
won't work so what we have to do instead

267
00:12:06,899 --> 00:12:09,689
his check for known properties or known

268
00:12:09,689 --> 00:12:11,730
methods are they present in a new

269
00:12:11,730 --> 00:12:16,079
instance of the element so it's a bit

270
00:12:16,079 --> 00:12:18,119
lucky because we don't know if they

271
00:12:18,119 --> 00:12:21,749
actually work but it gets it gets the

272
00:12:21,749 --> 00:12:24,660
job done it works it does what we do in

273
00:12:24,660 --> 00:12:28,170
most cases so for example if we want to

274
00:12:28,170 --> 00:12:30,300
check canvas support which i give the

275
00:12:30,300 --> 00:12:32,279
get context method is thereafter we want

276
00:12:32,279 --> 00:12:34,800
to check if video is supported which I

277
00:12:34,800 --> 00:12:37,199
could play method if if we want it to be

278
00:12:37,199 --> 00:12:38,699
a bit more accurate we could actually

279
00:12:38,699 --> 00:12:40,350
check if it's a function and not just

280
00:12:40,350 --> 00:12:44,759
the property HTML attributes are usually

281
00:12:44,759 --> 00:12:46,709
pretty straightforward of course there

282
00:12:46,709 --> 00:12:48,480
are caveats to that which will see

283
00:12:48,480 --> 00:12:51,300
afterwards but in the general case you

284
00:12:51,300 --> 00:12:55,470
just assign you just check if the the

285
00:12:55,470 --> 00:12:59,040
Gator is present because browsers assign

286
00:12:59,040 --> 00:13:01,319
a getter through every attribute that

287
00:13:01,319 --> 00:13:03,629
they support if they support placeholder

288
00:13:03,629 --> 00:13:05,490
attribute on inputs they also make a

289
00:13:05,490 --> 00:13:07,889
placeholder gather and setter or if they

290
00:13:07,889 --> 00:13:10,860
support multiple file inputs they create

291
00:13:10,860 --> 00:13:13,379
a multiple accessor so we can just check

292
00:13:13,379 --> 00:13:15,389
it if that's present it won't have a

293
00:13:15,389 --> 00:13:19,170
value so checking if input dot multiple

294
00:13:19,170 --> 00:13:21,540
has it through the volume won't work but

295
00:13:21,540 --> 00:13:23,990
it will be present it will be defined

296
00:13:23,990 --> 00:13:27,569
and attribute values are about the same

297
00:13:27,569 --> 00:13:32,660
as CSS values you just say you just set

298
00:13:32,660 --> 00:13:36,420
appropriate value and you check if the

299
00:13:36,420 --> 00:13:39,029
browser actually kept it for example in

300
00:13:39,029 --> 00:13:41,160
this case type is a supported attribute

301
00:13:41,160 --> 00:13:43,759
on inputs every browser supports it but

302
00:13:43,759 --> 00:13:47,879
some values aren't Lee is supported for

303
00:13:47,879 --> 00:13:50,220
example the number type which is used to

304
00:13:50,220 --> 00:13:52,199
create a spinner some browsers don't

305
00:13:52,199 --> 00:13:55,860
support that yet like Firefox or ie so

306
00:13:55,860 --> 00:13:58,230
which we set the type to a number and

307
00:13:58,230 --> 00:13:59,790
then we check if the browser actually

308
00:13:59,790 --> 00:14:02,490
kept that because if it doesn't it

309
00:14:02,490 --> 00:14:05,610
usually reverts back to the text value

310
00:14:05,610 --> 00:14:09,240
which is the default for events we can

311
00:14:09,240 --> 00:14:11,790
do something similar at least for events

312
00:14:11,790 --> 00:14:12,850
that have a

313
00:14:12,850 --> 00:14:15,670
an accessor like on something for

314
00:14:15,670 --> 00:14:19,660
example own mouth center we can set them

315
00:14:19,660 --> 00:14:21,990
to a very simple function like return

316
00:14:21,990 --> 00:14:25,000
nothing at which does nothing and then

317
00:14:25,000 --> 00:14:26,259
check was there a function actually

318
00:14:26,259 --> 00:14:30,009
created on that element if a function

319
00:14:30,009 --> 00:14:32,310
was created it means it's supported if

320
00:14:32,310 --> 00:14:35,589
nothing was if nothing is there it means

321
00:14:35,589 --> 00:14:38,589
it's not unfortunately there's no method

322
00:14:38,589 --> 00:14:42,310
there's no way to detect events like Dom

323
00:14:42,310 --> 00:14:46,029
content loaded or mutation events we

324
00:14:46,029 --> 00:14:47,769
don't have a way for that we have to

325
00:14:47,769 --> 00:14:50,290
detect something else that we know that

326
00:14:50,290 --> 00:14:52,269
if its present these events are also

327
00:14:52,269 --> 00:14:54,430
present for mutation events we can

328
00:14:54,430 --> 00:14:56,980
actually change the dolmen see if they

329
00:14:56,980 --> 00:14:59,740
got if they got fired but it's a bit

330
00:14:59,740 --> 00:15:03,279
it's much more messy than that and of

331
00:15:03,279 --> 00:15:06,190
course even the examples I showed aren't

332
00:15:06,190 --> 00:15:08,079
always that simple there are browser

333
00:15:08,079 --> 00:15:11,829
bugs and everything so for example we

334
00:15:11,829 --> 00:15:14,139
checked if local storage is supported by

335
00:15:14,139 --> 00:15:15,819
checking if its present on the window

336
00:15:15,819 --> 00:15:19,750
object but in firefox 3.6 accessing

337
00:15:19,750 --> 00:15:22,630
local storage throws an error so you

338
00:15:22,630 --> 00:15:25,060
also need to account for that or for

339
00:15:25,060 --> 00:15:27,670
example opera doesn't support pointer

340
00:15:27,670 --> 00:15:30,490
events on HTML elements but it still has

341
00:15:30,490 --> 00:15:33,009
them in the style object because it

342
00:15:33,009 --> 00:15:38,220
supports them in SVG so in a wish before

343
00:15:38,220 --> 00:15:41,139
actually deciding on a feature detection

344
00:15:41,139 --> 00:15:44,259
code we should really test in lots and

345
00:15:44,259 --> 00:15:46,000
lots of browsers to see if it actually

346
00:15:46,000 --> 00:15:48,459
works or maybe check the moderniser

347
00:15:48,459 --> 00:15:51,189
source to see how they did it because

348
00:15:51,189 --> 00:15:53,649
they need to test in many many browsers

349
00:15:53,649 --> 00:15:57,850
to develop their framework and of course

350
00:15:57,850 --> 00:15:59,439
there are some features that nobody can

351
00:15:59,439 --> 00:16:05,380
detect so far the the undetectable some

352
00:16:05,380 --> 00:16:07,930
features just you can't do anything

353
00:16:07,930 --> 00:16:10,550
about them even modernizer can't detect

354
00:16:10,550 --> 00:16:12,930
pointer events an opera used to be one

355
00:16:12,930 --> 00:16:14,519
of them because it kind of falls

356
00:16:14,519 --> 00:16:17,370
positive but now some clever guy whose

357
00:16:17,370 --> 00:16:19,860
name I forget actually came up with the

358
00:16:19,860 --> 00:16:22,170
detection method he's setting the

359
00:16:22,170 --> 00:16:23,970
property and then she's checking the

360
00:16:23,970 --> 00:16:26,209
computed style to see if it got applied

361
00:16:26,209 --> 00:16:28,470
so now we can't detect pointer events

362
00:16:28,470 --> 00:16:32,040
and the cord isn't that big but there

363
00:16:32,040 --> 00:16:35,459
are many other properties that features

364
00:16:35,459 --> 00:16:37,319
that can't be detected currently maybe

365
00:16:37,319 --> 00:16:41,490
you can think of a way we need that kind

366
00:16:41,490 --> 00:16:43,709
of thought we need people to come up

367
00:16:43,709 --> 00:16:45,420
with new ways to detect features just

368
00:16:45,420 --> 00:16:46,800
because there they are on that list

369
00:16:46,800 --> 00:16:49,139
doesn't mean they can't be detected it

370
00:16:49,139 --> 00:16:51,529
just means we're not clever enough yet

371
00:16:51,529 --> 00:16:56,550
maybe you are softer we've done with

372
00:16:56,550 --> 00:16:59,309
feature detection we're going to the

373
00:16:59,309 --> 00:17:01,079
interesting part with this

374
00:17:01,079 --> 00:17:03,839
implementation actually making the stuff

375
00:17:03,839 --> 00:17:08,610
work the first rule I think every

376
00:17:08,610 --> 00:17:11,429
polyfill should follow is following the

377
00:17:11,429 --> 00:17:15,839
spec not that kind of follow actually

378
00:17:15,839 --> 00:17:18,600
being faithful to the spec and doing and

379
00:17:18,600 --> 00:17:21,059
fit fulfilling the expectations that

380
00:17:21,059 --> 00:17:23,549
people have is there's no use if you're

381
00:17:23,549 --> 00:17:25,530
making a bully feel that behaves in a

382
00:17:25,530 --> 00:17:27,839
way that you think is better but it's

383
00:17:27,839 --> 00:17:29,280
not what's expected it will be

384
00:17:29,280 --> 00:17:31,260
inconsistent with native implementations

385
00:17:31,260 --> 00:17:34,049
it will be inconsistent with what people

386
00:17:34,049 --> 00:17:35,610
have learned it won't really be a

387
00:17:35,610 --> 00:17:37,590
polyfill it will be an API wrapper

388
00:17:37,590 --> 00:17:40,530
masquerading as a polyfill but however

389
00:17:40,530 --> 00:17:43,710
as much as it's important to follow the

390
00:17:43,710 --> 00:17:46,580
spec you should also know when to stop

391
00:17:46,580 --> 00:17:48,419
because you don't want to put your

392
00:17:48,419 --> 00:17:51,440
polyfill to end up like this fine lady

393
00:17:51,440 --> 00:17:54,630
you don't want your polyfill to be

394
00:17:54,630 --> 00:17:57,899
cluttered for example I fell into that

395
00:17:57,899 --> 00:18:02,700
this trap when i created a polyfill for

396
00:18:02,700 --> 00:18:07,230
the html5 progress element I wanted it

397
00:18:07,230 --> 00:18:10,080
to be as correct as possible I wanted it

398
00:18:10,080 --> 00:18:12,720
to respond to property changes and

399
00:18:12,720 --> 00:18:15,480
attribute changes and I wanted

400
00:18:15,480 --> 00:18:18,210
CSS to be super flexible I wanted to

401
00:18:18,210 --> 00:18:22,770
make the best progress polyfill and I

402
00:18:22,770 --> 00:18:26,690
ended up with some code that's 200 lines

403
00:18:26,690 --> 00:18:31,260
just to support progress bars who who

404
00:18:31,260 --> 00:18:35,010
want to use 200 lines just to be able to

405
00:18:35,010 --> 00:18:37,950
use the html5 progress bars your

406
00:18:37,950 --> 00:18:40,170
polyfills need to be small so that

407
00:18:40,170 --> 00:18:44,700
people will want to include them without

408
00:18:44,700 --> 00:18:47,460
introducing an overhead because even

409
00:18:47,460 --> 00:18:49,110
when they're not executed because the

410
00:18:49,110 --> 00:18:51,110
browser already supports the feature

411
00:18:51,110 --> 00:18:54,180
usually they get downloaded and we don't

412
00:18:54,180 --> 00:18:56,160
need we don't want to add that much

413
00:18:56,160 --> 00:18:58,950
bandwidth of course there are script

414
00:18:58,950 --> 00:19:00,930
loaders that only conditionally load

415
00:19:00,930 --> 00:19:03,150
polyfills but in the general case

416
00:19:03,150 --> 00:19:05,670
they're just included along with any

417
00:19:05,670 --> 00:19:10,020
other script a case that's quite

418
00:19:10,020 --> 00:19:13,890
tempting to go overboard is a polyfill

419
00:19:13,890 --> 00:19:16,980
for document head how many of you

420
00:19:16,980 --> 00:19:22,290
actually have used document head it's

421
00:19:22,290 --> 00:19:26,040
the same thing as document body but it

422
00:19:26,040 --> 00:19:28,950
refers to the head element it's an html5

423
00:19:28,950 --> 00:19:31,620
thing and it seems that it's really easy

424
00:19:31,620 --> 00:19:34,200
to create a pulley feel for it you just

425
00:19:34,200 --> 00:19:36,810
check if document head has a value and

426
00:19:36,810 --> 00:19:39,510
if it doesn't you just assign the first

427
00:19:39,510 --> 00:19:43,170
head element to it but however there's a

428
00:19:43,170 --> 00:19:45,480
big problem in that and I'm pretty sure

429
00:19:45,480 --> 00:19:47,820
some of you have already started seeing

430
00:19:47,820 --> 00:19:51,990
it if your document only has one frame

431
00:19:51,990 --> 00:19:56,610
that's fine it will work but if you have

432
00:19:56,610 --> 00:19:58,530
multiple frames and you try to actually

433
00:19:58,530 --> 00:20:02,070
use that in the other frame I want you

434
00:20:02,070 --> 00:20:05,550
will get a type error it yes it breaks

435
00:20:05,550 --> 00:20:08,630
expectations but what's the alternative

436
00:20:08,630 --> 00:20:12,390
what would you do not to avoid this the

437
00:20:12,390 --> 00:20:13,200
only solution

438
00:20:13,200 --> 00:20:16,710
Shin is to hijack every frame in the

439
00:20:16,710 --> 00:20:19,049
document monitor when frames get added

440
00:20:19,049 --> 00:20:22,889
and also fixed the document head for

441
00:20:22,889 --> 00:20:24,809
them as well and sometimes windows get

442
00:20:24,809 --> 00:20:27,000
opened with window open so we should

443
00:20:27,000 --> 00:20:29,779
replace the window open method and and

444
00:20:29,779 --> 00:20:32,760
fix that too I mean it gets really messy

445
00:20:32,760 --> 00:20:37,440
we don't want that that's fine the two

446
00:20:37,440 --> 00:20:39,179
line polyfill is what most people want

447
00:20:39,179 --> 00:20:41,010
they don't want a huge script that's

448
00:20:41,010 --> 00:20:45,590
super intrusive and and easy to break

449
00:20:45,590 --> 00:20:49,019
just for document head after all instead

450
00:20:49,019 --> 00:20:51,330
of doing that I'll just assign the head

451
00:20:51,330 --> 00:20:53,070
and the middle to have arrival and get

452
00:20:53,070 --> 00:20:58,470
it over with the second rule I think

453
00:20:58,470 --> 00:21:00,630
most polyfill should follow is not being

454
00:21:00,630 --> 00:21:04,230
intrusive like I said polyfill stood

455
00:21:04,230 --> 00:21:08,070
follow expectations and the expectations

456
00:21:08,070 --> 00:21:11,070
aren't that you hijack your host

457
00:21:11,070 --> 00:21:16,230
document with a relevant crap try not to

458
00:21:16,230 --> 00:21:18,059
replace the target element with another

459
00:21:18,059 --> 00:21:21,090
for example even if you're super careful

460
00:21:21,090 --> 00:21:23,389
and you copy old properties and all

461
00:21:23,389 --> 00:21:25,590
attributes and everything at the very

462
00:21:25,590 --> 00:21:27,480
least you'll wipe out all event

463
00:21:27,480 --> 00:21:32,309
listeners and it's really hard for the

464
00:21:32,309 --> 00:21:37,320
end user to work with that also try not

465
00:21:37,320 --> 00:21:40,289
to manipulate unrelated elements like

466
00:21:40,289 --> 00:21:41,880
the body it might be tempting to add a

467
00:21:41,880 --> 00:21:44,070
class to the body to use it in your CSS

468
00:21:44,070 --> 00:21:46,260
if you're prolly fuel comes with the CSS

469
00:21:46,260 --> 00:21:48,870
like HTML polyfills for example it might

470
00:21:48,870 --> 00:21:50,460
be tempting to add a class to the body

471
00:21:50,460 --> 00:21:53,460
to which corresponds to whether that

472
00:21:53,460 --> 00:21:56,220
feature is supported or not but you

473
00:21:56,220 --> 00:21:58,019
should try to find another way to do it

474
00:21:58,019 --> 00:22:00,419
because the the horse document might

475
00:22:00,419 --> 00:22:03,360
actually depend on how many classes the

476
00:22:03,360 --> 00:22:06,659
body has the right they might have a

477
00:22:06,659 --> 00:22:09,120
selector in use in their CSS about the

478
00:22:09,120 --> 00:22:11,190
body not having a class or if the body

479
00:22:11,190 --> 00:22:12,929
having only one class or something like

480
00:22:12,929 --> 00:22:13,570
that

481
00:22:13,570 --> 00:22:15,400
that will break and they'll be wondering

482
00:22:15,400 --> 00:22:17,920
why did it break they'll find out it's

483
00:22:17,920 --> 00:22:21,860
your bully film they won't like it much

484
00:22:21,870 --> 00:22:24,040
adding extra elements sometimes is

485
00:22:24,040 --> 00:22:26,470
inevitable but you should try to be as

486
00:22:26,470 --> 00:22:28,720
conservative as possible for example if

487
00:22:28,720 --> 00:22:31,030
you're making an HTML polyfill try to

488
00:22:31,030 --> 00:22:33,070
take advantage of the pseudo elements

489
00:22:33,070 --> 00:22:35,860
instead of adding new elements to the

490
00:22:35,860 --> 00:22:37,840
dome that break existing selectors that

491
00:22:37,840 --> 00:22:39,790
are already in the horse document for

492
00:22:39,790 --> 00:22:42,040
example especially now with css3

493
00:22:42,040 --> 00:22:46,090
selectors we have many CSS rules that

494
00:22:46,090 --> 00:22:48,310
depend on the play on the place an

495
00:22:48,310 --> 00:22:51,070
element has in the document on its index

496
00:22:51,070 --> 00:22:53,610
among its siblings on how many elements

497
00:22:53,610 --> 00:22:57,100
something has so you're breaking this if

498
00:22:57,100 --> 00:23:00,010
you are the extra elements try to avoid

499
00:23:00,010 --> 00:23:03,970
it also manipulating existing attributes

500
00:23:03,970 --> 00:23:07,210
is sometimes the only way but try to

501
00:23:07,210 --> 00:23:09,730
avoid that too like for example going

502
00:23:09,730 --> 00:23:11,320
through the elements you care about and

503
00:23:11,320 --> 00:23:14,050
changing their IDs or adding ideas or

504
00:23:14,050 --> 00:23:16,690
stuff like that so you have to do it

505
00:23:16,690 --> 00:23:21,100
sometimes but it breaks expectations for

506
00:23:21,100 --> 00:23:24,240
the horse document so try to avoid it I

507
00:23:24,240 --> 00:23:28,030
guess I don't need to tell you that that

508
00:23:28,030 --> 00:23:30,220
you should try not to pollute the global

509
00:23:30,220 --> 00:23:32,080
namespace probably already know it but I

510
00:23:32,080 --> 00:23:36,160
had to to add it and also that's quite

511
00:23:36,160 --> 00:23:39,760
obvious too but sometimes it breaks try

512
00:23:39,760 --> 00:23:42,760
not one leaky CSS like for example you

513
00:23:42,760 --> 00:23:44,620
should namespace your CSS to only apply

514
00:23:44,620 --> 00:23:48,190
to what you add to what you target don't

515
00:23:48,190 --> 00:23:50,770
add CSS like for example an element

516
00:23:50,770 --> 00:23:52,390
selector that would leak in other

517
00:23:52,390 --> 00:23:56,110
elements and not just your the target of

518
00:23:56,110 --> 00:23:58,270
your polyfill and of course all these

519
00:23:58,270 --> 00:24:00,990
it's just guidelines rules of thumb in

520
00:24:00,990 --> 00:24:03,790
most cases you will need to break at

521
00:24:03,790 --> 00:24:06,310
least one of them in most of oil fields

522
00:24:06,310 --> 00:24:08,830
at least in most HTML polyfills but just

523
00:24:08,830 --> 00:24:11,230
try to only do them if you really really

524
00:24:11,230 --> 00:24:16,440
have to

525
00:24:16,450 --> 00:24:18,919
also remember when we said at the

526
00:24:18,919 --> 00:24:20,750
beginning that one of the biggest

527
00:24:20,750 --> 00:24:24,890
advantages of polyfills is that they you

528
00:24:24,890 --> 00:24:26,480
will be able to remove them after a

529
00:24:26,480 --> 00:24:28,010
certain point maybe after some months

530
00:24:28,010 --> 00:24:30,880
maybe after some years when support gets

531
00:24:30,880 --> 00:24:33,260
better and you don't need that anymore

532
00:24:33,260 --> 00:24:34,850
because the browsers that don't support

533
00:24:34,850 --> 00:24:37,070
that feature a really old and nobody

534
00:24:37,070 --> 00:24:38,690
uses them anymore so you don't want the

535
00:24:38,690 --> 00:24:43,250
overhead so you're you should be able to

536
00:24:43,250 --> 00:24:44,900
remove that polyfill and you're that

537
00:24:44,900 --> 00:24:47,600
your code still works without the poly

538
00:24:47,600 --> 00:24:49,460
filled in in browsers that support these

539
00:24:49,460 --> 00:24:52,309
feature so you shouldn't require from

540
00:24:52,309 --> 00:24:54,470
the end user of your polyfill to do

541
00:24:54,470 --> 00:24:57,559
stuff like this feature detection

542
00:24:57,559 --> 00:24:59,900
belongs in your polyfill gathering on

543
00:24:59,900 --> 00:25:01,960
the elements and fixing them also

544
00:25:01,960 --> 00:25:05,600
depends on your polyfill belongs to your

545
00:25:05,600 --> 00:25:08,660
poi fill it might sound obvious but it's

546
00:25:08,660 --> 00:25:11,360
it's really surprising how many people

547
00:25:11,360 --> 00:25:13,580
don't follow that they make a function

548
00:25:13,580 --> 00:25:15,559
that implements some functionality and

549
00:25:15,559 --> 00:25:17,510
then they're like yeah use that function

550
00:25:17,510 --> 00:25:20,179
on any element you want to fix and they

551
00:25:20,179 --> 00:25:22,130
don't actually do that you know they

552
00:25:22,130 --> 00:25:24,260
don't actually do anything except

553
00:25:24,260 --> 00:25:26,390
defining that function so to use their

554
00:25:26,390 --> 00:25:28,220
polyfill you have to actually add

555
00:25:28,220 --> 00:25:30,429
JavaScript code get all these elements

556
00:25:30,429 --> 00:25:33,850
yourself and apply that function to them

557
00:25:33,850 --> 00:25:37,040
so afterwards when the time comes to

558
00:25:37,040 --> 00:25:40,100
remove the polyfill your code will break

559
00:25:40,100 --> 00:25:42,860
for example in this case it calls the

560
00:25:42,860 --> 00:25:45,740
net method over details object when the

561
00:25:45,740 --> 00:25:47,960
polyfill gets removed this will throw an

562
00:25:47,960 --> 00:25:51,070
error there's no details element defined

563
00:25:51,070 --> 00:25:54,350
so that's that's not how polyfill should

564
00:25:54,350 --> 00:26:00,770
work also your polyfill will be applied

565
00:26:00,770 --> 00:26:04,280
in many cases in many different cases in

566
00:26:04,280 --> 00:26:06,470
many many times the assumptions you make

567
00:26:06,470 --> 00:26:09,890
will be wrong many times we tend to make

568
00:26:09,890 --> 00:26:12,230
assumptions to make our job easier but

569
00:26:12,230 --> 00:26:14,140
those assumptions don't really don't

570
00:26:14,140 --> 00:26:16,450
apply to every dog any document and

571
00:26:16,450 --> 00:26:18,910
sometimes we know that and we just

572
00:26:18,910 --> 00:26:20,620
choose to make these assumptions and

573
00:26:20,620 --> 00:26:23,770
some other times we just didn't think of

574
00:26:23,770 --> 00:26:27,250
that and if you actually have to make an

575
00:26:27,250 --> 00:26:28,810
assumption for your polyfill to work

576
00:26:28,810 --> 00:26:30,370
because maybe otherwise your code will

577
00:26:30,370 --> 00:26:32,740
be 10 times as big that's fine but you

578
00:26:32,740 --> 00:26:34,300
should at least know that you're making

579
00:26:34,300 --> 00:26:36,400
this assumption it should be a known

580
00:26:36,400 --> 00:26:41,440
unknown so attributes and properties

581
00:26:41,440 --> 00:26:44,230
will change there will be other scripts

582
00:26:44,230 --> 00:26:46,240
on that page it won't be just yours and

583
00:26:46,240 --> 00:26:49,300
those scripts will actually change might

584
00:26:49,300 --> 00:26:50,680
actually change attributes and

585
00:26:50,680 --> 00:26:54,640
properties also new elements might get

586
00:26:54,640 --> 00:26:57,100
at it maybe by via Ajax or maybe they'll

587
00:26:57,100 --> 00:26:59,890
get created by some other script but the

588
00:26:59,890 --> 00:27:02,470
thing is if you make an example for

589
00:27:02,470 --> 00:27:05,580
example for the html5 details element

590
00:27:05,580 --> 00:27:08,770
nothing guarantees that there will be as

591
00:27:08,770 --> 00:27:10,420
many details element when the document

592
00:27:10,420 --> 00:27:13,000
is closed as the ones that were there

593
00:27:13,000 --> 00:27:17,590
when it was created CSS can be very

594
00:27:17,590 --> 00:27:21,280
different from the one you tried you

595
00:27:21,280 --> 00:27:23,350
might have making sinuses you might have

596
00:27:23,350 --> 00:27:25,990
been making some assumptions and certain

597
00:27:25,990 --> 00:27:28,680
kind of hot CSS will break them and

598
00:27:28,680 --> 00:27:32,080
there might not even be a dome that

599
00:27:32,080 --> 00:27:33,580
might sound weird and you might be

600
00:27:33,580 --> 00:27:36,010
thinking about thick cases like no

601
00:27:36,010 --> 00:27:38,530
genius for example but even in

602
00:27:38,530 --> 00:27:40,090
client-side JavaScript there's not

603
00:27:40,090 --> 00:27:42,850
always a dumb for example in web workers

604
00:27:42,850 --> 00:27:46,000
your code might need to run in in a web

605
00:27:46,000 --> 00:27:48,340
worker if it's actually a polyfill that

606
00:27:48,340 --> 00:27:50,980
applies to something like that so you

607
00:27:50,980 --> 00:27:53,230
shouldn't depend in a dome being present

608
00:27:53,230 --> 00:27:55,930
and it might you might be thinking now

609
00:27:55,930 --> 00:27:58,300
why would I depend on a dome if my

610
00:27:58,300 --> 00:28:00,100
polyfill has nothing to do with the dome

611
00:28:00,100 --> 00:28:03,040
and I can it can even run in a web

612
00:28:03,040 --> 00:28:04,810
worker for example if your polyfill

613
00:28:04,810 --> 00:28:07,570
needs to resolve URLs and get the

614
00:28:07,570 --> 00:28:10,240
separate parts one waste partially URL

615
00:28:10,240 --> 00:28:13,210
yourself and return the and split it in

616
00:28:13,210 --> 00:28:14,680
two parts like the horse named the pass

617
00:28:14,680 --> 00:28:17,740
the pestering and everything but another

618
00:28:17,740 --> 00:28:19,250
way it would be to create a dummy

619
00:28:19,250 --> 00:28:22,400
element and set its href to that URL and

620
00:28:22,400 --> 00:28:24,470
then get the properties from there which

621
00:28:24,470 --> 00:28:26,150
will might sound quite clever at the

622
00:28:26,150 --> 00:28:28,070
time but it will break when there's no

623
00:28:28,070 --> 00:28:31,010
don't present even though URLs aren't

624
00:28:31,010 --> 00:28:33,110
breaking your elders in two parts isn't

625
00:28:33,110 --> 00:28:36,920
something that needs to depend on a dome

626
00:28:36,920 --> 00:28:39,890
and also you shouldn't even depend on

627
00:28:39,890 --> 00:28:42,980
HTML it might not be HTML your polyfill

628
00:28:42,980 --> 00:28:45,110
might need to run in an SVG document or

629
00:28:45,110 --> 00:28:49,430
in an XML document and it should still

630
00:28:49,430 --> 00:28:53,720
not break of course some of these are

631
00:28:53,720 --> 00:28:58,100
edge cases and some of these are edge

632
00:28:58,100 --> 00:29:01,220
cases and maybe you want to make the

633
00:29:01,220 --> 00:29:03,440
decision not to support them because it

634
00:29:03,440 --> 00:29:05,600
will make your code base huge and you

635
00:29:05,600 --> 00:29:07,130
will fall into the trap I feel with the

636
00:29:07,130 --> 00:29:09,350
progress element with the progress

637
00:29:09,350 --> 00:29:12,050
polyfill but you should know that you're

638
00:29:12,050 --> 00:29:13,790
making these assumptions and preferably

639
00:29:13,790 --> 00:29:15,080
you should state them in the description

640
00:29:15,080 --> 00:29:17,600
of your polyfill some people know them

641
00:29:17,600 --> 00:29:18,830
and they won't spend time debugging

642
00:29:18,830 --> 00:29:22,130
something that isn't supposed to work in

643
00:29:22,130 --> 00:29:28,250
their case so the first thing responding

644
00:29:28,250 --> 00:29:30,440
to attribute changes this only applies

645
00:29:30,440 --> 00:29:34,880
to HTML polyfills how can we actually do

646
00:29:34,880 --> 00:29:37,940
stuff what attributes change we have two

647
00:29:37,940 --> 00:29:40,840
tools for this first is mutation events

648
00:29:40,840 --> 00:29:44,810
which which are events that get fired

649
00:29:44,810 --> 00:29:46,430
when the dome three changes when an

650
00:29:46,430 --> 00:29:48,140
attribute gets removed when an attribute

651
00:29:48,140 --> 00:29:50,320
changes when a new element gets added

652
00:29:50,320 --> 00:29:52,400
the problem with those are they are

653
00:29:52,400 --> 00:29:54,590
deprecated now and there's no

654
00:29:54,590 --> 00:29:58,160
alternative in the standard this they're

655
00:29:58,160 --> 00:30:00,560
preparing something but it's not even in

656
00:30:00,560 --> 00:30:02,240
the spec there's not even a speck yet

657
00:30:02,240 --> 00:30:05,240
and of course no browser supports it so

658
00:30:05,240 --> 00:30:06,669
for the time being

659
00:30:06,669 --> 00:30:08,499
even though they're deprecated they're

660
00:30:08,499 --> 00:30:11,879
the only thing we can use and in all die

661
00:30:11,879 --> 00:30:16,179
there's also this horrible proprietary

662
00:30:16,179 --> 00:30:21,309
property change event which is kind of

663
00:30:21,309 --> 00:30:23,440
horrible like all Microsoft proprietary

664
00:30:23,440 --> 00:30:26,169
things but sometimes it's the only way

665
00:30:26,169 --> 00:30:28,419
and in polyphenols it's the goal that

666
00:30:28,419 --> 00:30:32,159
counts actually filling in the gap

667
00:30:32,159 --> 00:30:34,480
because eventually it will get removed

668
00:30:34,480 --> 00:30:37,809
polyfills by nature are temporary so

669
00:30:37,809 --> 00:30:41,739
need do what you got to do for example

670
00:30:41,739 --> 00:30:43,570
Paul Backhouse created an amazing

671
00:30:43,570 --> 00:30:46,330
polyfill for CSS transforms and ie and

672
00:30:46,330 --> 00:30:48,639
he used that and that's actually how I

673
00:30:48,639 --> 00:30:50,609
learned about the property change event

674
00:30:50,609 --> 00:30:55,570
she's using that to convert CSS

675
00:30:55,570 --> 00:30:58,269
transitions to the matrix filter than

676
00:30:58,269 --> 00:31:01,929
added ie uses and that allows us to make

677
00:31:01,929 --> 00:31:06,850
CSS poly fills in IE that they can even

678
00:31:06,850 --> 00:31:09,489
respond to changes which is amazing we

679
00:31:09,489 --> 00:31:11,470
can't do that in other browsers CSS poly

680
00:31:11,470 --> 00:31:14,529
fills our pain in the ass but in IE we

681
00:31:14,529 --> 00:31:18,399
can with that thing so about mutation

682
00:31:18,399 --> 00:31:22,779
events an example of a mutation event is

683
00:31:22,779 --> 00:31:25,989
Dom attribute modified and that's one of

684
00:31:25,989 --> 00:31:27,220
the two you are going to use more

685
00:31:27,220 --> 00:31:29,259
frequently it gets fired when an

686
00:31:29,259 --> 00:31:33,509
attribute changes and it we can get the

687
00:31:33,509 --> 00:31:37,359
the old value from it the new value and

688
00:31:37,359 --> 00:31:40,690
the attribute name also mutation events

689
00:31:40,690 --> 00:31:43,779
bubble so we can just register an event

690
00:31:43,779 --> 00:31:48,009
handler in the document and then monitor

691
00:31:48,009 --> 00:31:50,350
all deauxma tribute modified events and

692
00:31:50,350 --> 00:31:52,039
if they're of the

693
00:31:52,039 --> 00:31:54,259
they're of the kind that interests us we

694
00:31:54,259 --> 00:31:56,749
do stuff if not we don't do anything for

695
00:31:56,749 --> 00:31:58,850
example in this case assume this is a

696
00:31:58,850 --> 00:32:02,210
part of a placeholder polyfill it tests

697
00:32:02,210 --> 00:32:04,309
if the node where the attribute got

698
00:32:04,309 --> 00:32:08,269
changed is an input node and then if the

699
00:32:08,269 --> 00:32:09,499
attribute that got changed is a

700
00:32:09,499 --> 00:32:10,970
placeholder attribute because then we

701
00:32:10,970 --> 00:32:12,619
need to update the placeholder or if

702
00:32:12,619 --> 00:32:14,029
it's a value because for example if we

703
00:32:14,029 --> 00:32:15,859
didn't have a valuable now we do we need

704
00:32:15,859 --> 00:32:18,169
to run it we need to make the pole of

705
00:32:18,169 --> 00:32:21,019
the placeholder vanish so if that's the

706
00:32:21,019 --> 00:32:23,570
case we call our function in our

707
00:32:23,570 --> 00:32:25,820
polyfill and we update the node we don't

708
00:32:25,820 --> 00:32:27,590
even need to pass the new and the old

709
00:32:27,590 --> 00:32:29,179
value is in this case because the only

710
00:32:29,179 --> 00:32:34,169
thing we need is the node in this case

711
00:32:34,179 --> 00:32:36,919
the second thing that our polyfill

712
00:32:36,919 --> 00:32:39,109
should try to be responsive is

713
00:32:39,109 --> 00:32:42,259
properties things are a bit better in

714
00:32:42,259 --> 00:32:45,440
this one because we have accessors like

715
00:32:45,440 --> 00:32:46,999
you might have heard the mascaras and

716
00:32:46,999 --> 00:32:51,169
sellers and these are pretty standard we

717
00:32:51,169 --> 00:32:54,009
also have on property change for old IE

718
00:32:54,009 --> 00:32:56,539
since i since all die he treats

719
00:32:56,539 --> 00:32:58,580
properties as attributes that event

720
00:32:58,580 --> 00:33:01,489
works in both and if your polyfill is

721
00:33:01,489 --> 00:33:05,239
only to fill in firefox specific

722
00:33:05,239 --> 00:33:07,129
functionality then you also have this

723
00:33:07,129 --> 00:33:11,539
amazing a method that supported only in

724
00:33:11,539 --> 00:33:14,149
mosul it's its proprietary but it's so

725
00:33:14,149 --> 00:33:16,129
amazing I think I think it should be

726
00:33:16,129 --> 00:33:18,259
added to the spec and everybody every

727
00:33:18,259 --> 00:33:20,470
browser should implement it instead of

728
00:33:20,470 --> 00:33:22,970
accessors make you replace the property

729
00:33:22,970 --> 00:33:25,340
with an accessor get a getter in the

730
00:33:25,340 --> 00:33:27,830
cellar just one of the two object watch

731
00:33:27,830 --> 00:33:29,659
doesn't replace the property it just

732
00:33:29,659 --> 00:33:32,629
watches it and it fires a call back when

733
00:33:32,629 --> 00:33:34,519
it actually changes which is exactly

734
00:33:34,519 --> 00:33:37,669
what we want in polyfills we don't

735
00:33:37,669 --> 00:33:39,950
really want to replace the property it's

736
00:33:39,950 --> 00:33:42,499
a hack but it's the only thing we have

737
00:33:42,499 --> 00:33:45,190
we actually just want to monitor changes

738
00:33:45,190 --> 00:33:47,899
watch changes and have something that's

739
00:33:47,899 --> 00:33:49,970
the equivalent of an event when the

740
00:33:49,970 --> 00:33:51,830
property when the property gets changed

741
00:33:51,830 --> 00:33:54,529
and that's the object watch is exactly

742
00:33:54,529 --> 00:33:58,039
what we want but it's only five for

743
00:33:58,039 --> 00:33:59,920
Firefox so

744
00:33:59,920 --> 00:34:04,150
focus a bit on accessors the standard

745
00:34:04,150 --> 00:34:06,400
syntax is the one presented here we use

746
00:34:06,400 --> 00:34:08,350
the Defiant property method in the

747
00:34:08,350 --> 00:34:11,130
object echoed in the object constructor

748
00:34:11,130 --> 00:34:14,320
as you probably know all the newegg

749
00:34:14,320 --> 00:34:16,540
mcrypt five functions and objects are

750
00:34:16,540 --> 00:34:18,220
just added on the object constructor

751
00:34:18,220 --> 00:34:20,230
instead of specific instances even

752
00:34:20,230 --> 00:34:22,840
though it would be more convenient so

753
00:34:22,840 --> 00:34:23,980
that they don't break backwards

754
00:34:23,980 --> 00:34:26,919
compatibility with when we make pony

755
00:34:26,919 --> 00:34:30,010
fills for them so we have the fine

756
00:34:30,010 --> 00:34:32,760
property it except get in the set

757
00:34:32,760 --> 00:34:37,540
property end up in the parameter and we

758
00:34:37,540 --> 00:34:40,000
make some callbacks for them which get

759
00:34:40,000 --> 00:34:42,880
fired when somebody attempts to set that

760
00:34:42,880 --> 00:34:46,000
property so this property is essentially

761
00:34:46,000 --> 00:34:48,610
functions like a property but actually

762
00:34:48,610 --> 00:34:52,210
it's more like a function for example in

763
00:34:52,210 --> 00:34:54,550
this case we define a getter and setter

764
00:34:54,550 --> 00:34:58,600
for a placeholder so when somebody tries

765
00:34:58,600 --> 00:35:04,060
to to get the placeholder value through

766
00:35:04,060 --> 00:35:06,520
together we actually invoke this

767
00:35:06,520 --> 00:35:08,590
function and return the attribute value

768
00:35:08,590 --> 00:35:10,900
because it's the same in this case in

769
00:35:10,900 --> 00:35:12,460
some other cases you might want to do

770
00:35:12,460 --> 00:35:14,260
some math because the Gator should

771
00:35:14,260 --> 00:35:16,180
return a number and they attribute

772
00:35:16,180 --> 00:35:18,220
always return strings but in this case

773
00:35:18,220 --> 00:35:21,070
it's the same and when it said we invoke

774
00:35:21,070 --> 00:35:23,110
a function of our polyfill that updates

775
00:35:23,110 --> 00:35:26,920
the the placeholder and also to match

776
00:35:26,920 --> 00:35:29,260
the native implementation of placeholder

777
00:35:29,260 --> 00:35:32,230
we make this accessor numerable and

778
00:35:32,230 --> 00:35:33,700
configurable which essentially means

779
00:35:33,700 --> 00:35:37,690
that a numeral is that when people use

780
00:35:37,690 --> 00:35:39,970
this object on foreign loops it will be

781
00:35:39,970 --> 00:35:43,150
present unlike some other properties

782
00:35:43,150 --> 00:35:45,640
that don't get enumerated and

783
00:35:45,640 --> 00:35:48,160
configurable means that we should be

784
00:35:48,160 --> 00:35:50,380
able to replace it with something else

785
00:35:50,380 --> 00:35:52,090
if we don't want these accessories

786
00:35:52,090 --> 00:35:55,660
anymore we I kind of disagree with it

787
00:35:55,660 --> 00:35:57,130
being configurable but that's how the

788
00:35:57,130 --> 00:35:59,980
native implementation works and like we

789
00:35:59,980 --> 00:36:00,560
said

790
00:36:00,560 --> 00:36:02,660
should follow the spec you shouldn't

791
00:36:02,660 --> 00:36:05,780
break expectations so this standard

792
00:36:05,780 --> 00:36:09,250
syntax of accesses is supported by I ate

793
00:36:09,250 --> 00:36:13,310
Firefox for pros safari 45 and opera 12

794
00:36:13,310 --> 00:36:17,330
and of course browses after those so

795
00:36:17,330 --> 00:36:18,740
what can we do with all the browsers

796
00:36:18,740 --> 00:36:20,840
some of them are really up for 12 isn't

797
00:36:20,840 --> 00:36:24,500
even released yet and some of them are

798
00:36:24,500 --> 00:36:26,450
quite recent like safari five is still

799
00:36:26,450 --> 00:36:29,960
kind of recent there is an older syntax

800
00:36:29,960 --> 00:36:32,870
for getters and setters which works in

801
00:36:32,870 --> 00:36:35,450
many more browsers in many older

802
00:36:35,450 --> 00:36:38,120
browsers this was before akma script

803
00:36:38,120 --> 00:36:39,860
five was published it was the first

804
00:36:39,860 --> 00:36:43,100
syntax we had and I'm so glad we didn't

805
00:36:43,100 --> 00:36:46,730
actually do that and the ACMA script

806
00:36:46,730 --> 00:36:51,130
five ways so much better this actually

807
00:36:51,130 --> 00:36:53,690
only allows us to set a getter and

808
00:36:53,690 --> 00:36:56,930
setter we can't set we can't control

809
00:36:56,930 --> 00:36:59,180
whether its innumerable or whether it's

810
00:36:59,180 --> 00:37:01,550
configurable or anything but in this

811
00:37:01,550 --> 00:37:04,400
case it does what we want and it's a

812
00:37:04,400 --> 00:37:07,610
good fallback if you don't want to have

813
00:37:07,610 --> 00:37:10,040
to deal with conditionals about whether

814
00:37:10,040 --> 00:37:12,790
it is defined property supported is

815
00:37:12,790 --> 00:37:15,680
defined get are supported there's this

816
00:37:15,680 --> 00:37:18,800
nice polyfill by Ellie gray which

817
00:37:18,800 --> 00:37:20,960
combines them so you can actually use

818
00:37:20,960 --> 00:37:24,590
object defined property and it will work

819
00:37:24,590 --> 00:37:26,360
even in those that don't support it and

820
00:37:26,360 --> 00:37:30,830
only support that kind of getters so you

821
00:37:30,830 --> 00:37:32,420
actually can use a poly fill in your

822
00:37:32,420 --> 00:37:38,420
polyfill that's so meta a problem with

823
00:37:38,420 --> 00:37:40,580
ie8 is that even though it supports

824
00:37:40,580 --> 00:37:44,150
believe either the support successors it

825
00:37:44,150 --> 00:37:48,200
only supports them on Dom elements so if

826
00:37:48,200 --> 00:37:50,420
you're if you need to do something else

827
00:37:50,420 --> 00:37:52,310
that's not related with Dom elements

828
00:37:52,310 --> 00:37:55,370
you're kind of screwed and also if that

829
00:37:55,370 --> 00:37:59,630
wasn't enough old ie thinks that

830
00:37:59,630 --> 00:38:02,420
properties and attributes are the same

831
00:38:02,420 --> 00:38:06,410
so essentially let's remember the the

832
00:38:06,410 --> 00:38:09,020
case I showed before when the

833
00:38:09,020 --> 00:38:11,900
placeholder property gets when when you

834
00:38:11,900 --> 00:38:13,520
try somebody tries to read the

835
00:38:13,520 --> 00:38:15,530
placeholder property we call get

836
00:38:15,530 --> 00:38:17,119
attribute and wear it and the attribute

837
00:38:17,119 --> 00:38:19,609
but what if the placehold what if the

838
00:38:19,609 --> 00:38:21,260
placeholder attribute is essentially the

839
00:38:21,260 --> 00:38:23,030
same as a placeholder property like what

840
00:38:23,030 --> 00:38:25,549
all the ethics we try to read the

841
00:38:25,549 --> 00:38:28,280
placeholder property so we try to read

842
00:38:28,280 --> 00:38:29,630
the place from the property because

843
00:38:29,630 --> 00:38:31,339
attributes and properties are the same

844
00:38:31,339 --> 00:38:33,799
for all day so what does this gives us

845
00:38:33,799 --> 00:38:36,819
give us it gives us infinite recursion

846
00:38:36,819 --> 00:38:41,869
it so it's not horrible it will act we

847
00:38:41,869 --> 00:38:43,790
will actually make a script that's

848
00:38:43,790 --> 00:38:47,240
really slow and it will return in a

849
00:38:47,240 --> 00:38:53,630
stack overflow also ie8 has this other

850
00:38:53,630 --> 00:38:57,020
problem with define property if you try

851
00:38:57,020 --> 00:39:00,530
to use a numerable true it will throw an

852
00:39:00,530 --> 00:39:02,530
error which you can catch with this

853
00:39:02,530 --> 00:39:07,280
weird code and just the solution to that

854
00:39:07,280 --> 00:39:10,130
is just to try to apply the accessor

855
00:39:10,130 --> 00:39:12,950
again without the innumerable true just

856
00:39:12,950 --> 00:39:20,130
set innumerable to false and try again

857
00:39:20,140 --> 00:39:24,440
also the third thing we said is that new

858
00:39:24,440 --> 00:39:26,510
elements might get added for example

859
00:39:26,510 --> 00:39:30,859
through ajax through some script so it's

860
00:39:30,859 --> 00:39:32,839
best if our polyfill doesn't break with

861
00:39:32,839 --> 00:39:35,660
them and it's kind of simple to account

862
00:39:35,660 --> 00:39:40,670
for them if we're modifying elements

863
00:39:40,670 --> 00:39:42,380
that are already supported we can just

864
00:39:42,380 --> 00:39:45,530
add the message to the corresponding

865
00:39:45,530 --> 00:39:49,309
prototype it you might you probably have

866
00:39:49,309 --> 00:39:51,230
heard that modifying host objects is

867
00:39:51,230 --> 00:39:55,010
evil but in this case you're not adding

868
00:39:55,010 --> 00:39:56,720
property you're not adding functions

869
00:39:56,720 --> 00:39:58,099
that were there you

870
00:39:58,099 --> 00:39:59,599
running functions that should be there

871
00:39:59,599 --> 00:40:02,809
and everyone if no matter how passionate

872
00:40:02,809 --> 00:40:04,940
they are about not modifying host

873
00:40:04,940 --> 00:40:07,249
objects everyone agrees that this is a

874
00:40:07,249 --> 00:40:12,140
legit case of doing that so you can even

875
00:40:12,140 --> 00:40:13,940
add a method to the element prototype

876
00:40:13,940 --> 00:40:15,979
which is for every element or two

877
00:40:15,979 --> 00:40:18,559
specific prototypes for example HTML

878
00:40:18,559 --> 00:40:22,099
input element so in that case it will be

879
00:40:22,099 --> 00:40:24,200
automatically in every new instance but

880
00:40:24,200 --> 00:40:25,819
if you can't do that for example if

881
00:40:25,819 --> 00:40:28,160
you're making a polyfill for a new html5

882
00:40:28,160 --> 00:40:29,809
element that doesn't have an interface

883
00:40:29,809 --> 00:40:32,210
in browsers that don't support it you

884
00:40:32,210 --> 00:40:34,369
can you should use the the Dom node

885
00:40:34,369 --> 00:40:37,489
inserted mutation event so that you do

886
00:40:37,489 --> 00:40:41,029
stuff when an element gets added that of

887
00:40:41,029 --> 00:40:44,059
the type we're interested in of course

888
00:40:44,059 --> 00:40:46,249
that bubbles too so we can follow the

889
00:40:46,249 --> 00:40:48,440
same approach as we did for DOMA tribute

890
00:40:48,440 --> 00:40:51,950
modified we just register a general

891
00:40:51,950 --> 00:40:53,839
hunger and we check if we're actually

892
00:40:53,839 --> 00:40:56,989
interested in that in that particular

893
00:40:56,989 --> 00:41:02,329
element that was added also another

894
00:41:02,329 --> 00:41:03,940
thing you should keep in mind is

895
00:41:03,940 --> 00:41:07,309
minimizing dependencies for example

896
00:41:07,309 --> 00:41:09,589
libraries like jQuery might do your job

897
00:41:09,589 --> 00:41:12,079
quite easy they might make your code a

898
00:41:12,079 --> 00:41:14,869
bit smaller but when you're making a

899
00:41:14,869 --> 00:41:17,569
polyfill that requires jQuery you're

900
00:41:17,569 --> 00:41:19,460
actually requiring that everyone who

901
00:41:19,460 --> 00:41:21,859
uses your polyfill also includes a

902
00:41:21,859 --> 00:41:24,890
library that's like so many kilobytes of

903
00:41:24,890 --> 00:41:26,719
code especially if it's not getting it

904
00:41:26,719 --> 00:41:30,049
so just to add a small feature some

905
00:41:30,049 --> 00:41:31,700
people will have to include a whole

906
00:41:31,700 --> 00:41:33,259
library if they're not using it already

907
00:41:33,259 --> 00:41:36,680
and especially in polyfills people want

908
00:41:36,680 --> 00:41:39,559
to use these latest these these new

909
00:41:39,559 --> 00:41:42,410
features so that they break free from

910
00:41:42,410 --> 00:41:47,779
libraries so you should you should try

911
00:41:47,779 --> 00:41:50,989
to avoid it as much as possible unless

912
00:41:50,989 --> 00:41:53,059
it really makes your job easier unless

913
00:41:53,059 --> 00:41:55,039
your code your polyfill becomes ten

914
00:41:55,039 --> 00:41:57,739
lines instead of 50 lights but if it's

915
00:41:57,739 --> 00:41:59,540
like a difference like for example

916
00:41:59,540 --> 00:42:02,660
well it fills it use jQuery that were

917
00:42:02,660 --> 00:42:05,150
like 40 lines with jquery and there were

918
00:42:05,150 --> 00:42:08,030
like fifty five without jquery is that

919
00:42:08,030 --> 00:42:16,280
really worth it also when you're making

920
00:42:16,280 --> 00:42:18,220
a polyfill you might be tempted to

921
00:42:18,220 --> 00:42:21,140
support every possible browser to

922
00:42:21,140 --> 00:42:26,750
support IE 697 and because you want

923
00:42:26,750 --> 00:42:28,400
people to use it and even in big

924
00:42:28,400 --> 00:42:30,740
projects that require a compatibility

925
00:42:30,740 --> 00:42:33,230
with my very old browsers but sometimes

926
00:42:33,230 --> 00:42:37,340
this makes your code huge and it's not

927
00:42:37,340 --> 00:42:40,270
really needed to be that huge for and

928
00:42:40,270 --> 00:42:42,440
sometimes you should you can use the

929
00:42:42,440 --> 00:42:44,810
internal methods that a browser can have

930
00:42:44,810 --> 00:42:46,550
and take advantage of them and do what

931
00:42:46,550 --> 00:42:50,510
you want for example how many of you

932
00:42:50,510 --> 00:42:52,760
have cared about much media and what it

933
00:42:52,760 --> 00:43:00,170
does what much media is a function it's

934
00:43:00,170 --> 00:43:02,630
a global function and it tests whether a

935
00:43:02,630 --> 00:43:05,410
document much as a certain media query

936
00:43:05,410 --> 00:43:09,260
so some browsers already supported

937
00:43:09,260 --> 00:43:13,130
supported and we decided to make a

938
00:43:13,130 --> 00:43:15,680
polyfill for those that don't so how

939
00:43:15,680 --> 00:43:18,650
would you go with that polyfill most

940
00:43:18,650 --> 00:43:20,510
people would probably try to parse the

941
00:43:20,510 --> 00:43:23,090
media query expression and then check

942
00:43:23,090 --> 00:43:25,820
every condition separately to see if it

943
00:43:25,820 --> 00:43:28,370
actually matches but we don't need to do

944
00:43:28,370 --> 00:43:30,710
that it could be much smaller but just

945
00:43:30,710 --> 00:43:32,420
taking advantage of what the browser

946
00:43:32,420 --> 00:43:35,060
does with media queries because the

947
00:43:35,060 --> 00:43:36,650
browser already has this functionality

948
00:43:36,650 --> 00:43:39,670
built in so let's see how Paul Irish

949
00:43:39,670 --> 00:43:43,340
tackled this problem he creates a new

950
00:43:43,340 --> 00:43:46,850
element a new dev set some types and

951
00:43:46,850 --> 00:43:49,250
styles and an ID that's unlikely to

952
00:43:49,250 --> 00:43:53,060
collide with another ID and then it adds

953
00:43:53,060 --> 00:43:57,019
a style element with a media query and

954
00:43:57,019 --> 00:43:59,809
that div style elements can be anywhere

955
00:43:59,809 --> 00:44:01,849
so they don't have to be in the head

956
00:44:01,849 --> 00:44:03,289
they can be anywhere in the document so

957
00:44:03,289 --> 00:44:05,419
that's pretty valid and it works and

958
00:44:05,419 --> 00:44:08,899
then it depends that element to the to

959
00:44:08,899 --> 00:44:14,199
the body so let's think a bit about that

960
00:44:14,199 --> 00:44:17,119
that's that has a media query and it

961
00:44:17,119 --> 00:44:20,029
gives that L that Dave it went for 42

962
00:44:20,029 --> 00:44:23,329
pixels what does that mean that if the

963
00:44:23,329 --> 00:44:25,249
media query matches the document that

964
00:44:25,249 --> 00:44:28,369
Dave will have a width of 42 pixels if

965
00:44:28,369 --> 00:44:31,939
it doesn't it will have another width so

966
00:44:31,939 --> 00:44:35,089
now to check if luck media query applies

967
00:44:35,089 --> 00:44:37,459
to this document we only need to check

968
00:44:37,459 --> 00:44:39,559
if the opposite width of the tip of the

969
00:44:39,559 --> 00:44:43,039
dev is 42 so we actually took advantage

970
00:44:43,039 --> 00:44:45,259
of the of the built-in browser

971
00:44:45,259 --> 00:44:48,789
capabilities for checking media queries

972
00:44:48,789 --> 00:44:53,779
and we didn't need to pass anything so

973
00:44:53,779 --> 00:44:56,809
after we get that value we clean up

974
00:44:56,809 --> 00:44:58,579
after ourselves remove that deer from

975
00:44:58,579 --> 00:45:00,649
the body and we return the result and

976
00:45:00,649 --> 00:45:03,130
because the spec is kind of weird and it

977
00:45:03,130 --> 00:45:06,349
requires us to return an object even

978
00:45:06,349 --> 00:45:08,739
though it might seem stupid and

979
00:45:08,739 --> 00:45:10,789
personally I don't agree with that much

980
00:45:10,789 --> 00:45:13,369
we have to follow the spec and return an

981
00:45:13,369 --> 00:45:16,939
object Leroy like it's required with the

982
00:45:16,939 --> 00:45:22,829
result and the media query passed

983
00:45:22,839 --> 00:45:27,409
another example of taking advantage of

984
00:45:27,409 --> 00:45:29,869
the browser capabilities is trying to

985
00:45:29,869 --> 00:45:33,319
implement outer HTML other HTML used to

986
00:45:33,319 --> 00:45:35,809
be a Microsoft proprietary thing but

987
00:45:35,809 --> 00:45:38,509
it's now in the html5 spec and

988
00:45:38,509 --> 00:45:40,039
eventually all browsers will implement

989
00:45:40,039 --> 00:45:47,269
it if they all don't already so some

990
00:45:47,269 --> 00:45:50,299
people might actually try to parse the

991
00:45:50,299 --> 00:45:52,519
the outer HTML do something with that or

992
00:45:52,519 --> 00:45:54,559
extract the innerhtml portion and then

993
00:45:54,559 --> 00:45:58,240
parse parse the the the talent portion

994
00:45:58,240 --> 00:45:59,350
something like that but it's actually

995
00:45:59,350 --> 00:46:06,610
much easier you first check if it's an

996
00:46:06,610 --> 00:46:08,890
XML document by tracking the xml version

997
00:46:08,890 --> 00:46:12,280
property of the document yeah that

998
00:46:12,280 --> 00:46:16,090
should be document not doc and if it's

999
00:46:16,090 --> 00:46:17,830
an XML document we can't use inner HTML

1000
00:46:17,830 --> 00:46:20,290
or anything like that so we invoke the

1001
00:46:20,290 --> 00:46:22,720
xmlserializer and we're turn we see

1002
00:46:22,720 --> 00:46:26,050
realize that node if it's not an HTML

1003
00:46:26,050 --> 00:46:27,640
and XML document which is the most

1004
00:46:27,640 --> 00:46:30,940
common case we create a new element that

1005
00:46:30,940 --> 00:46:32,740
we won't actually need but it will help

1006
00:46:32,740 --> 00:46:37,570
us in this case and we append we close

1007
00:46:37,570 --> 00:46:40,630
this the node we care about getting its

1008
00:46:40,630 --> 00:46:45,100
outer HTML we pass the false parameters

1009
00:46:45,100 --> 00:46:46,930
so that we don't clone the contents as

1010
00:46:46,930 --> 00:46:48,610
well because think about it we don't

1011
00:46:48,610 --> 00:46:52,420
need to pass through to to get the outer

1012
00:46:52,420 --> 00:46:54,430
HTML codes we just we can just get

1013
00:46:54,430 --> 00:46:56,770
enraged mo from that node from the

1014
00:46:56,770 --> 00:46:59,020
original notes so the only thing we care

1015
00:46:59,020 --> 00:47:01,450
about is getting the HTML for the outer

1016
00:47:01,450 --> 00:47:04,450
tag so we just apply it to that dummy

1017
00:47:04,450 --> 00:47:09,280
element then we replace we get the inner

1018
00:47:09,280 --> 00:47:12,930
HTML of the new element we replace those

1019
00:47:12,930 --> 00:47:16,210
that thing at in the middle and we had

1020
00:47:16,210 --> 00:47:19,450
enriched EML then the inner HTML of the

1021
00:47:19,450 --> 00:47:21,910
new element is what we want it's the

1022
00:47:21,910 --> 00:47:24,760
outer HTML that we wanted we didn't need

1023
00:47:24,760 --> 00:47:28,869
to do any parsing we just used the

1024
00:47:28,869 --> 00:47:33,609
browser capabilities also this is

1025
00:47:33,609 --> 00:47:34,930
sometimes an afterthought but it

1026
00:47:34,930 --> 00:47:37,420
shouldn't be if you're making an HTML

1027
00:47:37,420 --> 00:47:39,460
polyfill you shouldn't you should keep

1028
00:47:39,460 --> 00:47:41,800
accessibility in mind because native

1029
00:47:41,800 --> 00:47:46,030
elements have built-in area roles or

1030
00:47:46,030 --> 00:47:48,760
they can be focusable sometimes when the

1031
00:47:48,760 --> 00:47:51,030
spec says they should be focused ball or

1032
00:47:51,030 --> 00:47:53,410
they support some certain keyboard

1033
00:47:53,410 --> 00:47:54,470
shortcuts like

1034
00:47:54,470 --> 00:47:57,680
simplest as la- slider supports being

1035
00:47:57,680 --> 00:48:02,840
adjusted by the arrow keys but so if

1036
00:48:02,840 --> 00:48:04,250
you're actually implementing a slider

1037
00:48:04,250 --> 00:48:07,550
yourself you should try to fake these

1038
00:48:07,550 --> 00:48:09,200
things to you should make it focusable

1039
00:48:09,200 --> 00:48:12,260
by tabindex0 you should add some area

1040
00:48:12,260 --> 00:48:15,920
rolls yourself and some area attributes

1041
00:48:15,920 --> 00:48:17,660
and you should support these keyboard

1042
00:48:17,660 --> 00:48:20,410
shortcuts I've seen so many sliders that

1043
00:48:20,410 --> 00:48:22,849
can't be adjusted with the keyboard it's

1044
00:48:22,849 --> 00:48:24,200
so annoying it's not even for people

1045
00:48:24,200 --> 00:48:26,480
with disabilities everyone uses the

1046
00:48:26,480 --> 00:48:33,530
keyboard also like I said before CSS

1047
00:48:33,530 --> 00:48:35,770
poly fields are big pain in the ass if

1048
00:48:35,770 --> 00:48:38,300
if you're planning to start writing

1049
00:48:38,300 --> 00:48:41,080
polyfills don't start from CSS

1050
00:48:41,080 --> 00:48:44,090
everything is hard with them parsing is

1051
00:48:44,090 --> 00:48:45,680
hard because we need to parse the whole

1052
00:48:45,680 --> 00:48:48,890
thing because if you try to go through

1053
00:48:48,890 --> 00:48:51,080
the CSS object model the browser will

1054
00:48:51,080 --> 00:48:54,400
drop stuff it doesn't understand so

1055
00:48:54,400 --> 00:48:56,570
there's no point in doing that you

1056
00:48:56,570 --> 00:48:59,900
actually have to parse the whole CSS

1057
00:48:59,900 --> 00:49:02,780
style sheet also implementation is hard

1058
00:49:02,780 --> 00:49:05,210
at least implementations done

1059
00:49:05,210 --> 00:49:08,030
unobtrusively we all almost always have

1060
00:49:08,030 --> 00:49:10,190
to add extra elements and extra stuff

1061
00:49:10,190 --> 00:49:12,710
and it's always so intrusive and

1062
00:49:12,710 --> 00:49:14,780
reacting to changes is practically

1063
00:49:14,780 --> 00:49:17,119
impossible I mean I has this property

1064
00:49:17,119 --> 00:49:20,030
change event but other browsers don't so

1065
00:49:20,030 --> 00:49:22,760
we can't do anything about it they're

1066
00:49:22,760 --> 00:49:24,880
really hard and that's why we don't have

1067
00:49:24,880 --> 00:49:29,150
almost any CSS polyfills most of them

1068
00:49:29,150 --> 00:49:31,070
are just API rappers like i said before

1069
00:49:31,070 --> 00:49:32,720
like functions that you call to do

1070
00:49:32,720 --> 00:49:34,400
something but that's not really a

1071
00:49:34,400 --> 00:49:38,869
polyfill so after you've done you're

1072
00:49:38,869 --> 00:49:42,349
done with the creative part there comes

1073
00:49:42,349 --> 00:49:45,080
the distribution part because you might

1074
00:49:45,080 --> 00:49:48,200
be satisfied with your clever code but

1075
00:49:48,200 --> 00:49:50,660
you actually have to let other people

1076
00:49:50,660 --> 00:49:53,029
know and use it and help lacombe you

1077
00:49:53,029 --> 00:49:56,989
like like it helps you so the first part

1078
00:49:56,989 --> 00:50:00,259
is making a min ified version of your

1079
00:50:00,259 --> 00:50:04,159
script because people will actually end

1080
00:50:04,159 --> 00:50:05,900
up using that but you also have to

1081
00:50:05,900 --> 00:50:07,789
include the original version so that

1082
00:50:07,789 --> 00:50:10,009
people can study it and see what you did

1083
00:50:10,009 --> 00:50:13,130
how you didn't learn from you but you

1084
00:50:13,130 --> 00:50:14,599
should also include a mini fide version

1085
00:50:14,599 --> 00:50:17,390
to be used for production then upload it

1086
00:50:17,390 --> 00:50:20,630
to get them it's like the commonplace

1087
00:50:20,630 --> 00:50:23,959
these days for open source code and the

1088
00:50:23,959 --> 00:50:26,119
last step but one of the most important

1089
00:50:26,119 --> 00:50:28,579
is to add it to the polyfills list I

1090
00:50:28,579 --> 00:50:30,650
think this is the most official poly

1091
00:50:30,650 --> 00:50:32,569
fields list we currently have it's not

1092
00:50:32,569 --> 00:50:34,939
perfect it's just the list in the github

1093
00:50:34,939 --> 00:50:37,400
wiki and we should definitely do better

1094
00:50:37,400 --> 00:50:39,919
we need the poly fuels database of some

1095
00:50:39,919 --> 00:50:41,839
sort but currently this is the most

1096
00:50:41,839 --> 00:50:44,839
complete thing we have so you can just

1097
00:50:44,839 --> 00:50:47,539
edit this it's a wiki you owe everyone

1098
00:50:47,539 --> 00:50:51,419
can edit it and add your polyfill there

1099
00:50:51,429 --> 00:50:55,519
so now that this talk is nearing to its

1100
00:50:55,519 --> 00:50:57,880
end let's talk a bit about the people

1101
00:50:57,880 --> 00:51:01,239
that have helped a lot in this field

1102
00:51:01,239 --> 00:51:04,189
first of all Remy Sharpe is the guy who

1103
00:51:04,189 --> 00:51:06,380
actually thought of the word polyfill

1104
00:51:06,380 --> 00:51:09,499
and he's written many good polyfills

1105
00:51:09,499 --> 00:51:11,589
that are the people actually used today

1106
00:51:11,589 --> 00:51:15,229
also purple irises were written loads of

1107
00:51:15,229 --> 00:51:17,239
polyfills and he also maintains this

1108
00:51:17,239 --> 00:51:19,329
list of polyfills that i showed before

1109
00:51:19,329 --> 00:51:24,380
and i really admire le gray too he is

1110
00:51:24,380 --> 00:51:27,589
very young but he's really talented he's

1111
00:51:27,589 --> 00:51:30,439
written so many polyfills and his

1112
00:51:30,439 --> 00:51:32,959
polyfills are always amazing they

1113
00:51:32,959 --> 00:51:35,479
they're the least buggy poly fields i've

1114
00:51:35,479 --> 00:51:37,669
ever seen and he knows all these things

1115
00:51:37,669 --> 00:51:39,650
about the inner workings of browsers

1116
00:51:39,650 --> 00:51:42,709
that's like crazy but it's not just

1117
00:51:42,709 --> 00:51:46,130
these guys there are so many people that

1118
00:51:46,130 --> 00:51:49,669
have helped by creating a polyfill are

1119
00:51:49,669 --> 00:51:51,769
improving an existing polyfill this list

1120
00:51:51,769 --> 00:51:54,709
is by no means exhaustive there are so

1121
00:51:54,709 --> 00:51:57,849
many more people and these people have

1122
00:51:57,849 --> 00:51:59,510
spent their time

1123
00:51:59,510 --> 00:52:03,260
and energy just to help all of you just

1124
00:52:03,260 --> 00:52:05,450
to help the community I think they

1125
00:52:05,450 --> 00:52:15,960
deserve a loud club for that

1126
00:52:15,970 --> 00:52:20,120
and you can be you can also do that you

1127
00:52:20,120 --> 00:52:22,580
can also help the community like legatus

1128
00:52:22,580 --> 00:52:26,870
calc you while developing something you

1129
00:52:26,870 --> 00:52:28,970
can write something you can write a

1130
00:52:28,970 --> 00:52:32,120
polyfill or help in by writing a feature

1131
00:52:32,120 --> 00:52:34,610
detection test for something that's

1132
00:52:34,610 --> 00:52:37,400
considered undetectable you can really

1133
00:52:37,400 --> 00:52:40,160
make a difference and that won't really

1134
00:52:40,160 --> 00:52:42,500
help yours it will really help yourself

1135
00:52:42,500 --> 00:52:45,020
and your day to day development and will

1136
00:52:45,020 --> 00:52:47,120
make your code more future proof but it

1137
00:52:47,120 --> 00:52:50,780
will also help everyone so go ahead and

