1
00:00:09,320 --> 00:00:13,040

so how many of y'all were at Jess comp

2
00:00:13,040 --> 00:00:16,170
okay so most of you may or may not have

3
00:00:16,170 --> 00:00:17,580
taken the opportunity to see the closing

4
00:00:17,580 --> 00:00:19,529
talk in which we announced tracer which

5
00:00:19,529 --> 00:00:21,090
is a JavaScript of JavaScript compiler

6
00:00:21,090 --> 00:00:24,090
written in JavaScript there are many

7
00:00:24,090 --> 00:00:27,000
like it this one is different no it's

8
00:00:27,000 --> 00:00:29,010
different because it's not just only

9
00:00:29,010 --> 00:00:30,060
because it's written in JavaScript but

10
00:00:30,060 --> 00:00:31,890
because the source language that it

11
00:00:31,890 --> 00:00:36,300
consumes is some variant of what we hope

12
00:00:36,300 --> 00:00:38,219
will be a set of features that are in

13
00:00:38,219 --> 00:00:41,520
the next version of Java Script so it's

14
00:00:41,520 --> 00:00:44,489
JavaScript of the future more or less to

15
00:00:44,489 --> 00:00:47,460
JavaScript of today strictly speaking

16
00:00:47,460 --> 00:00:50,399
es5 so browsers that running is 5 or

17
00:00:50,399 --> 00:00:51,989
environments of running s5 like node can

18
00:00:51,989 --> 00:00:54,840
take advantage of this and so we all the

19
00:00:54,840 --> 00:00:59,489
demos we did for JS conf demo tracer in

20
00:00:59,489 --> 00:01:02,250
the browser but tracer absolutely works

21
00:01:02,250 --> 00:01:04,500
on the on node in fact we have a batch

22
00:01:04,500 --> 00:01:07,979
mode that relies on node uses v8 to go

23
00:01:07,979 --> 00:01:10,049
and automatically generate code for you

24
00:01:10,049 --> 00:01:12,900
so you can run it to batch content that

25
00:01:12,900 --> 00:01:14,390
you'd like to serve to the client

26
00:01:14,390 --> 00:01:17,369
written in the future version or you can

27
00:01:17,369 --> 00:01:20,640
run it online inside of node to make it

28
00:01:20,640 --> 00:01:23,400
make it go so but today's talk is sort

29
00:01:23,400 --> 00:01:29,009
of not just about what it is and what it

30
00:01:29,009 --> 00:01:31,860
does for you but rather we want to sort

31
00:01:31,860 --> 00:01:33,479
of peel back the layers a little bit and

32
00:01:33,479 --> 00:01:36,560
show you kind of how it works because

33
00:01:36,560 --> 00:01:39,270
fundamentally tracer is not about like

34
00:01:39,270 --> 00:01:40,710
hey look everybody here's a great tool

35
00:01:40,710 --> 00:01:43,020
for you to use it's a it's a tool that's

36
00:01:43,020 --> 00:01:45,509
got an expiration date on and that

37
00:01:45,509 --> 00:01:47,100
expiration date is when the language

38
00:01:47,100 --> 00:01:49,140
gets much more awesome you won't need it

39
00:01:49,140 --> 00:01:51,119
right because you're working a note on

40
00:01:51,119 --> 00:01:53,310
the server your environments moving a

41
00:01:53,310 --> 00:01:54,329
lot faster than the client-side

42
00:01:54,329 --> 00:01:55,920
environment is you get to choose your

43
00:01:55,920 --> 00:01:57,600
version of VA right you get to choose

44
00:01:57,600 --> 00:01:59,939
your version of the language and as soon

45
00:01:59,939 --> 00:02:01,649
as v8 get stuff or as soon as you decide

46
00:02:01,649 --> 00:02:04,040
to change your deployment environment

47
00:02:04,040 --> 00:02:06,119
you get all of the advantages of

48
00:02:06,119 --> 00:02:07,619
everything you've just dumped into your

49
00:02:07,619 --> 00:02:09,690
world which you don't get on the client

50
00:02:09,690 --> 00:02:11,370
and the client side you're at the mercy

51
00:02:11,370 --> 00:02:13,450
of whatever your your

52
00:02:13,450 --> 00:02:15,730
users happen to have deployed and

53
00:02:15,730 --> 00:02:17,020
they're going to move relatively slowly

54
00:02:17,020 --> 00:02:18,610
compared to your server site environment

55
00:02:18,610 --> 00:02:20,709
which is why I think there's this large

56
00:02:20,709 --> 00:02:23,440
and growing population of alternative

57
00:02:23,440 --> 00:02:24,760
languages for server-side development

58
00:02:24,760 --> 00:02:27,900
including JavaScript thank goodness so

59
00:02:27,900 --> 00:02:30,370
because they're the economics and the

60
00:02:30,370 --> 00:02:31,900
and the constraints of the of the client

61
00:02:31,900 --> 00:02:33,489
side are different than the server side

62
00:02:33,489 --> 00:02:36,220
we can use that to help move faster on

63
00:02:36,220 --> 00:02:37,750
the server and so this is the community

64
00:02:37,750 --> 00:02:38,769
that's going to be able to try out this

65
00:02:38,769 --> 00:02:41,860
new stuff faster use it first stretch

66
00:02:41,860 --> 00:02:43,840
its legs and provide this sort of

67
00:02:43,840 --> 00:02:45,220
detailed feedback we absolutely need to

68
00:02:45,220 --> 00:02:46,150
make sure that the next original

69
00:02:46,150 --> 00:02:48,310
language has all of the right stuff in

70
00:02:48,310 --> 00:02:50,319
it and none of the stuff that we think

71
00:02:50,319 --> 00:02:54,299
is buggy so harmony is pretty awesome so

72
00:02:54,299 --> 00:02:56,980
the stuff that's already on the slated

73
00:02:56,980 --> 00:02:59,500
for the proposals list for harmony gives

74
00:02:59,500 --> 00:03:03,730
us modules it gives us proxies proxies

75
00:03:03,730 --> 00:03:05,560
are amazing if you've used node proxy

76
00:03:05,560 --> 00:03:08,920
you've seen it firsthand or proxies

77
00:03:08,920 --> 00:03:12,790
under spider monkey harmony gives us a

78
00:03:12,790 --> 00:03:15,120
bunch of syntactic fixes it gives us

79
00:03:15,120 --> 00:03:19,780
semantic fixes for things like

80
00:03:19,780 --> 00:03:21,459
asynchronous module loading or

81
00:03:21,459 --> 00:03:22,540
apparently synchronous module loading

82
00:03:22,540 --> 00:03:23,769
with asynchronous behavior the sorts of

83
00:03:23,769 --> 00:03:26,590
stuff that you wind up doing all the

84
00:03:26,590 --> 00:03:29,560
time in either no directly or in

85
00:03:29,560 --> 00:03:30,970
patterns that you sort of carry around

86
00:03:30,970 --> 00:03:32,440
with you in code that you're working on

87
00:03:32,440 --> 00:03:35,650
so for example the node has its own

88
00:03:35,650 --> 00:03:37,959
require system which is synchronous

89
00:03:37,959 --> 00:03:40,420
right which is sort of mirrors the

90
00:03:40,420 --> 00:03:41,950
apparently synchronous behavior of

91
00:03:41,950 --> 00:03:43,690
what's happening under the covers in

92
00:03:43,690 --> 00:03:46,630
harmony modules and so we sort of see

93
00:03:46,630 --> 00:03:48,389
this this pressure being taken off of

94
00:03:48,389 --> 00:03:50,859
patterns and off of libraries by the

95
00:03:50,859 --> 00:03:52,750
language when we move to harmony

96
00:03:52,750 --> 00:03:55,000
features and so that I just want to give

97
00:03:55,000 --> 00:03:57,250
you a really simple example and sort of

98
00:03:57,250 --> 00:03:58,900
we're going to walk through what happens

99
00:03:58,900 --> 00:04:01,000
inside of a compiler from point A to

100
00:04:01,000 --> 00:04:03,579
point B when we go from a source

101
00:04:03,579 --> 00:04:06,130
language to the destination target

102
00:04:06,130 --> 00:04:07,750
because what we really want out of these

103
00:04:07,750 --> 00:04:10,750
compilers is for them to hopefully be

104
00:04:10,750 --> 00:04:12,430
backwards compatible semantically like

105
00:04:12,430 --> 00:04:13,720
we want the next evolution of the

106
00:04:13,720 --> 00:04:15,459
language to be built on primitives that

107
00:04:15,459 --> 00:04:18,070
we know and love right for instance when

108
00:04:18,070 --> 00:04:19,479
we go and talk about classes we don't

109
00:04:19,479 --> 00:04:21,489
necessarily want class-based 00 fused

110
00:04:21,489 --> 00:04:23,260
into the language in a way that's that's

111
00:04:23,260 --> 00:04:25,750
sort of upsetting to the prototypal 00

112
00:04:25,750 --> 00:04:27,620
and object

113
00:04:27,620 --> 00:04:29,849
composition styles of inheritance that

114
00:04:29,849 --> 00:04:32,130
we know and love today some people do

115
00:04:32,130 --> 00:04:33,240
want that but they tend not to be

116
00:04:33,240 --> 00:04:34,590
JavaScript programmers already they tend

117
00:04:34,590 --> 00:04:35,490
to be coming from a different place

118
00:04:35,490 --> 00:04:37,889
those of us who love JavaScript I think

119
00:04:37,889 --> 00:04:39,210
are much more in tune with the idea of

120
00:04:39,210 --> 00:04:40,800
keeping prototypal inheritance and

121
00:04:40,800 --> 00:04:42,449
giving it significantly better syntax so

122
00:04:42,449 --> 00:04:43,860
that idea of sort of taking the

123
00:04:43,860 --> 00:04:46,680
semantics we have giving it a better way

124
00:04:46,680 --> 00:04:48,360
to say what you mean is exactly what we

125
00:04:48,360 --> 00:04:50,759
want to get to I think broadly speaking

126
00:04:50,759 --> 00:04:52,710
and I know that the the committee is

127
00:04:52,710 --> 00:04:54,030
working hard to make to make that happen

128
00:04:54,030 --> 00:04:56,069
in a bunch of places so let's walk

129
00:04:56,069 --> 00:04:58,530
through how one of those features that

130
00:04:58,530 --> 00:04:59,970
does exactly this that's got a great

131
00:04:59,970 --> 00:05:03,539
expression in today's semantics can be

132
00:05:03,539 --> 00:05:06,690
implemented through a compiler so this

133
00:05:06,690 --> 00:05:09,750
is a pretty common example of a variable

134
00:05:09,750 --> 00:05:11,550
arguments function variable arity our

135
00:05:11,550 --> 00:05:14,069
function where you'd have to go to note

136
00:05:14,069 --> 00:05:15,449
that in some other piece of metadata

137
00:05:15,449 --> 00:05:18,810
like a jjs thought comment someplace to

138
00:05:18,810 --> 00:05:19,800
note that this thing is going to take

139
00:05:19,800 --> 00:05:22,080
more than one argument which is the

140
00:05:22,080 --> 00:05:24,810
actual function dot length result here

141
00:05:24,810 --> 00:05:26,669
and it's going to provide a default

142
00:05:26,669 --> 00:05:28,229
value for format which you also have to

143
00:05:28,229 --> 00:05:29,880
go document someplace else it's not

144
00:05:29,880 --> 00:05:32,150
actually readable in your code and

145
00:05:32,150 --> 00:05:33,810
you're gonna have to deal with this

146
00:05:33,810 --> 00:05:35,690
parameter thing because you know

147
00:05:35,690 --> 00:05:38,340
arguments isn't actually an array as

148
00:05:38,340 --> 00:05:40,530
things are messy okay so harmony gives

149
00:05:40,530 --> 00:05:42,180
us a much better answer harmony lets us

150
00:05:42,180 --> 00:05:44,699
say I'm going to provide a default

151
00:05:44,699 --> 00:05:46,530
parameter value so if I don't provide

152
00:05:46,530 --> 00:05:48,300
one it's going to be defaulted to that

153
00:05:48,300 --> 00:05:50,190
empty string and everything else that

154
00:05:50,190 --> 00:05:51,930
you pass in beyond the initial is going

155
00:05:51,930 --> 00:05:54,000
to be bucketed into a local variable

156
00:05:54,000 --> 00:05:55,800
called params right that's pretty

157
00:05:55,800 --> 00:05:58,110
awesome that means that no longer going

158
00:05:58,110 --> 00:05:59,610
to be have to shuttling the arguments

159
00:05:59,610 --> 00:06:01,620
object around to try and go pull stuff

160
00:06:01,620 --> 00:06:02,969
out and try not to mutate it because

161
00:06:02,969 --> 00:06:05,130
it's live instead you're going to have

162
00:06:05,130 --> 00:06:07,440
an object that does what you want and

163
00:06:07,440 --> 00:06:10,050
and gives you this really nice toast in

164
00:06:10,050 --> 00:06:13,289
text which has a mirror on the spread

165
00:06:13,289 --> 00:06:15,060
operator so that when you go to use it

166
00:06:15,060 --> 00:06:17,009
in other places you no longer have to

167
00:06:17,009 --> 00:06:18,569
use call and apply this is really nice

168
00:06:18,569 --> 00:06:22,889
stuff okay so how do we get there well

169
00:06:22,889 --> 00:06:25,139
let's let's take this code you know so

170
00:06:25,139 --> 00:06:26,280
this is what we this is what we start

171
00:06:26,280 --> 00:06:27,690
with and this is what we'd like to be

172
00:06:27,690 --> 00:06:29,849
writing so let's take this code and sort

173
00:06:29,849 --> 00:06:33,539
of run it through tracer so we've got

174
00:06:33,539 --> 00:06:37,680
the tracer Ruppel over here and what

175
00:06:37,680 --> 00:06:39,599
we've got right now is when we type this

176
00:06:39,599 --> 00:06:40,740
in we've got

177
00:06:40,740 --> 00:06:42,569
Pilar no right you can't see everything

178
00:06:42,569 --> 00:06:46,800
let's let's fix that okay so wait when

179
00:06:46,800 --> 00:06:49,830
you uh when you run this through the

180
00:06:49,830 --> 00:06:52,020
tracer repple what you get out of the

181
00:06:52,020 --> 00:06:55,440
other side is the sort of the exact same

182
00:06:55,440 --> 00:06:57,419
thing except the function has been

183
00:06:57,419 --> 00:06:59,520
rewritten for you right so the rest this

184
00:06:59,520 --> 00:07:00,990
talk is about how the heck does that

185
00:07:00,990 --> 00:07:03,389
happen right because a lot of us sort of

186
00:07:03,389 --> 00:07:04,979
three compilers like there's some big

187
00:07:04,979 --> 00:07:06,630
black box there a scary thing there are

188
00:07:06,630 --> 00:07:08,639
things that compiler people do and we're

189
00:07:08,639 --> 00:07:09,810
not compiler people we write

190
00:07:09,810 --> 00:07:11,940
applications but compilers don't have to

191
00:07:11,940 --> 00:07:13,199
be scary they don't have to be somebody

192
00:07:13,199 --> 00:07:15,479
else's somebody else's bag there are

193
00:07:15,479 --> 00:07:22,039
things that we can address so um yeah

194
00:07:22,039 --> 00:07:24,479
again we can see exactly what's going on

195
00:07:24,479 --> 00:07:30,720
there and I'm gonna yeah yeah so so I'm

196
00:07:30,720 --> 00:07:32,490
going to hand it over to Peter to sort

197
00:07:32,490 --> 00:07:35,819
of walk us through the rest of the

198
00:07:35,819 --> 00:07:37,979
compiler life cycle but if you take

199
00:07:37,979 --> 00:07:39,330
anything away from today's talk I hope

200
00:07:39,330 --> 00:07:41,659
that you you start to believe that

201
00:07:41,659 --> 00:07:44,220
JavaScript programmers can participate

202
00:07:44,220 --> 00:07:45,900
in the process of evolving the language

203
00:07:45,900 --> 00:07:47,639
not just by telling us what you want or

204
00:07:47,639 --> 00:07:49,169
telling us what you need by helping us

205
00:07:49,169 --> 00:07:50,969
prototype this stuff and we'll show you

206
00:07:50,969 --> 00:08:00,199
how howdy hey I'm Peter helm thanks Alex

207
00:08:00,199 --> 00:08:04,469
so I'm a compiled a guy so I'm just

208
00:08:04,469 --> 00:08:05,340
going to try and walk you guys through

209
00:08:05,340 --> 00:08:07,650
sort of the basics of the anatomy of a

210
00:08:07,650 --> 00:08:10,979
compiler and basically you know a

211
00:08:10,979 --> 00:08:12,509
high-level a compiler is just going to

212
00:08:12,509 --> 00:08:15,150
take a source program that you've

213
00:08:15,150 --> 00:08:17,280
written and convert it into something

214
00:08:17,280 --> 00:08:20,039
else and you know some compilers you

215
00:08:20,039 --> 00:08:22,860
will convert it down to machine code and

216
00:08:22,860 --> 00:08:25,199
this compiler is going to turn take

217
00:08:25,199 --> 00:08:27,539
source code that too with this risk

218
00:08:27,539 --> 00:08:29,009
which is JavaScript plus new features

219
00:08:29,009 --> 00:08:32,250
and turn into JavaScript sort of of

220
00:08:32,250 --> 00:08:35,729
today and you know compilers is a pretty

221
00:08:35,729 --> 00:08:42,419
well studied domain and so you know

222
00:08:42,419 --> 00:08:43,560
there's some common patterns that you

223
00:08:43,560 --> 00:08:44,760
use to sort of get yourself through a

224
00:08:44,760 --> 00:08:47,550
compiler so the first the first stage of

225
00:08:47,550 --> 00:08:50,040
a compiler is called lexing also known

226
00:08:50,040 --> 00:08:51,990
as scanning or tokenizing and basically

227
00:08:51,990 --> 00:08:53,540
what you do is you take the

228
00:08:53,540 --> 00:08:54,560
our source code is an array of

229
00:08:54,560 --> 00:08:57,410
characters and you turn it into an array

230
00:08:57,410 --> 00:09:00,050
of tokens once you've got an array of

231
00:09:00,050 --> 00:09:04,070
tokens you do the syntactic analysis so

232
00:09:04,070 --> 00:09:05,509
you parse the tokens and turn it into a

233
00:09:05,509 --> 00:09:07,160
tree I'll get a little bit more detail

234
00:09:07,160 --> 00:09:10,100
of what this looks like once you've got

235
00:09:10,100 --> 00:09:13,220
a tree that represents your program then

236
00:09:13,220 --> 00:09:15,920
you can transform that tree from a tree

237
00:09:15,920 --> 00:09:20,060
containing so each statement each node

238
00:09:20,060 --> 00:09:21,019
in the tree is going to represent a

239
00:09:21,019 --> 00:09:22,759
statement in your program and so a

240
00:09:22,759 --> 00:09:26,000
transformer will take will take a nodes

241
00:09:26,000 --> 00:09:28,759
that are not represented in the in the

242
00:09:28,759 --> 00:09:31,940
output language and transform them into

243
00:09:31,940 --> 00:09:33,860
nodes that are represented in the applet

244
00:09:33,860 --> 00:09:36,500
language and then lastly once you've got

245
00:09:36,500 --> 00:09:39,410
a transform tree then you just write

246
00:09:39,410 --> 00:09:41,120
that tree out and cover it back into

247
00:09:41,120 --> 00:09:44,209
characters again and I'll just walk you

248
00:09:44,209 --> 00:09:49,910
through that pretty quickly here so the

249
00:09:49,910 --> 00:09:52,670
first thing is lexing and as I mentioned

250
00:09:52,670 --> 00:09:54,500
lexing is the process of basically just

251
00:09:54,500 --> 00:09:56,300
taking characters and turning them into

252
00:09:56,300 --> 00:09:59,839
tokens and here's the code snippet from

253
00:09:59,839 --> 00:10:02,149
tracer that shows you basically the

254
00:10:02,149 --> 00:10:05,170
basics of flexing or scanning and token

255
00:10:05,170 --> 00:10:08,089
you know we start by skipping two

256
00:10:08,089 --> 00:10:11,089
comments we remember the index of the

257
00:10:11,089 --> 00:10:14,029
beginning of the token if we're at the

258
00:10:14,029 --> 00:10:16,880
end of the file we just create a token

259
00:10:16,880 --> 00:10:19,160
which is the end of the file otherwise

260
00:10:19,160 --> 00:10:21,380
you've got the next character we look at

261
00:10:21,380 --> 00:10:23,750
it if it's an open curly we create a

262
00:10:23,750 --> 00:10:27,079
token which is an open curly and we note

263
00:10:27,079 --> 00:10:29,930
the beginning of the token and so the

264
00:10:29,930 --> 00:10:32,000
Craig token does pretty much what you'd

265
00:10:32,000 --> 00:10:34,459
expect it creates a new object which is

266
00:10:34,459 --> 00:10:38,000
a token its dash is the token type in it

267
00:10:38,000 --> 00:10:41,029
and it stashes the location and if

268
00:10:41,029 --> 00:10:42,620
you've got more information like the

269
00:10:42,620 --> 00:10:45,260
token is like a string or a number it's

270
00:10:45,260 --> 00:10:46,370
going to store the string or number

271
00:10:46,370 --> 00:10:47,990
value into the end of the token object

272
00:10:47,990 --> 00:10:50,930
but really at the end of the day this is

273
00:10:50,930 --> 00:10:52,880
the sort of the core of what a tokenizer

274
00:10:52,880 --> 00:10:55,160
does obviously there's a bunch of stuff

275
00:10:55,160 --> 00:10:57,740
to scaffolding to kind of get you to set

276
00:10:57,740 --> 00:10:59,839
this up but then the day it's it's

277
00:10:59,839 --> 00:11:02,209
really tokenization is you know pretty

278
00:11:02,209 --> 00:11:05,620
straightforward

279
00:11:05,630 --> 00:11:09,149
so once you've got your tokens then the

280
00:11:09,149 --> 00:11:10,649
question is how do you build a tree that

281
00:11:10,649 --> 00:11:12,509
represents your program so you want to

282
00:11:12,509 --> 00:11:13,889
have like one node say which is a

283
00:11:13,889 --> 00:11:15,630
function and the children of the

284
00:11:15,630 --> 00:11:18,389
function are going to be you know the

285
00:11:18,389 --> 00:11:20,250
arguments of the function the name of

286
00:11:20,250 --> 00:11:21,839
the function you know the body the

287
00:11:21,839 --> 00:11:25,019
function well first thing you do is you

288
00:11:25,019 --> 00:11:27,750
get your token stream and you ask

289
00:11:27,750 --> 00:11:29,100
yourself hey what's the next token and

290
00:11:29,100 --> 00:11:31,860
my soakin stream if it's savar then you

291
00:11:31,860 --> 00:11:33,420
parse the variable statement if its

292
00:11:33,420 --> 00:11:35,509
function your parts function declaration

293
00:11:35,509 --> 00:11:37,860
and of course obviously there's a whole

294
00:11:37,860 --> 00:11:39,540
bunch of other options in here but at

295
00:11:39,540 --> 00:11:41,130
the end of the day this is the sort of

296
00:11:41,130 --> 00:11:45,509
the basics of it a lot of folks you know

297
00:11:45,509 --> 00:11:46,949
come out of college and in college they

298
00:11:46,949 --> 00:11:48,120
tell you hey you got to use a parser

299
00:11:48,120 --> 00:11:51,740
generator for this it turns out that

300
00:11:51,740 --> 00:11:53,670
most of the guys I know that have been

301
00:11:53,670 --> 00:11:54,779
doing compilers for a long long time

302
00:11:54,779 --> 00:11:58,319
actually don't use parser generators and

303
00:11:58,319 --> 00:12:00,779
there's a bunch of reasons for that the

304
00:12:00,779 --> 00:12:02,490
first reason basically it comes down to

305
00:12:02,490 --> 00:12:05,639
the fact that you know writing it hand

306
00:12:05,639 --> 00:12:07,589
coded yourself is actually really not

307
00:12:07,589 --> 00:12:09,839
that hard once you understand the

308
00:12:09,839 --> 00:12:14,790
patterns and you know it kind of also

309
00:12:14,790 --> 00:12:16,139
uses one of the arguments that that I

310
00:12:16,139 --> 00:12:18,420
think folks are using for for no j/s

311
00:12:18,420 --> 00:12:20,639
which is there's value add and having

312
00:12:20,639 --> 00:12:21,990
just one language in your system you

313
00:12:21,990 --> 00:12:23,069
know if you use a parser generator

314
00:12:23,069 --> 00:12:25,019
you've got you express your grammar in a

315
00:12:25,019 --> 00:12:26,880
language which is not your programming

316
00:12:26,880 --> 00:12:29,370
language and there's a lot of value in

317
00:12:29,370 --> 00:12:31,579
having just one language in your system

318
00:12:31,579 --> 00:12:33,930
you know you make makes it much easier

319
00:12:33,930 --> 00:12:37,800
to debug and anyway there's a bunch of

320
00:12:37,800 --> 00:12:39,389
other reasons that I won't get into you

321
00:12:39,389 --> 00:12:41,279
in terms of why I think parser

322
00:12:41,279 --> 00:12:42,449
generators or perhaps is not the best

323
00:12:42,449 --> 00:12:47,790
tool so again what happens when you want

324
00:12:47,790 --> 00:12:49,470
to say parts of function well again it's

325
00:12:49,470 --> 00:12:50,790
a similar kind of thing there's not a

326
00:12:50,790 --> 00:12:53,189
lot of magic to it you stash away the

327
00:12:53,189 --> 00:12:54,329
location of the start of the parse tree

328
00:12:54,329 --> 00:12:57,510
so you can give good error messages you

329
00:12:57,510 --> 00:13:00,029
eat a function token you check to see if

330
00:13:00,029 --> 00:13:01,380
there's an identifier which is the name

331
00:13:01,380 --> 00:13:03,389
of the function you know you eat a

332
00:13:03,389 --> 00:13:05,970
friend eat your formal parameters a

333
00:13:05,970 --> 00:13:09,180
close friend your function body and then

334
00:13:09,180 --> 00:13:10,680
you create up a new object which is

335
00:13:10,680 --> 00:13:14,130
basically just got all these values as

336
00:13:14,130 --> 00:13:16,800
members and off you go so again there's

337
00:13:16,800 --> 00:13:19,160
not a whole lot of magic

338
00:13:19,160 --> 00:13:23,180
and just give you one more quick example

339
00:13:23,180 --> 00:13:27,090
an if statement again you know looks

340
00:13:27,090 --> 00:13:28,680
very very similar and this is code that

341
00:13:28,680 --> 00:13:30,740
I just cut and paste from the compiler

342
00:13:30,740 --> 00:13:33,750
you know you walk through you know you

343
00:13:33,750 --> 00:13:36,930
just eat the tokens the token text types

344
00:13:36,930 --> 00:13:39,300
that you're expecting you know the only

345
00:13:39,300 --> 00:13:40,590
tricky bit here is that you know where

346
00:13:40,590 --> 00:13:42,390
again we're peaking for the token to see

347
00:13:42,390 --> 00:13:46,830
if there's an else clause or not and and

348
00:13:46,830 --> 00:13:49,710
then we build a new node which

349
00:13:49,710 --> 00:13:53,370
represents the the if statement so again

350
00:13:53,370 --> 00:13:55,800
not a whole lot of magic here and once

351
00:13:55,800 --> 00:13:58,010
you know you recognize the patterns here

352
00:13:58,010 --> 00:14:00,380
you know it's actually pretty reasonable

353
00:14:00,380 --> 00:14:03,240
and it's actually not not too bad

354
00:14:03,240 --> 00:14:04,980
compared to say a B and F grammar and

355
00:14:04,980 --> 00:14:06,600
again the nice thing about this is you

356
00:14:06,600 --> 00:14:07,890
don't have to learn a new language to

357
00:14:07,890 --> 00:14:09,390
express your length to express the

358
00:14:09,390 --> 00:14:15,260
grammar of your language so transformers

359
00:14:15,260 --> 00:14:17,700
transformers are where the real work is

360
00:14:17,700 --> 00:14:20,130
done this is where you're taking a tree

361
00:14:20,130 --> 00:14:23,310
the parse tree which represents your

362
00:14:23,310 --> 00:14:26,220
program and transforming it into a

363
00:14:26,220 --> 00:14:28,110
subset of the language which does not

364
00:14:28,110 --> 00:14:31,520
include the the features that are not in

365
00:14:31,520 --> 00:14:36,960
sort of JavaScript now and this is this

366
00:14:36,960 --> 00:14:38,340
is one where I'm going to I'm going to

367
00:14:38,340 --> 00:14:43,170
just switch to VI here quickly hello so

368
00:14:43,170 --> 00:14:47,120
this is the this is the transformer for

369
00:14:47,120 --> 00:14:50,730
rest parameters and basically what it is

370
00:14:50,730 --> 00:14:54,410
is once you walk your tree and

371
00:14:54,410 --> 00:14:57,960
everywhere that you find a function with

372
00:14:57,960 --> 00:15:01,500
a rest parameter in it you basically

373
00:15:01,500 --> 00:15:03,900
call this function and you do this

374
00:15:03,900 --> 00:15:06,510
transform that's described here in the

375
00:15:06,510 --> 00:15:09,060
comment a function with a rest parameter

376
00:15:09,060 --> 00:15:11,520
here and it gets turned into a function

377
00:15:11,520 --> 00:15:14,430
that looks like this and you can just

378
00:15:14,430 --> 00:15:15,870
kind of walk it backwards you know we're

379
00:15:15,870 --> 00:15:17,820
creating a function declaration it's got

380
00:15:17,820 --> 00:15:19,790
the same name as the input function

381
00:15:19,790 --> 00:15:22,080
we've transformed the parameters without

382
00:15:22,080 --> 00:15:23,490
rest and you can sort of see that

383
00:15:23,490 --> 00:15:27,270
happening sort of up here and of course

384
00:15:27,270 --> 00:15:30,460
we transform the body

385
00:15:30,460 --> 00:15:34,010
by adding a block to are adding the

386
00:15:34,010 --> 00:15:36,050
extra variable statement which has the

387
00:15:36,050 --> 00:15:41,180
call to array dot prototype flyff and

388
00:15:41,180 --> 00:15:42,920
again it's it's a little bit you know

389
00:15:42,920 --> 00:15:44,660
reading code that's building up trees is

390
00:15:44,660 --> 00:15:47,240
kind of gnarly but again this is you

391
00:15:47,240 --> 00:15:48,950
know there's not a lot of magic here and

392
00:15:48,950 --> 00:15:52,220
once you understand the patterns you

393
00:15:52,220 --> 00:15:53,210
know it's something that you can

394
00:15:53,210 --> 00:16:04,830
actually you can actually read all right

395
00:16:04,840 --> 00:16:08,660
and then lastly output so once you've

396
00:16:08,660 --> 00:16:10,310
transformed your trees you've got a tree

397
00:16:10,310 --> 00:16:11,900
that's represents sort of the output

398
00:16:11,900 --> 00:16:14,060
that you want you just turn that output

399
00:16:14,060 --> 00:16:18,140
into text and you know we've got some

400
00:16:18,140 --> 00:16:20,870
simple primitives here you know where

401
00:16:20,870 --> 00:16:22,520
you just say right so for a function

402
00:16:22,520 --> 00:16:24,320
declaration you know you write the

403
00:16:24,320 --> 00:16:25,760
keyword function which is just going to

404
00:16:25,760 --> 00:16:28,490
write you know the text function you

405
00:16:28,490 --> 00:16:29,990
know if it's got a name then we write

406
00:16:29,990 --> 00:16:33,250
the name you know we read an open paren

407
00:16:33,250 --> 00:16:35,990
we visit the formal parameter list close

408
00:16:35,990 --> 00:16:38,480
paren function body again it's a pretty

409
00:16:38,480 --> 00:16:41,210
straightforward system once you once you

410
00:16:41,210 --> 00:16:44,210
once you look at it now of course the

411
00:16:44,210 --> 00:16:46,670
trick to all this is a sort of knowing

412
00:16:46,670 --> 00:16:48,410
the patterns and setting up the patterns

413
00:16:48,410 --> 00:16:50,060
so that you can actually compose this

414
00:16:50,060 --> 00:16:54,230
well but you know and once you've got

415
00:16:54,230 --> 00:16:57,530
that then the actual me to the of it is

416
00:16:57,530 --> 00:17:03,600
actually fairly straightforward now we

417
00:17:03,610 --> 00:17:08,030
all right so I want to walk you through

418
00:17:08,030 --> 00:17:09,500
a little more sophisticated

419
00:17:09,500 --> 00:17:12,140
transformation which is the async

420
00:17:12,140 --> 00:17:15,020
function or it's a called deferred

421
00:17:15,020 --> 00:17:16,970
functions rather which is which is a

422
00:17:16,970 --> 00:17:18,290
language feature that we're looking at

423
00:17:18,290 --> 00:17:22,400
to try and help with async asynchronous

424
00:17:22,400 --> 00:17:25,910
callback style programming and that went

425
00:17:25,910 --> 00:17:27,230
through this a little bit and they in

426
00:17:27,230 --> 00:17:30,440
the in the talk at at j s conf and i

427
00:17:30,440 --> 00:17:31,370
want to kind of go into a little bit

428
00:17:31,370 --> 00:17:32,780
more details or how the transformation

429
00:17:32,780 --> 00:17:36,230
works and and and so why this is is I

430
00:17:36,230 --> 00:17:40,910
think at least is helpful to you and

431
00:17:40,920 --> 00:17:44,590
so here's a piece of callback code we've

432
00:17:44,590 --> 00:17:46,960
got an animate function it takes an

433
00:17:46,960 --> 00:17:50,560
element an HTML element this is a

434
00:17:50,560 --> 00:17:52,930
browser scenario obviously and it takes

435
00:17:52,930 --> 00:17:54,670
a call back to say hey once this

436
00:17:54,670 --> 00:17:57,240
animation is finished call this callback

437
00:17:57,240 --> 00:18:00,160
and what's actually happening here is

438
00:18:00,160 --> 00:18:03,610
we're just setting the style of the left

439
00:18:03,610 --> 00:18:08,560
margin of the element and in a loop and

440
00:18:08,560 --> 00:18:10,960
then each time through the loop we wait

441
00:18:10,960 --> 00:18:14,380
for 5 milliseconds until we get to the

442
00:18:14,380 --> 00:18:17,620
left margin of 350 and then once once

443
00:18:17,620 --> 00:18:18,670
we're done we want to invoke the

444
00:18:18,670 --> 00:18:23,830
callback and so you know if I for folks

445
00:18:23,830 --> 00:18:24,640
that are familiar with callback

446
00:18:24,640 --> 00:18:26,380
programming this is perhaps relatively

447
00:18:26,380 --> 00:18:29,490
straightforward to to read but it's a

448
00:18:29,490 --> 00:18:32,260
anyways it's pretty reassuring are

449
00:18:32,260 --> 00:18:34,420
pretty it does twist up the code quite a

450
00:18:34,420 --> 00:18:38,170
bit and then so we want to in our

451
00:18:38,170 --> 00:18:39,610
example we're going to animate the this

452
00:18:39,610 --> 00:18:41,590
element and then we're going to when

453
00:18:41,590 --> 00:18:42,430
we're done we're just going to have an

454
00:18:42,430 --> 00:18:46,890
alert that says hey okay we're not so I

455
00:18:46,890 --> 00:18:53,310
known the there's in the in the the

456
00:18:53,310 --> 00:18:58,630
browser libraries there's this deferred

457
00:18:58,630 --> 00:18:59,950
pattern also known as the promise

458
00:18:59,950 --> 00:19:03,250
pattern and the promise pattern allows

459
00:19:03,250 --> 00:19:08,740
you to compose of functions that async

460
00:19:08,740 --> 00:19:09,960
Chris functions a little bit better

461
00:19:09,960 --> 00:19:13,060
because by moving the call back out of

462
00:19:13,060 --> 00:19:17,080
the argument list and returning an

463
00:19:17,080 --> 00:19:19,000
object upon which you can add a call

464
00:19:19,000 --> 00:19:23,740
back so this is again code is just all

465
00:19:23,740 --> 00:19:26,980
equi script now so there's no X there's

466
00:19:26,980 --> 00:19:29,770
no new features here but here we've got

467
00:19:29,770 --> 00:19:31,540
a defer time out which returns a

468
00:19:31,540 --> 00:19:33,250
deferred object creates a deferred

469
00:19:33,250 --> 00:19:36,490
object calls window set time I set

470
00:19:36,490 --> 00:19:38,050
timeout when the time it happens it's

471
00:19:38,050 --> 00:19:39,700
going to going to signal the deferred

472
00:19:39,700 --> 00:19:41,440
object and say hey you're done now so

473
00:19:41,440 --> 00:19:44,950
call all people and then it's just going

474
00:19:44,950 --> 00:19:49,990
to return that that object and the

475
00:19:49,990 --> 00:19:54,450
animate is every time it wants to

476
00:19:54,460 --> 00:19:59,270
every time it wants to actually wait for

477
00:19:59,270 --> 00:20:00,470
five milliseconds it's going to

478
00:20:00,470 --> 00:20:02,540
basically call 24 timeout with five

479
00:20:02,540 --> 00:20:04,400
milliseconds and then it's going to say

480
00:20:04,400 --> 00:20:09,050
when you're done add my continuation add

481
00:20:09,050 --> 00:20:15,860
my callback to the return value and at

482
00:20:15,860 --> 00:20:17,930
the same time this animate function is

483
00:20:17,930 --> 00:20:20,510
going to is also going to return a

484
00:20:20,510 --> 00:20:22,910
deferred and when it's done it's going

485
00:20:22,910 --> 00:20:24,140
to just say hey I'm going to sick of my

486
00:20:24,140 --> 00:20:26,480
deferred that I'm done and so the caller

487
00:20:26,480 --> 00:20:29,450
of animate now doesn't pass in whoops

488
00:20:29,450 --> 00:20:32,480
sorry doesn't pass in the callback it

489
00:20:32,480 --> 00:20:36,560
just adds its continuation on to the

490
00:20:36,560 --> 00:20:38,800
return value of of the animate function

491
00:20:38,800 --> 00:20:43,940
so so this is kind of nice because you

492
00:20:43,940 --> 00:20:46,520
can just say you know animate you know

493
00:20:46,520 --> 00:20:48,050
it reads kind of nice right says I want

494
00:20:48,050 --> 00:20:49,790
to animate something and then I want to

495
00:20:49,790 --> 00:20:51,650
do an alert all right so it reads a

496
00:20:51,650 --> 00:20:54,500
little bit more composedly unfortunately

497
00:20:54,500 --> 00:20:56,780
when you start getting into for just

498
00:20:56,780 --> 00:20:59,270
straight linear composition I want to do

499
00:20:59,270 --> 00:21:00,410
this then I want to do this thing I want

500
00:21:00,410 --> 00:21:02,480
to do this the then composition works

501
00:21:02,480 --> 00:21:06,470
quite well but here what we're actually

502
00:21:06,470 --> 00:21:08,750
have is essentially something very much

503
00:21:08,750 --> 00:21:10,310
like a for loop but it's actually

504
00:21:10,310 --> 00:21:13,160
unrolled so tanned to turn it into a

505
00:21:13,160 --> 00:21:16,430
call back and there's I'm a compiler guy

506
00:21:16,430 --> 00:21:18,950
and so I speak I speak compiler and

507
00:21:18,950 --> 00:21:20,780
there's a transformation there's a

508
00:21:20,780 --> 00:21:22,220
description of this transformation it's

509
00:21:22,220 --> 00:21:23,960
called continuation passing style and

510
00:21:23,960 --> 00:21:25,690
it's actually a very well understood

511
00:21:25,690 --> 00:21:27,850
transformation in the compiler community

512
00:21:27,850 --> 00:21:32,810
and it turns out that a lot of a lot of

513
00:21:32,810 --> 00:21:34,360
times when you do this transformation

514
00:21:34,360 --> 00:21:36,730
when you're doing these transformations

515
00:21:36,730 --> 00:21:39,980
in compilers you actually use this

516
00:21:39,980 --> 00:21:41,900
continuation passing style technique and

517
00:21:41,900 --> 00:21:43,490
have it actually automated by the

518
00:21:43,490 --> 00:21:47,090
compiler you know in the in the opening

519
00:21:47,090 --> 00:21:49,010
talk you know it's mentioned you know

520
00:21:49,010 --> 00:21:50,210
what is some of the biggest problems

521
00:21:50,210 --> 00:21:51,290
with node well one of the biggest

522
00:21:51,290 --> 00:21:52,640
problems with node is that you have to

523
00:21:52,640 --> 00:21:55,930
turn your code inside out using

524
00:21:55,930 --> 00:21:58,190
continuation passing style right using

525
00:21:58,190 --> 00:22:00,590
callbacks and that's something that is a

526
00:22:00,590 --> 00:22:02,630
real barrier to entry for folks in in

527
00:22:02,630 --> 00:22:03,870
node

528
00:22:03,870 --> 00:22:06,840
and so the question is well you know if

529
00:22:06,840 --> 00:22:09,780
compilers can do this CPS for you what

530
00:22:09,780 --> 00:22:11,510
can we do to make this easier for you

531
00:22:11,510 --> 00:22:15,600
you know more readable and so what I'm

532
00:22:15,600 --> 00:22:18,540
going to show you and so this is where

533
00:22:18,540 --> 00:22:21,510
now this is the same every everything

534
00:22:21,510 --> 00:22:23,700
you see here is the same function so the

535
00:22:23,700 --> 00:22:25,620
defer timeout is exactly the same code

536
00:22:25,620 --> 00:22:28,740
the way that animate is is chained on is

537
00:22:28,740 --> 00:22:30,630
exactly the same but now you'll notice

538
00:22:30,630 --> 00:22:33,150
that the animate function is using sort

539
00:22:33,150 --> 00:22:36,179
of this proposed feature here which is

540
00:22:36,179 --> 00:22:38,670
called a weight and what is happening

541
00:22:38,670 --> 00:22:41,670
here is is when you any function that

542
00:22:41,670 --> 00:22:44,460
contains in a weight or when you see a

543
00:22:44,460 --> 00:22:47,370
weight of an expression it says evaluate

544
00:22:47,370 --> 00:22:50,160
that expression and then attach the

545
00:22:50,160 --> 00:22:51,780
continuation of the function i'm

546
00:22:51,780 --> 00:22:56,040
currently in to the end of that deferred

547
00:22:56,040 --> 00:22:58,650
object and then what i'm going to do is

548
00:22:58,650 --> 00:23:00,510
I'm going to return a new deferred

549
00:23:00,510 --> 00:23:04,200
object to my collar so semantically this

550
00:23:04,200 --> 00:23:06,000
is doing exactly what was happening in

551
00:23:06,000 --> 00:23:09,510
this previous slide all right but

552
00:23:09,510 --> 00:23:11,910
instead of having to turn this into

553
00:23:11,910 --> 00:23:16,170
continuation passing style with a call

554
00:23:16,170 --> 00:23:19,440
back we can just write it like a regular

555
00:23:19,440 --> 00:23:23,670
for loop and the hope is is that with

556
00:23:23,670 --> 00:23:26,820
with this kind of language feature will

557
00:23:26,820 --> 00:23:28,980
actually sort of takes a lot of the

558
00:23:28,980 --> 00:23:32,340
difficulty and of sort of coming to the

559
00:23:32,340 --> 00:23:36,450
callback style world out of out of out

560
00:23:36,450 --> 00:23:43,050
of node out of note um all right how

561
00:23:43,050 --> 00:23:48,260
much your transforms so i'll show you

562
00:23:48,260 --> 00:23:51,179
what this is going to end up looking

563
00:23:51,179 --> 00:23:56,260
like

564
00:23:56,270 --> 00:24:05,460
just pop it into the ripple loop I'm

565
00:24:05,460 --> 00:24:07,920
going to do is I'm just going to get rid

566
00:24:07,920 --> 00:24:12,080
of this so that it shortens up okay so

567
00:24:12,080 --> 00:24:16,970
this is actually showing the the

568
00:24:16,970 --> 00:24:19,860
generated code that the compiler is

569
00:24:19,860 --> 00:24:24,530
going to generate for you for this so

570
00:24:24,530 --> 00:24:26,760
here's our defer time out which we just

571
00:24:26,760 --> 00:24:28,890
kind of comment it out and here's the

572
00:24:28,890 --> 00:24:33,810
animate function and what happens is the

573
00:24:33,810 --> 00:24:36,540
compiler turns your function into a

574
00:24:36,540 --> 00:24:41,550
state machine and basically every line

575
00:24:41,550 --> 00:24:47,070
every statement in the input basically

576
00:24:47,070 --> 00:24:49,110
gets turned into a single state in our

577
00:24:49,110 --> 00:24:53,280
state machine and then the compiler sort

578
00:24:53,280 --> 00:24:57,040
of knits the state machines together by

579
00:24:57,050 --> 00:25:02,820
and and and and hooks it all up so so

580
00:25:02,820 --> 00:25:05,220
for example you know our first our first

581
00:25:05,220 --> 00:25:07,140
state here is left equals 0 then we've

582
00:25:07,140 --> 00:25:09,930
got left less than 350 and then we've

583
00:25:09,930 --> 00:25:12,060
got you know element style and then

584
00:25:12,060 --> 00:25:13,410
we've got their weight so let's walk it

585
00:25:13,410 --> 00:25:15,330
through and you can see here's our left

586
00:25:15,330 --> 00:25:17,670
equals 0 then go to state six and then

587
00:25:17,670 --> 00:25:20,550
state 6 says do the comparison based on

588
00:25:20,550 --> 00:25:21,900
the comparison we decide to go which

589
00:25:21,900 --> 00:25:24,930
which state we're going to go to next so

590
00:25:24,930 --> 00:25:26,250
again there's no magic here and this is

591
00:25:26,250 --> 00:25:28,950
obviously not as pretty as the the CPS

592
00:25:28,950 --> 00:25:30,120
transform code that you would write

593
00:25:30,120 --> 00:25:32,430
yourself but the nice part about this is

594
00:25:32,430 --> 00:25:33,630
that you know you didn't have to write

595
00:25:33,630 --> 00:25:35,580
this at all you know the compiler wrote

596
00:25:35,580 --> 00:25:40,230
it wrote it for you anyway so that and

597
00:25:40,230 --> 00:25:42,390
then I'll just take you through the

598
00:25:42,390 --> 00:25:44,970
actual meat of this you know here we're

599
00:25:44,970 --> 00:25:46,650
actually saying hey call the four-time

600
00:25:46,650 --> 00:25:49,260
out and we're going to get a weight task

601
00:25:49,260 --> 00:25:52,020
back get a variable back we're going to

602
00:25:52,020 --> 00:25:56,070
attach a callback and an error back to

603
00:25:56,070 --> 00:25:58,950
on to that object and then we're going

604
00:25:58,950 --> 00:26:02,700
to return back to our caller and when if

605
00:26:02,700 --> 00:26:04,530
you if the callback is called we're

606
00:26:04,530 --> 00:26:05,910
going to go to say one if the air back

607
00:26:05,910 --> 00:26:07,020
is called we're going to go to stay too

608
00:26:07,020 --> 00:26:08,970
nice part about this is it actually

609
00:26:08,970 --> 00:26:10,110
chains all your exceptions as well

610
00:26:10,110 --> 00:26:19,350
question oh um are you asking about this

611
00:26:19,350 --> 00:26:21,450
code here yeah so there's so there's

612
00:26:21,450 --> 00:26:23,490
dead code in here and the reason why is

613
00:26:23,490 --> 00:26:26,370
just that um the way that this code is

614
00:26:26,370 --> 00:26:29,100
written is we we focused on trying to

615
00:26:29,100 --> 00:26:31,860
make the transform simple as possible

616
00:26:31,860 --> 00:26:34,380
and understandable as possible like the

617
00:26:34,380 --> 00:26:36,120
transforming code i should say the code

618
00:26:36,120 --> 00:26:37,860
that's generating this as opposed to

619
00:26:37,860 --> 00:26:39,360
trying to generate completely optimal

620
00:26:39,360 --> 00:26:45,090
output actual transfer marco ok so i can

621
00:26:45,090 --> 00:26:49,679
i can show you the transforming code let

622
00:26:49,679 --> 00:27:01,820
me do that good lord where is it hang on

623
00:27:01,820 --> 00:27:08,810
sorry

624
00:27:08,820 --> 00:27:10,840
so I think the important part to

625
00:27:10,840 --> 00:27:12,100
remember here is what when you're

626
00:27:12,100 --> 00:27:13,330
looking what's happening here in the

627
00:27:13,330 --> 00:27:14,950
transformation it's sort of like this

628
00:27:14,950 --> 00:27:16,450
library of hacks that you put together

629
00:27:16,450 --> 00:27:17,710
to sort of achieve something in

630
00:27:17,710 --> 00:27:19,210
JavaScript right where the job or

631
00:27:19,210 --> 00:27:21,070
JavaScript has the semantics available

632
00:27:21,070 --> 00:27:22,299
for you and you just have to put

633
00:27:22,299 --> 00:27:23,769
together this large pile of code to sort

634
00:27:23,769 --> 00:27:25,360
of make it happen in JavaScript and when

635
00:27:25,360 --> 00:27:28,539
you're doing that that's the exact same

636
00:27:28,539 --> 00:27:30,460
library of hacks that you sort of embed

637
00:27:30,460 --> 00:27:32,649
into this transformation form of your

638
00:27:32,649 --> 00:27:34,289
compiler you write it a different way

639
00:27:34,289 --> 00:27:36,580
but if there's something that you want

640
00:27:36,580 --> 00:27:38,559
to achieve through syntax in JavaScript

641
00:27:38,559 --> 00:27:40,960
once you sort of walk through this set

642
00:27:40,960 --> 00:27:43,690
of steps in the compiler chain the end

643
00:27:43,690 --> 00:27:45,340
state for each one of those hacks that

644
00:27:45,340 --> 00:27:47,260
you're giving syntax to is this

645
00:27:47,260 --> 00:27:48,909
transformation it's exactly the same

646
00:27:48,909 --> 00:27:50,080
code that you were going to have to

647
00:27:50,080 --> 00:27:52,120
generate yourself or write out the long

648
00:27:52,120 --> 00:27:54,250
hand yourself and the front of the

649
00:27:54,250 --> 00:27:56,169
compiler tool chain is just there to get

650
00:27:56,169 --> 00:27:57,460
you into a state where you can transform

651
00:27:57,460 --> 00:27:59,620
this tree to generate that same thing

652
00:27:59,620 --> 00:28:00,970
that you were going to write by hand so

653
00:28:00,970 --> 00:28:02,110
if you think about it in terms of like

654
00:28:02,110 --> 00:28:04,690
I'm doing this a lot I write it all the

655
00:28:04,690 --> 00:28:06,220
time I want to stop writing it all the

656
00:28:06,220 --> 00:28:08,860
time and then walk back from there it's

657
00:28:08,860 --> 00:28:10,480
really easy in many ways to start

658
00:28:10,480 --> 00:28:11,559
especially if it's all JavaScript

659
00:28:11,559 --> 00:28:12,850
especial but it's all one language it's

660
00:28:12,850 --> 00:28:14,230
really easy to start hacking on this and

661
00:28:14,230 --> 00:28:16,179
say it'd be great if javascript did this

662
00:28:16,179 --> 00:28:17,620
instead and makes it really

663
00:28:17,620 --> 00:28:18,820
straightforward to start working on it

664
00:28:18,820 --> 00:28:20,710
this is the worst case scenario so if

665
00:28:20,710 --> 00:28:22,659
this it doesn't scare the heck out of

666
00:28:22,659 --> 00:28:28,590
you you two can work on a compiler yeah

667
00:28:28,590 --> 00:28:31,240
yeah so this is this is and this is the

668
00:28:31,240 --> 00:28:33,100
this is actually like by far the

669
00:28:33,100 --> 00:28:36,669
gnarliest of the transforms so anyhow so

670
00:28:36,669 --> 00:28:38,679
this is you know and the trick is is

671
00:28:38,679 --> 00:28:42,010
just to sort of break it down into into

672
00:28:42,010 --> 00:28:47,649
cases and enroll it in yes our waiter

673
00:28:47,649 --> 00:28:50,889
time okay and that's basically it if

674
00:28:50,889 --> 00:28:52,720
you're interested in looking at the

675
00:28:52,720 --> 00:28:55,090
Christian compiler here's the links um

