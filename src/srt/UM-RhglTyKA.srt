1
00:00:05,650 --> 00:00:10,000

so hi folks I'm pleased how's everyone

2
00:00:10,000 --> 00:00:14,650
doing right now how how am i doing I'm

3
00:00:14,650 --> 00:00:17,980
doing okay thanks for asking oh no I'm

4
00:00:17,980 --> 00:00:19,570
actually really really stoked to be here

5
00:00:19,570 --> 00:00:22,840
because I love Hawaii I love going to

6
00:00:22,840 --> 00:00:25,239
the beach and surfing and doing things

7
00:00:25,239 --> 00:00:28,090
in the ocean this is me on a recent

8
00:00:28,090 --> 00:00:31,570
scuba trip here but a recreational

9
00:00:31,570 --> 00:00:34,000
diving doesn't really pay the bills so I

10
00:00:34,000 --> 00:00:35,620
do a little bit of software engineering

11
00:00:35,620 --> 00:00:38,800
on the side and my first engineering job

12
00:00:38,800 --> 00:00:42,280
was in 2015 where I worked at an unnamed

13
00:00:42,280 --> 00:00:45,730
company I'd been coding small things on

14
00:00:45,730 --> 00:00:47,079
my own like Neopets

15
00:00:47,079 --> 00:00:49,390
storefronts and myspace fiends since I

16
00:00:49,390 --> 00:00:51,879
was a teenager but this was my yeah who

17
00:00:51,879 --> 00:00:53,469
knew pets or once I moved from MySpace

18
00:00:53,469 --> 00:00:56,499
either way this is my first time working

19
00:00:56,499 --> 00:00:58,809
on a team and building a capital P

20
00:00:58,809 --> 00:01:00,789
product and this was also my first

21
00:01:00,789 --> 00:01:03,339
introduction to graph QL so show of

22
00:01:03,339 --> 00:01:05,530
hands how many people here have worked

23
00:01:05,530 --> 00:01:09,070
with graph QL before cool cool cool so

24
00:01:09,070 --> 00:01:12,190
yeah graph QL is a query language in an

25
00:01:12,190 --> 00:01:15,520
application it fits in the API layer

26
00:01:15,520 --> 00:01:18,010
much like rest does how many people here

27
00:01:18,010 --> 00:01:21,640
have worked with REST API s how many

28
00:01:21,640 --> 00:01:24,070
people here worked with graph QL before

29
00:01:24,070 --> 00:01:27,850
they ever worked with a REST API handle

30
00:01:27,850 --> 00:01:30,520
nice but yeah I still think it's unusual

31
00:01:30,520 --> 00:01:33,040
to have this experience of learning and

32
00:01:33,040 --> 00:01:35,530
working with graph QL first and I think

33
00:01:35,530 --> 00:01:37,720
that that early exposure set the

34
00:01:37,720 --> 00:01:40,120
foundation for how I view product

35
00:01:40,120 --> 00:01:42,100
development overall and this is a

36
00:01:42,100 --> 00:01:48,069
picture of me realizing that

37
00:01:48,079 --> 00:01:50,579
imagine if your first introduction to

38
00:01:50,579 --> 00:01:52,380
web development was through something

39
00:01:52,380 --> 00:01:54,119
like react and I'm sure that for many of

40
00:01:54,119 --> 00:01:55,770
you you don't even have to imagine that

41
00:01:55,770 --> 00:01:58,500
but you'd probably understand that that

42
00:01:58,500 --> 00:02:00,179
kind of introduction left a unique

43
00:02:00,179 --> 00:02:02,819
impression on you and it molded your way

44
00:02:02,819 --> 00:02:04,890
of thinking about web app development

45
00:02:04,890 --> 00:02:06,990
right and I think that that's the case

46
00:02:06,990 --> 00:02:08,940
with me and Graziella and product

47
00:02:08,940 --> 00:02:12,930
development as well so in the first

48
00:02:12,930 --> 00:02:14,879
engineering job I worked on recruiting

49
00:02:14,879 --> 00:02:17,160
products we built a suite of products

50
00:02:17,160 --> 00:02:20,099
and tools that our recruiters used to do

51
00:02:20,099 --> 00:02:22,200
their jobs in my sound kind of

52
00:02:22,200 --> 00:02:23,940
surprising but for a company of that

53
00:02:23,940 --> 00:02:26,150
size that recruits on that scale

54
00:02:26,150 --> 00:02:29,099
greenhouse just doesn't cut it so it's

55
00:02:29,099 --> 00:02:30,540
actually a cost saver to have an

56
00:02:30,540 --> 00:02:32,610
internal team building those tools for

57
00:02:32,610 --> 00:02:35,430
you and for recruiting that statement is

58
00:02:35,430 --> 00:02:38,610
true partly because of the scale that we

59
00:02:38,610 --> 00:02:40,500
were dealing with like more than a

60
00:02:40,500 --> 00:02:42,480
million candidates in our pool thousands

61
00:02:42,480 --> 00:02:44,579
of interviews every day hundreds of

62
00:02:44,579 --> 00:02:46,410
thousands of recruiting decisions that

63
00:02:46,410 --> 00:02:48,599
have to be made every day from resume

64
00:02:48,599 --> 00:02:51,540
reviews to final offers but that's also

65
00:02:51,540 --> 00:02:54,299
true because recruiting is an incredibly

66
00:02:54,299 --> 00:02:57,450
complex problem domain and what do I

67
00:02:57,450 --> 00:03:00,000
mean by complex problem domain let's

68
00:03:00,000 --> 00:03:02,190
define domain when I talk about domain

69
00:03:02,190 --> 00:03:04,950
I'm talking about the subject area for

70
00:03:04,950 --> 00:03:07,500
which you are building software so on my

71
00:03:07,500 --> 00:03:09,420
old team our domain was the tech

72
00:03:09,420 --> 00:03:12,510
recruiting space I had to understand how

73
00:03:12,510 --> 00:03:14,850
the industry sources candidates how

74
00:03:14,850 --> 00:03:16,829
often recruiters engage candidates and

75
00:03:16,829 --> 00:03:19,200
in what ways and how people prepare for

76
00:03:19,200 --> 00:03:22,980
interviews and a lot more and then what

77
00:03:22,980 --> 00:03:25,530
do I mean by complex it's important to

78
00:03:25,530 --> 00:03:28,260
differentiate complicated from complex

79
00:03:28,260 --> 00:03:31,349
complicated is about many rules and

80
00:03:31,349 --> 00:03:33,750
steps but predictable ones and getting

81
00:03:33,750 --> 00:03:35,849
predictable results from the same sets

82
00:03:35,849 --> 00:03:38,750
of inputs think like taxes software

83
00:03:38,750 --> 00:03:42,000
American taxes are super complicated but

84
00:03:42,000 --> 00:03:43,950
it can be simplified by pruning or

85
00:03:43,950 --> 00:03:45,870
consolidating steps and that's what the

86
00:03:45,870 --> 00:03:48,510
taxes software does but complex is

87
00:03:48,510 --> 00:03:51,150
different we can't easily turn a complex

88
00:03:51,150 --> 00:03:53,639
problem into a set of predictable rules

89
00:03:53,639 --> 00:03:55,100
to follow

90
00:03:55,100 --> 00:03:58,660
because complex problems are fuzzy

91
00:03:58,660 --> 00:04:00,910
relationship-driven and constantly

92
00:04:00,910 --> 00:04:03,700
evolving so by definition there's no

93
00:04:03,700 --> 00:04:06,160
solution to a complex problem like

94
00:04:06,160 --> 00:04:08,500
recruiting and trying to solve it once

95
00:04:08,500 --> 00:04:10,930
and for all is kind of misguided the

96
00:04:10,930 --> 00:04:13,180
best we can do is continuously manage it

97
00:04:13,180 --> 00:04:15,310
how do we manage a complex problem

98
00:04:15,310 --> 00:04:18,489
domain let's find out I worked on that

99
00:04:18,489 --> 00:04:20,140
team for a while and I learned a ton

100
00:04:20,140 --> 00:04:22,450
about the recruiting space a lot about

101
00:04:22,450 --> 00:04:24,340
graffiti whoa and a lot about product

102
00:04:24,340 --> 00:04:26,380
development and then I went to work at a

103
00:04:26,380 --> 00:04:28,510
small start-up whose tech stack was

104
00:04:28,510 --> 00:04:30,730
really similar to my old team except no

105
00:04:30,730 --> 00:04:33,580
graph QL and I sat in meetings and I

106
00:04:33,580 --> 00:04:35,320
read over a technical specs and things

107
00:04:35,320 --> 00:04:38,770
just felt different not worse because

108
00:04:38,770 --> 00:04:40,660
God forbid I say anyone technology is

109
00:04:40,660 --> 00:04:43,510
worse than another just different and

110
00:04:43,510 --> 00:04:45,640
the things we focused on were different

111
00:04:45,640 --> 00:04:47,440
the way we discuss problems was

112
00:04:47,440 --> 00:04:49,660
different and I think that that contrast

113
00:04:49,660 --> 00:04:52,600
shed a light on my past experience and

114
00:04:52,600 --> 00:04:55,060
helped me develop opinions on a product

115
00:04:55,060 --> 00:04:57,040
development within a complex product

116
00:04:57,040 --> 00:05:00,070
domain should look like I had an aha

117
00:05:00,070 --> 00:05:02,380
moment or more like a series of aha

118
00:05:02,380 --> 00:05:04,150
moments when I started to think about

119
00:05:04,150 --> 00:05:07,090
where this difference came from so I

120
00:05:07,090 --> 00:05:08,140
wanted to share some of those opinions

121
00:05:08,140 --> 00:05:10,720
with y'all in this talk called graph QL

122
00:05:10,720 --> 00:05:14,590
the domain way by the end of this talk I

123
00:05:14,590 --> 00:05:16,630
hope to convince you of this that graph

124
00:05:16,630 --> 00:05:19,150
2l gives product teams superpowers by

125
00:05:19,150 --> 00:05:20,560
letting them focus on their domain

126
00:05:20,560 --> 00:05:23,290
rather than their data and I also hope

127
00:05:23,290 --> 00:05:25,090
that you can learn something that will

128
00:05:25,090 --> 00:05:27,220
be helpful to you as a product developer

129
00:05:27,220 --> 00:05:30,420
even if you don't use graph QL yet

130
00:05:30,420 --> 00:05:33,790
let's do a high-level overview really

131
00:05:33,790 --> 00:05:35,230
grateful that Shawn showed you all some

132
00:05:35,230 --> 00:05:36,910
cool graphic UL stuff yesterday because

133
00:05:36,910 --> 00:05:38,590
it takes the pressure off of this part a

134
00:05:38,590 --> 00:05:41,890
little bit if I said us before graph 2 I

135
00:05:41,890 --> 00:05:44,320
was a query language it's also a runtime

136
00:05:44,320 --> 00:05:47,500
for fulfilling those queries so to be

137
00:05:47,500 --> 00:05:49,360
clear it's not a programming language

138
00:05:49,360 --> 00:05:52,210
and it's not a graph database in fact

139
00:05:52,210 --> 00:05:54,220
graph GL was pretty agnostic about both

140
00:05:54,220 --> 00:05:56,610
of these things there are graph QL

141
00:05:56,610 --> 00:05:59,080
implementations out there in JavaScript

142
00:05:59,080 --> 00:06:02,550
obviously but also ruby scala closure

143
00:06:02,550 --> 00:06:04,270
doesn't care what programming language

144
00:06:04,270 --> 00:06:06,700
you implement it in and you can use

145
00:06:06,700 --> 00:06:08,590
whichever and however many different

146
00:06:08,590 --> 00:06:11,290
data sources you want with it

147
00:06:11,290 --> 00:06:13,360
this graphic shows where graph QL sits

148
00:06:13,360 --> 00:06:15,400
as the API layer between all of your

149
00:06:15,400 --> 00:06:17,680
possible clients and all of your data

150
00:06:17,680 --> 00:06:19,930
sources it can talk to any kind of

151
00:06:19,930 --> 00:06:22,240
database micro-service a third party API

152
00:06:22,240 --> 00:06:25,390
it can act as a layer to a legacy system

153
00:06:25,390 --> 00:06:27,550
it can talk to another graph QL server

154
00:06:27,550 --> 00:06:31,690
or to an existing REST API the rest it's

155
00:06:31,690 --> 00:06:33,400
important to understand that graph QL

156
00:06:33,400 --> 00:06:35,650
doesn't replace your data layer concerns

157
00:06:35,650 --> 00:06:37,930
but it does let you decouple those

158
00:06:37,930 --> 00:06:39,730
concerns from your product domain

159
00:06:39,730 --> 00:06:42,820
concerns I'm gonna keep showing you some

160
00:06:42,820 --> 00:06:45,400
snippets of graph QL alongside the rest

161
00:06:45,400 --> 00:06:47,350
of this talks content but this is all we

162
00:06:47,350 --> 00:06:50,050
need to know to get started so changing

163
00:06:50,050 --> 00:06:52,150
teams got me curious about different

164
00:06:52,150 --> 00:06:53,980
product development philosophies out

165
00:06:53,980 --> 00:06:56,110
there and eventually I came across one

166
00:06:56,110 --> 00:06:56,500
called

167
00:06:56,500 --> 00:06:59,110
domain driven development I think that

168
00:06:59,110 --> 00:07:01,210
graph QL and domain driven development

169
00:07:01,210 --> 00:07:03,310
go really well with each other and

170
00:07:03,310 --> 00:07:05,260
hopefully you think so too by the end of

171
00:07:05,260 --> 00:07:07,360
this talk but even if you don't use

172
00:07:07,360 --> 00:07:09,150
graph QL if you're building software

173
00:07:09,150 --> 00:07:12,580
within a complex domain the principles

174
00:07:12,580 --> 00:07:14,890
of DDD can really help you collaborate

175
00:07:14,890 --> 00:07:17,170
better and build a better product for

176
00:07:17,170 --> 00:07:20,590
your user I want to talk about five

177
00:07:20,590 --> 00:07:22,210
strategies within domain driven

178
00:07:22,210 --> 00:07:23,890
development that I feel are most

179
00:07:23,890 --> 00:07:26,680
relevant to my own product development

180
00:07:26,680 --> 00:07:29,710
experience and to graph QL we'll go

181
00:07:29,710 --> 00:07:31,420
through each strategy one by one so

182
00:07:31,420 --> 00:07:33,370
don't worry if these go fast I just want

183
00:07:33,370 --> 00:07:36,190
to let you know what's coming the first

184
00:07:36,190 --> 00:07:38,290
strategy is finding the important parts

185
00:07:38,290 --> 00:07:40,960
of the problem second strategy

186
00:07:40,960 --> 00:07:44,380
oops second one is creating a model that

187
00:07:44,380 --> 00:07:48,100
solves that problem then we collaborate

188
00:07:48,100 --> 00:07:50,650
to using a shared language to build a

189
00:07:50,650 --> 00:07:53,770
better model we make sure to separate

190
00:07:53,770 --> 00:07:56,050
our domain logic from our infrastructure

191
00:07:56,050 --> 00:07:58,960
logic and we also make sure to clearly

192
00:07:58,960 --> 00:08:01,480
document all of our changes so let's go

193
00:08:01,480 --> 00:08:03,790
to the first strategy breaking down the

194
00:08:03,790 --> 00:08:05,320
problem that you're trying to solve and

195
00:08:05,320 --> 00:08:07,090
highlighting what the most important

196
00:08:07,090 --> 00:08:10,780
parts are even outside of DDD or using

197
00:08:10,780 --> 00:08:12,700
graph QL this is a pretty important part

198
00:08:12,700 --> 00:08:15,250
of software development right when you

199
00:08:15,250 --> 00:08:17,560
work within a complex domain there's a

200
00:08:17,560 --> 00:08:19,600
wealth of information but not all of it

201
00:08:19,600 --> 00:08:20,180
is rel

202
00:08:20,180 --> 00:08:22,850
to the problem at hand you can find

203
00:08:22,850 --> 00:08:24,470
where to put your focus by breaking down

204
00:08:24,470 --> 00:08:26,389
your problem and asking which parts

205
00:08:26,389 --> 00:08:29,570
deliver the most value building software

206
00:08:29,570 --> 00:08:31,520
is really expensive way to solve a

207
00:08:31,520 --> 00:08:33,649
problem and I think not everything

208
00:08:33,649 --> 00:08:36,020
merits a problem solution so a product

209
00:08:36,020 --> 00:08:37,820
solution I mean so it's important to be

210
00:08:37,820 --> 00:08:40,880
thoughtful about these things let's

211
00:08:40,880 --> 00:08:42,890
practice finding the important parts of

212
00:08:42,890 --> 00:08:45,080
a problem with a sample problem and by

213
00:08:45,080 --> 00:08:46,190
the way this is the problem that I made

214
00:08:46,190 --> 00:08:48,140
up I never worked on anything like this

215
00:08:48,140 --> 00:08:50,180
so don't come after me for exposing

216
00:08:50,180 --> 00:08:54,680
trade secrets or whatever on average 20%

217
00:08:54,680 --> 00:08:56,540
of our interviewers cancel their

218
00:08:56,540 --> 00:08:59,120
interview slot less than 24 hours before

219
00:08:59,120 --> 00:09:00,310
their scheduled interview

220
00:09:00,310 --> 00:09:03,140
this means that coordinators are rushing

221
00:09:03,140 --> 00:09:05,480
to fill slots and when they can't it's a

222
00:09:05,480 --> 00:09:08,720
really bad candidate experience I see

223
00:09:08,720 --> 00:09:12,230
two sub problems here problem a is that

224
00:09:12,230 --> 00:09:15,410
20% of interviewers cancel and problem B

225
00:09:15,410 --> 00:09:17,870
is coordinators have to drop everything

226
00:09:17,870 --> 00:09:21,050
and rush to find a fill-in which problem

227
00:09:21,050 --> 00:09:22,790
do you think we should solve with a

228
00:09:22,790 --> 00:09:24,830
product solution vote now on your phones

229
00:09:24,830 --> 00:09:28,130
okay now there's no voting but to know

230
00:09:28,130 --> 00:09:29,930
which is the right problem to solve

231
00:09:29,930 --> 00:09:31,820
you need to have domain knowledge which

232
00:09:31,820 --> 00:09:33,500
you can get by talking to domain experts

233
00:09:33,500 --> 00:09:35,870
so let's think about problem a for a

234
00:09:35,870 --> 00:09:38,450
little bit why do people cancel maybe

235
00:09:38,450 --> 00:09:40,339
they had a scheduling conflict

236
00:09:40,339 --> 00:09:43,160
maybe they got sick how much lower could

237
00:09:43,160 --> 00:09:45,350
we change this number realistically like

238
00:09:45,350 --> 00:09:47,690
maybe we can make it go from 20 percent

239
00:09:47,690 --> 00:09:50,089
to 10 percent so 10 percent of

240
00:09:50,089 --> 00:09:51,589
candidates would still have a really bad

241
00:09:51,589 --> 00:09:54,430
experience but what about so problem B

242
00:09:54,430 --> 00:09:56,660
coordinators have to rush to fill in

243
00:09:56,660 --> 00:09:59,420
interview slots at the last minute if we

244
00:09:59,420 --> 00:10:01,520
can make that process really easy or

245
00:10:01,520 --> 00:10:03,950
non-existent then it's okay for some

246
00:10:03,950 --> 00:10:06,650
interviewers to cancel so we can go and

247
00:10:06,650 --> 00:10:08,570
talk to an expert in our domain like an

248
00:10:08,570 --> 00:10:10,310
interview coordinator and ask what they

249
00:10:10,310 --> 00:10:12,260
think and they might say something like

250
00:10:12,260 --> 00:10:14,570
you know a lot of times people cancel

251
00:10:14,570 --> 00:10:16,430
because they're sick and we can't really

252
00:10:16,430 --> 00:10:18,770
do anything to change that I would

253
00:10:18,770 --> 00:10:20,540
rather just have a backup interviewer or

254
00:10:20,540 --> 00:10:23,060
a tool that makes it super easy to find

255
00:10:23,060 --> 00:10:26,000
one and now we know where to focus our

256
00:10:26,000 --> 00:10:30,230
product building acts efforts then the

257
00:10:30,230 --> 00:10:31,030
next step

258
00:10:31,030 --> 00:10:33,100
getting to work and designing a model

259
00:10:33,100 --> 00:10:35,680
that solves the problem it's easy for me

260
00:10:35,680 --> 00:10:37,570
as an engineer to start chasing a

261
00:10:37,570 --> 00:10:40,090
perfect abstraction so I have to try

262
00:10:40,090 --> 00:10:41,860
really hard to keep in mind the actual

263
00:10:41,860 --> 00:10:43,540
business need that this project

264
00:10:43,540 --> 00:10:46,090
addresses remember that we're building a

265
00:10:46,090 --> 00:10:48,580
product within a complex domain it's

266
00:10:48,580 --> 00:10:50,080
kind of a waste of time to try to build

267
00:10:50,080 --> 00:10:52,270
a perfect mapping between the real world

268
00:10:52,270 --> 00:10:54,820
and your API layer because by definition

269
00:10:54,820 --> 00:10:57,310
the complex domain we're working in is

270
00:10:57,310 --> 00:10:59,860
fuzzy and ever-changing so I think we

271
00:10:59,860 --> 00:11:01,600
just have to accept that we're not gonna

272
00:11:01,600 --> 00:11:03,760
reach domain model harmony and our best

273
00:11:03,760 --> 00:11:06,340
approach is to build an evolvable model

274
00:11:06,340 --> 00:11:08,130
that brings us that business value now

275
00:11:08,130 --> 00:11:11,110
and a good question to ask yourself here

276
00:11:11,110 --> 00:11:13,570
is what's the smallest possible change I

277
00:11:13,570 --> 00:11:16,180
can make to deliver this value to answer

278
00:11:16,180 --> 00:11:17,680
that question we need to know the

279
00:11:17,680 --> 00:11:20,590
current state of the world and this is

280
00:11:20,590 --> 00:11:22,450
where I want to introduce you all to a

281
00:11:22,450 --> 00:11:24,490
core concept in graph two I'll call the

282
00:11:24,490 --> 00:11:27,280
schema the schema is where you define

283
00:11:27,280 --> 00:11:29,140
all the data that is available to the

284
00:11:29,140 --> 00:11:31,780
client the basic building block is the

285
00:11:31,780 --> 00:11:34,570
type and a type can have fields and also

286
00:11:34,570 --> 00:11:36,420
relationships to other types the

287
00:11:36,420 --> 00:11:39,010
graphical schema is where you model your

288
00:11:39,010 --> 00:11:41,380
business domain so any important entity

289
00:11:41,380 --> 00:11:43,060
in your domain could be defined as a

290
00:11:43,060 --> 00:11:45,970
type on the schema here's an example of

291
00:11:45,970 --> 00:11:47,950
a type of the interview type written in

292
00:11:47,950 --> 00:11:50,500
schema definition language what's the

293
00:11:50,500 --> 00:11:52,180
shape of an interview type well it has

294
00:11:52,180 --> 00:11:55,030
an ID a start in an endtime a room that

295
00:11:55,030 --> 00:11:57,370
it's held in a status which could be

296
00:11:57,370 --> 00:12:00,430
like scheduled or completed it has an

297
00:12:00,430 --> 00:12:01,630
interview type which could be like a

298
00:12:01,630 --> 00:12:04,420
systems interview or front-end coding it

299
00:12:04,420 --> 00:12:06,610
also has relationships to other types

300
00:12:06,610 --> 00:12:08,560
that are defined elsewhere on the schema

301
00:12:08,560 --> 00:12:11,500
Canada interviewer interview and vie and

302
00:12:11,500 --> 00:12:13,710
the interview loop but it's a part of

303
00:12:13,710 --> 00:12:16,300
remember we were talking about how graph

304
00:12:16,300 --> 00:12:18,430
QL is like an abstraction layer over all

305
00:12:18,430 --> 00:12:19,780
of the places you want to get your data

306
00:12:19,780 --> 00:12:22,630
from I see the schema also as an

307
00:12:22,630 --> 00:12:24,280
abstraction but over your business

308
00:12:24,280 --> 00:12:26,530
domain and I found a really natural to

309
00:12:26,530 --> 00:12:28,420
use schema definition language in

310
00:12:28,420 --> 00:12:30,640
product development because the graph

311
00:12:30,640 --> 00:12:33,280
based system resembles my natural mental

312
00:12:33,280 --> 00:12:35,800
model for relationships between real

313
00:12:35,800 --> 00:12:38,800
world things and maybe someone who are

314
00:12:38,800 --> 00:12:40,870
looking at this and thinking how is this

315
00:12:40,870 --> 00:12:43,500
different from a database model the

316
00:12:43,500 --> 00:12:45,420
sir has to do with what we're focusing

317
00:12:45,420 --> 00:12:47,460
on when we're designing each when

318
00:12:47,460 --> 00:12:48,990
designing a database structure we care

319
00:12:48,990 --> 00:12:51,540
about things like consistency redundancy

320
00:12:51,540 --> 00:12:53,970
and efficiency on the back end when

321
00:12:53,970 --> 00:12:55,980
designing a graphic UL schema we care

322
00:12:55,980 --> 00:12:57,510
about the needs of our front-end client

323
00:12:57,510 --> 00:13:00,420
specifically when writing the schema

324
00:13:00,420 --> 00:13:02,160
it's definitely tempting to just

325
00:13:02,160 --> 00:13:04,590
recreate a 101 in mapping to your

326
00:13:04,590 --> 00:13:06,810
underlying database setup or to your

327
00:13:06,810 --> 00:13:09,180
existing REST API but by doing so you're

328
00:13:09,180 --> 00:13:11,580
introducing unnecessary complexity on

329
00:13:11,580 --> 00:13:13,970
the client side let's look at an example

330
00:13:13,970 --> 00:13:16,290
let's say this is the UI we're building

331
00:13:16,290 --> 00:13:18,270
floor please don't judge my design

332
00:13:18,270 --> 00:13:21,150
skills too harshly I get mistaken for a

333
00:13:21,150 --> 00:13:22,530
designer all the time but I definitely

334
00:13:22,530 --> 00:13:25,380
don't have those skills we want to

335
00:13:25,380 --> 00:13:26,910
display information about an interview

336
00:13:26,910 --> 00:13:28,980
loop namely we want to display the

337
00:13:28,980 --> 00:13:30,960
candidate name the job that they applied

338
00:13:30,960 --> 00:13:32,970
for and then a list of their interviews

339
00:13:32,970 --> 00:13:34,980
including their interviewers name and

340
00:13:34,980 --> 00:13:38,520
their feedback what would that look like

341
00:13:38,520 --> 00:13:40,920
if our graph UL types were just mappings

342
00:13:40,920 --> 00:13:42,930
to our database we'll start from the

343
00:13:42,930 --> 00:13:45,330
interview loop on the left is our domain

344
00:13:45,330 --> 00:13:47,760
style schema definition and on the right

345
00:13:47,760 --> 00:13:49,620
is our database style schema definition

346
00:13:49,620 --> 00:13:51,960
you'll see that the difference is that

347
00:13:51,960 --> 00:13:53,550
the relationships to other types are

348
00:13:53,550 --> 00:13:55,830
represented by string IDs instead of by

349
00:13:55,830 --> 00:13:58,710
the actual type so assuming we're gonna

350
00:13:58,710 --> 00:14:01,680
use our database style schema how does

351
00:14:01,680 --> 00:14:03,210
this affect the way that we write our

352
00:14:03,210 --> 00:14:06,810
client code buckle in this is what a

353
00:14:06,810 --> 00:14:09,510
query in graph QL looks like in this one

354
00:14:09,510 --> 00:14:11,640
we're giving some interview loop ID and

355
00:14:11,640 --> 00:14:14,790
asking for the IDS of the candidate the

356
00:14:14,790 --> 00:14:16,860
job requisition and all the interviews

357
00:14:16,860 --> 00:14:19,500
on the loop we stored those IDs and then

358
00:14:19,500 --> 00:14:22,530
we kick off some other queries we do

359
00:14:22,530 --> 00:14:24,120
three more queries to get the candidate

360
00:14:24,120 --> 00:14:27,000
name the job requisition title and then

361
00:14:27,000 --> 00:14:28,589
all the data that we need for each of

362
00:14:28,589 --> 00:14:30,600
the interviews and we're still not done

363
00:14:30,600 --> 00:14:32,280
because for each of those interviews we

364
00:14:32,280 --> 00:14:33,570
also need to get the interviewers name

365
00:14:33,570 --> 00:14:36,180
and then there's a bunch of code that we

366
00:14:36,180 --> 00:14:38,040
still have to write to parse this data

367
00:14:38,040 --> 00:14:42,020
and map it into the right format

368
00:14:42,020 --> 00:14:44,910
remember this is more complex than it

369
00:14:44,910 --> 00:14:46,740
needs to be because of our decision to

370
00:14:46,740 --> 00:14:48,570
make our graph QL schema map to our

371
00:14:48,570 --> 00:14:51,180
databases what would this look like if

372
00:14:51,180 --> 00:14:53,459
we design our schema to match our mental

373
00:14:53,459 --> 00:14:56,940
model instead if we wrote our schema

374
00:14:56,940 --> 00:14:57,270
tonight

375
00:14:57,270 --> 00:14:59,340
our mental model we can get exactly the

376
00:14:59,340 --> 00:15:01,110
data that we want in the shape that we

377
00:15:01,110 --> 00:15:04,020
want with just one request being able to

378
00:15:04,020 --> 00:15:06,180
write queries like this simplifies our

379
00:15:06,180 --> 00:15:08,190
work on the client by a lot and if we

380
00:15:08,190 --> 00:15:10,170
ran this query this would be the data

381
00:15:10,170 --> 00:15:12,390
that we get back we have our candidate

382
00:15:12,390 --> 00:15:14,580
Barack Obama who applied for a product

383
00:15:14,580 --> 00:15:16,140
engineer role and was interviewed by

384
00:15:16,140 --> 00:15:18,360
Michelle Obama which is not a conflict

385
00:15:18,360 --> 00:15:21,990
of interest at all don't worry after you

386
00:15:21,990 --> 00:15:24,330
get some initial ideas down it's time to

387
00:15:24,330 --> 00:15:25,950
work together with your team to make it

388
00:15:25,950 --> 00:15:27,930
good and for this part to go well

389
00:15:27,930 --> 00:15:30,150
everyone has to have a shared

390
00:15:30,150 --> 00:15:32,640
understanding of your domain and even

391
00:15:32,640 --> 00:15:34,680
more importantly an established shared

392
00:15:34,680 --> 00:15:36,960
language to talk about it with why is

393
00:15:36,960 --> 00:15:40,110
this part so important without a shared

394
00:15:40,110 --> 00:15:41,970
language collaboration between teams

395
00:15:41,970 --> 00:15:44,280
within a company is really inefficient

396
00:15:44,280 --> 00:15:46,800
you're gonna mix business jargon with

397
00:15:46,800 --> 00:15:48,990
technical jargon and everyone is just

398
00:15:48,990 --> 00:15:50,670
going to be constantly talking past each

399
00:15:50,670 --> 00:15:53,370
other without even realizing it having a

400
00:15:53,370 --> 00:15:55,500
shared language removes a large chunk of

401
00:15:55,500 --> 00:15:57,750
ambiguity and misinterpretation and it

402
00:15:57,750 --> 00:16:00,480
ultimately saves you time and especially

403
00:16:00,480 --> 00:16:02,550
when we're building for complex domains

404
00:16:02,550 --> 00:16:04,950
we need to iterate quickly to keep up

405
00:16:04,950 --> 00:16:06,390
with the ever-changing nature of our

406
00:16:06,390 --> 00:16:08,160
domain so we need those tight feedback

407
00:16:08,160 --> 00:16:11,130
loops so I take my text back and I set

408
00:16:11,130 --> 00:16:13,500
up a meeting actually I'm gonna call it

409
00:16:13,500 --> 00:16:15,060
a working session after Anna's talk

410
00:16:15,060 --> 00:16:17,490
yesterday I really like that I set up a

411
00:16:17,490 --> 00:16:19,440
working session with maybe one other

412
00:16:19,440 --> 00:16:22,770
engineer a p.m. a designer and a domain

413
00:16:22,770 --> 00:16:25,260
expert so my last job our domain experts

414
00:16:25,260 --> 00:16:27,900
were longtime recruiters and recruiting

415
00:16:27,900 --> 00:16:30,210
managers these are the people who have

416
00:16:30,210 --> 00:16:32,340
the most on-the-ground realistic

417
00:16:32,340 --> 00:16:34,620
knowledge of your domain so you're

418
00:16:34,620 --> 00:16:36,240
really doing yourself a disservice if

419
00:16:36,240 --> 00:16:37,920
you don't include them early in your

420
00:16:37,920 --> 00:16:39,930
development process I'm gonna say it

421
00:16:39,930 --> 00:16:40,740
again because I think it's really

422
00:16:40,740 --> 00:16:42,450
important talk to your domain experts

423
00:16:42,450 --> 00:16:44,070
like think right now who are your domain

424
00:16:44,070 --> 00:16:46,080
experts for the area that you work in

425
00:16:46,080 --> 00:16:47,670
and how can you include them in your

426
00:16:47,670 --> 00:16:51,320
development process more where were we

427
00:16:51,320 --> 00:16:53,760
okay we're in the working session we're

428
00:16:53,760 --> 00:16:55,560
collaborating on our proposed changes

429
00:16:55,560 --> 00:16:58,800
and in the session we talked about a lot

430
00:16:58,800 --> 00:17:00,840
of things but I wanted to share some

431
00:17:00,840 --> 00:17:03,360
concrete tips for building and

432
00:17:03,360 --> 00:17:06,000
maintaining a shared vocabulary or as

433
00:17:06,000 --> 00:17:07,260
it's called in domain driven development

434
00:17:07,260 --> 00:17:08,120
you

435
00:17:08,120 --> 00:17:12,260
kotas language first ensure that you

436
00:17:12,260 --> 00:17:14,720
only use one word for specific concept

437
00:17:14,720 --> 00:17:17,209
don't let domain experts and developers

438
00:17:17,209 --> 00:17:18,800
have two words that address the same

439
00:17:18,800 --> 00:17:22,610
thing second try to stay away from

440
00:17:22,610 --> 00:17:25,309
overloaded technical terms like service

441
00:17:25,309 --> 00:17:28,760
policy manager etc in your API layer

442
00:17:28,760 --> 00:17:31,070
words in your API layer should

443
00:17:31,070 --> 00:17:33,460
correspond to concepts in your domain

444
00:17:33,460 --> 00:17:37,010
third create and maintain a glossary of

445
00:17:37,010 --> 00:17:39,800
terms with explicit definitions this is

446
00:17:39,800 --> 00:17:41,900
something that you get basically for

447
00:17:41,900 --> 00:17:43,700
free with graph key well it's really

448
00:17:43,700 --> 00:17:47,840
cool and I'll show you how in a bit use

449
00:17:47,840 --> 00:17:49,490
terms from your shared language

450
00:17:49,490 --> 00:17:52,429
everywhere namespaces classes filenames

451
00:17:52,429 --> 00:17:54,950
properties method names you should also

452
00:17:54,950 --> 00:17:56,660
be able to find the same language that

453
00:17:56,660 --> 00:17:58,730
you use in your code in your support

454
00:17:58,730 --> 00:18:01,460
articles in your internal update emails

455
00:18:01,460 --> 00:18:03,980
in your product specs this is how you

456
00:18:03,980 --> 00:18:06,860
keep a shared language alive and useful

457
00:18:06,860 --> 00:18:09,980
by using it and then as you gain a

458
00:18:09,980 --> 00:18:11,660
deeper understanding of your business

459
00:18:11,660 --> 00:18:13,970
domain your shared language will evolve

460
00:18:13,970 --> 00:18:16,400
as well periodically refactor your code

461
00:18:16,400 --> 00:18:19,190
base to reflect this this is also

462
00:18:19,190 --> 00:18:21,440
something that's much easier to do in a

463
00:18:21,440 --> 00:18:23,510
typed and well-documented code base like

464
00:18:23,510 --> 00:18:26,240
one that uses graph QL and I know that

465
00:18:26,240 --> 00:18:28,100
this sounds like a lot of work but it's

466
00:18:28,100 --> 00:18:31,070
necessary work because there is always

467
00:18:31,070 --> 00:18:33,440
going to be some underlying model and if

468
00:18:33,440 --> 00:18:35,179
you're not putting conscious effort into

469
00:18:35,179 --> 00:18:37,820
building a useful and evolvable model

470
00:18:37,820 --> 00:18:40,280
then you're probably modeling garbage by

471
00:18:40,280 --> 00:18:42,980
accident this is the kind of upfront

472
00:18:42,980 --> 00:18:44,840
work that makes sure that you're solving

473
00:18:44,840 --> 00:18:46,460
the right problem that you have the

474
00:18:46,460 --> 00:18:48,230
correct assumptions about your domain

475
00:18:48,230 --> 00:18:49,730
and that you're not making some

476
00:18:49,730 --> 00:18:51,440
incorrect assumption into your model

477
00:18:51,440 --> 00:18:53,210
that's going to give you headaches for

478
00:18:53,210 --> 00:18:57,590
years to come another strategy in DDD is

479
00:18:57,590 --> 00:18:59,870
separating your business logic from your

480
00:18:59,870 --> 00:19:01,760
infrastructure logic and if you get

481
00:19:01,760 --> 00:19:03,200
nothing else from this talk here's a

482
00:19:03,200 --> 00:19:06,210
life hack for separating egg yolks

483
00:19:06,210 --> 00:19:08,309
and why is it important to keep these

484
00:19:08,309 --> 00:19:10,679
things separate not the egg yolks I mean

485
00:19:10,679 --> 00:19:13,559
the different logic types over time your

486
00:19:13,559 --> 00:19:15,570
product priorities change or your

487
00:19:15,570 --> 00:19:17,399
understanding of your product domain

488
00:19:17,399 --> 00:19:19,169
changes and so your product itself

489
00:19:19,169 --> 00:19:21,629
changes there's a regular cadence within

490
00:19:21,629 --> 00:19:23,480
which you add new features and whatnot

491
00:19:23,480 --> 00:19:26,220
at the same time as your company grows

492
00:19:26,220 --> 00:19:28,619
and it grows its user base you probably

493
00:19:28,619 --> 00:19:29,669
also will need to make some

494
00:19:29,669 --> 00:19:31,320
infrastructure changes to accommodate

495
00:19:31,320 --> 00:19:34,019
that but those are two separate things

496
00:19:34,019 --> 00:19:36,119
right you're changing product needs and

497
00:19:36,119 --> 00:19:38,759
then you're changing scale needs a lot

498
00:19:38,759 --> 00:19:41,490
of complexity in applications comes from

499
00:19:41,490 --> 00:19:43,679
these two things being entangled when we

500
00:19:43,679 --> 00:19:45,389
want them to be isolated so that they

501
00:19:45,389 --> 00:19:48,470
can grow and change at their own pace

502
00:19:48,470 --> 00:19:52,139
remember our good old schema graph QL

503
00:19:52,139 --> 00:19:55,049
has a special type called query this is

504
00:19:55,049 --> 00:19:56,580
a special type because it defines the

505
00:19:56,580 --> 00:19:59,340
entry point for all of your data for

506
00:19:59,340 --> 00:20:01,110
every type in our schema and for every

507
00:20:01,110 --> 00:20:03,179
field on every type we have to teach

508
00:20:03,179 --> 00:20:05,249
graph QL where that data actually lives

509
00:20:05,249 --> 00:20:07,590
and how to get it we do this in the

510
00:20:07,590 --> 00:20:09,990
resolvers and the resolvers are

511
00:20:09,990 --> 00:20:12,509
functions that tell graph QL where and

512
00:20:12,509 --> 00:20:14,419
how to resolve the types you've defined

513
00:20:14,419 --> 00:20:16,559
this is where you'd write the code that

514
00:20:16,559 --> 00:20:18,480
accesses your data source whatever it

515
00:20:18,480 --> 00:20:20,759
may be let's look at this example

516
00:20:20,759 --> 00:20:23,999
I wrote a MongoDB example but remember

517
00:20:23,999 --> 00:20:26,159
you can put logic to ask us anything in

518
00:20:26,159 --> 00:20:28,950
the resolvers in this example we have a

519
00:20:28,950 --> 00:20:31,110
query called all interviews that returns

520
00:20:31,110 --> 00:20:33,749
you guessed it all the interviews from a

521
00:20:33,749 --> 00:20:36,809
MongoDB document we also have a query

522
00:20:36,809 --> 00:20:39,269
called interviews by candidate that lets

523
00:20:39,269 --> 00:20:41,309
you filter the interviews using a

524
00:20:41,309 --> 00:20:44,279
candidate ID oh by the way if you like

525
00:20:44,279 --> 00:20:46,259
this editor theme amy webelo made it

526
00:20:46,259 --> 00:20:49,499
it's called fairy floss check it out as

527
00:20:49,499 --> 00:20:51,690
I said before a few times in domain

528
00:20:51,690 --> 00:20:53,549
driven development it's really important

529
00:20:53,549 --> 00:20:55,139
for the whole team to have a shared

530
00:20:55,139 --> 00:20:57,240
understanding of the business domain and

531
00:20:57,240 --> 00:20:59,429
a shared language to use when talking

532
00:20:59,429 --> 00:21:01,559
about it so you need to document

533
00:21:01,559 --> 00:21:03,779
everything and I know that everyone says

534
00:21:03,779 --> 00:21:05,249
this in like this really aspirational

535
00:21:05,249 --> 00:21:07,710
way but graphic you graph to out really

536
00:21:07,710 --> 00:21:09,929
does make this much easier because of

537
00:21:09,929 --> 00:21:11,639
the type system your domain is

538
00:21:11,639 --> 00:21:14,879
practically self documenting there's

539
00:21:14,879 --> 00:21:17,440
this really cool tool

540
00:21:17,440 --> 00:21:21,430
video playing yeah no is it yeah there's

541
00:21:21,430 --> 00:21:22,870
this really cool tool called graphical

542
00:21:22,870 --> 00:21:25,780
it's a sandbox for your graph QL schema

543
00:21:25,780 --> 00:21:28,510
and here I have a video of graphical

544
00:21:28,510 --> 00:21:31,810
over the github graph QL API if you want

545
00:21:31,810 --> 00:21:34,060
to try out graph QL this is a really

546
00:21:34,060 --> 00:21:36,370
good place to get started you can write

547
00:21:36,370 --> 00:21:38,560
and run arbitrary queries and get real

548
00:21:38,560 --> 00:21:41,050
data back and my favorite part is the

549
00:21:41,050 --> 00:21:42,880
documentation Explorer on the right

550
00:21:42,880 --> 00:21:45,310
where you can navigate and search

551
00:21:45,310 --> 00:21:46,720
through every type that you've defined

552
00:21:46,720 --> 00:21:49,120
in your schema including descriptions

553
00:21:49,120 --> 00:21:52,090
for every type a protip is you can make

554
00:21:52,090 --> 00:21:54,340
descriptions a required field for any

555
00:21:54,340 --> 00:21:56,260
new type in your schema and you've got

556
00:21:56,260 --> 00:21:59,620
built in documentation that way let's do

557
00:21:59,620 --> 00:22:01,660
a recap at the beginning of the talk I

558
00:22:01,660 --> 00:22:03,790
said that graph QL gives product team

559
00:22:03,790 --> 00:22:05,800
superpowers by letting them focus on

560
00:22:05,800 --> 00:22:08,050
their domain rather than their data and

561
00:22:08,050 --> 00:22:10,510
we've learned that this domain focused

562
00:22:10,510 --> 00:22:12,460
way of structuring your work is called

563
00:22:12,460 --> 00:22:15,250
domain driven development how our graph

564
00:22:15,250 --> 00:22:17,050
QL and domain driven development tied

565
00:22:17,050 --> 00:22:20,710
together one it's impossible for a

566
00:22:20,710 --> 00:22:22,180
schema designed to be an afterthought

567
00:22:22,180 --> 00:22:24,340
because for anything to work in your API

568
00:22:24,340 --> 00:22:26,080
you have to define it in your schema

569
00:22:26,080 --> 00:22:27,970
first and this forces you to think

570
00:22:27,970 --> 00:22:29,800
upfront about your schema and your

571
00:22:29,800 --> 00:22:33,370
domain graph based modeling feels really

572
00:22:33,370 --> 00:22:35,860
natural and speeds up development on the

573
00:22:35,860 --> 00:22:38,340
client side the schema definition

574
00:22:38,340 --> 00:22:40,870
reduces communication errors between

575
00:22:40,870 --> 00:22:43,330
teams because everyone is on the same

576
00:22:43,330 --> 00:22:45,070
page about what terms mean and what

577
00:22:45,070 --> 00:22:48,030
relationships between types look like

578
00:22:48,030 --> 00:22:50,830
you get built-in separation of concerns

579
00:22:50,830 --> 00:22:53,440
between your domain and your infra logic

580
00:22:53,440 --> 00:22:56,710
because of the resolvers and you get

581
00:22:56,710 --> 00:22:58,720
really nice documentation with very

582
00:22:58,720 --> 00:23:00,280
little extra effort because of the type

583
00:23:00,280 --> 00:23:02,080
system and the awesome tooling that's

584
00:23:02,080 --> 00:23:06,370
available in the graph QL ecosystem and

585
00:23:06,370 --> 00:23:08,170
after all of this maybe some of y'all

586
00:23:08,170 --> 00:23:10,390
are thinking it sounds like a lot of

587
00:23:10,390 --> 00:23:12,910
work and a lot of meetings and first of

588
00:23:12,910 --> 00:23:14,830
all yeah if you're not working in a

589
00:23:14,830 --> 00:23:16,420
complex problem domain this is

590
00:23:16,420 --> 00:23:19,140
definitely overkill but otherwise

591
00:23:19,140 --> 00:23:21,280
personally getting to work more

592
00:23:21,280 --> 00:23:22,840
collaboratively is one of the things

593
00:23:22,840 --> 00:23:24,730
that I love about working with graphs

594
00:23:24,730 --> 00:23:28,300
well and following DDD it's exposed me

595
00:23:28,300 --> 00:23:30,490
to new domains and new opportunities too

596
00:23:30,490 --> 00:23:32,230
about those domains so I got to

597
00:23:32,230 --> 00:23:34,059
understand the entire recruiting

598
00:23:34,059 --> 00:23:35,890
pipeline very in-depth and on my current

599
00:23:35,890 --> 00:23:37,809
job I've gotten to learn a bunch about

600
00:23:37,809 --> 00:23:40,510
political organizing how nonprofits run

601
00:23:40,510 --> 00:23:43,120
and a ton about text messages as a

602
00:23:43,120 --> 00:23:46,780
platform I also strongly believe that

603
00:23:46,780 --> 00:23:48,850
the best product engineering teams don't

604
00:23:48,850 --> 00:23:50,620
just use the most cutting-edge tech or

605
00:23:50,620 --> 00:23:52,660
focus on building pristine code bases

606
00:23:52,660 --> 00:23:55,030
they also think and care deeply about

607
00:23:55,030 --> 00:23:57,070
their products their users and their

608
00:23:57,070 --> 00:23:59,920
domain if you want to learn more about

609
00:23:59,920 --> 00:24:02,740
DDD Eric Evans's domain driven design is

610
00:24:02,740 --> 00:24:05,140
the canonical text and I also use

611
00:24:05,140 --> 00:24:06,940
patterns principles and practices of

612
00:24:06,940 --> 00:24:10,330
domain driven design aka the PPP of DDD

613
00:24:10,330 --> 00:24:12,790
and if you'd like to hear more about

614
00:24:12,790 --> 00:24:14,500
graph QL and domain driven design

615
00:24:14,500 --> 00:24:17,350
specifically this talk by mark Andre

616
00:24:17,350 --> 00:24:19,870
zero from graph QL Summit last year is

617
00:24:19,870 --> 00:24:21,610
really good and also talks about it and

618
00:24:21,610 --> 00:24:23,890
finally Emily Griffin made those

619
00:24:23,890 --> 00:24:25,780
adorable illustrations you can find her

620
00:24:25,780 --> 00:24:27,550
on Twitter at Emily with curls

621
00:24:27,550 --> 00:24:29,350
you should totally Commission her to do

622
00:24:29,350 --> 00:24:31,090
art for your next talk so that's it

623
00:24:31,090 --> 00:24:32,300
thanks everyone

624
00:24:32,300 --> 00:24:36,110
[Applause]

