1
00:00:37,980 --> 00:00:41,440

alright thanks for coming to this talk

2
00:00:41,440 --> 00:00:44,440
it seems to be my luck that at

3
00:00:44,440 --> 00:00:46,630
conferences I'm often up against people

4
00:00:46,630 --> 00:00:49,360
i admire at the same time in the other

5
00:00:49,360 --> 00:00:51,070
room and that is the case here you

6
00:00:51,070 --> 00:00:52,870
should definitely check out James long's

7
00:00:52,870 --> 00:00:55,780
works on ensuite je s macros for

8
00:00:55,780 --> 00:00:57,790
JavaScript since we came to this talk

9
00:00:57,790 --> 00:01:00,399
and you're missing that but since you

10
00:01:00,399 --> 00:01:02,500
did come to this talk I think you're in

11
00:01:02,500 --> 00:01:05,979
for a treat I'm going to talk about a

12
00:01:05,979 --> 00:01:08,680
project called regenerator which is an

13
00:01:08,680 --> 00:01:10,750
effort to take one of the really cool I

14
00:01:10,750 --> 00:01:13,420
think the coolest feature of the next

15
00:01:13,420 --> 00:01:15,760
version of JavaScript acma script 6 and

16
00:01:15,760 --> 00:01:19,659
simulate it using javascript of today so

17
00:01:19,659 --> 00:01:20,979
you can go ahead and use that feature

18
00:01:20,979 --> 00:01:24,460
from the future in the present or in a

19
00:01:24,460 --> 00:01:27,760
browser more to the point i'm ben newman

20
00:01:27,760 --> 00:01:30,909
and i work at facebook a release

21
00:01:30,909 --> 00:01:34,420
regenerator with my my team at facebook

22
00:01:34,420 --> 00:01:36,250
which is the javascript infrastructure

23
00:01:36,250 --> 00:01:37,990
team and we have been maintaining it

24
00:01:37,990 --> 00:01:40,150
actively so it's not just thrown over

25
00:01:40,150 --> 00:01:42,010
the wall if you want to talk to me

26
00:01:42,010 --> 00:01:44,650
specifically in following up on any of

27
00:01:44,650 --> 00:01:46,240
this stuff or just get to know me i'm

28
00:01:46,240 --> 00:01:49,270
benjamin without the eye on most forms

29
00:01:49,270 --> 00:01:54,640
of social media as you can see there so

30
00:01:54,640 --> 00:01:58,540
when we released regenerator wrote up

31
00:01:58,540 --> 00:02:01,090
this sort of call to action page and

32
00:02:01,090 --> 00:02:04,390
posted it up on hacker news and got into

33
00:02:04,390 --> 00:02:06,430
like the top five and the the comments

34
00:02:06,430 --> 00:02:10,169
were all really surprisingly

35
00:02:10,169 --> 00:02:12,159
appreciative there was very little

36
00:02:12,159 --> 00:02:15,010
backlash and one of the things I think

37
00:02:15,010 --> 00:02:17,920
went well about this launch is that it's

38
00:02:17,920 --> 00:02:20,260
it signals just from a headline like

39
00:02:20,260 --> 00:02:23,260
this that you might need to have or want

40
00:02:23,260 --> 00:02:26,140
to have a little bit of context a little

41
00:02:26,140 --> 00:02:28,030
bit of experience with the idea of

42
00:02:28,030 --> 00:02:31,269
generator functions before you have an

43
00:02:31,269 --> 00:02:33,700
opinion about you know the way we did it

44
00:02:33,700 --> 00:02:37,000
was correct or the best way of doing it

45
00:02:37,000 --> 00:02:41,530
and so I I live in New York and one of

46
00:02:41,530 --> 00:02:44,409
our local meetups is Brooklyn j/s at the

47
00:02:44,409 --> 00:02:46,659
last instance of Brooklyn jas Brittany

48
00:02:46,659 --> 00:02:48,819
sister Rose gave a talk about technical

49
00:02:48,819 --> 00:02:51,670
writing and she gave me a term that that

50
00:02:51,670 --> 00:02:54,310
now sort of helps me conceptualize this

51
00:02:54,310 --> 00:02:57,760
this idea so you have low context and

52
00:02:57,760 --> 00:03:01,840
high context audience members and you

53
00:03:01,840 --> 00:03:03,220
can write in different ways and you

54
00:03:03,220 --> 00:03:06,340
should write in different ways when your

55
00:03:06,340 --> 00:03:07,959
audience comes in with some context

56
00:03:07,959 --> 00:03:09,639
versus when they come in with much

57
00:03:09,639 --> 00:03:12,730
context and so I'm making a bet that

58
00:03:12,730 --> 00:03:15,639
jayus conf and the group of people who

59
00:03:15,639 --> 00:03:17,650
have come to this talk stand the best

60
00:03:17,650 --> 00:03:19,629
chance of having a little bit of context

61
00:03:19,629 --> 00:03:21,970
around these issues of anyone anywhere

62
00:03:21,970 --> 00:03:24,519
so I hope you don't mind if I abuse you

63
00:03:24,519 --> 00:03:27,069
with what I would consider to be a

64
00:03:27,069 --> 00:03:28,599
pretty technical talk there's a lot of

65
00:03:28,599 --> 00:03:31,690
code and I would just encourage you if

66
00:03:31,690 --> 00:03:33,849
you if you want to follow along at all

67
00:03:33,849 --> 00:03:36,400
look at the slides read along with the

68
00:03:36,400 --> 00:03:38,319
code as I'm talking about it otherwise

69
00:03:38,319 --> 00:03:41,739
if I'm just talking about it and you

70
00:03:41,739 --> 00:03:43,209
know you haven't been looking you may

71
00:03:43,209 --> 00:03:44,680
find yourself lost which is totally fine

72
00:03:44,680 --> 00:03:46,870
i'll try to change the tone of my voice

73
00:03:46,870 --> 00:03:48,069
when there's something like sort of

74
00:03:48,069 --> 00:03:50,739
independently interesting and you know

75
00:03:50,739 --> 00:03:54,000
maybe you can get back on the the path

76
00:03:54,000 --> 00:03:59,500
but with that warning out of the way so

77
00:03:59,500 --> 00:04:02,879
calls to action right are something we

78
00:04:02,879 --> 00:04:06,519
often feel like issuing when we've built

79
00:04:06,519 --> 00:04:08,079
something that we're proud of we think

80
00:04:08,079 --> 00:04:09,819
other people should use it we think it's

81
00:04:09,819 --> 00:04:12,190
a better way of doing things then the

82
00:04:12,190 --> 00:04:13,359
way things have been done in the past

83
00:04:13,359 --> 00:04:16,329
and we want to tell ourselves that we

84
00:04:16,329 --> 00:04:17,859
and everybody else should have been

85
00:04:17,859 --> 00:04:21,940
doing it this way all along and github

86
00:04:21,940 --> 00:04:24,700
is indeed littered with better ways of

87
00:04:24,700 --> 00:04:26,289
doing things really better ways for

88
00:04:26,289 --> 00:04:28,340
someone of doing something

89
00:04:28,340 --> 00:04:30,680
that never quite caught on and why is

90
00:04:30,680 --> 00:04:35,600
that well I would claim that in addition

91
00:04:35,600 --> 00:04:38,960
to having a bright idea about how you

92
00:04:38,960 --> 00:04:40,490
ought to have done something from the

93
00:04:40,490 --> 00:04:43,669
beginning you can't just go back and

94
00:04:43,669 --> 00:04:45,530
start over from scratch if you could it

95
00:04:45,530 --> 00:04:46,850
would be easy to do it the right way

96
00:04:46,850 --> 00:04:51,320
from scratch but they're also you also

97
00:04:51,320 --> 00:04:53,300
have to have a second clever idea which

98
00:04:53,300 --> 00:04:55,340
is how to get from where you are right

99
00:04:55,340 --> 00:04:57,680
now with the the application stack that

100
00:04:57,680 --> 00:05:00,680
you've inherited to that new place that

101
00:05:00,680 --> 00:05:03,050
is as if you started from scratch with

102
00:05:03,050 --> 00:05:05,300
all the right ideas so there has to be a

103
00:05:05,300 --> 00:05:07,639
way forward not just backwards and then

104
00:05:07,639 --> 00:05:11,300
forwards again and I would go I would go

105
00:05:11,300 --> 00:05:12,530
further to claim that programming

106
00:05:12,530 --> 00:05:14,930
languages are notoriously difficult in

107
00:05:14,930 --> 00:05:16,820
this way they're difficult to fix

108
00:05:16,820 --> 00:05:21,229
forward so if i can ask inflammatory

109
00:05:21,229 --> 00:05:22,520
question that may not be so inflammatory

110
00:05:22,520 --> 00:05:24,380
here because this is a JavaScript and

111
00:05:24,380 --> 00:05:28,280
not a Python conference what why is it

112
00:05:28,280 --> 00:05:30,770
it's been since 2008 and Python 3 is

113
00:05:30,770 --> 00:05:33,169
definitely a better language in a lot of

114
00:05:33,169 --> 00:05:35,780
ways than Python 2 and Python 2 is one

115
00:05:35,780 --> 00:05:36,830
of the most successful programming

116
00:05:36,830 --> 00:05:38,780
language in the history of programming

117
00:05:38,780 --> 00:05:42,260
languages why is it that big projects

118
00:05:42,260 --> 00:05:45,530
haven't switched to python 3 Django for

119
00:05:45,530 --> 00:05:51,020
instance and so I don't know how many

120
00:05:51,020 --> 00:05:52,669
people have used python of any version

121
00:05:52,669 --> 00:05:56,810
in the room almost everyone maybe eighty

122
00:05:56,810 --> 00:05:58,370
ninety percent how many people have

123
00:05:58,370 --> 00:06:01,039
written a line of Python 3 that runs in

124
00:06:01,039 --> 00:06:03,590
production all right all right we can

125
00:06:03,590 --> 00:06:06,770
walk away from this discussion okay so I

126
00:06:06,770 --> 00:06:08,330
don't want to go into this too much but

127
00:06:08,330 --> 00:06:11,389
Python 3 is a lot of new features some

128
00:06:11,389 --> 00:06:13,099
of which are fairly trivial to switch

129
00:06:13,099 --> 00:06:15,080
over to they have a two to three script

130
00:06:15,080 --> 00:06:17,389
to convert your print keywords to print

131
00:06:17,389 --> 00:06:19,190
function since that's so like small

132
00:06:19,190 --> 00:06:20,720
cosmetic thing that changed but there

133
00:06:20,720 --> 00:06:22,900
are also differences in the semantics of

134
00:06:22,900 --> 00:06:26,570
like Unicode handling in Python 3 that

135
00:06:26,570 --> 00:06:27,889
are definitely the right way to do

136
00:06:27,889 --> 00:06:31,550
things like byte strings in Python 2 or

137
00:06:31,550 --> 00:06:34,220
a source of a lot of trouble but you

138
00:06:34,220 --> 00:06:36,919
can't just switch one day and start

139
00:06:36,919 --> 00:06:39,469
using that feature of Python 3 and

140
00:06:39,469 --> 00:06:41,300
because it's one big language that you

141
00:06:41,300 --> 00:06:42,110
have to start use

142
00:06:42,110 --> 00:06:43,850
in all at once you've got to sort of

143
00:06:43,850 --> 00:06:45,590
swallow the things that are difficult to

144
00:06:45,590 --> 00:06:48,170
swallow along with savoring the things

145
00:06:48,170 --> 00:06:51,530
that you actually want so to bring this

146
00:06:51,530 --> 00:06:53,990
back to what we care about how can echo

147
00:06:53,990 --> 00:06:56,390
script six which is the technical

148
00:06:56,390 --> 00:06:57,860
standards name for the next version of

149
00:06:57,860 --> 00:07:00,650
JavaScript avoid this trap the Python 3

150
00:07:00,650 --> 00:07:04,790
trap if you will so my crazy idea which

151
00:07:04,790 --> 00:07:06,470
I'm giving myself too much credit to

152
00:07:06,470 --> 00:07:08,330
call my idea but it's something I've

153
00:07:08,330 --> 00:07:10,310
become passionate about in the last year

154
00:07:10,310 --> 00:07:12,530
or so is that we might be able to ease

155
00:07:12,530 --> 00:07:14,420
ourselves into the new version of the

156
00:07:14,420 --> 00:07:17,540
language by simulating its most useful

157
00:07:17,540 --> 00:07:21,380
features in the current version of the

158
00:07:21,380 --> 00:07:24,050
language right so why would we want to

159
00:07:24,050 --> 00:07:25,570
do that obviously there's a cost to

160
00:07:25,570 --> 00:07:27,740
simulating features and if you could

161
00:07:27,740 --> 00:07:29,090
just switch to the next version of the

162
00:07:29,090 --> 00:07:31,400
language native support for all those

163
00:07:31,400 --> 00:07:33,050
things and wouldn't you be better off

164
00:07:33,050 --> 00:07:36,230
well i think that the insight here is

165
00:07:36,230 --> 00:07:38,210
that at every step of this process you

166
00:07:38,210 --> 00:07:41,120
have this like perfect hybrid of the old

167
00:07:41,120 --> 00:07:43,430
language and the new that suits your

168
00:07:43,430 --> 00:07:46,370
needs exactly and you know exactly why

169
00:07:46,370 --> 00:07:48,530
you've adopted each of its features you

170
00:07:48,530 --> 00:07:50,090
get to prove them out even before

171
00:07:50,090 --> 00:07:53,480
they're fully standardized and you you

172
00:07:53,480 --> 00:07:56,060
just you know that the language you're

173
00:07:56,060 --> 00:07:57,710
using is the language you want to be

174
00:07:57,710 --> 00:07:59,600
using and there aren't these like hidden

175
00:07:59,600 --> 00:08:02,120
dragons that you're going to have to

176
00:08:02,120 --> 00:08:07,750
confront at some point so a phrase that

177
00:08:07,750 --> 00:08:10,550
I might have come up with for this is

178
00:08:10,550 --> 00:08:12,890
linguistic time-travel we're reaching

179
00:08:12,890 --> 00:08:15,880
into the future and selectively taking

180
00:08:15,880 --> 00:08:18,650
parts of the future a future of

181
00:08:18,650 --> 00:08:20,990
JavaScript bringing them into JavaScript

182
00:08:20,990 --> 00:08:25,680
of today so what's an example

183
00:08:25,680 --> 00:08:29,250
well this is not generated related this

184
00:08:29,250 --> 00:08:31,770
is a sort of simpler but also cool

185
00:08:31,770 --> 00:08:34,110
feature of ECMO script six arrow

186
00:08:34,110 --> 00:08:37,710
functions are a nice way of writing you

187
00:08:37,710 --> 00:08:39,630
know the hundreds of little throwaway

188
00:08:39,630 --> 00:08:40,950
callback functions that you need to

189
00:08:40,950 --> 00:08:42,659
write in JavaScript so you get to do

190
00:08:42,659 --> 00:08:45,839
away with the function keyword and you

191
00:08:45,839 --> 00:08:48,089
can just have an expression instead of a

192
00:08:48,089 --> 00:08:50,070
whole curly brace delimited body with a

193
00:08:50,070 --> 00:08:51,990
return statement in it so these two

194
00:08:51,990 --> 00:08:53,580
things are equivalent if you're running

195
00:08:53,580 --> 00:08:56,190
a six but there's a fairly

196
00:08:56,190 --> 00:08:58,110
straightforward translation from the

197
00:08:58,110 --> 00:09:00,890
futuristic syntax to the syntax of today

198
00:09:00,890 --> 00:09:03,839
and if you find these slides online

199
00:09:03,839 --> 00:09:07,560
you'll see that this is all sort of live

200
00:09:07,560 --> 00:09:09,360
editable in case you want to play with

201
00:09:09,360 --> 00:09:12,750
it and see how it works and now I've

202
00:09:12,750 --> 00:09:17,580
ruined it oh well okay so how does that

203
00:09:17,580 --> 00:09:20,339
work well we've got a tool chain that we

204
00:09:20,339 --> 00:09:22,430
have to face book that I've worked on

205
00:09:22,430 --> 00:09:25,170
and that is open source it actually

206
00:09:25,170 --> 00:09:27,029
predates my time at Facebook started

207
00:09:27,029 --> 00:09:28,790
working on it when i worked at quora

208
00:09:28,790 --> 00:09:32,100
it's called recast and it has some

209
00:09:32,100 --> 00:09:34,380
utilities for traversing what are called

210
00:09:34,380 --> 00:09:36,150
abstract syntax trees which are these

211
00:09:36,150 --> 00:09:38,430
sort of object graph representations of

212
00:09:38,430 --> 00:09:41,790
your code and ways of telling what type

213
00:09:41,790 --> 00:09:43,350
of node you're looking at and also ways

214
00:09:43,350 --> 00:09:46,260
of building up new kinds of nodes so you

215
00:09:46,260 --> 00:09:48,540
call recast at parse with a string of

216
00:09:48,540 --> 00:09:50,430
code that gives you back this tree and

217
00:09:50,430 --> 00:09:54,270
then you need to modify the tree hope

218
00:09:54,270 --> 00:09:57,000
you can see this the slides are at

219
00:09:57,000 --> 00:10:00,870
Benjamin without the idea hub I 0 / jazz

220
00:10:00,870 --> 00:10:06,480
camp 2014 if you want to pull that up ok

221
00:10:06,480 --> 00:10:08,700
so we're traversing the tree starting at

222
00:10:08,700 --> 00:10:10,050
the root of it which is typically like

223
00:10:10,050 --> 00:10:13,589
the program type node and this callback

224
00:10:13,589 --> 00:10:15,480
function is going to be called on every

225
00:10:15,480 --> 00:10:17,220
node and we just want to only do

226
00:10:17,220 --> 00:10:18,750
anything for the arrow function

227
00:10:18,750 --> 00:10:20,040
expression it's because we're going to

228
00:10:20,040 --> 00:10:21,420
try to get rid of those and turn them

229
00:10:21,420 --> 00:10:23,310
into plain old good old-fashioned

230
00:10:23,310 --> 00:10:27,450
functions so we grabbed the body of the

231
00:10:27,450 --> 00:10:29,339
arrow function expression if we find one

232
00:10:29,339 --> 00:10:32,820
and if it's an expression function that

233
00:10:32,820 --> 00:10:34,980
is it doesn't have a curly brace block

234
00:10:34,980 --> 00:10:36,420
statement body with a return statement

235
00:10:36,420 --> 00:10:38,329
in it we want to turn it into

236
00:10:38,329 --> 00:10:42,100
one of those because expression

237
00:10:42,100 --> 00:10:45,319
functions are not legal until we have

238
00:10:45,319 --> 00:10:47,329
xmas cryptic so I guess that's a another

239
00:10:47,329 --> 00:10:51,549
feature that we're supporting here and

240
00:10:51,549 --> 00:10:54,529
then we want to create a new function

241
00:10:54,529 --> 00:10:57,470
expression using all the same properties

242
00:10:57,470 --> 00:10:58,999
as the arrow function expression

243
00:10:58,999 --> 00:11:00,079
basically the only thing that's

244
00:11:00,079 --> 00:11:02,569
different is the the type this function

245
00:11:02,569 --> 00:11:04,670
expression now instead of arrow function

246
00:11:04,670 --> 00:11:07,069
expression and then one of the

247
00:11:07,069 --> 00:11:08,899
conveniences of arrow functions is that

248
00:11:08,899 --> 00:11:12,290
they automatically bind to the value of

249
00:11:12,290 --> 00:11:14,389
this in the enclosing environment so we

250
00:11:14,389 --> 00:11:16,129
have to simulate that as well so we're

251
00:11:16,129 --> 00:11:17,899
going to make a member expression out of

252
00:11:17,899 --> 00:11:19,850
our function expression and the

253
00:11:19,850 --> 00:11:22,100
identifier bind and call that as a

254
00:11:22,100 --> 00:11:25,459
method passing this to it right and then

255
00:11:25,459 --> 00:11:27,319
all that remains is to replace the

256
00:11:27,319 --> 00:11:29,209
original arrow function expression with

257
00:11:29,209 --> 00:11:33,350
this bound expression and then you call

258
00:11:33,350 --> 00:11:35,600
recast I'd print with that same abstract

259
00:11:35,600 --> 00:11:38,299
syntax tree grab the little code

260
00:11:38,299 --> 00:11:40,189
property off of the object that it

261
00:11:40,189 --> 00:11:43,459
returns and print that however you want

262
00:11:43,459 --> 00:11:45,290
or write it to a file and it prints out

263
00:11:45,290 --> 00:11:47,949
the thing that we were trying to create

264
00:11:47,949 --> 00:11:51,679
cool so that's sort of a warm-up example

265
00:11:51,679 --> 00:11:53,869
of transforming code at the abstract

266
00:11:53,869 --> 00:11:57,259
syntax tree level and if you already

267
00:11:57,259 --> 00:11:58,489
have a build stuff for static resources

268
00:11:58,489 --> 00:12:02,149
you can have this newfound ability in a

269
00:12:02,149 --> 00:12:03,799
matter of minutes if you use browserify

270
00:12:03,799 --> 00:12:07,939
or some other static build pipeline so

271
00:12:07,939 --> 00:12:12,049
what is this recast thing well I came up

272
00:12:12,049 --> 00:12:14,239
with the name when I first wrote it I

273
00:12:14,239 --> 00:12:15,949
thought it was clever because it

274
00:12:15,949 --> 00:12:17,959
recursively traverses abstract syntax

275
00:12:17,959 --> 00:12:23,299
trees so wreck AST sort of makes sense

276
00:12:23,299 --> 00:12:25,699
at that level but it's also a word an

277
00:12:25,699 --> 00:12:28,100
english verb which means to like melt

278
00:12:28,100 --> 00:12:30,860
some metal down and reshape it or you

279
00:12:30,860 --> 00:12:32,449
know arrange something again remodel

280
00:12:32,449 --> 00:12:34,639
supply a theater work with a new cast

281
00:12:34,639 --> 00:12:37,790
sort of thing so i also like to think it

282
00:12:37,790 --> 00:12:41,689
has some poetry to it so how do you use

283
00:12:41,689 --> 00:12:44,419
recast just to recap you require it you

284
00:12:44,419 --> 00:12:46,160
call recast at parts on the source and

285
00:12:46,160 --> 00:12:47,869
then you get to do literally anything

286
00:12:47,869 --> 00:12:50,769
you want with the abstract syntax tree

287
00:12:50,769 --> 00:12:51,920
recast

288
00:12:51,920 --> 00:12:55,310
care it does bundle suggested traversal

289
00:12:55,310 --> 00:12:57,500
tool but you really don't even have to

290
00:12:57,500 --> 00:12:59,389
use that and I'm not even super thrilled

291
00:12:59,389 --> 00:13:01,430
with it so I recommend you find anything

292
00:13:01,430 --> 00:13:03,529
that works and then you call recast up

293
00:13:03,529 --> 00:13:04,940
print with the modified abstract syntax

294
00:13:04,940 --> 00:13:07,160
tree and you know do whatever you want

295
00:13:07,160 --> 00:13:09,110
with the resulting string so that's

296
00:13:09,110 --> 00:13:11,720
that's how it goes and what's magical

297
00:13:11,720 --> 00:13:13,579
about this like you could just pretty

298
00:13:13,579 --> 00:13:15,860
print the result and that would give you

299
00:13:15,860 --> 00:13:18,199
working code you'd be able to use Eknath

300
00:13:18,199 --> 00:13:20,180
script six today which is part of the

301
00:13:20,180 --> 00:13:21,680
promise here but there's another

302
00:13:21,680 --> 00:13:23,300
property of recast that's pretty cool

303
00:13:23,300 --> 00:13:26,779
that's I think best described as

304
00:13:26,779 --> 00:13:28,300
non-destructive partial source

305
00:13:28,300 --> 00:13:31,310
transformation so it will try to use

306
00:13:31,310 --> 00:13:34,519
reuse original source code for parts of

307
00:13:34,519 --> 00:13:37,910
the tree that you didn't modify which is

308
00:13:37,910 --> 00:13:40,519
cool both because it lets you write

309
00:13:40,519 --> 00:13:42,139
transforms and then generate human

310
00:13:42,139 --> 00:13:44,089
readable diffs and I've done this to

311
00:13:44,089 --> 00:13:46,760
great success in my job at Facebook and

312
00:13:46,760 --> 00:13:51,350
because since the printer knows where

313
00:13:51,350 --> 00:13:53,029
those original fragments of source code

314
00:13:53,029 --> 00:13:55,149
are coming from can actually give you

315
00:13:55,149 --> 00:13:58,310
really good source maps for free totally

316
00:13:58,310 --> 00:14:00,440
automatically for any arbitrary abstract

317
00:14:00,440 --> 00:14:02,000
syntax tree transform you might want to

318
00:14:02,000 --> 00:14:04,610
write so if you like source maps that

319
00:14:04,610 --> 00:14:07,040
might be pretty appealing so this

320
00:14:07,040 --> 00:14:09,740
presents a moral hazard of sorts you can

321
00:14:09,740 --> 00:14:11,000
start writing scripts that you know

322
00:14:11,000 --> 00:14:12,350
rearrange the furniture in your code

323
00:14:12,350 --> 00:14:17,209
base ad nauseam and appear to be you

324
00:14:17,209 --> 00:14:18,620
know the most productive program or

325
00:14:18,620 --> 00:14:20,750
anyone has ever seen and the laziest at

326
00:14:20,750 --> 00:14:25,250
the same time or you can in the Gandhian

327
00:14:25,250 --> 00:14:26,810
sense be the change you want to see in

328
00:14:26,810 --> 00:14:29,810
the world and I my confession is that I

329
00:14:29,810 --> 00:14:31,790
gave in to that temptation the first

330
00:14:31,790 --> 00:14:36,199
temptation for a time there was a couple

331
00:14:36,199 --> 00:14:39,019
of weeks or months at work where I had

332
00:14:39,019 --> 00:14:41,120
written a script that would translate a

333
00:14:41,120 --> 00:14:43,370
lot of old idioms for defining classes

334
00:14:43,370 --> 00:14:45,470
in JavaScript in our code base to the

335
00:14:45,470 --> 00:14:48,110
new ekman script six class syntax and I

336
00:14:48,110 --> 00:14:49,190
was just running it over tens of

337
00:14:49,190 --> 00:14:50,930
thousands of files coming in in the

338
00:14:50,930 --> 00:14:52,370
morning and like you know spending five

339
00:14:52,370 --> 00:14:54,110
minutes or so doing that and then like

340
00:14:54,110 --> 00:14:56,720
waiting for humans to review those gifts

341
00:14:56,720 --> 00:14:59,360
and it's remarkable both the people to

342
00:14:59,360 --> 00:15:01,010
review them and that in a lot of cases

343
00:15:01,010 --> 00:15:02,360
they didn't realize that this had

344
00:15:02,360 --> 00:15:04,290
actually been generated by a script

345
00:15:04,290 --> 00:15:08,370
the beauty of recast and all told I only

346
00:15:08,370 --> 00:15:10,339
converted sixteen hundred or so files

347
00:15:10,339 --> 00:15:12,709
for like a combined hundred fifty

348
00:15:12,709 --> 00:15:15,120
thousand insertions and deletions worth

349
00:15:15,120 --> 00:15:17,759
of diff and I guess you can tell from

350
00:15:17,759 --> 00:15:20,959
this we have about one class per file so

351
00:15:20,959 --> 00:15:24,209
1658 classes the cool thing is that we

352
00:15:24,209 --> 00:15:28,110
now have 3,500 almost 3,600 classes in

353
00:15:28,110 --> 00:15:30,600
the code base today and you know you

354
00:15:30,600 --> 00:15:32,699
know that those extra classes got

355
00:15:32,699 --> 00:15:34,259
written by people who just looked around

356
00:15:34,259 --> 00:15:36,089
at the code base that had been sort of

357
00:15:36,089 --> 00:15:38,399
boot strapped into the new style and

358
00:15:38,399 --> 00:15:40,649
they did what they found everywhere else

359
00:15:40,649 --> 00:15:42,449
they mimicked the style as you should do

360
00:15:42,449 --> 00:15:44,370
in any large code base so that's the

361
00:15:44,370 --> 00:15:46,350
real value of this kind of automatic

362
00:15:46,350 --> 00:15:49,829
source transformation if you get nothing

363
00:15:49,829 --> 00:15:52,139
outside of this talk there's a cool unix

364
00:15:52,139 --> 00:15:53,730
tool called parallel that lets you write

365
00:15:53,730 --> 00:15:55,949
really simple as you know

366
00:15:55,949 --> 00:15:57,930
single-threaded scripts that take one

367
00:15:57,930 --> 00:16:00,149
argument and then run a whole bunch of

368
00:16:00,149 --> 00:16:02,040
copies of them appropriate for you know

369
00:16:02,040 --> 00:16:03,870
the number of cores I've 32 cores and I

370
00:16:03,870 --> 00:16:06,750
my def machine at facebook so i was able

371
00:16:06,750 --> 00:16:09,269
to do something like 230 sort of

372
00:16:09,269 --> 00:16:11,160
subjected seconds worth of work in 12

373
00:16:11,160 --> 00:16:14,550
seconds so that's cool i give a whole

374
00:16:14,550 --> 00:16:16,829
talk actually about this project a

375
00:16:16,829 --> 00:16:19,350
couple of months ago so these these

376
00:16:19,350 --> 00:16:23,250
links will take you there ok so what

377
00:16:23,250 --> 00:16:25,829
about something little trickier as

378
00:16:25,829 --> 00:16:28,019
promised we are going to talk about

379
00:16:28,019 --> 00:16:30,959
generator functions so here's an example

380
00:16:30,959 --> 00:16:34,170
of a generator function and I apologize

381
00:16:34,170 --> 00:16:37,230
that it's not like Fibonacci or

382
00:16:37,230 --> 00:16:39,000
something like that it's a little bit

383
00:16:39,000 --> 00:16:40,769
more sophisticated this had all of the

384
00:16:40,769 --> 00:16:42,240
things that I wanted to talk about in it

385
00:16:42,240 --> 00:16:44,010
so that's why I chose this function for

386
00:16:44,010 --> 00:16:46,319
printing out the or rather yielding each

387
00:16:46,319 --> 00:16:49,980
of the permutations of a given list so I

388
00:16:49,980 --> 00:16:52,050
did look this out to remind myself how

389
00:16:52,050 --> 00:16:55,829
to do this ah so the way it works is if

390
00:16:55,829 --> 00:16:58,470
the list is just 1 or 0 elements that's

391
00:16:58,470 --> 00:17:01,740
the only permutation of the list so you

392
00:17:01,740 --> 00:17:04,770
yield that otherwise you take the list

393
00:17:04,770 --> 00:17:06,540
consisting of just the first element in

394
00:17:06,540 --> 00:17:09,059
the list and then you take all the

395
00:17:09,059 --> 00:17:12,470
permutations of the rest of the list and

396
00:17:12,470 --> 00:17:15,780
for each of those child permutations you

397
00:17:15,780 --> 00:17:18,209
sort of walk the first element

398
00:17:18,209 --> 00:17:22,470
it at each place so you you know none of

399
00:17:22,470 --> 00:17:24,059
those permutations contain that element

400
00:17:24,059 --> 00:17:25,980
but then you put it back in at each

401
00:17:25,980 --> 00:17:28,559
possible place and so when you yield

402
00:17:28,559 --> 00:17:30,330
each of those things you're yielding all

403
00:17:30,330 --> 00:17:32,330
the possible permutations of the list

404
00:17:32,330 --> 00:17:35,730
and here's an example of how you might

405
00:17:35,730 --> 00:17:41,010
use it with the list 132 and get some

406
00:17:41,010 --> 00:17:53,970
water so if you're used to generator

407
00:17:53,970 --> 00:17:56,100
functions in Python you may not be used

408
00:17:56,100 --> 00:17:58,500
to the next method of the generator

409
00:17:58,500 --> 00:18:00,779
object returning little object that has

410
00:18:00,779 --> 00:18:02,580
a value field and a done field but

411
00:18:02,580 --> 00:18:05,309
that's the API that we've decided on for

412
00:18:05,309 --> 00:18:07,799
Agnes crypt 6 so in each of those cases

413
00:18:07,799 --> 00:18:10,039
the value is one of the permutations and

414
00:18:10,039 --> 00:18:12,149
done would be false but then at the very

415
00:18:12,149 --> 00:18:14,370
end done is true and the value is

416
00:18:14,370 --> 00:18:17,370
undefined so that's that's what that's

417
00:18:17,370 --> 00:18:20,159
about there's also another syntax for a

418
00:18:20,159 --> 00:18:22,669
prettier syntax for iterating over the

419
00:18:22,669 --> 00:18:25,529
values of a generator the four of loop

420
00:18:25,529 --> 00:18:28,140
so it's easy to confuse this with 4n but

421
00:18:28,140 --> 00:18:30,210
iterates over the values of its argument

422
00:18:30,210 --> 00:18:39,590
instead of the keys

423
00:18:39,600 --> 00:18:41,980
so how hard could it be to translate

424
00:18:41,980 --> 00:18:44,350
this futuristic syntax into something

425
00:18:44,350 --> 00:18:47,710
that runs in a browser today well this

426
00:18:47,710 --> 00:18:51,790
was like May of 2013 I thought it was

427
00:18:51,790 --> 00:18:54,760
funny to tweet cryptically about having

428
00:18:54,760 --> 00:18:57,130
almost finished my life's work and boy

429
00:18:57,130 --> 00:18:58,690
was that hubris because I wasn't

430
00:18:58,690 --> 00:19:00,940
anywhere close to being done the project

431
00:19:00,940 --> 00:19:02,440
was actually called degenerate at that

432
00:19:02,440 --> 00:19:04,870
point sort of self-deprecating is my

433
00:19:04,870 --> 00:19:07,809
style i guess and i was i was so far

434
00:19:07,809 --> 00:19:10,929
away from being anywhere on top of this

435
00:19:10,929 --> 00:19:12,970
project that i'm glad i didn't actually

436
00:19:12,970 --> 00:19:15,070
identify in this tweet what what i was

437
00:19:15,070 --> 00:19:17,559
talking about it's basically the

438
00:19:17,559 --> 00:19:20,140
trickiest code I've ever written which

439
00:19:20,140 --> 00:19:21,700
may say more about me than the code

440
00:19:21,700 --> 00:19:23,770
itself but I also think it's bad as

441
00:19:23,770 --> 00:19:28,000
tricky as translation or source

442
00:19:28,000 --> 00:19:30,790
transformation gets so if you absorb any

443
00:19:30,790 --> 00:19:33,549
of this then that's great you've

444
00:19:33,549 --> 00:19:38,040
absorbed you know something that is

445
00:19:38,040 --> 00:19:40,240
probably the best example of a really

446
00:19:40,240 --> 00:19:43,120
nasty source to source transformation

447
00:19:43,120 --> 00:19:45,990
and you can do anything at that point

448
00:19:45,990 --> 00:19:49,590
okay so here's our original function and

449
00:19:49,590 --> 00:19:52,330
what's the first step well it's going to

450
00:19:52,330 --> 00:19:56,230
turn out to be convenient if we take all

451
00:19:56,230 --> 00:19:58,059
of the variable declarations from inside

452
00:19:58,059 --> 00:20:00,040
of this function and waste them to the

453
00:20:00,040 --> 00:20:01,240
the top of the function which is

454
00:20:01,240 --> 00:20:03,580
something that JavaScript does anyway so

455
00:20:03,580 --> 00:20:07,870
first PSP and i are now declared at the

456
00:20:07,870 --> 00:20:09,190
first line of the function and wherever

457
00:20:09,190 --> 00:20:12,070
they used to be variable declarations

458
00:20:12,070 --> 00:20:13,600
those are just assignment statements

459
00:20:13,600 --> 00:20:15,760
right so why do we do that why does that

460
00:20:15,760 --> 00:20:16,780
matter that doesn't actually change

461
00:20:16,780 --> 00:20:20,559
anything yet well then introduce a

462
00:20:20,559 --> 00:20:22,299
couple more variables some temporary

463
00:20:22,299 --> 00:20:27,340
variables and a loop variable I yeah

464
00:20:27,340 --> 00:20:30,160
okay the reason for that t0 and t1 is

465
00:20:30,160 --> 00:20:31,480
that we're going to turn the four of

466
00:20:31,480 --> 00:20:33,549
loop just into a while loop so that we

467
00:20:33,549 --> 00:20:34,870
can treat it the same way as any other

468
00:20:34,870 --> 00:20:38,590
while loop so if you if you see 4p of PS

469
00:20:38,590 --> 00:20:40,990
it's now going to change into this call

470
00:20:40,990 --> 00:20:43,480
to the values function of our little

471
00:20:43,480 --> 00:20:46,600
runtime object wrap generator and then

472
00:20:46,600 --> 00:20:48,610
just going to iterate over that

473
00:20:48,610 --> 00:20:50,890
generator calling next until it's done

474
00:20:50,890 --> 00:20:51,710
and each

475
00:20:51,710 --> 00:20:53,870
time it will assign the value to the

476
00:20:53,870 --> 00:20:55,850
loop variable P so now we've got a plain

477
00:20:55,850 --> 00:20:57,710
old while lib don't have to care about

478
00:20:57,710 --> 00:21:00,830
four of loops anymore okay so still

479
00:21:00,830 --> 00:21:02,240
haven't really changed anything still

480
00:21:02,240 --> 00:21:04,850
have yield expressions and it's still a

481
00:21:04,850 --> 00:21:07,610
generator but now we're going to return

482
00:21:07,610 --> 00:21:10,669
a an anonymous generator that doesn't

483
00:21:10,669 --> 00:21:12,409
take any arguments it's just a closure

484
00:21:12,409 --> 00:21:14,600
that has all of those variables in its

485
00:21:14,600 --> 00:21:17,690
scope and so now now we're beginning to

486
00:21:17,690 --> 00:21:20,929
get somewhere and so this is a big leap

487
00:21:20,929 --> 00:21:23,600
but we need to turn the body of this

488
00:21:23,600 --> 00:21:25,190
function into something that can execute

489
00:21:25,190 --> 00:21:28,610
in JavaScript of today and my idea for

490
00:21:28,610 --> 00:21:31,580
how to do that is to have a switch

491
00:21:31,580 --> 00:21:34,149
statement inside of a wild true loop

492
00:21:34,149 --> 00:21:36,679
where the cases of the switch statement

493
00:21:36,679 --> 00:21:39,730
are jump targets that we can sort of

494
00:21:39,730 --> 00:21:42,590
jump to as if we had a go-to statement

495
00:21:42,590 --> 00:21:44,210
in JavaScript which sounds like the

496
00:21:44,210 --> 00:21:45,470
worst thing in the world but ends up

497
00:21:45,470 --> 00:21:48,770
being pretty cool so the first one is

498
00:21:48,770 --> 00:21:50,899
case zero as you might imagine and this

499
00:21:50,899 --> 00:21:52,700
is going to test to see what the length

500
00:21:52,700 --> 00:21:54,370
of the list is if it's less than two

501
00:21:54,370 --> 00:21:58,159
we're going to jump to case five and we

502
00:21:58,159 --> 00:22:00,110
do that by setting contacts next to five

503
00:22:00,110 --> 00:22:01,640
and then breaking which you'll note

504
00:22:01,640 --> 00:22:03,320
breaks out of the switch statement but

505
00:22:03,320 --> 00:22:05,299
not the while loop so we loop back

506
00:22:05,299 --> 00:22:07,220
around for another iteration context

507
00:22:07,220 --> 00:22:13,820
next is five and then case five will

508
00:22:13,820 --> 00:22:17,390
come later you may remember in this case

509
00:22:17,390 --> 00:22:19,270
that we wanted to yield the list itself

510
00:22:19,270 --> 00:22:21,980
so the way we do that is by returning

511
00:22:21,980 --> 00:22:23,870
the list so that's the answer to what

512
00:22:23,870 --> 00:22:25,399
happens to the yield expression it

513
00:22:25,399 --> 00:22:28,490
becomes a return statement but we want

514
00:22:28,490 --> 00:22:30,620
to know where to come back to after we

515
00:22:30,620 --> 00:22:32,779
call back into the the generator next

516
00:22:32,779 --> 00:22:34,909
function so we've set context I next two

517
00:22:34,909 --> 00:22:36,260
three in this case which is the next

518
00:22:36,260 --> 00:22:39,799
case and if you remember in that case

519
00:22:39,799 --> 00:22:41,630
after we yield that one value of the

520
00:22:41,630 --> 00:22:43,549
list we're done so we're going to jump

521
00:22:43,549 --> 00:22:45,679
all the way to the end which happens to

522
00:22:45,679 --> 00:22:49,130
be a case 19 as you can see over there

523
00:22:49,130 --> 00:22:51,770
on the side which is called context stop

524
00:22:51,770 --> 00:22:54,200
shuts everything down and freeze some

525
00:22:54,200 --> 00:22:58,309
memory and so that's the like you know

526
00:22:58,309 --> 00:23:02,539
abort abort case but in case the length

527
00:23:02,539 --> 00:23:04,909
was not less than 2 then we were going

528
00:23:04,909 --> 00:23:05,420
to jump to

529
00:23:05,420 --> 00:23:08,720
the fifth case and here it is this is

530
00:23:08,720 --> 00:23:12,920
where we call where we get the first

531
00:23:12,920 --> 00:23:14,780
element as a list and then the rest of

532
00:23:14,780 --> 00:23:17,120
the permutations and the values of those

533
00:23:17,120 --> 00:23:19,690
that permutations object and we

534
00:23:19,690 --> 00:23:21,740
deliberately fall through which is

535
00:23:21,740 --> 00:23:22,910
another thing you should probably never

536
00:23:22,910 --> 00:23:24,350
do when you're writing a real switch

537
00:23:24,350 --> 00:23:25,550
statement but in this case it is

538
00:23:25,550 --> 00:23:27,970
intentional that we fall through to case

539
00:23:27,970 --> 00:23:30,050
8k say it exists just so that we can

540
00:23:30,050 --> 00:23:34,940
jump back to it by the way and then if

541
00:23:34,940 --> 00:23:38,360
we are if we are done with the generator

542
00:23:38,360 --> 00:23:40,190
we're going to jump to a case 19 which

543
00:23:40,190 --> 00:23:42,740
is the the final case otherwise we're

544
00:23:42,740 --> 00:23:44,540
going to set the loop variable to the

545
00:23:44,540 --> 00:23:48,380
value of the most recent thing that was

546
00:23:48,380 --> 00:23:50,170
returned by the generator next method

547
00:23:50,170 --> 00:23:53,840
and now here's our sort of obliterated

548
00:23:53,840 --> 00:23:57,020
vassar rated for loop or setting I the

549
00:23:57,020 --> 00:23:59,930
loop index variable 20 and the loop head

550
00:23:59,930 --> 00:24:03,190
location is this case 11 and while the

551
00:24:03,190 --> 00:24:05,570
while I is less than list of length

552
00:24:05,570 --> 00:24:12,290
we're going to jump to 17 or in case it

553
00:24:12,290 --> 00:24:13,910
is not less than length we jump to 17

554
00:24:13,910 --> 00:24:18,050
otherwise we plan on jump in back to 14

555
00:24:18,050 --> 00:24:20,720
after we yield this expression and I

556
00:24:20,720 --> 00:24:22,730
think this is a good illustration of

557
00:24:22,730 --> 00:24:26,270
what's cool about recast so this these

558
00:24:26,270 --> 00:24:28,100
comments here this like practice that

559
00:24:28,100 --> 00:24:30,860
people have some people of lining their

560
00:24:30,860 --> 00:24:32,330
comments up vertically especially when

561
00:24:32,330 --> 00:24:33,890
all the words are the same link finishes

562
00:24:33,890 --> 00:24:37,480
so visually pleasing that's that's very

563
00:24:37,480 --> 00:24:40,280
idiomatic it's very hard to capture in

564
00:24:40,280 --> 00:24:42,950
code to identify the intent of that

565
00:24:42,950 --> 00:24:45,050
formatting and try to like recreate it

566
00:24:45,050 --> 00:24:48,380
later if you're pretty printing so the

567
00:24:48,380 --> 00:24:49,760
fact that recast is able to just take

568
00:24:49,760 --> 00:24:51,770
that whole rate up prototype duck and

569
00:24:51,770 --> 00:24:55,400
cat dot call blah expression and just

570
00:24:55,400 --> 00:24:58,400
copy it over to the output and you'll

571
00:24:58,400 --> 00:25:00,800
notice it's actually indented it by two

572
00:25:00,800 --> 00:25:04,160
spaces means that in large part the

573
00:25:04,160 --> 00:25:05,540
parts of the the tree that you haven't

574
00:25:05,540 --> 00:25:07,550
touched just carry over all of their

575
00:25:07,550 --> 00:25:09,230
idiomatic formatting and you don't have

576
00:25:09,230 --> 00:25:11,840
to apologize for that when you submit a

577
00:25:11,840 --> 00:25:15,560
diff for humans to review ok so we're

578
00:25:15,560 --> 00:25:17,900
yielding that permutation which is

579
00:25:17,900 --> 00:25:20,120
concatenation of a prefix and the first

580
00:25:20,120 --> 00:25:23,810
element and a suffix and then coming

581
00:25:23,810 --> 00:25:26,090
back to case 14 the next time we call in

582
00:25:26,090 --> 00:25:28,370
to the generator and this is the update

583
00:25:28,370 --> 00:25:30,050
case of that for loop so we're

584
00:25:30,050 --> 00:25:31,610
incrementing the loop variable and then

585
00:25:31,610 --> 00:25:34,550
jumping back to case 11 which was which

586
00:25:34,550 --> 00:25:36,770
was the head of that loop where we test

587
00:25:36,770 --> 00:25:39,110
the length and eventually I is not going

588
00:25:39,110 --> 00:25:41,150
to be less than the length anymore and

589
00:25:41,150 --> 00:25:44,300
so we're going to get jumped to the the

590
00:25:44,300 --> 00:25:48,860
case 17 here and where is that taking us

591
00:25:48,860 --> 00:25:51,260
let's see Oh remember we were inside of

592
00:25:51,260 --> 00:25:53,450
a while loop so we need to jump back to

593
00:25:53,450 --> 00:25:55,340
the head of that while loop and then

594
00:25:55,340 --> 00:25:57,620
continue testing the result of the

595
00:25:57,620 --> 00:26:00,290
generator to see if we're done finally

596
00:26:00,290 --> 00:26:02,540
there are a lot of permutations of even

597
00:26:02,540 --> 00:26:05,090
small lists so you can see how this ends

598
00:26:05,090 --> 00:26:06,920
up generating a lot of them but that's

599
00:26:06,920 --> 00:26:09,620
it that's java script that runs in a

600
00:26:09,620 --> 00:26:13,490
browser today with one exception I still

601
00:26:13,490 --> 00:26:14,900
haven't explained where this context

602
00:26:14,900 --> 00:26:16,610
object comes from and I'm going to sort

603
00:26:16,610 --> 00:26:19,130
of wave my hands here but we're going to

604
00:26:19,130 --> 00:26:21,080
pass the whole anonymous function to

605
00:26:21,080 --> 00:26:24,320
this wrap generator runtime function and

606
00:26:24,320 --> 00:26:25,970
that will return the generator object

607
00:26:25,970 --> 00:26:29,120
that has the next method and also make

608
00:26:29,120 --> 00:26:30,950
sure that the context gets passed in in

609
00:26:30,950 --> 00:26:35,210
each case okay so if you stuck with me

610
00:26:35,210 --> 00:26:37,310
through that then you understand how

611
00:26:37,310 --> 00:26:45,140
regenerator works yeah well that's a

612
00:26:45,140 --> 00:26:52,310
good question yeah yeah I if I could

613
00:26:52,310 --> 00:26:55,610
make it prettier I certainly would but I

614
00:26:55,610 --> 00:26:57,920
will say this is a function that has

615
00:26:57,920 --> 00:26:59,750
like multiple yields in it and loops and

616
00:26:59,750 --> 00:27:01,490
everything so it's like a good example

617
00:27:01,490 --> 00:27:03,770
in a fairly compact space of like all

618
00:27:03,770 --> 00:27:05,270
the features of a generator which is

619
00:27:05,270 --> 00:27:07,340
contributing in part to it looking

620
00:27:07,340 --> 00:27:09,890
pretty messy but you could imagine

621
00:27:09,890 --> 00:27:12,560
stepping through this and debugging the

622
00:27:12,560 --> 00:27:15,490
code with a little bit of context I hope

623
00:27:15,490 --> 00:27:19,929
maybe that's wishful thinking all right

624
00:27:19,929 --> 00:27:22,779
so that's all well and good you can

625
00:27:22,779 --> 00:27:24,309
convince yourself if you stare that

626
00:27:24,309 --> 00:27:25,659
could long enough that it kind of does

627
00:27:25,659 --> 00:27:27,759
what it's supposed to do generate some

628
00:27:27,759 --> 00:27:32,009
permutations but how in the world do you

629
00:27:32,009 --> 00:27:34,450
programmatically generate code like that

630
00:27:34,450 --> 00:27:38,169
from ECMO script six so i'll show you

631
00:27:38,169 --> 00:27:41,679
how a for statement which is you know

632
00:27:41,679 --> 00:27:44,230
the normal like three part for statement

633
00:27:44,230 --> 00:27:45,940
rather than a for n if we rub statement

634
00:27:45,940 --> 00:27:49,419
gets code generated alright so this is

635
00:27:49,419 --> 00:27:53,139
an actual case from the emitter code for

636
00:27:53,139 --> 00:27:55,240
a generator so when we encounter

637
00:27:55,240 --> 00:27:58,360
something of type for statement we first

638
00:27:58,360 --> 00:28:02,230
create a series of locations and these

639
00:28:02,230 --> 00:28:07,179
are sort of like uninitialized literal

640
00:28:07,179 --> 00:28:09,759
numeric values that are going to end up

641
00:28:09,759 --> 00:28:14,350
becoming jump targets and case labels in

642
00:28:14,350 --> 00:28:17,289
that switch statement and so if the for

643
00:28:17,289 --> 00:28:19,899
statement does have an in a net part the

644
00:28:19,899 --> 00:28:21,759
like variable declaration thing we're

645
00:28:21,759 --> 00:28:24,039
going to explode that which is my sort

646
00:28:24,039 --> 00:28:27,429
of made-up terminology for turning it

647
00:28:27,429 --> 00:28:29,470
into like a state machine if it contains

648
00:28:29,470 --> 00:28:33,369
any yields and then we're going to mark

649
00:28:33,369 --> 00:28:36,429
the head to say you know now we're at a

650
00:28:36,429 --> 00:28:38,350
place where we would want to jump back

651
00:28:38,350 --> 00:28:40,059
to if we were doing another iteration of

652
00:28:40,059 --> 00:28:43,269
the loop if there's a test in the for

653
00:28:43,269 --> 00:28:44,919
statement and it doesn't have to be a

654
00:28:44,919 --> 00:28:49,029
test then if the test is false we jump

655
00:28:49,029 --> 00:28:51,999
to the after location and note that we

656
00:28:51,999 --> 00:28:53,409
don't even really know where the after

657
00:28:53,409 --> 00:28:55,840
location is yet but it's still fine to

658
00:28:55,840 --> 00:28:57,789
plan on jumping there when we do know

659
00:28:57,789 --> 00:29:01,149
and then because this is a loop we want

660
00:29:01,149 --> 00:29:02,619
to keep track of what loops were inside

661
00:29:02,619 --> 00:29:04,509
in case we come across a break or a

662
00:29:04,509 --> 00:29:06,490
continue or return that we need to

663
00:29:06,490 --> 00:29:08,499
interpret in that context so there's

664
00:29:08,499 --> 00:29:13,690
this leap manager leap is my made-up

665
00:29:13,690 --> 00:29:15,879
term for a break or continue or a yield

666
00:29:15,879 --> 00:29:18,850
or a throw that knows how to deal with

667
00:29:18,850 --> 00:29:21,279
those things and there's we're putting a

668
00:29:21,279 --> 00:29:24,179
new loop entry onto that stack and then

669
00:29:24,179 --> 00:29:28,620
exploding the the body of the loop

670
00:29:28,630 --> 00:29:32,650
and now after the body we are going to

671
00:29:32,650 --> 00:29:35,050
omit the code for the update part of the

672
00:29:35,050 --> 00:29:37,420
for statement and so we need to mark

673
00:29:37,420 --> 00:29:39,880
that so we can jump to it if there is an

674
00:29:39,880 --> 00:29:41,110
update part I guess I might have been

675
00:29:41,110 --> 00:29:43,450
able to avoid marking it if there wasn't

676
00:29:43,450 --> 00:29:46,690
but I did then we generate code for that

677
00:29:46,690 --> 00:29:50,260
and we met some code that jumps back to

678
00:29:50,260 --> 00:29:52,360
the head of the loop so we're going to

679
00:29:52,360 --> 00:29:55,360
go right back to the test part and then

680
00:29:55,360 --> 00:29:58,030
mark the after part and so now we've

681
00:29:58,030 --> 00:29:59,530
marked all of our locations they have

682
00:29:59,530 --> 00:30:03,570
actual numeric values and can be used in

683
00:30:03,570 --> 00:30:06,760
the code that generated and now we're

684
00:30:06,760 --> 00:30:09,370
done so we break out of this case we've

685
00:30:09,370 --> 00:30:12,100
successfully emitted code for a for

686
00:30:12,100 --> 00:30:18,250
statement so how does look work it's

687
00:30:18,250 --> 00:30:19,960
actually dead simple simplest thing in

688
00:30:19,960 --> 00:30:23,470
the talk it returns a literal abstract

689
00:30:23,470 --> 00:30:26,320
syntax tree node object initialized to

690
00:30:26,320 --> 00:30:28,210
negative one just as a sentinel for this

691
00:30:28,210 --> 00:30:32,500
is not good yet and then when we mark it

692
00:30:32,500 --> 00:30:34,690
we're keeping this listing of all of the

693
00:30:34,690 --> 00:30:36,850
statements that we've emitted so far so

694
00:30:36,850 --> 00:30:38,710
we know what the next one what the the

695
00:30:38,710 --> 00:30:40,570
location of the next one is going to be

696
00:30:40,570 --> 00:30:43,420
so mark assigns that location to

697
00:30:43,420 --> 00:30:48,850
whatever literal node you pass into it

698
00:30:48,850 --> 00:30:51,220
and goes I haven't initializes it and

699
00:30:51,220 --> 00:30:52,600
had some assertions about it not being

700
00:30:52,600 --> 00:30:55,960
already initialized and so forth so once

701
00:30:55,960 --> 00:30:57,250
we've marked something we know that

702
00:30:57,250 --> 00:30:59,440
we're going to emit a case statement in

703
00:30:59,440 --> 00:31:02,080
the in the switch statement eventually

704
00:31:02,080 --> 00:31:06,910
all right so b dot literal and in that

705
00:31:06,910 --> 00:31:08,950
literal maybe a little confusing those

706
00:31:08,950 --> 00:31:11,620
are actually provided by recast if if

707
00:31:11,620 --> 00:31:13,900
you recall you could say require recast

708
00:31:13,900 --> 00:31:15,940
at types that builders that literal and

709
00:31:15,940 --> 00:31:19,230
require recast at types that named types

710
00:31:19,230 --> 00:31:22,409
cool

711
00:31:22,419 --> 00:31:24,609
right so this is an example about how

712
00:31:24,609 --> 00:31:28,119
that jump if not thing works and it's

713
00:31:28,119 --> 00:31:30,429
pretty straightforward but I'm not going

714
00:31:30,429 --> 00:31:33,519
to spend time on it right now basically

715
00:31:33,519 --> 00:31:35,409
you do some assertions and you try to

716
00:31:35,409 --> 00:31:38,859
avoid having double negation if possible

717
00:31:38,859 --> 00:31:40,359
just because that was a problem that I

718
00:31:40,359 --> 00:31:42,369
could fix and it makes the code nicer

719
00:31:42,369 --> 00:31:46,049
and then you emit an if statement that

720
00:31:46,049 --> 00:31:49,629
sets the context next property to the

721
00:31:49,629 --> 00:31:50,739
next location that you want to jump to

722
00:31:50,739 --> 00:31:55,230
and also admit a break statement so I

723
00:31:55,230 --> 00:31:57,820
know I race through that but I think it

724
00:31:57,820 --> 00:31:59,230
will be self-explanatory if you were to

725
00:31:59,230 --> 00:32:02,109
go back and look at it all right so

726
00:32:02,109 --> 00:32:07,210
explode statement is the last of the

727
00:32:07,210 --> 00:32:09,220
sort of drill down examples that I want

728
00:32:09,220 --> 00:32:11,710
to talk about I don't think I actually

729
00:32:11,710 --> 00:32:14,139
have time to go through it but the

730
00:32:14,139 --> 00:32:19,059
interesting part about it is that recast

731
00:32:19,059 --> 00:32:21,879
or sorry regenerator understands whether

732
00:32:21,879 --> 00:32:24,789
a statement or an expression contains

733
00:32:24,789 --> 00:32:26,859
any yield expressions or any problematic

734
00:32:26,859 --> 00:32:30,489
breaks or continues and if it doesn't if

735
00:32:30,489 --> 00:32:32,529
it doesn't in my terminology contain

736
00:32:32,529 --> 00:32:35,739
leap then we can just omit the statement

737
00:32:35,739 --> 00:32:38,049
as it was so a large part of the

738
00:32:38,049 --> 00:32:40,989
performance promises of regenerator are

739
00:32:40,989 --> 00:32:42,730
that if you're not using yield in a

740
00:32:42,730 --> 00:32:44,859
certain part of your code it just is

741
00:32:44,859 --> 00:32:49,149
left untouched you could imagine you

742
00:32:49,149 --> 00:32:50,859
know exploding everything out into a big

743
00:32:50,859 --> 00:32:52,359
state machine that is much longer than

744
00:32:52,359 --> 00:32:54,909
your original code and that would be you

745
00:32:54,909 --> 00:32:58,590
know perhaps logically correct but not

746
00:32:58,590 --> 00:33:02,429
performant or very easily compressible

747
00:33:02,429 --> 00:33:05,379
okay another exciting part is what

748
00:33:05,379 --> 00:33:06,999
happens if an exception gets thrown in

749
00:33:06,999 --> 00:33:09,009
the middle of the state machine and the

750
00:33:09,009 --> 00:33:10,840
secret to that is remembering where you

751
00:33:10,840 --> 00:33:13,570
last knew that you were and having a

752
00:33:13,570 --> 00:33:16,809
little map that can be inspected to

753
00:33:16,809 --> 00:33:20,049
figure out what try statement or catch

754
00:33:20,049 --> 00:33:22,090
block or finally block you're inside of

755
00:33:22,090 --> 00:33:26,830
and sort of twiddles context next and

756
00:33:26,830 --> 00:33:29,440
then calls back into the generator and

757
00:33:29,440 --> 00:33:32,950
so you appear to resume at the the place

758
00:33:32,950 --> 00:33:35,710
where you expected to for instance you

759
00:33:35,710 --> 00:33:37,679
an exception is thrown by this block

760
00:33:37,679 --> 00:33:40,779
you'll resume in the code that was

761
00:33:40,779 --> 00:33:43,960
emitted for the catch block so this

762
00:33:43,960 --> 00:33:46,059
whole example actually works and ends up

763
00:33:46,059 --> 00:33:49,360
being surprisingly short and I'll I'll

764
00:33:49,360 --> 00:33:52,299
leave that for free to go through if you

765
00:33:52,299 --> 00:33:56,010
are so inclined and then here's the

766
00:33:56,010 --> 00:33:58,630
runtime code that supports all of that

767
00:33:58,630 --> 00:34:00,220
and the interesting thing about this is

768
00:34:00,220 --> 00:34:02,350
that it's invoking this in the very

769
00:34:02,350 --> 00:34:04,090
middle the inner function that's the

770
00:34:04,090 --> 00:34:05,140
function with the switch statement

771
00:34:05,140 --> 00:34:07,630
inside of it that we've been talking

772
00:34:07,630 --> 00:34:09,970
about so far and so that's where you see

773
00:34:09,970 --> 00:34:12,609
it's passed in the context and we get

774
00:34:12,609 --> 00:34:15,190
the value back out if everything is ok

775
00:34:15,190 --> 00:34:18,399
we return the object with value and done

776
00:34:18,399 --> 00:34:20,800
properties if there's an exception then

777
00:34:20,800 --> 00:34:23,740
we call context dispatch exception with

778
00:34:23,740 --> 00:34:25,720
that exception value and that's what

779
00:34:25,720 --> 00:34:27,970
sets everything up for control to resume

780
00:34:27,970 --> 00:34:33,280
in the exceptional control path all

781
00:34:33,280 --> 00:34:36,040
right so the good news is as mentioned

782
00:34:36,040 --> 00:34:37,599
earlier this is pretty much as hard as

783
00:34:37,599 --> 00:34:39,849
it gets which may not sound like good

784
00:34:39,849 --> 00:34:43,750
news but like this was a hard project

785
00:34:43,750 --> 00:34:46,690
for me I'll be honest and it took a

786
00:34:46,690 --> 00:34:48,310
while to wrap my head around these

787
00:34:48,310 --> 00:34:51,970
things and so it's means nothing if it

788
00:34:51,970 --> 00:34:54,460
if it takes you a while to wrap your

789
00:34:54,460 --> 00:34:57,310
head around them as well but if you pick

790
00:34:57,310 --> 00:34:59,380
up on anything here at least gotten a

791
00:34:59,380 --> 00:35:01,180
sense for like how complicated this is

792
00:35:01,180 --> 00:35:04,330
or in the end how tractable it is then

793
00:35:04,330 --> 00:35:07,180
that's great and you can do a lot of

794
00:35:07,180 --> 00:35:09,310
smaller things like adding support for

795
00:35:09,310 --> 00:35:11,260
async functions and weight expressions

796
00:35:11,260 --> 00:35:14,560
to the language in like this much code

797
00:35:14,560 --> 00:35:16,390
this is the entire run time for that

798
00:35:16,390 --> 00:35:18,670
really cool acma script 7 feature that's

799
00:35:18,670 --> 00:35:19,960
coming down the pipe and that's already

800
00:35:19,960 --> 00:35:23,080
implemented in a pull request for a

801
00:35:23,080 --> 00:35:26,440
generator but I just mentioned that's a

802
00:35:26,440 --> 00:35:28,869
necklace crypt 7 feature not echo script

803
00:35:28,869 --> 00:35:30,520
six so we're not just bridging the gap

804
00:35:30,520 --> 00:35:33,070
here between today and whenever acma

805
00:35:33,070 --> 00:35:35,109
script 6 is fully supported we're always

806
00:35:35,109 --> 00:35:39,089
going to be looking into the future so

807
00:35:39,089 --> 00:35:41,550
my motto is always be transpiring

808
00:35:41,550 --> 00:35:44,440
because incremental translation is the

809
00:35:44,440 --> 00:35:46,780
key to avoiding that pythons 3 trap for

810
00:35:46,780 --> 00:35:48,910
JavaScript that's how we bring about the

811
00:35:48,910 --> 00:35:49,390
future with

812
00:35:49,390 --> 00:35:52,000
choking on it and it's how we know that

813
00:35:52,000 --> 00:35:53,050
the future is actually going to be

814
00:35:53,050 --> 00:35:56,710
pretty great because it's as I said

815
00:35:56,710 --> 00:35:59,280
before linguistic time travel of a sort

816
00:35:59,280 --> 00:36:01,990
still really hard not everything can be

817
00:36:01,990 --> 00:36:03,280
transpired I don't know what to do

818
00:36:03,280 --> 00:36:06,490
without prescrip symbols and st

819
00:36:06,490 --> 00:36:07,690
transforms don't always play well

820
00:36:07,690 --> 00:36:09,490
together to transforms could be

821
00:36:09,490 --> 00:36:11,320
competing to be like the thing that adds

822
00:36:11,320 --> 00:36:12,700
something to the first line of a

823
00:36:12,700 --> 00:36:14,950
function and who wins well it just you

824
00:36:14,950 --> 00:36:16,960
have to figure out which one should come

825
00:36:16,960 --> 00:36:18,790
first you have to break that tie and you

826
00:36:18,790 --> 00:36:21,640
can't really do that automatically you

827
00:36:21,640 --> 00:36:22,780
really need to have something like

828
00:36:22,780 --> 00:36:24,520
source maps when you're hugging

829
00:36:24,520 --> 00:36:26,320
generated code like we just went through

830
00:36:26,320 --> 00:36:29,530
because it's not as readable as the

831
00:36:29,530 --> 00:36:32,290
futuristic syntax for sure and the

832
00:36:32,290 --> 00:36:33,700
language specification can totally

833
00:36:33,700 --> 00:36:35,890
change out from under you a saint can

834
00:36:35,890 --> 00:36:37,900
wait not specified yet might have to

835
00:36:37,900 --> 00:36:40,060
rewrite that pull request but it wasn't

836
00:36:40,060 --> 00:36:41,470
too much effort in the first place so

837
00:36:41,470 --> 00:36:44,140
I'm going to try to track those changes

838
00:36:44,140 --> 00:36:47,470
as they come so my team at Facebook

839
00:36:47,470 --> 00:36:48,730
JavaScript infrastructure is gonna be

840
00:36:48,730 --> 00:36:51,190
working with this as long as it takes to

841
00:36:51,190 --> 00:36:54,730
make the process seamless and it's all

842
00:36:54,730 --> 00:36:56,290
gonna be open source we're just getting

843
00:36:56,290 --> 00:36:58,660
started and you are absolutely more than

