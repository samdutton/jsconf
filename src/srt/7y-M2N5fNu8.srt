1
00:00:10,219 --> 00:00:13,920

so I wanted to talk today a little bit

2
00:00:13,920 --> 00:00:16,590
about a proposal that I've been working

3
00:00:16,590 --> 00:00:23,010
on sort of to hopefully give us a better

4
00:00:23,010 --> 00:00:25,760
Dom API to work with in the browser

5
00:00:25,760 --> 00:00:30,000
I've been working with different browser

6
00:00:30,000 --> 00:00:33,440
vendors I've been working with Mozilla

7
00:00:33,440 --> 00:00:36,600
the Internet Explorer team I've been and

8
00:00:36,600 --> 00:00:38,969
I've been talking with the w3c about

9
00:00:38,969 --> 00:00:41,969
coming up with a good API that we can

10
00:00:41,969 --> 00:00:46,530
all work with so with the core of my

11
00:00:46,530 --> 00:00:51,930
proposal centers around is the build

12
00:00:51,930 --> 00:00:56,960
list no list is a highly underused

13
00:00:56,960 --> 00:00:59,969
object in java javascript in the dom

14
00:00:59,969 --> 00:01:03,989
right now you can get a no list in a

15
00:01:03,989 --> 00:01:05,489
couple of ways you can get a no list but

16
00:01:05,489 --> 00:01:07,740
if you want to do child nodes for

17
00:01:07,740 --> 00:01:08,970
example child nodes will give you a no

18
00:01:08,970 --> 00:01:11,130
list if you do get elements by tag name

19
00:01:11,130 --> 00:01:12,570
that will give you a no list query

20
00:01:12,570 --> 00:01:15,479
selector all I'll give you a no list and

21
00:01:15,479 --> 00:01:16,860
all these no lists have sort of

22
00:01:16,860 --> 00:01:18,750
different states some node lists or

23
00:01:18,750 --> 00:01:20,490
static in that they're just they just

24
00:01:20,490 --> 00:01:22,020
don't change like if you if you do query

25
00:01:22,020 --> 00:01:23,810
selector all you'll just get back

26
00:01:23,810 --> 00:01:27,150
spectively a glorified array that isn't

27
00:01:27,150 --> 00:01:29,220
an array it's much less useful than an

28
00:01:29,220 --> 00:01:32,850
array and that's not changing but if you

29
00:01:32,850 --> 00:01:35,280
do get elements by tag name that's also

30
00:01:35,280 --> 00:01:37,530
no list but it's updated live every

31
00:01:37,530 --> 00:01:39,570
single time a new for example div comes

32
00:01:39,570 --> 00:01:41,130
into the page that node list gets

33
00:01:41,130 --> 00:01:45,689
updated dynamically there's also the

34
00:01:45,689 --> 00:01:51,869
concept of HTML collection it's in it's

35
00:01:51,869 --> 00:01:55,259
in a it was in the current specification

36
00:01:55,259 --> 00:01:57,180
but it's also on html5 and it's not

37
00:01:57,180 --> 00:01:59,430
really clear why htmlcollection exists

38
00:01:59,430 --> 00:02:02,579
since it is just an old list but so we

39
00:02:02,579 --> 00:02:04,020
have this kind of you know bastard child

40
00:02:04,020 --> 00:02:05,969
existing here that really should be

41
00:02:05,969 --> 00:02:08,399
killed off or something but anyway so

42
00:02:08,399 --> 00:02:10,410
what I wanted to do is take this concept

43
00:02:10,410 --> 00:02:12,569
of a know list which is kind

44
00:02:12,569 --> 00:02:13,980
neutered right now it doesn't really

45
00:02:13,980 --> 00:02:15,749
like I said it's a sort of an array that

46
00:02:15,749 --> 00:02:17,370
doesn't really have any meat to it and

47
00:02:17,370 --> 00:02:22,889
make it actually useful part of dom the

48
00:02:22,889 --> 00:02:25,730
reason why i wanted to do this is that

49
00:02:25,730 --> 00:02:30,019
this concept of that you see in a lot of

50
00:02:30,019 --> 00:02:34,079
frameworks now it's a thing sort of

51
00:02:34,079 --> 00:02:36,269
originated by what we did in jquery

52
00:02:36,269 --> 00:02:38,519
originally which is effectively instead

53
00:02:38,519 --> 00:02:40,290
of operation instead of operating on a

54
00:02:40,290 --> 00:02:41,459
single element at a time

55
00:02:41,459 --> 00:02:43,530
you operate simultaneously against sets

56
00:02:43,530 --> 00:02:45,930
of elements and as it stands right now

57
00:02:45,930 --> 00:02:47,250
the browser doesn't really provide a

58
00:02:47,250 --> 00:02:50,099
mechanism for doing that so i wanted to

59
00:02:50,099 --> 00:02:51,389
provide some abilities to make that

60
00:02:51,389 --> 00:02:59,340
possible to start i i'm introducing a

61
00:02:59,340 --> 00:03:02,939
new method called a create node list and

62
00:03:02,939 --> 00:03:05,370
create no list of works are like create

63
00:03:05,370 --> 00:03:08,219
element and other functions of that

64
00:03:08,219 --> 00:03:11,219
nature and you can pass in an array of

65
00:03:11,219 --> 00:03:14,579
nodes an object essentially any object

66
00:03:14,579 --> 00:03:15,949
that kind of looks like an array of

67
00:03:15,949 --> 00:03:27,239
nodes so you can pass in for example you

68
00:03:27,239 --> 00:03:29,220
could pass them down and it would it

69
00:03:29,220 --> 00:03:31,169
would understand it and turn that into a

70
00:03:31,169 --> 00:03:34,290
node list as the output now effectively

71
00:03:34,290 --> 00:03:36,959
what I define a know list as because

72
00:03:36,959 --> 00:03:38,549
since up until this point there has been

73
00:03:38,549 --> 00:03:41,040
no no definition of what a no list

74
00:03:41,040 --> 00:03:43,229
should be it's just sort of this kind of

75
00:03:43,229 --> 00:03:46,409
mysterious sort of list so what I say is

76
00:03:46,409 --> 00:03:50,519
that a no list is you know has has these

77
00:03:50,519 --> 00:03:52,949
properties for each individual node

78
00:03:52,949 --> 00:03:54,419
that's contained in the in this

79
00:03:54,419 --> 00:03:57,090
container has a length additionally all

80
00:03:57,090 --> 00:03:58,829
the nodes are guaranteed to be in

81
00:03:58,829 --> 00:04:01,739
document order so if you have a whole

82
00:04:01,739 --> 00:04:04,259
bunch of elements in it they're all they

83
00:04:04,259 --> 00:04:05,609
will always come out sorted in the

84
00:04:05,609 --> 00:04:06,900
correct order in which they're in the

85
00:04:06,900 --> 00:04:09,060
document additionally there will be no

86
00:04:09,060 --> 00:04:11,759
duplicates so if you if you had multiple

87
00:04:11,759 --> 00:04:13,979
if you if you passed in multiple

88
00:04:13,979 --> 00:04:15,689
document bodies for example you would

89
00:04:15,689 --> 00:04:19,380
only get one body back so this is sort

90
00:04:19,380 --> 00:04:20,849
of set the ground rules I mean this is

91
00:04:20,849 --> 00:04:23,430
this is pretty standard in that all the

92
00:04:23,430 --> 00:04:24,659
all the node lists that you get right

93
00:04:24,659 --> 00:04:26,000
now and

94
00:04:26,000 --> 00:04:27,830
have these properties you know that they

95
00:04:27,830 --> 00:04:30,229
work like this they all come back in

96
00:04:30,229 --> 00:04:31,370
document order and they have no

97
00:04:31,370 --> 00:04:34,639
duplicates so I just wanted to maintain

98
00:04:34,639 --> 00:04:38,750
that state but the where the really

99
00:04:38,750 --> 00:04:42,710
interesting stuff comes in is if if we

100
00:04:42,710 --> 00:04:45,169
have this know list

101
00:04:45,169 --> 00:04:46,909
that's coming from get on with my tag

102
00:04:46,909 --> 00:04:49,460
name Korea selector etc and we have the

103
00:04:49,460 --> 00:04:53,150
ability to create custom no lists we it

104
00:04:53,150 --> 00:04:55,009
becomes really useful to be able to

105
00:04:55,009 --> 00:04:57,699
extend then don't list prototype so

106
00:04:57,699 --> 00:05:00,409
effectively when my proposal centers

107
00:05:00,409 --> 00:05:02,569
around is extending the no list

108
00:05:02,569 --> 00:05:04,310
prototype with a whole bunch of really

109
00:05:04,310 --> 00:05:07,219
useful functionality that we can use in

110
00:05:07,219 --> 00:05:12,199
web applications additionally if we

111
00:05:12,199 --> 00:05:14,090
don't end up killing off HTML collection

112
00:05:14,090 --> 00:05:15,620
we should make HTML collection and hear

113
00:05:15,620 --> 00:05:17,569
it from note list because right now

114
00:05:17,569 --> 00:05:19,069
they're kind of two separate things that

115
00:05:19,069 --> 00:05:21,500
don't really inherit from each other

116
00:05:21,500 --> 00:05:23,900
it's all really weird but but again I

117
00:05:23,900 --> 00:05:25,009
think a channel collection should just

118
00:05:25,009 --> 00:05:28,969
die so will you see HTML collection come

119
00:05:28,969 --> 00:05:31,279
up is if you do like uh dot children

120
00:05:31,279 --> 00:05:32,539
it's all from there like the old Dom

121
00:05:32,539 --> 00:05:34,430
zero days like if you do document dot

122
00:05:34,430 --> 00:05:37,639
forms document dot links you know stuff

123
00:05:37,639 --> 00:05:39,159
like that that no one ever uses anymore

124
00:05:39,159 --> 00:05:42,440
when some like crazy legacy apps but

125
00:05:42,440 --> 00:05:47,840
that's all HTML collection so one of the

126
00:05:47,840 --> 00:05:50,710
things that's really easy to implement

127
00:05:50,710 --> 00:05:54,759
is is a training like functionality and

128
00:05:54,759 --> 00:05:59,870
one of the concepts the way you get a

129
00:05:59,870 --> 00:06:01,940
chaining like thing is that on the no

130
00:06:01,940 --> 00:06:04,340
less prototype you introduce a create

131
00:06:04,340 --> 00:06:06,800
note list method so that means from any

132
00:06:06,800 --> 00:06:08,599
note from any note list you can do

133
00:06:08,599 --> 00:06:10,159
another you can create another know list

134
00:06:10,159 --> 00:06:12,440
and when you do that the parent node

135
00:06:12,440 --> 00:06:13,909
will always point back to where it came

136
00:06:13,909 --> 00:06:17,150
from so just as an example here so this

137
00:06:17,150 --> 00:06:19,219
isn't it doesn't work right now but just

138
00:06:19,219 --> 00:06:22,490
to show you as how it would work so for

139
00:06:22,490 --> 00:06:23,930
example if you did if you've got the

140
00:06:23,930 --> 00:06:26,719
child nodes and uh from the body element

141
00:06:26,719 --> 00:06:29,479
and you asked for its parent node you

142
00:06:29,479 --> 00:06:30,800
would get back to where it came from

143
00:06:30,800 --> 00:06:34,009
so you so any know list that you get you

144
00:06:34,009 --> 00:06:35,750
can always go back to where from from

145
00:06:35,750 --> 00:06:37,969
whence it came so additionally for

146
00:06:37,969 --> 00:06:39,150
example if you did

147
00:06:39,150 --> 00:06:41,070
query selector all and then you did a

148
00:06:41,070 --> 00:06:43,560
query selector all on the results set on

149
00:06:43,560 --> 00:06:45,840
the no list you could always get back to

150
00:06:45,840 --> 00:06:48,660
that original uh no list again so this

151
00:06:48,660 --> 00:06:51,060
way you can very easily traverse through

152
00:06:51,060 --> 00:06:54,270
these result sets and again so this is

153
00:06:54,270 --> 00:06:57,300
something that doesn't work it yet but

154
00:06:57,300 --> 00:06:59,780
I've something I'm proposing

155
00:06:59,780 --> 00:07:03,630
additionally on the so some of the

156
00:07:03,630 --> 00:07:06,600
things I want to see on the node list

157
00:07:06,600 --> 00:07:08,790
prototype or a whole bunch of array

158
00:07:08,790 --> 00:07:10,980
methods there are bunch of things that

159
00:07:10,980 --> 00:07:13,110
would be very very useful to be able to

160
00:07:13,110 --> 00:07:15,270
use against no list so for example

161
00:07:15,270 --> 00:07:17,250
different ways different ways of looping

162
00:07:17,250 --> 00:07:20,190
so like if you only have like a for each

163
00:07:20,190 --> 00:07:24,180
map filter all of those and and some of

164
00:07:24,180 --> 00:07:26,640
the default built-in array methods like

165
00:07:26,640 --> 00:07:29,280
sliced concat things of that nature

166
00:07:29,280 --> 00:07:32,810
now all some of these like sliced concat

167
00:07:32,810 --> 00:07:38,190
map and yeah there's a yeah slice can

168
00:07:38,190 --> 00:07:40,770
catnap and filter will all return new

169
00:07:40,770 --> 00:07:43,320
node lists as a result since they all

170
00:07:43,320 --> 00:07:46,080
modified the node list in some way so

171
00:07:46,080 --> 00:07:50,670
for example we said a query selector

172
00:07:50,670 --> 00:07:54,810
home you know find all the divs and then

173
00:07:54,810 --> 00:08:05,310
you know we map it so a map for each and

174
00:08:05,310 --> 00:08:08,430
that and you have to come from that's

175
00:08:08,430 --> 00:08:09,990
been a Firefox now for quite some time

176
00:08:09,990 --> 00:08:11,850
and it's in a part of a construct five

177
00:08:11,850 --> 00:08:15,390
so here we get me to say um give us all

178
00:08:15,390 --> 00:08:18,720
the parent nodes of all the divs for

179
00:08:18,720 --> 00:08:21,360
example so that's this is a an operation

180
00:08:21,360 --> 00:08:23,630
that can't be achieved through normal

181
00:08:23,630 --> 00:08:26,940
CSS traversal but it's something that we

182
00:08:26,940 --> 00:08:32,170
could do using the power of JavaScript

183
00:08:32,180 --> 00:08:35,910
okay so there's a whole bunch of

184
00:08:35,910 --> 00:08:39,690
different methods that I want to

185
00:08:39,690 --> 00:08:41,820
introduce and all these methods

186
00:08:41,820 --> 00:08:45,060
typically end up what I say is then a

187
00:08:45,060 --> 00:08:47,670
bleeding through to the elements

188
00:08:47,670 --> 00:08:51,300
themselves so just as an example you

189
00:08:51,300 --> 00:08:52,920
have traversal

190
00:08:52,920 --> 00:08:56,459
so I showed an example of it so for

191
00:08:56,459 --> 00:09:01,799
example if you do similar to what I

192
00:09:01,799 --> 00:09:03,839
showed before so you could say get

193
00:09:03,839 --> 00:09:12,799
elements by tag name and then say get

194
00:09:12,799 --> 00:09:20,790
elements class name so I mean you get

195
00:09:20,790 --> 00:09:22,589
you could effectively chain these

196
00:09:22,589 --> 00:09:24,720
operations together because it doesn't

197
00:09:24,720 --> 00:09:25,829
really make sense now because what

198
00:09:25,829 --> 00:09:27,329
happens now is that were restricted to

199
00:09:27,329 --> 00:09:30,209
using these methods only on either the

200
00:09:30,209 --> 00:09:34,169
document or on an element and or in the

201
00:09:34,169 --> 00:09:36,809
case of the query selector a document

202
00:09:36,809 --> 00:09:40,109
fragment when it makes a lot of sense to

203
00:09:40,109 --> 00:09:41,699
be able to use them against sets of

204
00:09:41,699 --> 00:09:43,829
elements simultaneously so in this way

205
00:09:43,829 --> 00:09:46,109
what we be doing is finding all the divs

206
00:09:46,109 --> 00:09:48,779
that are on the page and then finding

207
00:09:48,779 --> 00:09:52,109
all the elements the test class name in

208
00:09:52,109 --> 00:09:54,899
that are in all these divs and so what

209
00:09:54,899 --> 00:09:56,369
would be happening internally is that it

210
00:09:56,369 --> 00:09:58,499
would be concatenated all these result

211
00:09:58,499 --> 00:10:00,749
sets together and then returning one

212
00:10:00,749 --> 00:10:03,360
unified know list back as a result so

213
00:10:03,360 --> 00:10:05,309
again like each of these are going to be

214
00:10:05,309 --> 00:10:07,529
returning no lists again and again like

215
00:10:07,529 --> 00:10:10,049
the note list will have for example the

216
00:10:10,049 --> 00:10:11,850
parent node which is pointing back to

217
00:10:11,850 --> 00:10:13,549
the array of divs

218
00:10:13,549 --> 00:10:19,350
sorry the no list of those so I propose

219
00:10:19,350 --> 00:10:21,269
that we bring over a crea selector all I

220
00:10:21,269 --> 00:10:23,669
also have some proposals for fixing the

221
00:10:23,669 --> 00:10:25,259
selectors API because right now the

222
00:10:25,259 --> 00:10:27,360
selectors API has a lot of mixed missing

223
00:10:27,360 --> 00:10:32,859
functionality in it included including

224
00:10:32,869 --> 00:10:35,489
there's one there's one that I proposed

225
00:10:35,489 --> 00:10:39,609
to scoped query selector all

226
00:10:39,619 --> 00:10:42,059
additionally a matress selector so being

227
00:10:42,059 --> 00:10:44,009
able to say you know do these elements

228
00:10:44,009 --> 00:10:45,989
match this particular selector and

229
00:10:45,989 --> 00:10:47,610
additionally a filter selector so being

230
00:10:47,610 --> 00:10:49,980
able to take a set and reduce it down to

231
00:10:49,980 --> 00:10:52,889
a small or no list that matches a

232
00:10:52,889 --> 00:10:55,200
particular selector so the parent

233
00:10:55,200 --> 00:10:59,430
of analyst points to denote list that

234
00:10:59,430 --> 00:11:05,149
responded yes Kevin this is just me I

235
00:11:05,149 --> 00:11:09,839
mean it's I mean if if you uh I mean the

236
00:11:09,839 --> 00:11:14,220
thing is that I okay yeah

237
00:11:14,220 --> 00:11:17,370
something else to set a parent node yes

238
00:11:17,370 --> 00:11:20,699
like parent is like I think of like like

239
00:11:20,699 --> 00:11:22,649
I think of like a nose actually

240
00:11:22,649 --> 00:11:25,230
paramedic Dom tree Trenton if you're

241
00:11:25,230 --> 00:11:27,120
trying to like if in all these other

242
00:11:27,120 --> 00:11:28,500
places we're trying to offend with your

243
00:11:28,500 --> 00:11:33,209
mister seems like like that's that's

244
00:11:33,209 --> 00:11:46,680
like when you're calling a parent over I

245
00:11:46,680 --> 00:11:49,410
mean the reason why I late a parent node

246
00:11:49,410 --> 00:11:54,060
in particular I mean there's nothing

247
00:11:54,060 --> 00:11:56,279
semantically wrong with it and at least

248
00:11:56,279 --> 00:11:58,949
in the fact that it is a parent node it

249
00:11:58,949 --> 00:12:01,320
is still a node but the thing is that

250
00:12:01,320 --> 00:12:07,079
it's you know it's it's giving you the

251
00:12:07,079 --> 00:12:09,510
ability to you know to traverse through

252
00:12:09,510 --> 00:12:11,160
much of the same way that you would

253
00:12:11,160 --> 00:12:14,540
traverse through in the normal Dom tree

254
00:12:14,540 --> 00:12:17,100
so I mean cuz theoretically if you

255
00:12:17,100 --> 00:12:18,269
Traverse back far enough

256
00:12:18,269 --> 00:12:20,730
if you said parent node parent node that

257
00:12:20,730 --> 00:12:23,100
would give you document so you would be

258
00:12:23,100 --> 00:12:24,170
able to you would be able to get back

259
00:12:24,170 --> 00:12:26,550
from where you came originally either

260
00:12:26,550 --> 00:12:29,870
way you did it

261
00:12:29,880 --> 00:12:37,670
yeah it sounds singular okay all right

262
00:12:37,670 --> 00:12:41,699
it's not a huge issue in either way but

263
00:12:41,699 --> 00:13:01,529
um okay yeah all right so additionally I

264
00:13:01,529 --> 00:13:04,949
want to make it so that if you call any

265
00:13:04,949 --> 00:13:08,100
of the base methods provided in in the

266
00:13:08,100 --> 00:13:10,529
Dom so if you call you know appendchild

267
00:13:10,529 --> 00:13:13,350
remove child any of those you know

268
00:13:13,350 --> 00:13:15,779
insert before anything that can take a

269
00:13:15,779 --> 00:13:18,839
dom node can also take a node list so

270
00:13:18,839 --> 00:13:20,339
for example you can say append child

271
00:13:20,339 --> 00:13:23,069
know list and it'll insert every single

272
00:13:23,069 --> 00:13:24,839
one of those elements you no longer have

273
00:13:24,839 --> 00:13:26,880
to loop through each individual element

274
00:13:26,880 --> 00:13:29,699
append each one it much in the same way

275
00:13:29,699 --> 00:13:32,339
that document fragments work with the

276
00:13:32,339 --> 00:13:33,810
document fragment you can insert the

277
00:13:33,810 --> 00:13:36,449
fragment wholesale but it works in the

278
00:13:36,449 --> 00:13:38,040
same way you can insert a know list a

279
00:13:38,040 --> 00:13:42,720
wholesale so again so anything that can

280
00:13:42,720 --> 00:13:44,459
take a Dom node append child remove

281
00:13:44,459 --> 00:13:47,519
child everything also this it should

282
00:13:47,519 --> 00:13:50,519
also implement the event interface so if

283
00:13:50,519 --> 00:13:52,769
you do add event list or remove masoor

284
00:13:52,769 --> 00:13:55,290
dispatch of them all of those will bleed

285
00:13:55,290 --> 00:13:58,199
through to the actual Romans themselves

286
00:13:58,199 --> 00:14:00,779
so if you say add event listener click

287
00:14:00,779 --> 00:14:02,939
it'll added each individual element in

288
00:14:02,939 --> 00:14:07,199
the node list now the peers where things

289
00:14:07,199 --> 00:14:08,759
start to get really interesting so since

290
00:14:08,759 --> 00:14:11,639
we have this nice API for encapsulating

291
00:14:11,639 --> 00:14:13,920
all this functionality we can actually

292
00:14:13,920 --> 00:14:15,480
solve a whole bunch of really hard

293
00:14:15,480 --> 00:14:18,930
problems namely there's two problems

294
00:14:18,930 --> 00:14:19,860
that I think are particularly

295
00:14:19,860 --> 00:14:22,079
interesting one is the problem of having

296
00:14:22,079 --> 00:14:25,319
mutation events and also the problem of

297
00:14:25,319 --> 00:14:29,160
good Dom security so if we so in the

298
00:14:29,160 --> 00:14:30,660
case of mutation events for example

299
00:14:30,660 --> 00:14:35,160
right now we browsers say some browsers

300
00:14:35,160 --> 00:14:36,779
implement mutation events which allow

301
00:14:36,779 --> 00:14:40,769
you to listen to a particular point in

302
00:14:40,769 --> 00:14:42,190
the Dom tree

303
00:14:42,190 --> 00:14:44,320
wait and see like when an attribute has

304
00:14:44,320 --> 00:14:45,940
been modified in an element or when an

305
00:14:45,940 --> 00:14:47,170
element has been inserted or removed

306
00:14:47,170 --> 00:14:49,780
from the page it's all really slow and

307
00:14:49,780 --> 00:14:51,880
because the problem is is that it's all

308
00:14:51,880 --> 00:14:56,340
synchronous so like for example if you

309
00:14:56,340 --> 00:14:59,170
if you in if you have to go through an

310
00:14:59,170 --> 00:15:01,630
insert in 500 divs that's gonna trigger

311
00:15:01,630 --> 00:15:04,420
500 events and each one there's gonna be

312
00:15:04,420 --> 00:15:07,360
on each individual element it's a

313
00:15:07,360 --> 00:15:09,310
fantastically slow and because the

314
00:15:09,310 --> 00:15:12,190
browser's can't delay it there's no way

315
00:15:12,190 --> 00:15:14,470
for them to optimize it so there was a

316
00:15:14,470 --> 00:15:16,630
proposal there was a number of holes uh

317
00:15:16,630 --> 00:15:21,190
that came out to try and fix mutation

318
00:15:21,190 --> 00:15:24,040
events there's a page in the w3c site

319
00:15:24,040 --> 00:15:25,810
where all the browser vendors proposed

320
00:15:25,810 --> 00:15:28,750
made different proposals the only one I

321
00:15:28,750 --> 00:15:30,940
felt that had some merit was one

322
00:15:30,940 --> 00:15:35,260
proposed by the IE team and I didn't

323
00:15:35,260 --> 00:15:37,330
like the the particulars but the one

324
00:15:37,330 --> 00:15:39,070
thing I did like is that these the the

325
00:15:39,070 --> 00:15:40,720
main change that they made was that they

326
00:15:40,720 --> 00:15:42,820
made it asynchronous there is no longer

327
00:15:42,820 --> 00:15:45,010
guarantee that the mutation events will

328
00:15:45,010 --> 00:15:48,520
occur synchronously so I take that

329
00:15:48,520 --> 00:15:51,850
concept and apply it here so what

330
00:15:51,850 --> 00:15:57,250
happens is there's so at least in my

331
00:15:57,250 --> 00:15:58,720
proposal like if you do create no list

332
00:15:58,720 --> 00:16:01,390
for example the result that's coming

333
00:16:01,390 --> 00:16:04,570
back from that will always be static the

334
00:16:04,570 --> 00:16:07,000
live load live no list to begin with are

335
00:16:07,000 --> 00:16:09,850
really kind of crazy I think every

336
00:16:09,850 --> 00:16:12,100
browser vendor would appreciate if live

337
00:16:12,100 --> 00:16:15,010
no list this didn't exist since it would

338
00:16:15,010 --> 00:16:16,630
make things a whole lot faster it

339
00:16:16,630 --> 00:16:17,890
wouldn't have to maintain trying to

340
00:16:17,890 --> 00:16:20,500
maintain this day all over the place so

341
00:16:20,500 --> 00:16:22,540
the way I counteract the existence of

342
00:16:22,540 --> 00:16:25,540
these live no lists is there's a new

343
00:16:25,540 --> 00:16:30,310
query method so for example here make it

344
00:16:30,310 --> 00:16:38,130
a little bit bigger

345
00:16:38,140 --> 00:16:43,550
all right so so for example here we do

346
00:16:43,550 --> 00:16:45,500
this is example I used earlier so we do

347
00:16:45,500 --> 00:16:47,090
Priya sector all day if we find all the

348
00:16:47,090 --> 00:16:49,040
divs in the page and that we do a map

349
00:16:49,040 --> 00:16:51,530
and we get all that all the parents of

350
00:16:51,530 --> 00:16:53,690
those divs so again this is this is a

351
00:16:53,690 --> 00:16:55,550
selector that this is a traversal that

352
00:16:55,550 --> 00:16:58,040
you can't normally do with it's just

353
00:16:58,040 --> 00:17:00,260
plain CSS this is something that you can

354
00:17:00,260 --> 00:17:03,320
only do through script so then later on

355
00:17:03,320 --> 00:17:05,960
in your code the pages obviously been

356
00:17:05,960 --> 00:17:07,400
updated some new dibs that come into the

357
00:17:07,400 --> 00:17:09,290
page or some some devs have been moved

358
00:17:09,290 --> 00:17:10,970
around and they now have new parents you

359
00:17:10,970 --> 00:17:13,100
want to get the current result set so

360
00:17:13,100 --> 00:17:16,370
all you have to do is say a parent stock

361
00:17:16,370 --> 00:17:19,720
query and this returns and the new

362
00:17:19,720 --> 00:17:23,090
result set the new known list based upon

363
00:17:23,090 --> 00:17:25,910
the previous results so the way it works

364
00:17:25,910 --> 00:17:29,540
is it actually it goes back up through

365
00:17:29,540 --> 00:17:33,170
the tree so each individual method that

366
00:17:33,170 --> 00:17:36,410
modifies the state you know that

367
00:17:36,410 --> 00:17:38,120
modifies to no less that returns a new

368
00:17:38,120 --> 00:17:41,000
node list so for example here creator

369
00:17:41,000 --> 00:17:45,260
selector all is modified such that any

370
00:17:45,260 --> 00:17:47,090
at any point it's possible to go back

371
00:17:47,090 --> 00:17:50,090
and we query again yeah so we could just

372
00:17:50,090 --> 00:17:54,830
say if we do a very crew something like

373
00:17:54,830 --> 00:17:58,490
this we say odd divs and then we can do

374
00:17:58,490 --> 00:18:05,930
like we do an interval and then every 13

375
00:18:05,930 --> 00:18:10,340
milliseconds you know we query and do

376
00:18:10,340 --> 00:18:12,380
something on those divs and and this

377
00:18:12,380 --> 00:18:14,510
will give us the new result set and all

378
00:18:14,510 --> 00:18:16,940
we query those results so in the same

379
00:18:16,940 --> 00:18:21,200
way what's that modify those it returns

380
00:18:21,200 --> 00:18:24,140
a new one it does not modify so that

381
00:18:24,140 --> 00:18:25,370
that's a bit that's a big thing is that

382
00:18:25,370 --> 00:18:26,900
none of the methods that I proposed and

383
00:18:26,900 --> 00:18:30,260
modify the list itself it's it's not

384
00:18:30,260 --> 00:18:31,970
immutable but at least that's just good

385
00:18:31,970 --> 00:18:34,190
practice there's not not - I think

386
00:18:34,190 --> 00:18:35,150
that's what like one of the things that

387
00:18:35,150 --> 00:18:36,950
was that's was done very wrong like we

388
00:18:36,950 --> 00:18:39,620
have like dot reverse for example in the

389
00:18:39,620 --> 00:18:42,680
array API and that modifies and like

390
00:18:42,680 --> 00:18:44,180
just stuff like that that this was just

391
00:18:44,180 --> 00:18:47,360
wrong okay so we can do the query so not

392
00:18:47,360 --> 00:18:48,950
only does the query we run the previous

393
00:18:48,950 --> 00:18:50,419
sector all but also we runs

394
00:18:50,419 --> 00:18:52,609
map again and anything else you've

395
00:18:52,609 --> 00:18:54,950
you've changed along the way so in this

396
00:18:54,950 --> 00:18:56,659
way you can get you can always get the

397
00:18:56,659 --> 00:18:58,549
new result set and when you run the

398
00:18:58,549 --> 00:19:00,049
query you don't have to know what those

399
00:19:00,049 --> 00:19:02,090
original steps were to get the result

400
00:19:02,090 --> 00:19:16,340
result

401
00:19:16,350 --> 00:19:18,990
yes yeah that's exactly what it's doing

402
00:19:18,990 --> 00:19:21,000
internally is that you know internally

403
00:19:21,000 --> 00:19:23,970
all what it's doing is saying it goes

404
00:19:23,970 --> 00:19:25,409
back to this step it goes back to the

405
00:19:25,409 --> 00:19:27,029
map step and it says do you have a

406
00:19:27,029 --> 00:19:29,370
parent that can be query okay go to the

407
00:19:29,370 --> 00:19:30,720
parent first then it says do you have a

408
00:19:30,720 --> 00:19:33,029
parent that you need query is this no it

409
00:19:33,029 --> 00:19:34,740
runs this query then it goes back down

410
00:19:34,740 --> 00:19:38,120
again so it's recursive in that way so

411
00:19:38,120 --> 00:19:40,860
but the nice thing so now we have a way

412
00:19:40,860 --> 00:19:44,700
to we query a result set we can add in

413
00:19:44,700 --> 00:19:47,549
events so we can add in an added and

414
00:19:47,549 --> 00:19:50,850
removed event to the know list itself so

415
00:19:50,850 --> 00:19:53,340
we can say okay when something has been

416
00:19:53,340 --> 00:19:55,529
added to the know list or removed from

417
00:19:55,529 --> 00:19:57,539
the node list but it's not it's not

418
00:19:57,539 --> 00:20:00,389
limited to just just the elements or our

419
00:20:00,389 --> 00:20:03,629
CSS selectors you can have complex

420
00:20:03,629 --> 00:20:06,000
things like functions that can be

421
00:20:06,000 --> 00:20:07,559
running and manipulating the state in

422
00:20:07,559 --> 00:20:09,360
that way you know maps or filters or

423
00:20:09,360 --> 00:20:11,490
things of that nature so what you can do

424
00:20:11,490 --> 00:20:13,440
is you can you can effectively reproduce

425
00:20:13,440 --> 00:20:17,159
live events yeah you know um so you can

426
00:20:17,159 --> 00:20:18,389
say alright we're psyched or I'll find

427
00:20:18,389 --> 00:20:21,090
all the divs set a class on them and

428
00:20:21,090 --> 00:20:23,129
then when new ones are added set a class

429
00:20:23,129 --> 00:20:24,929
in them so this is going to set a class

430
00:20:24,929 --> 00:20:27,179
on all the divs under page now and all

431
00:20:27,179 --> 00:20:29,120
the divs that ever will be in the page

432
00:20:29,120 --> 00:20:32,429
and so and then here's the

433
00:20:32,429 --> 00:20:34,019
implementation of live events it's like

434
00:20:34,019 --> 00:20:37,740
three lines so if you say dot live you

435
00:20:37,740 --> 00:20:39,750
pass in a function and it runs against

436
00:20:39,750 --> 00:20:41,129
all current elements and all future

437
00:20:41,129 --> 00:20:44,039
elements so I don't I don't think this

438
00:20:44,039 --> 00:20:45,570
would be a good thing to land and the

439
00:20:45,570 --> 00:20:48,539
and the first iteration API but it'd be

440
00:20:48,539 --> 00:20:50,309
some deputies so easy to write like any

441
00:20:50,309 --> 00:20:52,049
framework that wants to extend this API

442
00:20:52,049 --> 00:20:55,860
can totally write it okay so building a

443
00:20:55,860 --> 00:20:57,870
then so this is something that can

444
00:20:57,870 --> 00:20:59,779
provide a great deal of flexibility

445
00:20:59,779 --> 00:21:01,860
something that isn't capable right now

446
00:21:01,860 --> 00:21:04,559
with like delegation for example the

447
00:21:04,559 --> 00:21:06,419
delegation you're you you're restricted

448
00:21:06,419 --> 00:21:08,549
to only working with events whereas with

449
00:21:08,549 --> 00:21:10,169
this case you can work with anything you

450
00:21:10,169 --> 00:21:12,330
know modifying classes or or what have

451
00:21:12,330 --> 00:21:17,279
you so the next thing is the next thing

452
00:21:17,279 --> 00:21:22,139
the huge advantage here is security so

453
00:21:22,139 --> 00:21:24,000
I've been talking with Alec Rockford

454
00:21:24,000 --> 00:21:25,889
about this and what's really nice about

455
00:21:25,889 --> 00:21:28,169
this particular API style is that it's

456
00:21:28,169 --> 00:21:30,179
really easy to secure

457
00:21:30,179 --> 00:21:32,129
and what I mean by secure is that right

458
00:21:32,129 --> 00:21:34,919
now within the Dom anytime you have

459
00:21:34,919 --> 00:21:37,139
access to a Dom element you can walk

460
00:21:37,139 --> 00:21:39,149
straight back up the tree get to the

461
00:21:39,149 --> 00:21:41,879
window and wreak havoc you can you can

462
00:21:41,879 --> 00:21:43,469
do whatever you want and call well I

463
00:21:43,469 --> 00:21:44,969
mean that the typical example is you

464
00:21:44,969 --> 00:21:46,649
call an alert and you're you know you're

465
00:21:46,649 --> 00:21:50,999
home home free but I'm introducing a new

466
00:21:50,999 --> 00:21:53,249
method called secure and what that does

467
00:21:53,249 --> 00:21:54,599
is if you run it on a know list it

468
00:21:54,599 --> 00:21:56,340
returns a new know list that is

469
00:21:56,340 --> 00:21:58,440
completely locked down and it's locked

470
00:21:58,440 --> 00:21:59,999
out in some very critical ways and that

471
00:21:59,999 --> 00:22:02,669
nodes are no longer accessible on the

472
00:22:02,669 --> 00:22:04,799
nose noblesse itself so if you say no

473
00:22:04,799 --> 00:22:07,529
list item at item zero it's just gonna

474
00:22:07,529 --> 00:22:10,820
be nothing there's none defined

475
00:22:10,820 --> 00:22:13,710
additionally but but but that's okay

476
00:22:13,710 --> 00:22:15,839
because all the nodes are gonna be

477
00:22:15,839 --> 00:22:17,669
encapsulated within the no list itself

478
00:22:17,669 --> 00:22:20,249
so all the nodes will be there and so

479
00:22:20,249 --> 00:22:22,679
like you could call like dot remove or

480
00:22:22,679 --> 00:22:25,529
or any of the other methods that exist

481
00:22:25,529 --> 00:22:29,759
but without having to access but without

482
00:22:29,759 --> 00:22:34,469
exposing the actual Dom nodes so just as

483
00:22:34,469 --> 00:22:37,919
a example here so if we call a previous

484
00:22:37,919 --> 00:22:41,129
lecture on some widget and we you return

485
00:22:41,129 --> 00:22:43,799
a secured version of that element of

486
00:22:43,799 --> 00:22:47,219
that node list for example so if you try

487
00:22:47,219 --> 00:22:48,869
to call parent node or a parent node

488
00:22:48,869 --> 00:22:52,049
list that will return null if you try to

489
00:22:52,049 --> 00:22:54,419
walk back up the tree take a break out

490
00:22:54,419 --> 00:22:56,789
that will return the empty no lists try

491
00:22:56,789 --> 00:22:58,019
to access first element that will return

492
00:22:58,019 --> 00:23:00,179
undefined you try to loop through to get

493
00:23:00,179 --> 00:23:01,799
to the elements each the elements will

494
00:23:01,799 --> 00:23:05,399
be null but what's nice is that even

495
00:23:05,399 --> 00:23:06,779
even though it looked it looks like it's

496
00:23:06,779 --> 00:23:08,969
crippled like this you can still say you

497
00:23:08,969 --> 00:23:11,129
can still say all right nodes query

498
00:23:11,129 --> 00:23:15,599
selector all did that foo then you could

499
00:23:15,599 --> 00:23:17,909
call Leon like append you know some

500
00:23:17,909 --> 00:23:19,769
stuff you know or you know like you can

501
00:23:19,769 --> 00:23:22,379
still perform Dom operations against it

502
00:23:22,379 --> 00:23:26,460
but without exposing to the user that

503
00:23:26,460 --> 00:23:28,739
that dangerous path of being able to

504
00:23:28,739 --> 00:23:29,969
walk back up the tree to get to the

505
00:23:29,969 --> 00:23:32,249
window so again like this is this is a

506
00:23:32,249 --> 00:23:34,909
Dom API that that continues that

507
00:23:34,909 --> 00:23:39,269
specifically obscures that particular

508
00:23:39,269 --> 00:23:40,990
way out yes what happens

509
00:23:40,990 --> 00:23:43,390
so you've got that like appendchild here

510
00:23:43,390 --> 00:23:45,340
right seven kinda funny though this

511
00:23:45,340 --> 00:23:47,470
we've got at the appendchild method oh

512
00:23:47,470 --> 00:23:52,030
yeah so one thing that has so we're I

513
00:23:52,030 --> 00:23:55,380
talked about some of those yeah um yeah

514
00:23:55,380 --> 00:23:58,390
okay so what happens when say you give

515
00:23:58,390 --> 00:24:00,309
it an argument I mean obviously this

516
00:24:00,309 --> 00:24:02,860
this will be incorrect but if you say

517
00:24:02,860 --> 00:24:04,330
something like we've got another ski

518
00:24:04,330 --> 00:24:05,350
call appendchild

519
00:24:05,350 --> 00:24:08,590
document dot create element yeah you

520
00:24:08,590 --> 00:24:11,950
created one div whereas you might think

521
00:24:11,950 --> 00:24:14,410
you could anyone do for every item in

522
00:24:14,410 --> 00:24:16,000
the list you're really just creating one

523
00:24:16,000 --> 00:24:20,530
div and depending it over and over to a

524
00:24:20,530 --> 00:24:24,670
collection so the one thing that

525
00:24:24,670 --> 00:24:27,340
obviously that'll have to be worked out

526
00:24:27,340 --> 00:24:31,480
but the the way at least we we solve it

527
00:24:31,480 --> 00:24:33,340
at the moment at least in jQuery for

528
00:24:33,340 --> 00:24:35,230
example is that we clone the the first

529
00:24:35,230 --> 00:24:37,480
one's the real insertion of then the

530
00:24:37,480 --> 00:24:39,400
second through and ones are clones of

531
00:24:39,400 --> 00:24:55,909
the original

532
00:24:55,919 --> 00:25:06,070
you can append to okay so to clarify it

533
00:25:06,070 --> 00:25:12,639
so there's did presumably so there's

534
00:25:12,639 --> 00:25:15,100
there's a separate sort of API here that

535
00:25:15,100 --> 00:25:17,200
I didn't mention which is the ability to

536
00:25:17,200 --> 00:25:19,659
create dom nodes but not through the

537
00:25:19,659 --> 00:25:21,460
traditional create element means because

538
00:25:21,460 --> 00:25:23,080
like right now we don't have like there

539
00:25:23,080 --> 00:25:25,389
isn't an api specified for doing you

540
00:25:25,389 --> 00:25:30,340
know HTML to dock to dom fragment and

541
00:25:30,340 --> 00:25:33,039
like that needs to exist and like any of

542
00:25:33,039 --> 00:25:34,330
these methods should be able to take a

543
00:25:34,330 --> 00:25:36,190
string HTML string and be able to still

544
00:25:36,190 --> 00:25:41,379
work so in the case so this is to

545
00:25:41,379 --> 00:25:43,509
clarify what you're saying you wouldn't

546
00:25:43,509 --> 00:25:44,679
be able to call document.createelement

547
00:25:44,679 --> 00:25:47,379
in this secured environment in this

548
00:25:47,379 --> 00:25:48,999
theoretical secured environment some

549
00:25:48,999 --> 00:25:49,989
because you want to have access the

550
00:25:49,989 --> 00:25:52,720
document to begin with some of you guys

551
00:25:52,720 --> 00:25:54,070
if you did then what's the point of

552
00:25:54,070 --> 00:25:55,599
having it be secured your are you

553
00:25:55,599 --> 00:25:59,049
already free so one thing i want to

554
00:25:59,049 --> 00:26:01,629
mention real quick so these so these are

555
00:26:01,629 --> 00:26:03,820
the things that i haven't I haven't

556
00:26:03,820 --> 00:26:06,519
completely specified yet but it doesn't

557
00:26:06,519 --> 00:26:08,859
really matter since their implementation

558
00:26:08,859 --> 00:26:12,340
isn't critical like all like the

559
00:26:12,340 --> 00:26:13,749
implementation for these are like two or

560
00:26:13,749 --> 00:26:16,950
three lines per item it's not massive

561
00:26:16,950 --> 00:26:18,789
when I considered to be the critical

562
00:26:18,789 --> 00:26:20,830
part is getting this good initial API

563
00:26:20,830 --> 00:26:24,190
out that we can build off of and in at

564
00:26:24,190 --> 00:26:25,570
least getting this specified and in

565
00:26:25,570 --> 00:26:27,249
browsers so that we can extend it and

566
00:26:27,249 --> 00:26:31,149
build better API and then so one last

567
00:26:31,149 --> 00:26:33,489
thing that I wanted to mention because I

568
00:26:33,489 --> 00:26:36,129
think I'm out of time here is that in

569
00:26:36,129 --> 00:26:38,649
order what when I'm so I'm working on

570
00:26:38,649 --> 00:26:40,509
this and again I'm working with you know

571
00:26:40,509 --> 00:26:41,729
Mozilla ie

572
00:26:41,729 --> 00:26:45,519
and the w3c is I'm working on

573
00:26:45,519 --> 00:26:46,299
implementation

574
00:26:46,299 --> 00:26:48,639
that's pure JavaScript implementation

575
00:26:48,639 --> 00:26:50,769
that implements the full API and a full

576
00:26:50,769 --> 00:26:52,960
test suite to go along with it so for

577
00:26:52,960 --> 00:26:54,099
example here's history I'm over five

578
00:26:54,099 --> 00:26:56,619
hundred tests at the moment and I'm just

579
00:26:56,619 --> 00:26:57,879
trucking along and adding more and more

580
00:26:57,879 --> 00:27:00,700
tests to prove that this not not only

581
00:27:00,700 --> 00:27:01,660
were

582
00:27:01,660 --> 00:27:03,910
but it's actually feasible and works in

583
00:27:03,910 --> 00:27:07,750
current browsers so hopefully while

584
00:27:07,750 --> 00:27:09,100
we're waiting for browser vendors to

585
00:27:09,100 --> 00:27:10,780
implemented which hopefully shouldn't be

586
00:27:10,780 --> 00:27:14,140
that long we can actually use it in the

587
00:27:14,140 --> 00:27:17,020
interim so any questions really quick

588
00:27:17,020 --> 00:27:19,270
before I have to secede to the next

589
00:27:19,270 --> 00:27:23,740
person it's now published I'm publishing

590
00:27:23,740 --> 00:27:28,750
this month it will be up at I'll be

591
00:27:28,750 --> 00:27:32,980
publishing it a couple places yeah so at

592
00:27:32,980 --> 00:27:37,870
least my goal is to is this month to

593
00:27:37,870 --> 00:27:39,490
finish to finish the test suite and

594
00:27:39,490 --> 00:27:42,760
implementation and publish those and

595
00:27:42,760 --> 00:27:48,610
then work with Doug's duck shoppers over

596
00:27:48,610 --> 00:27:53,190
at the w3c and work on a draft of the

597
00:27:53,190 --> 00:27:57,850
recommendation so the endlichs Amaury

598
00:27:57,850 --> 00:28:00,940
i'm already communicating with the IE

599
00:28:00,940 --> 00:28:03,210
team and the Missoula team on

600
00:28:03,210 --> 00:28:07,540
implementations but I'm hoping at the

601
00:28:07,540 --> 00:28:08,980
very least that having a test suite and

602
00:28:08,980 --> 00:28:11,020
a sample invitation should be enough to

603
00:28:11,020 --> 00:28:13,450
get them off the ground and towards

604
00:28:13,450 --> 00:28:28,960
implementing a pending

605
00:28:28,970 --> 00:28:32,250
to document um

606
00:28:32,250 --> 00:28:34,860
I mean I'd imagine that internally it

607
00:28:34,860 --> 00:28:36,149
would probably work similarly to a

608
00:28:36,149 --> 00:28:39,539
document fragment but it's a little bit

609
00:28:39,539 --> 00:28:41,490
different in that like like for example

610
00:28:41,490 --> 00:28:43,679
if you call clone node on a document

611
00:28:43,679 --> 00:28:45,480
fragment that clones the document

612
00:28:45,480 --> 00:28:48,600
fragment and incidentally the contents

613
00:28:48,600 --> 00:28:49,320
of that fragment

614
00:28:49,320 --> 00:28:51,630
whereas what I'm proposing is more it's

615
00:28:51,630 --> 00:28:54,210
everything just passes through so if you

616
00:28:54,210 --> 00:28:58,380
were to theoretically clone the no list

617
00:28:58,380 --> 00:28:59,580
you wouldn't be cloning the nola you'd

618
00:28:59,580 --> 00:29:04,450
be cloning the contents of the node list

619
00:29:04,460 --> 00:29:13,440
so another question

620
00:29:13,450 --> 00:29:16,620
so it's impacting in some way so I'm I'm

621
00:29:16,620 --> 00:29:18,910
deprecating some things in jQuery that

622
00:29:18,910 --> 00:29:22,270
just should hope to help but get us

623
00:29:22,270 --> 00:29:25,179
towards a because I guess there should

624
00:29:25,179 --> 00:29:28,750
be a much more pure implementation I'm

625
00:29:28,750 --> 00:29:30,400
also very interested in being able to do

626
00:29:30,400 --> 00:29:32,950
that the thing that I mentioned the dot

627
00:29:32,950 --> 00:29:35,049
query like being able to wreak weary

628
00:29:35,049 --> 00:29:37,240
state like we don't have that right now

629
00:29:37,240 --> 00:29:38,650
in core but that seems like something

630
00:29:38,650 --> 00:29:40,260
that'd be really cool I'm really useful

631
00:29:40,260 --> 00:29:42,190
so that's something I'm also interested

632
00:29:42,190 --> 00:29:45,460
in I know I have a deprecation page

633
00:29:45,460 --> 00:29:48,610
somewhere that's up an ether pad so yeah

634
00:29:48,610 --> 00:29:55,870
I don't know if that's still there yeah

635
00:29:55,870 --> 00:29:57,190
so I've been collecting things that I

636
00:29:57,190 --> 00:29:59,380
want to deprecated but anyway so yeah I

637
00:29:59,380 --> 00:30:03,580
think some of these are related to this

638
00:30:03,580 --> 00:30:09,429
the API that I'm working on other

639
00:30:09,429 --> 00:30:12,370
questions oh yeah if you have any

640
00:30:12,370 --> 00:30:14,770
questions proof proofread uh hump me

641
00:30:14,770 --> 00:30:16,900
down and I'll be able to answer them as

