1
00:00:10,160 --> 00:00:12,960

I'm gonna talk about CoffeeScript which

2
00:00:12,960 --> 00:00:15,089
is a little language that is written in

3
00:00:15,089 --> 00:00:18,150
itself and compiles to JavaScript so I

4
00:00:18,150 --> 00:00:19,800
was pretty interested in a lot of what

5
00:00:19,800 --> 00:00:21,270
Crockford was just saying couple minutes

6
00:00:21,270 --> 00:00:24,570
ago over in the other in track' about

7
00:00:24,570 --> 00:00:26,460
all of the sort of deficiencies and

8
00:00:26,460 --> 00:00:27,539
things that people aren't satisfied with

9
00:00:27,539 --> 00:00:29,699
in JavaScript and things that could have

10
00:00:29,699 --> 00:00:30,960
been done better bad parts that should

11
00:00:30,960 --> 00:00:33,239
be left out and you know it should be

12
00:00:33,239 --> 00:00:35,309
kind of like a human right but for but

13
00:00:35,309 --> 00:00:36,719
for coders that you should have a coders

14
00:00:36,719 --> 00:00:38,670
right to have javascript be the language

15
00:00:38,670 --> 00:00:41,940
that you want it to be and and because

16
00:00:41,940 --> 00:00:44,370
javascript has such a nice clean

17
00:00:44,370 --> 00:00:48,030
functional object-oriented lexically

18
00:00:48,030 --> 00:00:50,430
scoped core you can build a lot of

19
00:00:50,430 --> 00:00:51,750
interesting languages on top of it

20
00:00:51,750 --> 00:00:53,309
without having to get too far away from

21
00:00:53,309 --> 00:00:56,399
what the core idea of javascript is so

22
00:00:56,399 --> 00:00:58,199
could I get a quick show of hands of how

23
00:00:58,199 --> 00:00:58,859
many of you have played with

24
00:00:58,859 --> 00:01:01,350
CoffeeScript before all right so that's

25
00:01:01,350 --> 00:01:03,510
a that's a pretty good mix so I'm gonna

26
00:01:03,510 --> 00:01:04,710
go quickly through some of the language

27
00:01:04,710 --> 00:01:07,680
features what it does differently than

28
00:01:07,680 --> 00:01:09,000
JavaScript and then also how its

29
00:01:09,000 --> 00:01:10,020
implemented if you want to write

30
00:01:10,020 --> 00:01:11,580
something like this for your own

31
00:01:11,580 --> 00:01:13,590
language that would be however however

32
00:01:13,590 --> 00:01:17,130
you sell fit so let's see here

33
00:01:17,130 --> 00:01:19,080
this talk is gonna be pretty rapid-fire

34
00:01:19,080 --> 00:01:20,549
it's also just gonna be all codes so we

35
00:01:20,549 --> 00:01:22,080
can if you have any questions feel free

36
00:01:22,080 --> 00:01:23,430
to raise your hand in the middle and we

37
00:01:23,430 --> 00:01:25,320
can change things and recompile it and

38
00:01:25,320 --> 00:01:28,259
see see how it works so so there's kind

39
00:01:28,259 --> 00:01:30,110
of three main aspects to the idea of

40
00:01:30,110 --> 00:01:31,950
doing this you know there's a lot of

41
00:01:31,950 --> 00:01:33,990
languages I mean I guess the other one

42
00:01:33,990 --> 00:01:34,710
of the other really big ones is

43
00:01:34,710 --> 00:01:37,439
objective J which puts Objective C into

44
00:01:37,439 --> 00:01:39,270
JavaScript but to do that you have to

45
00:01:39,270 --> 00:01:41,850
have kind of an entire runtime but the

46
00:01:41,850 --> 00:01:44,850
idea here is not so much to support an

47
00:01:44,850 --> 00:01:46,229
existing language like Python or Ruby

48
00:01:46,229 --> 00:01:48,630
into JavaScript directly but instead to

49
00:01:48,630 --> 00:01:50,939
take the core of JavaScript and to clean

50
00:01:50,939 --> 00:01:52,770
out all the syntax that you know looks

51
00:01:52,770 --> 00:01:54,090
like Java but you don't really need and

52
00:01:54,090 --> 00:01:56,340
to also clean up some of the semantics

53
00:01:56,340 --> 00:01:59,189
so things like var how you know you have

54
00:01:59,189 --> 00:02:00,299
to use var the first time you declare

55
00:02:00,299 --> 00:02:02,549
the variable never again thereafter and

56
00:02:02,549 --> 00:02:04,079
you almost always need to use it the

57
00:02:04,079 --> 00:02:05,250
first time because you don't want it to

58
00:02:05,250 --> 00:02:07,280
be global so things like that go away

59
00:02:07,280 --> 00:02:09,869
things like like statements go away

60
00:02:09,869 --> 00:02:11,160
everything is an expression in

61
00:02:11,160 --> 00:02:13,690
CoffeeScript so you can pass the

62
00:02:13,690 --> 00:02:16,120
result of an if statement directly back

63
00:02:16,120 --> 00:02:18,400
to you can assign it to a variable you

64
00:02:18,400 --> 00:02:20,950
can pass it back to a callback that sort

65
00:02:20,950 --> 00:02:23,020
of thing so that's the second aspect we

66
00:02:23,020 --> 00:02:24,190
have that we have the cleaned up syntax

67
00:02:24,190 --> 00:02:26,320
we have we have cleaned up semantics and

68
00:02:26,320 --> 00:02:27,850
there's also extra goodies so language

69
00:02:27,850 --> 00:02:30,850
features like slices splats that's the

70
00:02:30,850 --> 00:02:32,800
very attic arguments that the Crockford

71
00:02:32,800 --> 00:02:35,610
is talking about before you have

72
00:02:35,610 --> 00:02:37,540
comprehensions instead of low-level

73
00:02:37,540 --> 00:02:40,300
loops and all all kinds of extra goodies

74
00:02:40,300 --> 00:02:41,860
that we can there's some things that you

75
00:02:41,860 --> 00:02:44,110
can't do like Brian was just talking

76
00:02:44,110 --> 00:02:45,550
about like with method missing you can't

77
00:02:45,550 --> 00:02:48,250
do that without actually either having

78
00:02:48,250 --> 00:02:50,320
an interpreter or having you know or

79
00:02:50,320 --> 00:02:51,790
intercepting every single object call

80
00:02:51,790 --> 00:02:53,830
that you ever do so those kinds if

81
00:02:53,830 --> 00:02:54,400
there's some things that are just

82
00:02:54,400 --> 00:02:55,990
impossible but the things that we can do

83
00:02:55,990 --> 00:03:00,070
we try to so the gold so that that

84
00:03:00,070 --> 00:03:01,600
brings us to the golden rule is that

85
00:03:01,600 --> 00:03:03,550
it's just JavaScript it's not it's not

86
00:03:03,550 --> 00:03:05,440
it's not a runtime it's not an

87
00:03:05,440 --> 00:03:07,180
interpreter there's no special functions

88
00:03:07,180 --> 00:03:08,590
really allowed and that's a rule we

89
00:03:08,590 --> 00:03:10,420
break slightly but but we're not going

90
00:03:10,420 --> 00:03:11,410
to be injecting a whole bunch of

91
00:03:11,410 --> 00:03:13,240
CoffeeScript specific library functions

92
00:03:13,240 --> 00:03:14,770
into your code in general it just

93
00:03:14,770 --> 00:03:16,900
translates into the equivalent

94
00:03:16,900 --> 00:03:20,650
JavaScript so it leaves a lot of things

95
00:03:20,650 --> 00:03:22,630
out it is a smaller language then then

96
00:03:22,630 --> 00:03:24,310
JavaScript is you don't have with you

97
00:03:24,310 --> 00:03:25,690
don't have semicolons or semicolon

98
00:03:25,690 --> 00:03:26,709
insertion to deal with and you're

99
00:03:26,709 --> 00:03:28,600
parsing you don't have to worry about

100
00:03:28,600 --> 00:03:30,400
trailing commas there's no difference

101
00:03:30,400 --> 00:03:32,170
between the colon inside of the object

102
00:03:32,170 --> 00:03:34,090
to assign a property versus variable

103
00:03:34,090 --> 00:03:37,150
assignment outside syntax wise no

104
00:03:37,150 --> 00:03:38,770
implicit global variables because that's

105
00:03:38,770 --> 00:03:41,260
taken care of for you you don't even

106
00:03:41,260 --> 00:03:42,580
have to worry about low-level for loops

107
00:03:42,580 --> 00:03:43,989
because instead you have comprehensions

108
00:03:43,989 --> 00:03:45,340
and if you really really need the

109
00:03:45,340 --> 00:03:47,410
low-level loop you can use awhile so

110
00:03:47,410 --> 00:03:48,640
that's the one that we do expose and

111
00:03:48,640 --> 00:03:50,050
that can be that's the general have to

112
00:03:50,050 --> 00:03:52,239
be transformed into into anything else

113
00:03:52,239 --> 00:03:54,550
and no difference between turn areas and

114
00:03:54,550 --> 00:03:55,870
if else's right so in JavaScript you

115
00:03:55,870 --> 00:03:57,160
have an F else that's a statement you

116
00:03:57,160 --> 00:03:58,930
can't return that value but a ternary is

117
00:03:58,930 --> 00:04:01,150
an expression and you can and there's no

118
00:04:01,150 --> 00:04:02,500
real reason that they need to be two

119
00:04:02,500 --> 00:04:04,390
separate things so let's start with the

120
00:04:04,390 --> 00:04:08,140
basic basically a function so here you

121
00:04:08,140 --> 00:04:09,850
have a JavaScript function it's it's

122
00:04:09,850 --> 00:04:12,100
assigned to a variable named square it's

123
00:04:12,100 --> 00:04:14,019
also named so that if you need to debug

124
00:04:14,019 --> 00:04:15,040
it you'll actually have a name in what

125
00:04:15,040 --> 00:04:17,410
you say anonymous and you're gonna

126
00:04:17,410 --> 00:04:19,150
return you're taking a number X you

127
00:04:19,150 --> 00:04:21,700
return X times X and that's that's you

128
00:04:21,700 --> 00:04:23,320
know JavaScript 101 so if we were going

129
00:04:23,320 --> 00:04:24,610
to transform this into CoffeeScript what

130
00:04:24,610 --> 00:04:25,330
would that look like

131
00:04:25,330 --> 00:04:26,620
well first off you don't need a

132
00:04:26,620 --> 00:04:27,760
semicolon because

133
00:04:27,760 --> 00:04:31,220
why bother second you don't need to

134
00:04:31,220 --> 00:04:33,889
declare your your VAR you can just

135
00:04:33,889 --> 00:04:37,910
assign it we can we can use and this is

136
00:04:37,910 --> 00:04:39,410
kind of up to your style the preferred

137
00:04:39,410 --> 00:04:40,850
CoffeeScript styles to use colons to

138
00:04:40,850 --> 00:04:43,040
assign all over the place instead of

139
00:04:43,040 --> 00:04:44,450
equals but they are interchangeable so

140
00:04:44,450 --> 00:04:45,980
you can use equal signs instead of

141
00:04:45,980 --> 00:04:48,560
objects inside of objects as well so

142
00:04:48,560 --> 00:04:50,230
we'll switch this over to a colon

143
00:04:50,230 --> 00:04:52,639
returns are implicit inside of a

144
00:04:52,639 --> 00:04:54,139
function the last thing that you last

145
00:04:54,139 --> 00:04:55,669
expression you evaluate will always be

146
00:04:55,669 --> 00:04:56,960
returned so you don't need to return it

147
00:04:56,960 --> 00:04:58,910
yourself so we'll take that out and also

148
00:04:58,910 --> 00:05:02,810
the semicolon in there it uses Python

149
00:05:02,810 --> 00:05:05,390
style block whitespace syntax so you

150
00:05:05,390 --> 00:05:07,910
don't need to use Curly's to the limit

151
00:05:07,910 --> 00:05:09,770
your your blocks so we'll take off the

152
00:05:09,770 --> 00:05:11,180
Curly's and just use the indentation

153
00:05:11,180 --> 00:05:14,180
there and finally instead of the

154
00:05:14,180 --> 00:05:17,600
function keyword well I guess before we

155
00:05:17,600 --> 00:05:20,360
get to that we have square repeated

156
00:05:20,360 --> 00:05:22,130
twice and which always looks very

157
00:05:22,130 --> 00:05:23,690
redundant so let's take off one of those

158
00:05:23,690 --> 00:05:25,370
squares and finally instead of the

159
00:05:25,370 --> 00:05:27,139
function keyword what a function looks

160
00:05:27,139 --> 00:05:28,550
like is just an arrow pointing from the

161
00:05:28,550 --> 00:05:30,889
arguments to the result so we have

162
00:05:30,889 --> 00:05:33,740
square as a function of X and it goes to

163
00:05:33,740 --> 00:05:36,470
x times X and now that's highlighted as

164
00:05:36,470 --> 00:05:38,030
a function and you can also write that

165
00:05:38,030 --> 00:05:41,090
on one line like this so you can see how

166
00:05:41,090 --> 00:05:42,590
that got transformed square as a

167
00:05:42,590 --> 00:05:44,240
function that takes in action it returns

168
00:05:44,240 --> 00:05:48,320
x times X so that's a good example and

169
00:05:48,320 --> 00:05:51,110
actually let's give this a try so this

170
00:05:51,110 --> 00:05:52,640
textmate is hooked up and there's a

171
00:05:52,640 --> 00:05:53,900
there's a text made bundle there's a

172
00:05:53,900 --> 00:05:55,460
there's an Emacs bundle there's a vim

173
00:05:55,460 --> 00:05:56,690
bundle there's bundles for all your

174
00:05:56,690 --> 00:05:56,960
needs

175
00:05:56,960 --> 00:05:58,669
this one's hooked up so we can compile

176
00:05:58,669 --> 00:06:00,800
this and see what it turns into

177
00:06:00,800 --> 00:06:03,560
so here we have it back looking more or

178
00:06:03,560 --> 00:06:05,539
less like it did the the declaration got

179
00:06:05,539 --> 00:06:07,100
pushed up to the top but you have back

180
00:06:07,100 --> 00:06:08,539
your JavaScript function and if we run

181
00:06:08,539 --> 00:06:13,580
that let's say puts the square of 100

182
00:06:13,580 --> 00:06:17,000
and we get oops I have to do the whole

183
00:06:17,000 --> 00:06:20,860
thing let's do this we get back 10,000

184
00:06:20,860 --> 00:06:26,510
all right so um it the sort of the mo is

185
00:06:26,510 --> 00:06:28,789
to not change anything about JavaScript

186
00:06:28,789 --> 00:06:30,860
that's already you know very clear and

187
00:06:30,860 --> 00:06:32,419
very common it's not just changing it

188
00:06:32,419 --> 00:06:34,250
for changes sake so so arrays look the

189
00:06:34,250 --> 00:06:36,919
same object literals look the same

190
00:06:36,919 --> 00:06:38,479
there's a book very nicely done you can

191
00:06:38,479 --> 00:06:39,650
see how we're using the same assignment

192
00:06:39,650 --> 00:06:41,060
syntax element

193
00:06:41,060 --> 00:06:43,280
is an object literal that has hydrogen

194
00:06:43,280 --> 00:06:47,180
silicon and uranium properties with if

195
00:06:47,180 --> 00:06:48,889
you because it has because we are

196
00:06:48,889 --> 00:06:50,840
whitespace sensitive if you do your

197
00:06:50,840 --> 00:06:52,280
assignments on multiple lines you don't

198
00:06:52,280 --> 00:06:53,330
have to worry about comments you can

199
00:06:53,330 --> 00:06:54,770
leave them off you can put them in you

200
00:06:54,770 --> 00:06:55,940
can have trailing commas it's all going

201
00:06:55,940 --> 00:06:57,590
to compile to the same thing so actually

202
00:06:57,590 --> 00:06:59,800
let's do that we compile this to

203
00:06:59,800 --> 00:07:02,900
JavaScript and we'll get our commas and

204
00:07:02,900 --> 00:07:04,639
you can see even if you have them and

205
00:07:04,639 --> 00:07:07,970
it's trailing it's not going to be

206
00:07:07,970 --> 00:07:09,080
trailing when you compile it to

207
00:07:09,080 --> 00:07:11,360
JavaScript so you won't kill you on that

208
00:07:11,360 --> 00:07:15,229
and and property accessing is the same

209
00:07:15,229 --> 00:07:16,910
it's dot property so we can say it puts

210
00:07:16,910 --> 00:07:18,380
elements dot

211
00:07:18,380 --> 00:07:24,590
silicon and we're gonna get back 14 all

212
00:07:24,590 --> 00:07:25,300
right

213
00:07:25,300 --> 00:07:27,169
on to the next one so this is the

214
00:07:27,169 --> 00:07:28,580
whitespace for blocks and tax that I

215
00:07:28,580 --> 00:07:30,169
showed you before it of course looks

216
00:07:30,169 --> 00:07:32,960
more more Python II when it gets more

217
00:07:32,960 --> 00:07:35,930
nested so here's an if here's a block if

218
00:07:35,930 --> 00:07:38,150
statement if answer is yes and attempts

219
00:07:38,150 --> 00:07:39,440
is less than three then we have a

220
00:07:39,440 --> 00:07:42,139
try-catch try try again catch error

221
00:07:42,139 --> 00:07:44,840
report error and if you look at what

222
00:07:44,840 --> 00:07:46,460
this compiles to in JavaScript just to

223
00:07:46,460 --> 00:07:48,020
get a sense of how the whitespace is

224
00:07:48,020 --> 00:07:52,340
working it's gonna look like this so you

225
00:07:52,340 --> 00:07:53,990
can see how your try catch block got

226
00:07:53,990 --> 00:07:55,220
translated and all the curly has got

227
00:07:55,220 --> 00:07:57,770
inserted and this also shows some

228
00:07:57,770 --> 00:08:00,710
aliases that that you have so all of the

229
00:08:00,710 --> 00:08:02,900
JavaScript operators greater than less

230
00:08:02,900 --> 00:08:05,690
than triple equals stuff is available

231
00:08:05,690 --> 00:08:09,979
but you also have aliases so yes yes yes

232
00:08:09,979 --> 00:08:12,860
no on off our aliases for true false

233
00:08:12,860 --> 00:08:14,270
like they are in the ml so you can write

234
00:08:14,270 --> 00:08:15,500
things out a little bit more naturally

235
00:08:15,500 --> 00:08:17,180
if you're depending on what your wording

236
00:08:17,180 --> 00:08:19,610
is for your boolean and then also is in

237
00:08:19,610 --> 00:08:23,060
isn't for triple equals and not not

238
00:08:23,060 --> 00:08:28,970
triple equals which is nice too so a lot

239
00:08:28,970 --> 00:08:30,380
of things that are available in block

240
00:08:30,380 --> 00:08:32,360
syntax form like this are also available

241
00:08:32,360 --> 00:08:35,539
in postfix prefix or postfix so here we

242
00:08:35,539 --> 00:08:38,690
have if ignition is on block launch

243
00:08:38,690 --> 00:08:40,969
rocket or you could say launch rocket if

244
00:08:40,969 --> 00:08:43,159
ignition is on and if we compile this

245
00:08:43,159 --> 00:08:46,730
snippet right here we can see that I

246
00:08:46,730 --> 00:08:48,830
guess in one case it became the ternary

247
00:08:48,830 --> 00:08:51,770
and the other one it's a it's the actual

248
00:08:51,770 --> 00:08:53,060
block if but they're doing the same

249
00:08:53,060 --> 00:08:54,000
thing

250
00:08:54,000 --> 00:08:56,040
if ignition is true then you wash the

251
00:08:56,040 --> 00:08:58,590
rocket otherwise you don't and then the

252
00:08:58,590 --> 00:09:00,450
same thing for the same thing is true

253
00:09:00,450 --> 00:09:02,460
for basically for anything where you

254
00:09:02,460 --> 00:09:04,710
have a where you have an indented block

255
00:09:04,710 --> 00:09:06,240
you can also do a prefix if it's just a

256
00:09:06,240 --> 00:09:09,030
single line expression so here we're

257
00:09:09,030 --> 00:09:11,220
doing a comprehension so for every song

258
00:09:11,220 --> 00:09:12,990
in repertoire we're gonna sing it and

259
00:09:12,990 --> 00:09:15,720
then this is the same form but but

260
00:09:15,720 --> 00:09:18,680
written as a block all right

261
00:09:18,680 --> 00:09:21,990
so getting getting past the sort of the

262
00:09:21,990 --> 00:09:24,510
syntax subtractions the you know all the

263
00:09:24,510 --> 00:09:27,060
semicolons and punctuation noise towards

264
00:09:27,060 --> 00:09:29,190
the expression stuff which i think so

265
00:09:29,190 --> 00:09:30,330
I think that everything is an expression

266
00:09:30,330 --> 00:09:32,520
is probably the single most important

267
00:09:32,520 --> 00:09:34,560
feature of all of this it definitely

268
00:09:34,560 --> 00:09:36,240
changes the most in how your code is

269
00:09:36,240 --> 00:09:38,610
structured so here we have a

270
00:09:38,610 --> 00:09:40,620
comprehension you're going to print out

271
00:09:40,620 --> 00:09:43,620
I for I in that array in one two three

272
00:09:43,620 --> 00:09:46,230
and so this is this is an example of

273
00:09:46,230 --> 00:09:48,930
running a function call you know n times

274
00:09:48,930 --> 00:09:51,870
or I times for that entire statement so

275
00:09:51,870 --> 00:09:53,400
if we run that we're gonna get one two

276
00:09:53,400 --> 00:09:55,850
three I just ran the entire file sorry

277
00:09:55,850 --> 00:09:59,610
we're gonna get one two three but you

278
00:09:59,610 --> 00:10:01,740
can also so if you wrap if you wrap the

279
00:10:01,740 --> 00:10:04,940
comprehension and parentheses or if you

280
00:10:04,940 --> 00:10:08,550
call the comprehension or you return it

281
00:10:08,550 --> 00:10:09,780
or you assign it to a variable it's

282
00:10:09,780 --> 00:10:11,760
going to be converted into an expression

283
00:10:11,760 --> 00:10:13,710
for you and so what that means is is

284
00:10:13,710 --> 00:10:15,990
that as we're generating the code we we

285
00:10:15,990 --> 00:10:17,340
look at the comprehension and we say is

286
00:10:17,340 --> 00:10:19,860
it being used is it being returned is it

287
00:10:19,860 --> 00:10:22,530
being assigned to and if it is then it

288
00:10:22,530 --> 00:10:24,870
gets converted into the result of the

289
00:10:24,870 --> 00:10:26,400
computation every single time through

290
00:10:26,400 --> 00:10:27,900
the comprehension so this just to be

291
00:10:27,900 --> 00:10:29,340
familiar to you if you've used Python

292
00:10:29,340 --> 00:10:32,280
before or but it's basically the

293
00:10:32,280 --> 00:10:34,890
equivalent of doing on each or a select

294
00:10:34,890 --> 00:10:39,270
or a filter so you are taking your

295
00:10:39,270 --> 00:10:40,740
you're applying the you're applying the

296
00:10:40,740 --> 00:10:42,240
block of code for every time through the

297
00:10:42,240 --> 00:10:43,710
loop and then you're taking the array of

298
00:10:43,710 --> 00:10:45,210
results and you're turning that array so

299
00:10:45,210 --> 00:10:48,960
here we're gonna print out one two three

300
00:10:48,960 --> 00:10:51,150
as an array I guess P will make that

301
00:10:51,150 --> 00:10:53,570
more clear because P will inspect that

302
00:10:53,570 --> 00:10:56,070
so now we'll see one two three as an

303
00:10:56,070 --> 00:10:58,110
array as the result of this and so

304
00:10:58,110 --> 00:10:59,820
internally what it's doing is its it's

305
00:10:59,820 --> 00:11:01,650
pushing the result of every time through

306
00:11:01,650 --> 00:11:02,940
onto an array and then returning that

307
00:11:02,940 --> 00:11:05,670
when it's done so but this works exactly

308
00:11:05,670 --> 00:11:07,590
identically for

309
00:11:07,590 --> 00:11:09,090
for anything else so here we're gonna

310
00:11:09,090 --> 00:11:13,560
put a try/catch block directly into puts

311
00:11:13,560 --> 00:11:16,230
and so if we run that we're gonna try to

312
00:11:16,230 --> 00:11:18,480
call a property on a missing object this

313
00:11:18,480 --> 00:11:19,980
object is not defined that doesn't exist

314
00:11:19,980 --> 00:11:22,170
and then catch the error and then print

315
00:11:22,170 --> 00:11:26,670
that out so we have the error is

316
00:11:26,670 --> 00:11:29,570
reference error missing is not defined

317
00:11:29,570 --> 00:11:33,560
and so internally what happens is

318
00:11:33,560 --> 00:11:37,440
basically every every single node in the

319
00:11:37,440 --> 00:11:40,260
grammar knows how to return itself so

320
00:11:40,260 --> 00:11:42,120
you can ask it to basically if you're an

321
00:11:42,120 --> 00:11:44,640
if and it and you're being asked to

322
00:11:44,640 --> 00:11:46,740
return it'll return all it'll return

323
00:11:46,740 --> 00:11:47,880
from any of the branches that it goes

324
00:11:47,880 --> 00:11:50,850
into if you're a for loop I mean if

325
00:11:50,850 --> 00:11:52,110
you're if you're a comprehension you ask

326
00:11:52,110 --> 00:11:53,670
to be returned you're gonna return the

327
00:11:53,670 --> 00:11:55,440
results of going through the array if

328
00:11:55,440 --> 00:11:57,030
you're a try-catch you're gonna return

329
00:11:57,030 --> 00:11:58,680
the either the try or the catch

330
00:11:58,680 --> 00:12:00,450
depending on what gets fired and so

331
00:12:00,450 --> 00:12:03,870
based on that anytime you need to

332
00:12:03,870 --> 00:12:05,370
convert an expression a javascript

333
00:12:05,370 --> 00:12:07,560
expression into a I mean start a

334
00:12:07,560 --> 00:12:08,850
JavaScript statement into an expression

335
00:12:08,850 --> 00:12:10,890
you can wrap it in a closure so if you

336
00:12:10,890 --> 00:12:12,090
wrap it in a closure and then you return

337
00:12:12,090 --> 00:12:14,130
the result now you have something that

338
00:12:14,130 --> 00:12:16,170
used to be a statement but instead it

339
00:12:16,170 --> 00:12:17,670
can be used an expression so that's

340
00:12:17,670 --> 00:12:20,340
what's going on internally there the

341
00:12:20,340 --> 00:12:21,510
other thing that I didn't mention that

342
00:12:21,510 --> 00:12:24,030
this demonstrates is this isn't being

343
00:12:24,030 --> 00:12:26,520
syntax highlighted in this but we have

344
00:12:26,520 --> 00:12:29,760
string interpolation as is proposed in

345
00:12:29,760 --> 00:12:31,860
Ekman script harmony I'm one really fun

346
00:12:31,860 --> 00:12:33,720
place to mine for language ideas is

347
00:12:33,720 --> 00:12:35,490
there's an echo script harmony wiki that

348
00:12:35,490 --> 00:12:36,870
has a whole bunch of things that they're

349
00:12:36,870 --> 00:12:38,040
thinking about putting into the next

350
00:12:38,040 --> 00:12:39,780
version of JavaScript and this is one of

351
00:12:39,780 --> 00:12:43,500
the proposals this is just a quick

352
00:12:43,500 --> 00:12:45,270
little demo of how the var works so you

353
00:12:45,270 --> 00:12:46,200
might have noticed that we're not

354
00:12:46,200 --> 00:12:49,320
declaring var at all but what ends up

355
00:12:49,320 --> 00:12:51,600
happening is that you're you're when you

356
00:12:51,600 --> 00:12:53,220
when you first use a variable when you

357
00:12:53,220 --> 00:12:55,290
first assign to a variable its var

358
00:12:55,290 --> 00:12:57,030
declaration is going to get pushed up to

359
00:12:57,030 --> 00:12:59,370
the top of the nearest lexical scope so

360
00:12:59,370 --> 00:13:02,400
in this case a is going to have you know

361
00:13:02,400 --> 00:13:04,140
the equivalent of var a out here because

362
00:13:04,140 --> 00:13:05,370
it was first even though it's being

363
00:13:05,370 --> 00:13:07,350
referenced in the same exact way inside

364
00:13:07,350 --> 00:13:08,490
the function it was first reference

365
00:13:08,490 --> 00:13:11,460
outside and then B will have a VAR b

366
00:13:11,460 --> 00:13:12,870
inside the function won't be visible

367
00:13:12,870 --> 00:13:14,220
from the outside scope so that's how

368
00:13:14,220 --> 00:13:16,230
that's handled for you what it means is

369
00:13:16,230 --> 00:13:18,090
that you can't you can't shadow

370
00:13:18,090 --> 00:13:20,250
variables inside of a function

371
00:13:20,250 --> 00:13:21,360
the same name you're always going to be

372
00:13:21,360 --> 00:13:23,550
referring to the outside variable and

373
00:13:23,550 --> 00:13:25,320
that's similar to languages like Ruby

374
00:13:25,320 --> 00:13:26,940
inside of blocks if you refer to a

375
00:13:26,940 --> 00:13:28,290
variable the same name it's always going

376
00:13:28,290 --> 00:13:29,370
to be the outside one so you have to

377
00:13:29,370 --> 00:13:30,510
pick it if your name if you actually

378
00:13:30,510 --> 00:13:32,610
mean a different variable because there

379
00:13:32,610 --> 00:13:34,830
isn't devar for you and I think that's

380
00:13:34,830 --> 00:13:36,180
that's a worthwhile trade-off the other

381
00:13:36,180 --> 00:13:37,560
way isn't workable at all if everything

382
00:13:37,560 --> 00:13:41,050
shadows then you can't get anything done

383
00:13:41,060 --> 00:13:44,940
here's another example of a clean up it

384
00:13:44,940 --> 00:13:48,080
we fix Java scripts which statement so

385
00:13:48,080 --> 00:13:51,360
so I guess we have chef a long example

386
00:13:51,360 --> 00:13:53,010
of what it looks like these are the same

387
00:13:53,010 --> 00:13:55,140
sort of implicit blocks you can say when

388
00:13:55,140 --> 00:13:58,050
Moe then do an action or you can indent

389
00:13:58,050 --> 00:14:02,250
it like this is equivalent but switches

390
00:14:02,250 --> 00:14:04,470
internally compile into if-else chains

391
00:14:04,470 --> 00:14:07,440
using object identity to match instead

392
00:14:07,440 --> 00:14:09,120
of a JavaScript switch case statement

393
00:14:09,120 --> 00:14:11,160
because Java scripts which cases are

394
00:14:11,160 --> 00:14:12,570
implemented using labels you can only do

395
00:14:12,570 --> 00:14:14,130
string comparisons you can't compare

396
00:14:14,130 --> 00:14:15,270
anything that's not a string and if you

397
00:14:15,270 --> 00:14:17,340
do it'll course it and then also you

398
00:14:17,340 --> 00:14:19,670
have to stick and break after every

399
00:14:19,670 --> 00:14:21,630
after every case we don't want to fall

400
00:14:21,630 --> 00:14:23,310
through so so instead of doing that this

401
00:14:23,310 --> 00:14:25,620
becomes an if-else so we can put this

402
00:14:25,620 --> 00:14:29,460
back the way it was and give it a try so

403
00:14:29,460 --> 00:14:31,320
if we run this actually nothing will

404
00:14:31,320 --> 00:14:32,790
happen so then let's call so which

405
00:14:32,790 --> 00:14:34,740
stooge which dude is a function that

406
00:14:34,740 --> 00:14:36,330
switches on stood when it's Moe then it

407
00:14:36,330 --> 00:14:37,920
says it's Moe when it's curly and this

408
00:14:37,920 --> 00:14:41,220
is using actual objects not strings so

409
00:14:41,220 --> 00:14:45,750
let's say puts which is huge curly and

410
00:14:45,750 --> 00:14:47,850
let's run this file and we'll have it's

411
00:14:47,850 --> 00:14:48,990
curly oh I'm sorry I was already put

412
00:14:48,990 --> 00:14:50,540
saying we can just say which ducha curly

413
00:14:50,540 --> 00:14:52,710
we can do the same thing for moe

414
00:14:52,710 --> 00:14:56,780
and let's look at what it compiles into

415
00:14:56,780 --> 00:14:59,280
so we have our we have our two objects

416
00:14:59,280 --> 00:15:02,160
and you can see how we have our function

417
00:15:02,160 --> 00:15:04,950
it's a named function if Stooges moe

418
00:15:04,950 --> 00:15:07,440
then we return that value you can see

419
00:15:07,440 --> 00:15:08,730
how the returns are getting pushed into

420
00:15:08,730 --> 00:15:11,130
each into each statement so because the

421
00:15:11,130 --> 00:15:13,080
switch that's a good example because the

422
00:15:13,080 --> 00:15:14,490
switch was the last thing that happened

423
00:15:14,490 --> 00:15:15,750
inside the function you're always going

424
00:15:15,750 --> 00:15:18,560
to return a value no matter what you do

425
00:15:18,560 --> 00:15:22,140
let's see is 10 22 all right here's that

426
00:15:22,140 --> 00:15:29,100
string interpolation so we have dollar

427
00:15:29,100 --> 00:15:31,530
sign and and so this this is exactly the

428
00:15:31,530 --> 00:15:32,820
same as the proposed harmony syntax

429
00:15:32,820 --> 00:15:34,110
dollar sign literal

430
00:15:34,110 --> 00:15:36,149
or you can do literally just gets

431
00:15:36,149 --> 00:15:38,399
interpolate it directly and then you can

432
00:15:38,399 --> 00:15:39,810
with dollar sign with brackets you can

433
00:15:39,810 --> 00:15:41,640
do arbitrary expressions inside of your

434
00:15:41,640 --> 00:15:46,740
interpolation so let's say Jeremy name

435
00:15:46,740 --> 00:15:59,070
is Jeremy there you go and one thing

436
00:15:59,070 --> 00:16:00,899
that we add is a pythons chain

437
00:16:00,899 --> 00:16:02,970
comparisons so if you have more than one

438
00:16:02,970 --> 00:16:05,040
greater than less than comparison in a

439
00:16:05,040 --> 00:16:07,079
row it's going to do the correct order

440
00:16:07,079 --> 00:16:09,089
of operations to make that value work so

441
00:16:09,089 --> 00:16:10,589
healthy is if your cholesterol is less

442
00:16:10,589 --> 00:16:15,000
than 200 and more than 60 so healthy 133

443
00:16:15,000 --> 00:16:17,040
is going to be true and healthy 40 is

444
00:16:17,040 --> 00:16:19,350
going to be false and what's going on

445
00:16:19,350 --> 00:16:20,700
under the scenes behind the scenes here

446
00:16:20,700 --> 00:16:23,880
is this gets converted into 200 is

447
00:16:23,880 --> 00:16:26,430
greater and cholesterol is greater than

448
00:16:26,430 --> 00:16:28,560
60 and so this is one of those cases

449
00:16:28,560 --> 00:16:30,420
where if you're doing some like this in

450
00:16:30,420 --> 00:16:31,560
your own language you have to be careful

451
00:16:31,560 --> 00:16:33,180
if you ever have to reference a variable

452
00:16:33,180 --> 00:16:36,240
multiple times two to compute a result

453
00:16:36,240 --> 00:16:37,529
you have to be careful that you don't

454
00:16:37,529 --> 00:16:39,329
call if it for example if if what's

455
00:16:39,329 --> 00:16:40,470
going on here's a function call that you

456
00:16:40,470 --> 00:16:41,550
don't call the function twice because

457
00:16:41,550 --> 00:16:42,959
then that could have side effects and

458
00:16:42,959 --> 00:16:44,100
could do something you don't want it to

459
00:16:44,100 --> 00:16:45,870
do so the way we get around that is if

460
00:16:45,870 --> 00:16:47,220
cholesterol is actually a function call

461
00:16:47,220 --> 00:16:50,190
here and you compiled that what's gonna

462
00:16:50,190 --> 00:16:51,510
happen is you're gonna get a temporary

463
00:16:51,510 --> 00:16:53,730
variable assigned to cholesterol and

464
00:16:53,730 --> 00:16:55,199
then referenced in the later one so you

465
00:16:55,199 --> 00:16:56,640
don't have to so it doesn't get called

466
00:16:56,640 --> 00:16:57,029
twice

467
00:16:57,029 --> 00:16:58,890
and that that's the case in general for

468
00:16:58,890 --> 00:17:00,540
for something we need to have multiple

469
00:17:00,540 --> 00:17:02,610
references to an expression but you

470
00:17:02,610 --> 00:17:04,049
don't want to evaluate more than once is

471
00:17:04,049 --> 00:17:07,530
we'll do a temporary variable in the

472
00:17:07,530 --> 00:17:12,319
output JavaScript so really quickly

473
00:17:12,319 --> 00:17:14,370
besides we saw the array comprehensions

474
00:17:14,370 --> 00:17:16,709
before where you're saying I in a list

475
00:17:16,709 --> 00:17:18,329
of numbers but you can also do it for

476
00:17:18,329 --> 00:17:23,309
objects so it's for its for sorry so for

477
00:17:23,309 --> 00:17:25,650
a number in a list of numbers or for key

478
00:17:25,650 --> 00:17:28,530
comma value of an object so in this case

479
00:17:28,530 --> 00:17:29,460
we're gonna look at all the keys and

480
00:17:29,460 --> 00:17:31,410
this is so this is all being powered by

481
00:17:31,410 --> 00:17:33,150
nodejs on the back end so we're looking

482
00:17:33,150 --> 00:17:35,190
at all the keys in the process object

483
00:17:35,190 --> 00:17:37,410
which is the one of the global objects

484
00:17:37,410 --> 00:17:38,880
that you have and you're going to get

485
00:17:38,880 --> 00:17:42,809
back your big list of of node signals

486
00:17:42,809 --> 00:17:45,270
and such and so that's an object

487
00:17:45,270 --> 00:17:46,919
comprehension and of course you can have

488
00:17:46,919 --> 00:17:47,870
a block inside

489
00:17:47,870 --> 00:17:49,550
doing however much code you need to do

490
00:17:49,550 --> 00:17:51,020
and then there's also range

491
00:17:51,020 --> 00:17:52,910
comprehensions so instead of having to

492
00:17:52,910 --> 00:17:54,559
write out if you if you're if you're if

493
00:17:54,559 --> 00:17:55,760
you're a for-loop was just gonna be

494
00:17:55,760 --> 00:17:57,710
numbers and you're going to start at

495
00:17:57,710 --> 00:17:58,880
zero and go up to a certain amount

496
00:17:58,880 --> 00:18:00,830
instead of that you can use a range

497
00:18:00,830 --> 00:18:03,470
literal this is the same as Ruby's range

498
00:18:03,470 --> 00:18:05,890
literal more or less so two dots is is

499
00:18:05,890 --> 00:18:08,450
inclusive of the final value and three

500
00:18:08,450 --> 00:18:11,000
dots is exclusive and so this is this is

501
00:18:11,000 --> 00:18:13,490
going to be the comprehension of I in

502
00:18:13,490 --> 00:18:15,890
zero to twenty let me take off this by

503
00:18:15,890 --> 00:18:18,650
two for a minute and then we're going to

504
00:18:18,650 --> 00:18:20,929
join it so there you have from 0 up to

505
00:18:20,929 --> 00:18:24,590
20 you can you can do steps so we can

506
00:18:24,590 --> 00:18:28,640
say by two and that'll give you the even

507
00:18:28,640 --> 00:18:31,490
numbers and you can also do filters so

508
00:18:31,490 --> 00:18:33,020
this is where this is where that select

509
00:18:33,020 --> 00:18:35,600
filter kind of thing comes in so for any

510
00:18:35,600 --> 00:18:37,280
comprehension you can say when and then

511
00:18:37,280 --> 00:18:39,260
you have an arbitrary condition to to

512
00:18:39,260 --> 00:18:42,010
satisfy so in this case let's say when I

513
00:18:42,010 --> 00:18:44,900
mod two is one and we'll get all the odd

514
00:18:44,900 --> 00:18:47,480
numbers or a but this when I'm on two

515
00:18:47,480 --> 00:18:53,179
isn't 0 isn't 0 and now we get all the

516
00:18:53,179 --> 00:18:57,160
odd numbers between 0 and 20 inclusive

517
00:18:57,160 --> 00:18:59,300
all right I'm gonna try to get through

518
00:18:59,300 --> 00:19:02,630
this on time so here's a JavaScript a

519
00:19:02,630 --> 00:19:04,280
statement again you can tell because of

520
00:19:04,280 --> 00:19:05,900
the semicolon so this is something

521
00:19:05,900 --> 00:19:06,920
you've probably done a lot where you

522
00:19:06,920 --> 00:19:07,970
have a default value you want to assign

523
00:19:07,970 --> 00:19:09,500
to a property inside at the beginning of

524
00:19:09,500 --> 00:19:14,420
a function so one of the simplest of

525
00:19:14,420 --> 00:19:16,400
plus equals and minus equals and divided

526
00:19:16,400 --> 00:19:18,530
by equals in JavaScript and in languages

527
00:19:18,530 --> 00:19:19,910
like Ruby you would have instead of

528
00:19:19,910 --> 00:19:22,210
writing this you would write or equals

529
00:19:22,210 --> 00:19:25,280
to say that the options or equals the

530
00:19:25,280 --> 00:19:27,800
default value so one thing that we do to

531
00:19:27,800 --> 00:19:29,000
get rid of those you can still use those

532
00:19:29,000 --> 00:19:30,410
if you want to they're present it's it's

533
00:19:30,410 --> 00:19:31,730
all sort of backwards compatible with

534
00:19:31,730 --> 00:19:33,350
JavaScript you can sort of slip into it

535
00:19:33,350 --> 00:19:35,090
easily but the cleaner way to say that

536
00:19:35,090 --> 00:19:38,660
is just assign it to the half expression

537
00:19:38,660 --> 00:19:41,150
so options that value gets or the

538
00:19:41,150 --> 00:19:42,950
default value or you could do gets and

539
00:19:42,950 --> 00:19:46,910
or you could do gets plus and this would

540
00:19:46,910 --> 00:19:49,280
be like doing a plus equals assigning it

541
00:19:49,280 --> 00:19:53,720
to plus the default value so let's talk

542
00:19:53,720 --> 00:19:54,590
about splats

543
00:19:54,590 --> 00:19:57,800
splats are a nice feature where you know

544
00:19:57,800 --> 00:19:59,360
if you if you have a splat in your

545
00:19:59,360 --> 00:20:01,070
argument list will compile that into the

546
00:20:01,070 --> 00:20:01,730
correct look

547
00:20:01,730 --> 00:20:04,970
up inside of the arguments array to get

548
00:20:04,970 --> 00:20:06,260
back what you need so here we've got

549
00:20:06,260 --> 00:20:08,240
Best Actor the first arguments going to

550
00:20:08,240 --> 00:20:09,800
be the winner and then every every next

551
00:20:09,800 --> 00:20:11,030
arguments gonna be a runners-up and

552
00:20:11,030 --> 00:20:12,020
we're just going to print out who the

553
00:20:12,020 --> 00:20:14,450
winner is and then pass in three three

554
00:20:14,450 --> 00:20:18,560
actors and you'll get the expected

555
00:20:18,560 --> 00:20:22,250
result and if we look at what that

556
00:20:22,250 --> 00:20:24,320
compiles into you're gonna see that

557
00:20:24,320 --> 00:20:25,610
we're gonna be so this is one example

558
00:20:25,610 --> 00:20:27,470
where we do have a reference to a

559
00:20:27,470 --> 00:20:29,090
special function just to keep the code

560
00:20:29,090 --> 00:20:31,550
shorter the actual outputting bytes so

561
00:20:31,550 --> 00:20:32,810
we make a cash reference to a rate

562
00:20:32,810 --> 00:20:34,160
prototype slice and we're gonna slice

563
00:20:34,160 --> 00:20:40,250
the runners-up to get that this is kind

564
00:20:40,250 --> 00:20:41,870
of a fun one the the existential

565
00:20:41,870 --> 00:20:47,000
operator if so so or the the logical or

566
00:20:47,000 --> 00:20:48,590
there's a lot of falsey values and

567
00:20:48,590 --> 00:20:50,540
JavaScript things that like zero the

568
00:20:50,540 --> 00:20:53,570
empty string that that you might be they

569
00:20:53,570 --> 00:20:54,770
might be confusing to you so if you're

570
00:20:54,770 --> 00:20:56,570
trying to set a default speed for

571
00:20:56,570 --> 00:21:00,140
example and you use or if the speed

572
00:21:00,140 --> 00:21:01,520
happens to be zero which is a perfectly

573
00:21:01,520 --> 00:21:03,140
valid speed to have it's gonna still get

574
00:21:03,140 --> 00:21:04,400
the default which isn't what you want so

575
00:21:04,400 --> 00:21:05,330
what you really want is you want to say

576
00:21:05,330 --> 00:21:06,950
if it's not undefined and it's not null

577
00:21:06,950 --> 00:21:08,930
you know those are that being that not

578
00:21:08,930 --> 00:21:12,530
exist values then then use it so the

579
00:21:12,530 --> 00:21:14,090
existential operator which is the

580
00:21:14,090 --> 00:21:17,470
question mark gives you a way to sort of

581
00:21:17,470 --> 00:21:20,390
to say if it's undefined or if it's null

582
00:21:20,390 --> 00:21:23,090
then you know do one thing or else do

583
00:21:23,090 --> 00:21:25,150
the other thing so in this case if we

584
00:21:25,150 --> 00:21:27,980
leave this the way that it is using or

585
00:21:27,980 --> 00:21:33,290
and run that you're gonna get back 140

586
00:21:33,290 --> 00:21:35,060
let's see I wouldn't go around your step

587
00:21:35,060 --> 00:21:38,240
part right you can get back 140 but if

588
00:21:38,240 --> 00:21:41,960
we use the existential operator you're

589
00:21:41,960 --> 00:21:43,040
gonna get back to the correct value

590
00:21:43,040 --> 00:21:44,810
which is it's gonna stay zero because

591
00:21:44,810 --> 00:21:47,390
there is a valid speed and so you can

592
00:21:47,390 --> 00:21:48,920
use the existential operator with in

593
00:21:48,920 --> 00:21:50,750
property chain if you're walking down a

594
00:21:50,750 --> 00:21:52,670
property chain this is similar to a soak

595
00:21:52,670 --> 00:21:55,460
in groovy where if that value is

596
00:21:55,460 --> 00:21:57,350
undefined that property is undefined and

597
00:21:57,350 --> 00:21:58,430
it's going to stop and you're gonna get

598
00:21:58,430 --> 00:22:02,000
back undefined as the result so in this

599
00:22:02,000 --> 00:22:05,300
case we can say put suit name let's get

600
00:22:05,300 --> 00:22:09,680
rid of this and it's gonna say sue sue

601
00:22:09,680 --> 00:22:12,640
name that length does exist

602
00:22:12,640 --> 00:22:15,700
to name dot length dot other does not

603
00:22:15,700 --> 00:22:18,310
and we'll get back let's see let's keep

604
00:22:18,310 --> 00:22:22,780
going other dot dot 1.2.3 it's spelled

605
00:22:22,780 --> 00:22:28,930
wrong you get back an error but if you

606
00:22:28,930 --> 00:22:30,190
want to soak it up and you want to

607
00:22:30,190 --> 00:22:32,110
assign this often happens and you want

608
00:22:32,110 --> 00:22:33,460
to assign if it doesn't exist then just

609
00:22:33,460 --> 00:22:34,750
give me back undefined and I don't need

610
00:22:34,750 --> 00:22:38,800
to to continue then we can say oh let's

611
00:22:38,800 --> 00:22:41,230
soak up the result of that chain after

612
00:22:41,230 --> 00:22:42,730
other and you're going to get back

613
00:22:42,730 --> 00:22:44,440
undefined instead of the instead of the

614
00:22:44,440 --> 00:22:49,210
big exception so yeah dude is a

615
00:22:49,210 --> 00:22:53,050
judicious judicious use of soaks can

616
00:22:53,050 --> 00:22:55,300
help clean up your accessing and I'm

617
00:22:55,300 --> 00:22:57,430
gonna try to wrap things up there's

618
00:22:57,430 --> 00:23:01,030
class literals which this this is

619
00:23:01,030 --> 00:23:02,830
basically a lightweight wrapper around

620
00:23:02,830 --> 00:23:04,210
so it's this isn't this isn't like a

621
00:23:04,210 --> 00:23:05,710
full-blown class system with runtime

622
00:23:05,710 --> 00:23:07,420
objects and stuff all this is is setting

623
00:23:07,420 --> 00:23:09,100
up is basically you have an object

624
00:23:09,100 --> 00:23:10,120
literal and you set properties on an

625
00:23:10,120 --> 00:23:11,680
object right you have a class little

626
00:23:11,680 --> 00:23:13,120
you're setting objects on the prototype

627
00:23:13,120 --> 00:23:13,960
you're setting properties on the

628
00:23:13,960 --> 00:23:15,880
prototype so that when you make a new

629
00:23:15,880 --> 00:23:17,410
object everything will be set up for you

630
00:23:17,410 --> 00:23:19,960
correctly and so the two extra things

631
00:23:19,960 --> 00:23:21,040
that this lets you do that aren't so

632
00:23:21,040 --> 00:23:23,500
easy in JavaScript is it helps you

633
00:23:23,500 --> 00:23:24,850
correctly extend the prototype chain

634
00:23:24,850 --> 00:23:27,070
there's a lot of ways to incorrectly

635
00:23:27,070 --> 00:23:29,020
except extend the prototype chain where

636
00:23:29,020 --> 00:23:30,700
you're breaking your inheritance and you

637
00:23:30,700 --> 00:23:32,890
can only get one level deep but this

638
00:23:32,890 --> 00:23:34,750
will this this uses something similar to

639
00:23:34,750 --> 00:23:36,460
Google haratz from the closure library

640
00:23:36,460 --> 00:23:38,940
if you guys have ever checked that out

641
00:23:38,940 --> 00:23:41,560
to to basically you can have arbitrarily

642
00:23:41,560 --> 00:23:43,570
long inheritance chains with with

643
00:23:43,570 --> 00:23:44,920
everything working correctly including

644
00:23:44,920 --> 00:23:47,800
super so you can call super and it'll

645
00:23:47,800 --> 00:23:49,870
reference the function of the same name

646
00:23:49,870 --> 00:23:52,390
on the immediate ancestor and you can of

647
00:23:52,390 --> 00:23:53,920
course pass variables to that and do the

648
00:23:53,920 --> 00:23:55,720
super things that are usually tricky to

649
00:23:55,720 --> 00:23:58,240
do without a class library in JavaScript

650
00:23:58,240 --> 00:24:00,880
so here let's say so here we've got a

651
00:24:00,880 --> 00:24:03,010
sea chantey our Mariners we can make a

652
00:24:03,010 --> 00:24:06,670
new Mariner and have him sing make a new

653
00:24:06,670 --> 00:24:08,260
sailor and we can see how sing is

654
00:24:08,260 --> 00:24:10,690
overridden this is all you know OOP 101

655
00:24:10,690 --> 00:24:13,750
and then the pirate calls super and then

656
00:24:13,750 --> 00:24:17,190
says are so loud the pirates sing and

657
00:24:17,190 --> 00:24:20,830
that's all as expected and let's see I

658
00:24:20,830 --> 00:24:22,690
think that's that's getting close to the

659
00:24:22,690 --> 00:24:25,660
end I'm going to wrap things up so in

660
00:24:25,660 --> 00:24:26,770
terms of implement

661
00:24:26,770 --> 00:24:29,560
this CoffeeScript was first written in

662
00:24:29,560 --> 00:24:31,540
Ruby it was a ruby gem because of course

663
00:24:31,540 --> 00:24:32,980
when you start working on a new language

664
00:24:32,980 --> 00:24:36,130
you have to start with something and but

665
00:24:36,130 --> 00:24:37,030
now it's written entirely in

666
00:24:37,030 --> 00:24:38,440
CoffeeScript so there was a point where

667
00:24:38,440 --> 00:24:41,800
we we had a working ruby version and

668
00:24:41,800 --> 00:24:43,420
then wrote a CoffeeScript version that

669
00:24:43,420 --> 00:24:45,160
was more or less parallel had the ruby

670
00:24:45,160 --> 00:24:46,810
version compiled that and then had the

671
00:24:46,810 --> 00:24:48,580
CoffeeScript Version compiled itself and

672
00:24:48,580 --> 00:24:50,770
then now that's where we are so it's

673
00:24:50,770 --> 00:24:52,030
like I guess is that there's that

674
00:24:52,030 --> 00:24:53,440
Wittgenstein staying about pulling up

675
00:24:53,440 --> 00:24:55,270
the ladder after you you know we can't

676
00:24:55,270 --> 00:24:56,830
go back now if if the CoffeeScript

677
00:24:56,830 --> 00:24:58,540
interpreter disappears then there's no

678
00:24:58,540 --> 00:24:59,890
way to compile it at this point because

679
00:24:59,890 --> 00:25:02,920
that's that's all that does it so um so

680
00:25:02,920 --> 00:25:05,050
it was using Ruby and rack and rack is a

681
00:25:05,050 --> 00:25:07,890
it's a it's a yak style lalr parser

682
00:25:07,890 --> 00:25:10,480
generator that's that's done in Ruby and

683
00:25:10,480 --> 00:25:12,670
C but so now that we're in JavaScript it

684
00:25:12,670 --> 00:25:14,890
uses Jason which a Zack is gonna give a

685
00:25:14,890 --> 00:25:16,180
talk about shortly I think it's not the

686
00:25:16,180 --> 00:25:18,190
next one but the one after this which is

687
00:25:18,190 --> 00:25:20,410
a nice flexible JavaScript parser

688
00:25:20,410 --> 00:25:22,840
generator so so that's that's the

689
00:25:22,840 --> 00:25:24,250
current mix it's got a handwritten lexer

690
00:25:24,250 --> 00:25:26,980
done in CoffeeScript it's got a rewriter

691
00:25:26,980 --> 00:25:28,750
so the token stream gets rewritten

692
00:25:28,750 --> 00:25:30,010
before it actually gets sent to the

693
00:25:30,010 --> 00:25:31,690
parser which is something that lets us

694
00:25:31,690 --> 00:25:35,650
get go beyond the sort of basic lalr

695
00:25:35,650 --> 00:25:38,260
grammar we're doing stuff with with the

696
00:25:38,260 --> 00:25:39,880
with the implicit calls where you can

697
00:25:39,880 --> 00:25:42,010
see how we're saying you know we have we

698
00:25:42,010 --> 00:25:43,390
have calls that don't need parentheses

699
00:25:43,390 --> 00:25:44,470
and then they get matched all the way

700
00:25:44,470 --> 00:25:46,470
down to the end of the of the block

701
00:25:46,470 --> 00:25:49,120
doing things like that with uh with the

702
00:25:49,120 --> 00:25:52,210
significant whitespace and also the rest

703
00:25:52,210 --> 00:25:54,910
of language features gets a little bit

704
00:25:54,910 --> 00:25:55,990
tricky if you're trying to fit that into

705
00:25:55,990 --> 00:25:57,040
you know this would seem like it'll be a

706
00:25:57,040 --> 00:25:58,870
very large large language try to fit

707
00:25:58,870 --> 00:26:00,130
into a grammar but if you rewrite the

708
00:26:00,130 --> 00:26:01,480
token stream in advance to remove

709
00:26:01,480 --> 00:26:02,860
ambiguities and things that would be

710
00:26:02,860 --> 00:26:05,050
ambiguous if you decide in advance oh

711
00:26:05,050 --> 00:26:06,910
this is the way that implicit calls work

712
00:26:06,910 --> 00:26:08,950
before the parts before the parser ever

713
00:26:08,950 --> 00:26:10,750
sees it then you can have a much smaller

714
00:26:10,750 --> 00:26:12,670
parser so including including the

715
00:26:12,670 --> 00:26:14,050
grammar including the rewriter including

716
00:26:14,050 --> 00:26:17,100
the lecture it's 1,800 1,800 lines of

717
00:26:17,100 --> 00:26:19,030
CoffeeScript so it's not it's not very

718
00:26:19,030 --> 00:26:22,150
big and then and then that and then the

719
00:26:22,150 --> 00:26:24,070
result of the parsing stages the ast and

720
00:26:24,070 --> 00:26:25,960
then to generate the JavaScript you just

721
00:26:25,960 --> 00:26:27,730
call compile at the top level of the ast

722
00:26:27,730 --> 00:26:29,890
and all walks down and every node you

723
00:26:29,890 --> 00:26:31,630
know passing information around compiles

724
00:26:31,630 --> 00:26:34,600
the resulting JavaScript output so all

725
00:26:34,600 --> 00:26:37,810
of this is available on CoffeeScript org

726
00:26:37,810 --> 00:26:39,940
it is

727
00:26:39,940 --> 00:26:43,179
it is sort of a fun project it's not

728
00:26:43,179 --> 00:26:44,950
it's not supposed to you know I'm not

729
00:26:44,950 --> 00:26:46,750
trying to sell you one using it for your

730
00:26:46,750 --> 00:26:48,250
next big web app I think it's fun to

731
00:26:48,250 --> 00:26:50,559
play around in and the language still

732
00:26:50,559 --> 00:26:52,090
might change until we go to 1.0 if

733
00:26:52,090 --> 00:26:53,559
things have settled down a lot recently

734
00:26:53,559 --> 00:26:55,870
it used to be much more unstable the

735
00:26:55,870 --> 00:26:57,100
first version didn't have significant

736
00:26:57,100 --> 00:26:58,450
whitespace and then people were you know

737
00:26:58,450 --> 00:27:00,309
talking about it and we we decided to

738
00:27:00,309 --> 00:27:02,350
add it but uh so the language might

739
00:27:02,350 --> 00:27:03,700
still change and that's the caveat but

740
00:27:03,700 --> 00:27:05,169
besides that it is being used some

741
00:27:05,169 --> 00:27:06,250
people are using in production to do

742
00:27:06,250 --> 00:27:08,590
different things here's a fun example of

743
00:27:08,590 --> 00:27:10,870
someone who's using it to generate art

744
00:27:10,870 --> 00:27:12,460
on their website so this is using

745
00:27:12,460 --> 00:27:13,919
CoffeeScript in Raphael to

746
00:27:13,919 --> 00:27:15,700
combinatorially combine a whole bunch of

747
00:27:15,700 --> 00:27:17,700
little sketches that he has going on and

748
00:27:17,700 --> 00:27:19,809
and then I've got a fun example of this

749
00:27:19,809 --> 00:27:24,399
of my own which is right here so this

750
00:27:24,399 --> 00:27:26,679
shows that you don't really lose you're

751
00:27:26,679 --> 00:27:28,179
not gonna really lose any speed from

752
00:27:28,179 --> 00:27:30,009
from what JavaScript would be doing if

753
00:27:30,009 --> 00:27:31,299
you do something in CoffeeScript because

754
00:27:31,299 --> 00:27:32,379
it's gonna be a one-to-one translation

755
00:27:32,379 --> 00:27:34,570
so this is v8 powering a strange

756
00:27:34,570 --> 00:27:37,509
attractor that we can let's see we can

757
00:27:37,509 --> 00:27:41,039
reseed and draw in different ways and

758
00:27:41,039 --> 00:27:43,750
the and the processing speed of v8 here

759
00:27:43,750 --> 00:27:46,120
is is very good it's comparable actually

760
00:27:46,120 --> 00:27:48,159
to the to the Java processing versions

761
00:27:48,159 --> 00:27:51,580
of this same of the same sketch so again

762
00:27:51,580 --> 00:27:53,440
it's all on CoffeeScript org there is an

763
00:27:53,440 --> 00:27:55,539
interactive compiler you can try it'll

764
00:27:55,539 --> 00:27:57,549
it'll compile as you type right here

765
00:27:57,549 --> 00:27:59,649
it's running in the browser there's also

766
00:27:59,649 --> 00:28:01,960
the entire annotated source right next

767
00:28:01,960 --> 00:28:03,460
to that so if you want to read what the

768
00:28:03,460 --> 00:28:04,840
grammar looks like you can pop over to

769
00:28:04,840 --> 00:28:06,789
that and you can check out what all the

770
00:28:06,789 --> 00:28:08,710
rules are so here's statements

771
00:28:08,710 --> 00:28:11,100
expressions all this kind of stuff and

772
00:28:11,100 --> 00:28:13,809
come talk to me about it after if you

773
00:28:13,809 --> 00:28:19,110
have any more questions and thanks a lot

