<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Xi3sxygtDc4</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/Xi3sxygtDc4?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="12.929" data-end="15.48">Thank you.</span> <span data-start="15.48" data-end="16.76">GraphQL.</span> <span data-start="16.76" data-end="20.369">You might have heard of it by now, and, if you have, you've heard about how to it's great</span> <span data-start="20.369" data-end="27.66">for performance, backwards compatibility, and great for those hard to get out stains!</span> <span data-start="27.66" data-end="29.2">Probably!</span> </p>
<p><span data-start="29.2" data-end="31.24">There's seemingly nothing it can't do.</span> <span data-start="31.24" data-end="33.73">But have you wondered how?</span> <span data-start="33.73" data-end="36.93">How can GraphQL have these supposed superpowers?</span> <span data-start="36.93" data-end="41.16">I think the key to this lays in its basic building blocks.</span> <span data-start="41.16" data-end="46.079">In this talk, we will start off by taking a look at the schema definition language,</span> <span data-start="46.079" data-end="51.54">RSL, and the resolvers, and understand how they work together to execute a query.</span> <span data-start="51.54" data-end="57.63">Then I will show ways to use these features to graph all the things before finally entering</span> <span data-start="57.63" data-end="60.61">the "don't try this at home" portion of the talk.</span> <span data-start="60.61" data-end="69.32">First, g, the ' day, how is it going?</span> <span data-start="69.32" data-end="74.939">We work on building tooling services and platforms to enable at Red Bubble.</span> <span data-start="74.939" data-end="82.68">I'm the maintainer of Lis Sass and notes Sass.</span> <span data-start="82.68" data-end="84.29">So let's jump right into it.</span> <span data-start="84.29" data-end="86.75">The schema is the skeleton of GraphQL.</span> <span data-start="86.75" data-end="87.8">It's what gives it its shape.</span> </p>
<p><span data-start="87.8" data-end="91.45">Everything else builds on top of or happens because of the schema.</span> <span data-start="91.45" data-end="94.979">It is defined using the schema definition language.</span> <span data-start="94.979" data-end="98.28">We are we have an example schema.</span> <span data-start="98.28" data-end="103.34">We're using "type" to define conference.</span> <span data-start="103.34" data-end="106.85">Our conference type is a name field which we set as a string.</span> <span data-start="106.85" data-end="111.63">String is one of the skeletypes, in graph, and others like ints, floats, and booleans</span> <span data-start="111.63" data-end="114.76">and the other suspects.</span> <span data-start="114.76" data-end="120.49">We have a speakers' field which has an array of the speaker type.</span> <span data-start="120.49" data-end="123.74">It's not a built-in type, so we define it ourselves.</span> <span data-start="123.74" data-end="126.89">Our speaker has a name and a favourite emoji.</span> </p>
<p><span data-start="126.89" data-end="132.29">This gives me licence to use member throughout the talk!</span> <span data-start="132.29" data-end="134.65">We have some fields with exclamation marks and others don't.</span> <span data-start="134.65" data-end="139.069">It means a field is omitted but still valid.</span> <span data-start="139.069" data-end="145.939">IDs are convenient for querying and mutating data.</span> <span data-start="145.939" data-end="153.359">Speaking of querying and mutating data, we have the query types called root types.</span> <span data-start="153.359" data-end="156.169">There are others too but we're not going to talk about them today.</span> <span data-start="156.169" data-end="160.73">On our query type, we have a conference field that returns any conferences we know about.</span> <span data-start="160.73" data-end="167.78">We also have a speaker's field that has a required emoji argument and returns some speakers.</span> <span data-start="167.78" data-end="168.819">We have a mutation type.</span> <span data-start="168.819" data-end="173.4">It has a speak field, that takes a speaker ID and a Conference ID.</span> </p>
<p><span data-start="173.4" data-end="178.519">Something to note, it's common to refer to fields on query mutation types.</span> <span data-start="178.519" data-end="185.42">You see return-type mutation looks like the return type of a query field.</span> <span data-start="185.42" data-end="190.78">A field on a mutation could return things like booleans but as richer types as part</span> <span data-start="190.78" data-end="192.809">of the expressiveness of GraphQL.</span> <span data-start="192.809" data-end="198.5">There is some detail as to how these are defined that we won't go into today.</span> </p>
<p><span data-start="198.5" data-end="202.12">The important thing to take away from this is the field in the query type to ask for</span> <span data-start="202.12" data-end="205.909">information whereas fields and mutation type typically change things.</span> <span data-start="205.909" data-end="213.28">Lastly, the resulting data from mutation can be expected to have the changes already applied.</span> <span data-start="213.28" data-end="217.109">The schemas are the skeletons of GraphQL and at their beating heart.</span> <span data-start="217.109" data-end="218.9">They bring life to GraphQL.</span> <span data-start="218.9" data-end="223.739">With the amazing things that GraphQL can do, you would think they would be pretty complicated,</span> <span data-start="223.739" data-end="228.499">but it's the simplicity of resolvers that is the key to their flexibility.</span> <span data-start="228.499" data-end="229.779">It's just a function.</span> <span data-start="229.779" data-end="231.42">It takes a couple of arguments.</span> <span data-start="231.42" data-end="235.069">We're going to talk about these three today, but there are others.</span> <span data-start="235.069" data-end="240.43">You can define a resolver or any or all fields on your schema, including fields in the query</span> <span data-start="240.43" data-end="248.109">type, the speak field, and fields on any type like the emoji field on the speaker type.</span> <span data-start="248.109" data-end="252.209">Inside a resolver, you can do anything it could do in any other JavaScript function.</span> </p>
<p><span data-start="252.209" data-end="256.199">The only requirement is that it returns of value in the shape that matches the type of</span> <span data-start="256.199" data-end="260.389">the field that it is responsible for.</span> <span data-start="260.389" data-end="261.64">Here we have a map of resolvers.</span> <span data-start="261.64" data-end="266.09">It has a query object representing the query type.</span> <span data-start="266.09" data-end="270.08">And a query object, there is a speaker's resolver.</span> <span data-start="270.08" data-end="272.59">A speaker's query has an emoji argument.</span> <span data-start="272.59" data-end="277.33">We can access that argument by the name on the arc's argument on its resolver.</span> <span data-start="277.33" data-end="283.73">We know from our schema that the query should returning the or an array of speaker types.</span> <span data-start="283.73" data-end="290.36">Here it's returning an array of objects which have an integer ID field and a name and an</span> <span data-start="290.36" data-end="295.36">emoji string field which means they match the expected shape of the query and all is</span> <span data-start="295.36" data-end="296.36">well.</span> </p>
<p><span data-start="296.36" data-end="302.49">Remember, the conference field doesn't have an exclamation mark so it's entirely optional</span> <span data-start="302.49" data-end="303.49">here.</span> <span data-start="303.49" data-end="311.25">Our speaker mutation â€” here we have a speaker mutation loading data from the context by</span> <span data-start="311.25" data-end="313.79">the conference ID argument.</span> </p>
<p><span data-start="313.79" data-end="317.08">Conference is a bit special.</span> <span data-start="317.08" data-end="322.159">It makes it useful for storing things like configuration or services like database connections.</span> <span data-start="322.159" data-end="328.219">After it is loaded, the speaker ID argument is appended to the conference object, the</span> <span data-start="328.219" data-end="336.449">- finally does a query for the conferences that the speaker is attending.</span> <span data-start="336.449" data-end="337.449">So that was a lot.</span> <span data-start="337.449" data-end="339.939">But it is just a groundwork for what is coming up next.</span> <span data-start="339.939" data-end="345.379">We're going to take a look at practical use of resolvers to feel how they work together</span> <span data-start="345.379" data-end="349.57">and give you the versatility of GraphQL.</span> <span data-start="349.57" data-end="351.81">The simplest resolver is one that returns an object.</span> <span data-start="351.81" data-end="356.199">Earlier, we saw a resolver and all good because it returned a resolver that matched the shape</span> <span data-start="356.199" data-end="361.5">of the speaker type before how does GraphQL match the speaker shape?</span> </p>
<p><span data-start="361.5" data-end="365.639">Is there some kind of internal validation engine or some form of intro expect on their</span> <span data-start="365.639" data-end="367.37">return type or AI?</span> <span data-start="367.37" data-end="370.069">GraphQL can do these magical things.</span> <span data-start="370.069" data-end="372.41">Why not build AI in there?</span> <span data-start="372.41" data-end="376.509">No doubt there is a way to return these types.</span> <span data-start="376.509" data-end="381.069">If you're like me, you're thinking about how you would have done it yourself.</span> <span data-start="381.069" data-end="383.569">I've shown you how it happens.</span> <span data-start="383.569" data-end="387.53">Every field from GraphQL gets a default resolver.</span> <span data-start="387.53" data-end="389.919">The default resolver is straightforward.</span> </p>
<p><span data-start="389.919" data-end="394.979">For any field, it takes the object, the parent object and tries to be the access a field</span> <span data-start="394.979" data-end="398.43">as a function call, or an object property on the parent.</span> <span data-start="398.43" data-end="404.13">Importantly, this happens recursively, so, if a field returns a type, the field's return</span> <span data-start="404.13" data-end="409.24">type is a custom type, then all the fields on that type have their resolvers called.</span> <span data-start="409.24" data-end="411.74">This is what happens in our case.</span> <span data-start="411.74" data-end="415.87">The schema for our speaker's query returns return type to a null or an array of speaker</span> <span data-start="415.87" data-end="417.69">type.</span> <span data-start="417.69" data-end="419.35">GraphQL takes the speaker value.</span> <span data-start="419.35" data-end="421.72">If it is null, it's returned.</span> <span data-start="421.72" data-end="425.49">If it is an array, the value is iterated over and a resolver default is called for each</span> <span data-start="425.49" data-end="427.8">speaker field.</span> <span data-start="427.8" data-end="432.569">The parent armed for the resolver is the object at the current loop of the array.</span> </p>
<p><span data-start="432.569" data-end="437.02">If a resolver for a field returns the wrong time, GraphQL throws an error.</span> <span data-start="437.02" data-end="442.509">Also, if the return type of the initial speaker's query isn't null or an array, we also get</span> <span data-start="442.509" data-end="443.509">an error.</span> <span data-start="443.509" data-end="448.61">The default resolver is a great example of how we use building blocks to solve tricky</span> <span data-start="448.61" data-end="450.719">problems like validation.</span> <span data-start="450.719" data-end="457.15">So, a common use case for GraphQL is putting it in front of existing APIs.</span> <span data-start="457.15" data-end="461.099">This really its bread and butter and what gave it momentum to start off with.</span> </p>
<p><span data-start="461.099" data-end="463.33">Even here, there are interesting possibilities.</span> <span data-start="463.33" data-end="468.54">Here, I've updated our speaker query to make an HTTP request instead of returning a hard-coded</span> <span data-start="468.54" data-end="471.77">API.</span> <span data-start="471.77" data-end="474.58">The schema could have different types.</span> <span data-start="474.58" data-end="482.71">In this case, you iterate over the JSON and transform it to the phenotype you expect.</span> <span data-start="482.71" data-end="486.61">Once again, we've added the conference resolver to the speaker type.</span> <span data-start="486.61" data-end="489.469">There are a couple of interesting things happening here.</span> </p>
<p><span data-start="489.469" data-end="492.27">Firstly, using both jQuery and fetch.</span> <span data-start="492.27" data-end="493.849">Because, why wouldn't you?</span> <span data-start="493.849" data-end="498.122">You have the entire power of JavaScript and MPM at our resolvers, so we might as well</span> <span data-start="498.122" data-end="500.43">use it all.</span> <span data-start="500.43" data-end="508.73">We are iterating over the array of speakers, and for each of those speakers, the conference</span> <span data-start="508.73" data-end="511.5">resolver has called from an entirely different API.</span> <span data-start="511.5" data-end="517.5">Here, GraphQL's essentially aggregating across multiple APIs in order to resolve a single</span> <span data-start="517.5" data-end="518.5">query.</span> <span data-start="518.5" data-end="522.06">The remaining queries are resolved using a default resolver.</span> <span data-start="522.06" data-end="525.38">You can have a resolver with any or all fields.</span> <span data-start="525.38" data-end="532.18">You can resolve all fields by its own API and users wouldn't be any the wiser.</span> </p>
<p><span data-start="532.18" data-end="537.8">I'm not saying you should do this but you could if you wanted to.</span> <span data-start="537.8" data-end="541.649">GraphQL got a lot of attention early on because of how well it worked as a facade on top of</span> <span data-start="541.649" data-end="547.17">these fragmented APIs which often had incompatible methods of authentication, different transport</span> <span data-start="547.17" data-end="550.17">types or content types.</span> <span data-start="550.17" data-end="556.93">We can expose a single interface over â€” you have, APIs, without having to rewrite any</span> <span data-start="556.93" data-end="557.93">of them.</span> <span data-start="557.93" data-end="562.55">It wasn't long before people start rescinding these ideas, sometimes cutting out the APIs</span> <span data-start="562.55" data-end="565.05">altogether and going straight to the database.</span> <span data-start="565.05" data-end="569.29">Some truly innovative people have gone as far as defining the schemas themselves in</span> <span data-start="569.29" data-end="571.88">a different language.</span> <span data-start="571.88" data-end="577.81">Here, we are resolving a speaker query by making a -gate query.</span> <span data-start="577.81" data-end="587.53">We are pulling the database operation â€” we set this up earlier.</span> <span data-start="587.53" data-end="591.209">Because you have the full power of JavaScript to get a disposal here, you can do all the</span> <span data-start="591.209" data-end="597.66">things you would do in an attractional RM, like read or write instances, whatever the</span> <span data-start="597.66" data-end="599.79">requirements of that field might be.</span> <span data-start="599.79" data-end="605.73">If you can use a database, there's no reason you can't use any other kind of of data store.</span> </p>
<p><span data-start="605.73" data-end="611.51">Here, we are mixing and matching between relation al databases, elastic searches, at the field</span> <span data-start="611.51" data-end="612.51">resolver level.</span> <span data-start="612.51" data-end="617.44">Being able to make these choices at the field resolver levels allows us to fit best-fit</span> <span data-start="617.44" data-end="621.68">solutions for the requirements of an individual field and changes of requirements over time</span> <span data-start="621.68" data-end="623">as our systems change.</span> <span data-start="623" data-end="628.29">By no means saying this is unique to GraphQL, simply aiming to illustrate the ease as which</span> <span data-start="628.29" data-end="634.29">these capabilities are achieved between â€” within the play between schemas and resolvers within</span> </p>
<p><span data-start="634.29" data-end="635.29">GraphQL.</span> <span data-start="635.29" data-end="637.88">This is actually my favourite use case.</span> <span data-start="637.88" data-end="642.63">I said earlier that the platform team is a bubble, we focus on enabling everyone, not</span> <span data-start="642.63" data-end="643.63">just engineers.</span> <span data-start="643.63" data-end="648.04">The way we do this is let people bring their own tools and adapt our systems to work with</span> <span data-start="648.04" data-end="649.62">them.</span> <span data-start="649.62" data-end="651.28">Enter spreadsheets.</span> <span data-start="651.28" data-end="656.26">Who doesn't love a good spreadsheet in I know I do, our copy writers do, our data scientists</span> <span data-start="656.26" data-end="657.8">do.</span> </p>
<p><span data-start="657.8" data-end="663.279">They're practically ubiquitous and this makes them a powerful tool for enabling and encouraging</span> <span data-start="663.279" data-end="665.5">contributions.</span> <span data-start="665.5" data-end="668.889">Spreadsheets are fantastic for GraphQL because they are already structured.</span> <span data-start="668.889" data-end="673.49">They come with their own schemas in the form of columns and rows.</span> <span data-start="673.49" data-end="683.389">Here our speaker's query is loading it from disk, filtering the speakers to knows matching</span> <span data-start="683.389" data-end="686.04">the emoji we passed them as a query alter.</span> <span data-start="686.04" data-end="691.949">Now, anyone in our organisation can drag and drop a new spreadsheet on the GitHub UI.</span> </p>
<p><span data-start="691.949" data-end="699.86">This kicks off our pipelines, and if the test passes, this is live for everyone to see,</span> <span data-start="699.86" data-end="704.74">no engineer was required for this process.</span> <span data-start="704.74" data-end="713.019">I mentioned at Red Bubble, we have a lot of this GraphQL distributed and a lot of configuration</span> <span data-start="713.019" data-end="715.829">services to back this up.</span> <span data-start="715.829" data-end="719.959">These configurations services are different to other services in that they fetch configuration</span> <span data-start="719.959" data-end="721.699">on deploy and fetch low locally.</span> <span data-start="721.699" data-end="725.35">They're not meant to be used in request.</span> <span data-start="725.35" data-end="730.31">They may get over-the-wire updates as their lifetime goes on.</span> <span data-start="730.31" data-end="733.81">We like the approach for â€” but it covers the complexities.</span> <span data-start="733.81" data-end="738.339">Is is is the configuration stored in memory or on disk?</span> <span data-start="738.339" data-end="740.339">What happens when we receive an update?</span> <span data-start="740.339" data-end="743.76">How do we validate the new configuration?</span> <span data-start="743.76" data-end="748.23">We tried a few ways of managing and exposing configuration in our services and as you might</span> <span data-start="748.23" data-end="751.56">expected, we eventually landed on GraphQL.</span> </p>
<p><span data-start="751.56" data-end="755.14">Loading configuration files in resolver is pretty straightforward using the FS promises</span> <span data-start="755.14" data-end="756.14">API.</span> <span data-start="756.14" data-end="763.61">If we're unable to load the configuration for any reason, the server fails to boot.</span> <span data-start="763.61" data-end="767.269">This works really well in many cloud environments because currently running it deploys will</span> <span data-start="767.269" data-end="773.54">keep running until new versions can come up, so we don't lose any downtime.</span> <span data-start="773.54" data-end="780.41">Next up internally, we created a configuration object by querying for that GraphQL configuration.</span> <span data-start="780.41" data-end="785.81">If some important data is missing or if the data is otherwise unsuitable, the query fails</span> <span data-start="785.81" data-end="788.329">and the service failed fails to boot again.</span> <span data-start="788.329" data-end="794.39">Here, GraphQL's acting as an internal API abstracting over the node files APIs and abstracting</span> <span data-start="794.39" data-end="800.48">over the complexities of dealing with validity and freshness.</span> <span data-start="800.48" data-end="803.98">So some of you may have the inned in a previous slide, it was a chicken-and-egg scenario,</span> <span data-start="803.98" data-end="809.47">how to load configuration and put it in context if we are loading configuration inside a resolver?</span> </p>
<p><span data-start="809.47" data-end="812.43">This is where we do something nifty.</span> <span data-start="812.43" data-end="819.75">We create multiple GraphQL servers with their own schemas and resolvers.</span> <span data-start="819.75" data-end="824.48">One server handles incoming requests and reloads configuration by querying the second GraphQL</span> <span data-start="824.48" data-end="826.92">server.</span> <span data-start="826.92" data-end="828.17">That's right.</span> <span data-start="828.17" data-end="833.63">You can even use GraphQL to abstract over GraphQLs running on the same machine.</span> </p>
<p><span data-start="833.63" data-end="838.59">In fact, just about any API that is simply reads and writes can be represented as GraphQL</span> <span data-start="838.59" data-end="841.3">queries and mutations.</span> <span data-start="841.3" data-end="848.17">This is a real â€” this got me thinking â€” a light build up bulb moment for me.</span> <span data-start="848.17" data-end="850.73">What if our JavaScript APIs were GraphQL?</span> <span data-start="850.73" data-end="856.98">What if the browsers had a GraphQL interface?</span> <span data-start="856.98" data-end="860.55">This is my friends when things go off the rails.</span> <span data-start="860.55" data-end="863.139">Welcome to the don't try this portion at home.</span> <span data-start="863.139" data-end="866.06">Don't try this at home portion of the talk.</span> <span data-start="866.06" data-end="869.649">I hope by now I've been able to convince you that enough about any read or write interface</span> <span data-start="869.649" data-end="872.82">can be like plastered over with graphical representation.</span> <span data-start="872.82" data-end="877.68">This got me thinking: the browser has read and write APIs.</span> <span data-start="877.68" data-end="880.079">Surely these could have some graphical interfaces.</span> <span data-start="880.079" data-end="885.959">As it turns out, there's nothing about GraphQL that inherently limits you in server environments.</span> <span data-start="885.959" data-end="890.86">As long as you have a schema and resolver map, most implementations are happily run</span> <span data-start="890.86" data-end="891.87">in the browser.</span> <span data-start="891.87" data-end="892.87">Why?</span> </p>
<p><span data-start="892.87" data-end="897.1">I think there are a couple of good reasons for this.</span> <span data-start="897.1" data-end="901.43">We live in a world of heavy browser feature fragmentation, and even when those features</span> <span data-start="901.43" data-end="906.74">exist, like the rolled out in a progressive manner, with API fragmentation in those features.</span> <span data-start="906.74" data-end="912.889">There's the complexities of dealing with progressive enhance the and degradation because it's fun.</span> <span data-start="912.889" data-end="917.279">Admittedly, I did if for the fun, but there's something valuable in the idea of the interface</span> <span data-start="917.279" data-end="919.209">across all our web languages.</span> <span data-start="919.209" data-end="923.24">Let's look at some examples.</span> <span data-start="923.24" data-end="928.829">We've looked at how we use resolvers to interact with data stores, but the browser has a bunch</span> <span data-start="928.829" data-end="929.829">of its own data stores.</span> <span data-start="929.829" data-end="935.98">We have the web storage APIs in local storage and session storage, web SQL databases, and</span> <span data-start="935.98" data-end="936.98">cookies.</span> <span data-start="936.98" data-end="942.48">With a bit of creativity, you can stuff any kind of data inside a URL.</span> <span data-start="942.48" data-end="947.04">There's a handful of libraries that do this for us acting as an interface across a buffer</span> <span data-start="947.04" data-end="955.35">of these storage engines with using a mix of feature detection or polyfills.</span> </p>
<p><span data-start="955.35" data-end="957.6">And so abstracting over data source is something that GraphQL is already good at.</span> <span data-start="957.6" data-end="960.24">It's a really great fit for the scenario.</span> <span data-start="960.24" data-end="964.5">We are, we've taken the spreadsheet consolidate from earlier, but reading a file off disk</span> <span data-start="964.5" data-end="969.779">we're using it as an abstraction over various browser storage APIs.</span> <span data-start="969.779" data-end="974.529">Libraries will progressively enhance or degrade, depending on which APIs are available in the</span> <span data-start="974.529" data-end="977.59">current environment.</span> </p>
<p><span data-start="977.59" data-end="981.319">More importantly, the user APIs don't get to juggle all the different APIs themselves</span> <span data-start="981.319" data-end="984.17">or learn a whole new third-party API.</span> <span data-start="984.17" data-end="988.519">They're just looking at the schema for the types required and executing queries and mutations</span> <span data-start="988.519" data-end="992.269">as they already know how to on server.</span> <span data-start="992.269" data-end="998.069">Just like on the server, a browser has equally capable of making network requests to APIs.</span> <span data-start="998.069" data-end="1002.63">Just like on the server, we can call it working APIs within the resolvers.</span> <span data-start="1002.63" data-end="1008.33">Just like â€” we can gratefully degrade depending on what is available in the operating environment.</span> <span data-start="1008.33" data-end="1013.66">And that, my friends, is running GraphQL in the browser.</span> <span data-start="1013.66" data-end="1016.089">I think that's pretty cool.</span> <span data-start="1016.089" data-end="1017.269">So I thought I would end it here.</span> </p>
<p><span data-start="1017.269" data-end="1021.689">Like, in many ways, browser JS isn't different from the server side JS.</span> <span data-start="1021.689" data-end="1027.089">It's not surprising they're able to use GraphQL as an abstraction layer over finicky APIs.</span> <span data-start="1027.089" data-end="1030.47">There's something unique to the browser.</span> <span data-start="1030.47" data-end="1034.22">Does GraphQL still hold up in this new world?</span> <span data-start="1034.22" data-end="1036.68">For example, our good old buddy, the DOM.</span> <span data-start="1036.68" data-end="1039.3">DOM libraries are nothing new.</span> <span data-start="1039.3" data-end="1042.64">Some started our JavaScript journeys with DOJO.</span> <span data-start="1042.64" data-end="1055.09">Even new, like, in React â€” here is an example of what a schema might look like for document</span> <span data-start="1055.09" data-end="1056.29">query selector.</span> <span data-start="1056.29" data-end="1059.4">All the dollar-sign functions in jQuery.</span> <span data-start="1059.4" data-end="1063.44">And this is what the resolvers might look like.</span> <span data-start="1063.44" data-end="1067.82">We have a document query to get to our document object and the document type has APIs we care</span> <span data-start="1067.82" data-end="1069.32">about and fields.</span> </p>
<p><span data-start="1069.32" data-end="1074.91">The resolvers for those fields just call methods on the parent, the parent being document in</span> <span data-start="1074.91" data-end="1075.91">this case.</span> <span data-start="1075.91" data-end="1079.1">And I think things â€” things pretty much work as expected.</span> <span data-start="1079.1" data-end="1081.3">By now, you should not be surprised by anything on the slide.</span> <span data-start="1081.3" data-end="1084.29">It's like previous examples we've seen before.</span> <span data-start="1084.29" data-end="1086.6">The question you might have is why?</span> <span data-start="1086.6" data-end="1088.68">Why even do this?</span> <span data-start="1088.68" data-end="1090.01">And I get it: I was up front.</span> <span data-start="1090.01" data-end="1092.01">These aren't necessarily good ideas.</span> <span data-start="1092.01" data-end="1096.83">They're just ideas, but honestly, slides like this I think is why.</span> <span data-start="1096.83" data-end="1100.59">Every time I forget to await my fetch only to have JavaScript yell at me that I can't</span> <span data-start="1100.59" data-end="1103.91">use top-level awaits is why.</span> <span data-start="1103.91" data-end="1108.45">Every time I forget Node list aren't actually arrays is why.</span> </p>
<p><span data-start="1108.45" data-end="1112.46">Every time I decide whether to have to decide to use a callback or a promise interface is</span> <span data-start="1112.46" data-end="1113.65">why.</span> <span data-start="1113.65" data-end="1119.35">All the reasons you might use jQuery today because it's easier is why.</span> <span data-start="1119.35" data-end="1122.15">Something about these slides really speaks to me.</span> </p>
<p><span data-start="1122.15" data-end="1127.69">But I have to concede, building and maintaining a schema like this for the entirety of the</span> <span data-start="1127.69" data-end="1129.22">DOM is kind of absurd.</span> <span data-start="1129.22" data-end="1132.59">I get shivers thinking about what it would take to maintain.</span> <span data-start="1132.59" data-end="1137">So maybe some enterprising folks could generate schemas and resolvers by scraping things like</span> <span data-start="1137" data-end="1145.97">MDN or W3C specs or get crazy with web IDL, or maybe if we don't have the schema.</span> <span data-start="1145.97" data-end="1150.18">I know I spent you 20 minutes saying they're amazing and the skeleton of GraphQL.</span> <span data-start="1150.18" data-end="1156.18">That's all true, but also I'm really lazy, like super lazy.</span> <span data-start="1156.18" data-end="1158.12">Did you see that schema?</span> <span data-start="1158.12" data-end="1161.13">It's massive, and it's not getting any smaller any time.</span> <span data-start="1161.13" data-end="1165.11">So if we don't have schemas, we don't need resolvers, either.</span> <span data-start="1165.11" data-end="1181.66">I know, the beating heart of GraphQL, life blood, blah, blah, blah .. if I squint my</span> <span data-start="1181.66" data-end="1187.55">eyes and tilt my head and use imagination, this looks like the resolver we had in our</span> </p>
<p><span data-start="1187.55" data-end="1190.37">DOM APIs.</span> <span data-start="1190.37" data-end="1194.67">So what if we define our own default resolver?</span> <span data-start="1194.67" data-end="1199.71">A single resolver that was general enough to handle any field for any DOM API, if it</span> <span data-start="1199.71" data-end="1203.36">follows a general pattern of fields being properties or functions on their parents,</span> <span data-start="1203.36" data-end="1204.96">then we don't really need the schema.</span> <span data-start="1204.96" data-end="1208.43">Like the DOM is the schema, like MDM becomes our schema.</span> <span data-start="1208.43" data-end="1215">I thought it was a nifty idea and gave it a shot.</span> <span data-start="1215" data-end="1218.66">So I have some demos coming up.</span> <span data-start="1218.66" data-end="1220.02">I think this stuff is cool.</span> <span data-start="1220.02" data-end="1222.04">I've been told it's probably just me!</span> <span data-start="1222.04" data-end="1227.94">If you think this stuff is kind of cool, how about giving it a clap so I know to continue.</span> <span data-start="1227.94" data-end="1228.94">[Applause].</span> </p>
<p><span data-start="1228.94" data-end="1230.21">All right.</span> <span data-start="1230.21" data-end="1237.53">So, in the interests of tile, I have demos prepared earlier.</span> <span data-start="1237.53" data-end="1242.58">As I mentioned, we could abstract over things like network requests.</span> <span data-start="1242.58" data-end="1246.66">So here we are making our request to some random API that someone kindly allowed cause</span> <span data-start="1246.66" data-end="1247.66">on for me.</span> <span data-start="1247.66" data-end="1248.8">- calls on for me.</span> <span data-start="1248.8" data-end="1254.15">You can see here, we are essentially querying for our window object, run the object calling</span> <span data-start="1254.15" data-end="1255.15">fetch.</span> </p>
<p><span data-start="1255.15" data-end="1258.88">In fetch, we're passing an array of arguments that line up to the argument forward of the</span> <span data-start="1258.88" data-end="1260.44">fetch API.</span> <span data-start="1260.44" data-end="1264.97">We are saying fetch this URL and then causing the JSON method on that response.</span> <span data-start="1264.97" data-end="1269.7">Under the covers, you may await this, but you don't have to care about it.</span> <span data-start="1269.7" data-end="1272.5">It's done for you.</span> <span data-start="1272.5" data-end="1278.73">And here we can see the output, just for the saying that I'm not lying.</span> <span data-start="1278.73" data-end="1283.75">And you can get the result here by calling the path on which we made the query, so our</span> <span data-start="1283.75" data-end="1287">result is window reflect JSON.</span> </p>
<p><span data-start="1287" data-end="1292.5">You may think we've already showed how resolvers can make requests.</span> <span data-start="1292.5" data-end="1297.35">This is different, it's not resolvers making the network request, the query itself is the</span> <span data-start="1297.35" data-end="1298.35">network request.</span> <span data-start="1298.35" data-end="1300.9">We're resolving how to make requests.</span> <span data-start="1300.9" data-end="1305.55">It's a bit unique, I think.</span> <span data-start="1305.55" data-end="1307.44">So that is all well and good.</span> <span data-start="1307.44" data-end="1308.44">What about the DOM?</span> <span data-start="1308.44" data-end="1310.79">I promised the DOM.</span> <span data-start="1310.79" data-end="1319.61">So here, we're emulating what I talked about earlier, we are taking â€” querying the document,</span> <span data-start="1319.61" data-end="1323.99">querying the query selector role and giving it an parliament with the P tags.</span> <span data-start="1323.99" data-end="1326.37">On the resulting P tags, we're pulling properties off.</span> <span data-start="1326.37" data-end="1328.94">I think of this like a map.</span> </p>
<p><span data-start="1328.94" data-end="1333.49">Like, what we've saved here, because you don't have to know what this returns.</span> <span data-start="1333.49" data-end="1334.9">Is it an array, not an array?</span> <span data-start="1334.9" data-end="1336.57">How do we cast an array?</span> <span data-start="1336.57" data-end="1338.27">Is it going to yell at me?</span> <span data-start="1338.27" data-end="1341.87">All those areas you probably run into like I have.</span> <span data-start="1341.87" data-end="1342.87">And we can see the output here.</span> <span data-start="1342.87" data-end="1344.54">We can see the properties coming out.</span> <span data-start="1344.54" data-end="1350.91">That's not going to impress you.</span> <span data-start="1350.91" data-end="1356.23">Let's try this one out!</span> </p>
<p><span data-start="1356.23" data-end="1360.57">So here, we're doing the same thing, except we are using GraphQL aliases.</span> <span data-start="1360.57" data-end="1366.7">We are essentially saying passing a document in, saying this is the root purely for the</span> <span data-start="1366.7" data-end="1370.21">sake of indentation and readability but also for the sake that we can show we can operate</span> <span data-start="1370.21" data-end="1371.77">on the resolve to something else.</span> <span data-start="1371.77" data-end="1377.85">Passing in a document, doing three queries of the DOM and assigning those results to</span> <span data-start="1377.85" data-end="1379.97">variables.</span> </p>
<p><span data-start="1379.97" data-end="1388.549">We are saying our good boys are querying for all the Dojo emojis.</span> <span data-start="1388.549" data-end="1390.72">There are some dogs and not dogs here.</span> <span data-start="1390.72" data-end="1399.88">We're also querying for the non-Dojos, and for the yummy Dojo.</span> <span data-start="1399.88" data-end="1405.82">These though you the results of the variables, but really bringing this home, we can actually</span> <span data-start="1405.82" data-end="1412.83">pass this variable back into another query as the context, and here, we are doing the</span> <span data-start="1412.83" data-end="1420.71">mutation, calling set attribute on our first good est boy, and we are giving it a style</span> <span data-start="1420.71" data-end="1422.41">and increasing the font size.</span> </p>
<p><span data-start="1422.41" data-end="1437.47">If we scroll up â€” oh, I changed the name â€”  if we scroll up!</span> <span data-start="1437.47" data-end="1449.34">Giant hot dog!</span> <span data-start="1449.34" data-end="1453.29">[Applause].</span> <span data-start="1453.29" data-end="1456.9">As you may have guessed, this is the hungry boy.</span> <span data-start="1456.9" data-end="1466">We can query the DOM, we can mutate the DOM.</span> <span data-start="1466" data-end="1471.05">What else can we do?</span> <span data-start="1471.05" data-end="1474.96">We can also do animations on the DOM using web animation API.</span> <span data-start="1474.96" data-end="1482.79">Here, we are getting our hungry boy once again, and we're using the web animation API by calling</span> <span data-start="1482.79" data-end="1488.54">animate on the resulting thing and giving it the object of the web animation specs.</span> <span data-start="1488.54" data-end="1490.89">We are spinning it and scaling it up and down.</span> <span data-start="1490.89" data-end="1492.76">We can change these.</span> <span data-start="1492.76" data-end="1494.31">This is all live.</span> <span data-start="1494.31" data-end="1496.58">I'm not lying to you.</span> </p>
<p><span data-start="1496.58" data-end="1503.87">This is, like, so here we have had to do is look at MDN, find the API, and it's the same</span> <span data-start="1503.87" data-end="1504.87">query interface.</span> <span data-start="1504.87" data-end="1507.24">We didn't care how it returned or how it worked.</span> <span data-start="1507.24" data-end="1510.92">If we want to reuse the animation?</span> <span data-start="1510.92" data-end="1513.17">How do we copy it around and use it?</span> </p>
<p><span data-start="1513.17" data-end="1515.37">We can use the GraphQL fragments.</span> <span data-start="1515.37" data-end="1518.97">We are querying two different nodes in our yummy node.</span> <span data-start="1518.97" data-end="1523.62">We are giving a spin and a bounce animation.</span> <span data-start="1523.62" data-end="1528.78">These are defined down here asking from fragments on the element type before we have one that</span> <span data-start="1528.78" data-end="1532.58">bounces and one that spins, and then named as such.</span> </p>
<p><span data-start="1532.58" data-end="1546.37">If we uncomment this â€” woah, .. . Animations as variables.</span> <span data-start="1546.37" data-end="1550.06">That's the best I got.</span> <span data-start="1550.06" data-end="1553.12">I'm sorry!</span> <span data-start="1553.12" data-end="1554.65">[Applause].</span> <span data-start="1554.65" data-end="1558.85">I know some of you are thinking: DOM, who uses the DOM?</span> <span data-start="1558.85" data-end="1561.54">I'm more about the jQuery life.</span> </p>
<p><span data-start="1561.54" data-end="1565.39">For you, we have this.</span> <span data-start="1565.39" data-end="1570.34">We are passing our jQuery as the root context and can call jQuery as northerly.</span> <span data-start="1570.34" data-end="1573.5">We're doing our request for the item and calling animate function.</span> <span data-start="1573.5" data-end="1576.66">We're animating properties if the way that you would in jQuery.</span> <span data-start="1576.66" data-end="1578.82">These can be used together.</span> <span data-start="1578.82" data-end="1582.93">There's no limit to the hilarity that can ensue with enough animations.</span> </p>
<p><span data-start="1582.93" data-end="1586.5">Let's give this one more spin before I wrap up.</span> <span data-start="1586.5" data-end="1589.38">And there we go.</span> <span data-start="1589.38" data-end="1595.69">GraphQL on the DOM in the browser.</span> <span data-start="1595.69" data-end="1600.38">[Applause].</span> <span data-start="1600.38" data-end="1610.03">In closing, I started by saying GraphQL superpower be and shaped everything else like a â€” this</span> <span data-start="1610.03" data-end="1613.52">makes GraphQL infinitely versatile.</span> <span data-start="1613.52" data-end="1619.18">With a little creativity, we can GraphQL all the things and move towards a universal query</span> <span data-start="1619.18" data-end="1621.43">language before the web.</span> <span data-start="1621.43" data-end="1624.91">Thank you.</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
