<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Wo0qiGPSV-s</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/Wo0qiGPSV-s?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="3.139" data-end="31.31">Hi, everybody.</span> <span data-start="31.31" data-end="32.31">How we doing?</span> <span data-start="32.31" data-end="34.14">We got caffeinated?</span> <span data-start="34.14" data-end="35.37">Feeling good?</span> <span data-start="35.37" data-end="36.37">Nice.</span> <span data-start="36.37" data-end="39.809">So I'm Anjana Vakil, hello.</span> <span data-start="39.809" data-end="44.87">You can find me on Twitter at my name and today I'd like to talk to you about immutable</span> <span data-start="44.87" data-end="49.489">data structures for functional programming in JavaScript.</span> <span data-start="49.489" data-end="54.93">We're going to take a look at what immutable data structures are, why they're a really</span> <span data-start="54.93" data-end="59.82">cool way to handle the immutability that we typically use when we're doing functional</span> <span data-start="59.82" data-end="66.35">programming and how we can do that in JavaScript because I hear y'all like JavaScript!</span> </p>
<p><span data-start="66.35" data-end="69.15">So a little about me.</span> <span data-start="69.15" data-end="72.29">I'm probably the only not-web-developer in the room.</span> <span data-start="72.29" data-end="74.97">I am an engineer for Uber Research.</span> <span data-start="74.97" data-end="80.47">I work with them to develop a custom query language for data in the scientific research</span> <span data-start="80.47" data-end="81.85">funding domain.</span> <span data-start="81.85" data-end="85.95">I'm also an alum of the Recurse Center, which is a fantastic programming community in New</span> <span data-start="85.95" data-end="92.56">York City, and I am an alum of the Outreach Program, which if you have haven't heard of</span> <span data-start="92.56" data-end="101.21">it, it's getting women and more folks involved in these by giving them internships at Mozilla.</span> <span data-start="101.21" data-end="109.27">So I'm really happy to chat about those things if you want to come grab me after the talk.</span> <span data-start="109.27" data-end="114.409">But you might know that I like functional programming.</span> <span data-start="114.409" data-end="115.909">I think it rocks.</span> <span data-start="115.909" data-end="119.77">Anybody else agree with me that functional programming is cool?</span> <span data-start="119.77" data-end="120.77">Yeah!</span> <span data-start="120.77" data-end="127.549">Yeah, so functional programming is a pretty great way to avoid some of the headaches of</span> <span data-start="127.549" data-end="130.19">like imperative and object-oriented programming.</span> </p>
<p><span data-start="130.19" data-end="135.4">In functional programming, what we typically do is conceive of our programs as being just</span> <span data-start="135.4" data-end="136.73">pure functions.</span> <span data-start="136.73" data-end="142.489">That means their transform their inputs to outputs, and that's all they do.</span> <span data-start="142.489" data-end="149.2">They don't have my side effects like changing things in the console, and my taking things</span> <span data-start="149.2" data-end="151.78">in the global state are side effects.</span> </p>
<p><span data-start="151.78" data-end="158.21">But our data becomes data in, data out, and transformers of data.</span> <span data-start="158.21" data-end="163.29">And one thing that goes hand-in-hand with this, with avoiding side effects is immutable</span> <span data-start="163.29" data-end="164.61">data.</span> <span data-start="164.61" data-end="168">Immutable data meaning once we've created it, it never changes.</span> <span data-start="168" data-end="173.08">So this is a really good way of changing something accidental outside of your function.</span> </p>
<p><span data-start="173.08" data-end="176.659">If everything is immutable, you can't change anything.</span> <span data-start="176.659" data-end="182.72">So immutability another thing that rocks and it rocks pretty hard for other reasons that</span> <span data-start="182.72" data-end="184.16">we'll see in a moment.</span> <span data-start="184.16" data-end="187.659">But speaking of rocks, let's talk about rocks.</span> </p>
<p><span data-start="187.659" data-end="194.11">So this is a rock, and immutability rocks in the way that rocks rock.</span> <span data-start="194.11" data-end="198.049">Now I don't know about you, but I've been going to a lot of tech conferences recently</span> <span data-start="198.049" data-end="201.849">and I've been feeling like there has enough poetry.</span> <span data-start="201.849" data-end="208.29">So I'd like to read you a poem: Nobody sits like this rock sits.</span> <span data-start="208.29" data-end="210.379">You rock, rock.</span> <span data-start="210.379" data-end="213.629">The rock just sits and is.</span> <span data-start="213.629" data-end="216.439">You show us how to just sit here.</span> <span data-start="216.439" data-end="218.299">And that's what we need.</span> <span data-start="218.299" data-end="220.73">It's so true, so deep.</span> <span data-start="220.73" data-end="225.43">This is from  —  Don't thank me, thank I Heart Huckabees, that's</span> <span data-start="225.43" data-end="226.43">a great movie.</span> </p>
<p><span data-start="226.43" data-end="228.08">Check it out.</span> <span data-start="228.08" data-end="231.799">So this is really how immutable data rocks.</span> <span data-start="231.799" data-end="233.439">It just sits there.</span> <span data-start="233.439" data-end="234.439">It just is.</span> <span data-start="234.439" data-end="238.931">Once we've created it, it never changes and that's amazing because it can help us avoid</span> <span data-start="238.931" data-end="241.549">some of the headaches of immutability.</span> <span data-start="241.549" data-end="248.09">So with immutability, we have some things pretty easy, but other things become harder</span> <span data-start="248.09" data-end="249.25">and we'll see how that looks.</span> </p>
<p><span data-start="249.25" data-end="253.521">So let's say I have an array called foo and it's got some numbers in it.</span> <span data-start="253.521" data-end="256.47">Hm, and I'm already bored.</span> <span data-start="256.47" data-end="257.5">Let's make it more fun.</span> <span data-start="257.5" data-end="263.49">Let's say I have a zoo with some animals  —  more fun!</span> <span data-start="263.49" data-end="266.52">And I decided that I want to change something up about my zoo.</span> <span data-start="266.52" data-end="270.13">Maybe I want to replace that rabbit there with something a little more exotic.</span> </p>
<p><span data-start="270.13" data-end="272.73">Like an alien!</span> <span data-start="272.73" data-end="273.73">So this is cool.</span> <span data-start="273.73" data-end="276.25">I'm happy because I wanted a more exotic zoo.</span> <span data-start="276.25" data-end="278.01">I got an alien in my zoo now.</span> <span data-start="278.01" data-end="282.39">I didn't have to change anything except for that one little cell in my array.</span> <span data-start="282.39" data-end="289.3">That's pretty sweet but my co-worker over was expecting zoo to be filled with earth</span> <span data-start="289.3" data-end="294.55">beings, earth animals, and wasn't accounting for there being an alien in it.</span> <span data-start="294.55" data-end="296.51">Who put that in there?</span> <span data-start="296.51" data-end="298.82">Now my program doesn't work anymore.</span> <span data-start="298.82" data-end="300.42">Who did that?</span> <span data-start="300.42" data-end="304.59">So immutability has a couple problems.</span> <span data-start="304.59" data-end="310.69">We have to manage who's been changing what, when  —  who's been putting which animals in</span> <span data-start="310.69" data-end="311.69">the zoo.</span> </p>
<p><span data-start="311.69" data-end="316.88">We have to have a lot of overhead to manage that state, and that gives us headaches as</span> <span data-start="316.88" data-end="319.69">individuals, and as teams.</span> <span data-start="319.69" data-end="323.97">We also get bugs in the code because maybe I was only planning  —  or my co-worker was</span> <span data-start="323.97" data-end="330.14">only planning  —  to handle terrestrial beings and didn't have a case of aliens being accounted</span> <span data-start="330.14" data-end="332.78">for, and that broke something.</span> <span data-start="332.78" data-end="337.39">So these are some side effects of immutability that don't make us happy.</span> <span data-start="337.39" data-end="340.46">Let's try doing things the immutable way.</span> <span data-start="340.46" data-end="347.15">So in an immutable world, my array, my zoo, once I've created it, it just sits and is</span> <span data-start="347.15" data-end="348.15">forever.</span> <span data-start="348.15" data-end="350.28">I cannot change it.</span> <span data-start="350.28" data-end="356.3">What I can do if I want a new zoo that's more exotic is I can make a copy that's the same</span> <span data-start="356.3" data-end="363.47">size as my original array, and I can make the modification I want, so I can put my alien</span> <span data-start="363.47" data-end="365.05">in there in place of the rabbit.</span> </p>
<p><span data-start="365.05" data-end="375.01">And so this is pretty sweet because now my co-worker is maybe, and they're, like, whoo,</span> <span data-start="375.01" data-end="380.72">nothing broke in my program, and it's all still animal creatures but I had to copy over</span> <span data-start="380.72" data-end="381.97">that whole array.</span> <span data-start="381.97" data-end="388.59">I had to allocate the space for that entire array, even all of the stuff that didn't change.</span> <span data-start="388.59" data-end="392.1">I had to copy all of that over, as well.</span> <span data-start="392.1" data-end="395.44">So this means that my code runs pretty slow.</span> <span data-start="395.44" data-end="397.09">And it also takes up a lot of memory.</span> <span data-start="397.09" data-end="399.46">It takes up a lot of space and time.</span> <span data-start="399.46" data-end="404.71">The complexity on those things are bad because copying is a waste of both time and space.</span> <span data-start="404.71" data-end="406.09">It makes us sad face!</span> <span data-start="406.09" data-end="407.22">We don't want that.</span> <span data-start="407.22" data-end="412.04">So if we want to do immutability, we must be able to find a better way of doing that.</span> <span data-start="412.04" data-end="417.09">Luckily for us, a lot of very smart folks have been thinking very hard about this problem</span> <span data-start="417.09" data-end="420.08">for a while, and they've come up with some really good solutions for how we can deal</span> <span data-start="420.08" data-end="422.13">with immutability efficiently.</span> <span data-start="422.13" data-end="425.5">immutable data structures!</span> </p>
<p><span data-start="425.5" data-end="430.66">So immutable data structures is a term that you may have heard about, with functional</span> <span data-start="430.66" data-end="434.57">programming, or also in terms of React where they come in handy.</span> <span data-start="434.57" data-end="441.78">Technically, an immutable data structure is like the rock, it just sits, and is once you</span> <span data-start="441.78" data-end="442.78">create it.</span> <span data-start="442.78" data-end="444.44">It never changes.</span> <span data-start="444.44" data-end="448.31">But also hear the term persistent data structures banged about.</span> <span data-start="448.31" data-end="451.16">Sometimes these are used interchangeably, but they have slightly different meanings.</span> <span data-start="451.16" data-end="458.69">So if immutable data is data that never changes, persistent data is data for which we have</span> <span data-start="458.69" data-end="460.66">access to old versions.</span> <span data-start="460.66" data-end="466.78">So as we've been creating new modified versions of our data structures, we keep the old versions</span> <span data-start="466.78" data-end="468.16">around.</span> <span data-start="468.16" data-end="473.28">You might hear about partially persistent data structures where we can look at the old</span> <span data-start="473.28" data-end="477.02">versions, we can access them, but we can't go back and update any of them.</span> <span data-start="477.02" data-end="481.4">All we can update is the most current version that we have.</span> </p>
<p><span data-start="481.4" data-end="485.94">And then you might also hear about fully persistent data structures where we can actually time</span> <span data-start="485.94" data-end="489.5">travel, we can go back and update any of our past versions.</span> <span data-start="489.5" data-end="495.61">And if this is starting to ring a bell like it's version control like git, it's sort of</span> <span data-start="495.61" data-end="497.28">the same idea.</span> <span data-start="497.28" data-end="501.59">So we're going to talk about these as persistent immutable data structures, they're both persistent,</span> <span data-start="501.59" data-end="502.97">and immutable.</span> <span data-start="502.97" data-end="506.34">Let's see how this works.</span> </p>
<p><span data-start="506.34" data-end="510.93">The key to all of this is we want the old versions of our data, like, my original zoo</span> <span data-start="510.93" data-end="511.93">to stay put.</span> <span data-start="511.93" data-end="517.66">We just want to to sit like the rock but we want new versions to be created efficiently.</span> <span data-start="517.66" data-end="524.52">So what magical tricks do we have to use to, like, make this happen?</span> <span data-start="524.52" data-end="531.94">Do we have to make invocations do dances to the gods of space and time complexity?</span> <span data-start="531.94" data-end="533.01">No.</span> <span data-start="533.01" data-end="534.67">It's very simple.</span> <span data-start="534.67" data-end="536.79">Trees and sharing.</span> <span data-start="536.79" data-end="538.9">Isn't that sweet?</span> <span data-start="538.9" data-end="543.58">These two simple concepts will get us efficient immutable data.</span> <span data-start="543.58" data-end="545.22">How?</span> </p>
<p><span data-start="545.22" data-end="549.1">So let's talk about trees because trees rock pretty hard, as well, alternative, unfortunately</span> <span data-start="549.1" data-end="553.3">I don't have a poem for that, sorry.</span> <span data-start="553.3" data-end="559.22">Imagine that we could find a way to represent our zoo array as a tree.</span> <span data-start="559.22" data-end="563.26">So one thing I could do is I could put all of my animals  —  all of my values  —  in the</span> <span data-start="563.26" data-end="568.89">leaves of a tree, and I could make it so that each leaf holds one value, one animal.</span> <span data-start="568.89" data-end="571.46">But they might get lonely, so let's put them with a buddy.</span> <span data-start="571.46" data-end="573.57">Let's put them 2x2.</span> <span data-start="573.57" data-end="577.53">So each of our leaves will have two values and we'll hope that the buddies get along</span> <span data-start="577.53" data-end="583.77">and not each each other  —  looking at you, tiger, number six, don't eat that koala, and</span> <span data-start="583.77" data-end="589.931">we can go up to intermediate nodes up and up, until we get to the root node of the whole</span> <span data-start="589.931" data-end="597.24">structure, and now that root is an array represented previously by a tree.</span> </p>
<p><span data-start="597.24" data-end="601.91">So this is my tree now in this structure.</span> <span data-start="601.91" data-end="605.88">So given this type of structure, how do we update something?</span> <span data-start="605.88" data-end="609.47">Given that my data is immutable, and it can never change, how can I handle the fact that</span> <span data-start="609.47" data-end="612.87">it has an alien in it.</span> <span data-start="612.87" data-end="617.59">So here what I would do is I would take the node that contains the value that I want to</span> <span data-start="617.59" data-end="618.59">change.</span> <span data-start="618.59" data-end="626.89">So in this case it would be the 0/1 node that you see on the bottom of the screen.</span> </p>
<p><span data-start="626.89" data-end="631.17">And so I make a new copy where I've still got my monkey but I've changed the rabbit</span> <span data-start="631.17" data-end="634.17">to an alien.</span> <span data-start="634.17" data-end="639.59">And then I need to copy any of the intermediate nodes in the tree that were pointing to the</span> <span data-start="639.59" data-end="641.11">node that I changed.</span> <span data-start="641.11" data-end="646.33">So I basically trace a path up towards the root of the tree, which, now, I've got a new</span> <span data-start="646.33" data-end="651.28">root, which means another version of the data structure.</span> <span data-start="651.28" data-end="657.05">So this technique of making this update by copying the path from the leaf I changed to</span> <span data-start="657.05" data-end="659.23">the root is called path copying.</span> </p>
<p><span data-start="659.23" data-end="664.2">That's pretty cool because now I didn't have to copy the entire array; I just had to copy</span> <span data-start="664.2" data-end="670.08">the nodes on the way from the root to the leaf that I changed.</span> <span data-start="670.08" data-end="674.72">So if we've turned in something linear and copying into something logarithm.</span> <span data-start="674.72" data-end="680.17">That's pretty cool, that's more performant, and the data of this is that all of these</span> <span data-start="680.17" data-end="685.91">nodes in yellow here, so most of the tree is shared between the two versions, between</span> <span data-start="685.91" data-end="687.1">the old version and the new.</span> <span data-start="687.1" data-end="692.03">And so this saves me a lot of space because I can actually reuse the parts of the original</span> <span data-start="692.03" data-end="696.68">version that didn't change, whereas, before, I had to copy those over, as well.</span> <span data-start="696.68" data-end="701.3">So this means that what was before, like, a lot of memory consumption becomes a lot</span> <span data-start="701.3" data-end="706.08">smaller because you don't have to store as many copies of the things if they didn't change.</span> <span data-start="706.08" data-end="710.67">And that's called structural changing because we're sharing the structure of the tree between</span> <span data-start="710.67" data-end="713.37">the two versions.</span> </p>
<p><span data-start="713.37" data-end="719.69">So we've been talking about updating things but how do we get at the values in our data</span> <span data-start="719.69" data-end="720.69">structure?</span> <span data-start="720.69" data-end="721.69">How do we access them?</span> <span data-start="721.69" data-end="726.64">Well, it turns out this isn't just a tree, it's a special type of tree called a TRIE</span> <span data-start="726.64" data-end="733.05">tree, which originally came from the world "retrieval," so people could, I guess, call</span> <span data-start="733.05" data-end="739.67">it tree, which is funny because we also call TREE trees, so we can call them "tries" if</span> <span data-start="739.67" data-end="740.67">we want.</span> <span data-start="740.67" data-end="751.73">So a try is a type of tree, where the leaves represent the values, and the paths to the</span> <span data-start="751.73" data-end="757.279">value are the keys that that data is associated with.</span> <span data-start="757.279" data-end="761.62">So often you see TRIEs with values stored as keys.</span> <span data-start="761.62" data-end="769.46">So, for example, if I have T stored as a key, what I do to get to the T is I trace the tree</span> <span data-start="769.46" data-end="773.29">one letter at a time.</span> <span data-start="773.29" data-end="778.88">Then I go to T, and then to E, and then to EA, is my key, and then my value there is</span> <span data-start="778.88" data-end="780.3">three.</span> <span data-start="780.3" data-end="785.06">Because everything at the end sounds like "ee" in this talk.</span> </p>
<p><span data-start="785.06" data-end="791.48">So this is pretty cool, but in our data structure, we weren't using words, we just wanted an</span> <span data-start="791.48" data-end="794.83">array-type thing, we wanted indeces, right?</span> <span data-start="794.83" data-end="802.13">So the insight here is if we treat the index as a binary number, then we can pretend that</span> <span data-start="802.13" data-end="807.64">that's kind of, like, our word and we can descend the tree, bit-by-bit as if each representation</span> <span data-start="807.64" data-end="812.23">of our binary representation is a letter.</span> </p>
<p><span data-start="812.23" data-end="813.88">So let's see how that works.</span> <span data-start="813.88" data-end="820.529">If I'm trying to get at item five in my array, so the animal at index five, I'd convert that</span> <span data-start="820.529" data-end="826.58">to binary, so that's one, zero, one, and then I step through that as if it was a word.</span> <span data-start="826.58" data-end="829.85">I step through it letter-by-letter, bit-by-bit.</span> <span data-start="829.85" data-end="834.01">So I go from the root to the branch.</span> <span data-start="834.01" data-end="835.6">I have a choice of either zero or one.</span> <span data-start="835.6" data-end="837.06">I go to branch one first.</span> <span data-start="837.06" data-end="843.27">And then I go to branch zero, and then I take the thing on the one side.</span> <span data-start="843.27" data-end="849.94">So I go one, zero, one, down my tree and then I end up at my frog at index five.</span> </p>
<p><span data-start="849.94" data-end="855.23">So this is a pretty simple insight but it ends up being incredibly powerful because</span> <span data-start="855.23" data-end="861.85">it allows us to quickly traverse this tree structure, which lets us use that structural</span> <span data-start="861.85" data-end="867.83">sharing to more efficiently represent our new copies of our immutable data structure.</span> <span data-start="867.83" data-end="874.529">And, importantly, we don't have to be using a binary tree, meaning we have two branches</span> <span data-start="874.529" data-end="877.32">from each node.</span> <span data-start="877.32" data-end="882.73">That fits pretty well on a slide, but actually what you mostly see is a 32-way branching.</span> <span data-start="882.73" data-end="887.67">So in our trees that we've been looking at, we've kind of had one bit of information per</span> <span data-start="887.67" data-end="888.67">level.</span> <span data-start="888.67" data-end="895.11">And we've been descending bit-by-bit but if we had a 32-way branching tree, it would be</span> <span data-start="895.11" data-end="898.62">five bits of information that we would be representing at each level.</span> <span data-start="898.62" data-end="901.11">So that would look something like this.</span> <span data-start="901.11" data-end="910.07">If we had a much bigger number, like, 18,977, in binary, that's that bunch of ones and zeros.</span> </p>
<p><span data-start="910.07" data-end="913.67">This would be a really deep tree if I had to descend into it one at a time, it would</span> <span data-start="913.67" data-end="915.35">be like 15 levels deep.</span> <span data-start="915.35" data-end="917.07">Too much, too long.</span> <span data-start="917.07" data-end="924.9">So if I'd make more branches at each level, then I can chunk this up into kind of 5-bit</span> <span data-start="924.9" data-end="933.79">letters as it were, and descend the tree that it's now only three levels using the 32-way</span> <span data-start="933.79" data-end="935">branching.</span> <span data-start="935" data-end="940.8">So this is kind of a tradeoff between how deep your tree is going to be, and how big</span> <span data-start="940.8" data-end="944.93">the nodes are going to be because if I have just one bit of information at each level</span> <span data-start="944.93" data-end="946.39">then I have really small nodes.</span> <span data-start="946.39" data-end="950.38">That's quick to copy over but I have to go very, very deep down in the tree for a larger</span> <span data-start="950.38" data-end="951.38">array.</span> </p>
<p><span data-start="951.38" data-end="956.98">And generally, research has found that 32 is a pretty good tradeoff between the depth</span> <span data-start="956.98" data-end="959.42">of the tree.</span> <span data-start="959.42" data-end="965.04">So what we've seen is a bitmap vector TRIE.</span> <span data-start="965.04" data-end="968.31">That's just jargon.</span> <span data-start="968.31" data-end="969.44">We don't need to care about that.</span> <span data-start="969.44" data-end="973.55">But if you need something to Google, you can Google that.</span> <span data-start="973.55" data-end="978.69">This is cool for array-type of things and we have an index we want to jump there, but</span> <span data-start="978.69" data-end="979.69">what about objects?</span> <span data-start="979.69" data-end="985.151">We also want to be able to associate objects with arbitrary keys, not just indeces, so</span> <span data-start="985.151" data-end="989.8">we want non-integers as keys, how does that work?</span> <span data-start="989.8" data-end="993.26">So if I want a version of my data structure where it's no longer an array but it's something</span> <span data-start="993.26" data-end="998">like an object where I'm associated letters with each of my animals like M for monkey,</span> <span data-start="998" data-end="1004.52">and P for panda, et cetera, what I can do is I can take my keys, in this case, they're</span> <span data-start="1004.52" data-end="1008.54">letters, and hash them to get a number that represents the key.</span> </p>
<p><span data-start="1008.54" data-end="1012.16">So that each key will have its own number.</span> <span data-start="1012.16" data-end="1014.98">They won't be in order necessarily, but that's okay.</span> <span data-start="1014.98" data-end="1016.43">Objects don't have to be in order.</span> <span data-start="1016.43" data-end="1023.61">And then we can use the hash of that number in binary to descend the tree as before.</span> <span data-start="1023.61" data-end="1030.02">So if I wanted to look up the value associated with key "F," I could hash F, get some number,</span> <span data-start="1030.02" data-end="1034.429">and let's say I get five, like, A, B, C, D, E, five.</span> </p>
<p><span data-start="1034.429" data-end="1039.189">And that would be represented in binary as one, and I descend the tree as before, here,</span> <span data-start="1039.189" data-end="1043.42">for simplicity, just using a one bit at a time, two-way branching tree.</span> <span data-start="1043.42" data-end="1048">But typically we would be doing this with 32 branches per level.</span> <span data-start="1048" data-end="1054.82">So, again, we just descend the tree using the binary representation of our key, in this</span> <span data-start="1054.82" data-end="1060.22">case, we used a hash function to transform it from some arbitrary object into a number</span> <span data-start="1060.22" data-end="1063.809">and we get the animal we want  —  in this case, our frog.</span> </p>
<p><span data-start="1063.809" data-end="1064.809">Cool.</span> <span data-start="1064.809" data-end="1071.12">So that, if you want to Google it, the thing you could Google is a hash array mapped TRIE.</span> <span data-start="1071.12" data-end="1077.11">And this was a data structure parented by Phil Bagwell, and Rich Hickey, kind of started</span> <span data-start="1077.11" data-end="1083.481">using it, and a lot of these an implemented in languages like Clojure to implement the</span> <span data-start="1083.481" data-end="1085.73">data efficiently.</span> <span data-start="1085.73" data-end="1092.3">There's a ton of optimizations that are usually done on these data structures to make them</span> <span data-start="1092.3" data-end="1097.55">super-duper fast and lots of details that we're not covering here but this is the basic</span> <span data-start="1097.55" data-end="1099.12">idea.</span> <span data-start="1099.12" data-end="1105.05">Trees to represent our data, structural sharing so that we can reuse as much information as</span> <span data-start="1105.05" data-end="1108.97">possible between the old versions and the new versions.</span> <span data-start="1108.97" data-end="1118.26">And this idea of using binary representations of our keys, whether indeces, or hashed keys</span> <span data-start="1118.26" data-end="1122.59">to descend the tree to find the thing we're looking for.</span> <span data-start="1122.59" data-end="1127.73">So to recap, mutability induces headaches.</span> <span data-start="1127.73" data-end="1132.24">It is to be avoided especially if you're doing functional programming where the essential</span> <span data-start="1132.24" data-end="1138.54">idea is to not have side effects and only be using pure functions that don't change</span> <span data-start="1138.54" data-end="1143.52">anything except do the computation on the input and return the output.</span> </p>
<p><span data-start="1143.52" data-end="1147.71">Immutability, on the other hand, is great because if I'm using immutable data, I can't</span> <span data-start="1147.71" data-end="1153.99">mess up my co-worker's program by making the zoo she only thought was animals suddenly</span> <span data-start="1153.99" data-end="1155.39">have an alien in it.</span> <span data-start="1155.39" data-end="1161.61">But copying is a really bad way of handling data because it is not efficient neither with</span> <span data-start="1161.61" data-end="1164.1">respect to time, nor space.</span> <span data-start="1164.1" data-end="1170.77">And structural sharing, using these tree structures  —  or TRIE structures, and sharing as much</span> <span data-start="1170.77" data-end="1175.72">information from one version to the next is the really performant way to do this.</span> </p>
<p><span data-start="1175.72" data-end="1180.75">And so you're probably thinking, okay, these data structures are pretty cool.</span> <span data-start="1180.75" data-end="1182.74">But what am I supposed to do with them?</span> <span data-start="1182.74" data-end="1187.69">I'm not going to be building boxes of emoji here, am I?</span> <span data-start="1187.69" data-end="1190.28">No, you don't have to.</span> </p>
<p><span data-start="1190.28" data-end="1195.76">In JavaScript, there are some really great libraries out there to help you use these</span> <span data-start="1195.76" data-end="1197.17">right off the bat.</span> <span data-start="1197.17" data-end="1200.71">There are various solutions but I'm going to talk about a couple of them.</span> <span data-start="1200.71" data-end="1202.59">So one is called Mori.</span> <span data-start="1202.59" data-end="1208.48">Mori is basically a port of Clojure script by David Nolan that allows you to leverage</span> <span data-start="1208.48" data-end="1213.83">the implementations of these data structures from ClojureScript, which is the version of</span> <span data-start="1213.83" data-end="1221.13">Clojure which targets JavaScript from the comfort of your vanilla JavaScript.</span> <span data-start="1221.13" data-end="1223.77">And it's got a bit more of a Clojure feel to it.</span> <span data-start="1223.77" data-end="1226.76">A bit more of a functional language feel.</span> <span data-start="1226.76" data-end="1230.49">The API is functional and we're going to see what that looks like in a moment.</span> <span data-start="1230.49" data-end="1232.84">But that's one thing that kind of sets this library apart.</span> <span data-start="1232.84" data-end="1236.87">On the other hand, there's also Immutable.js.</span> <span data-start="1236.87" data-end="1238.929">This is a library put out by Facebook.</span> <span data-start="1238.929" data-end="1241.61">It was created by Lee Byron.</span> </p>
<p><span data-start="1241.61" data-end="1245.45">And this is a JavaScript implementation of these data structures.</span> <span data-start="1245.45" data-end="1248.59">So it has a bit more of that native JavaScript feel to it.</span> <span data-start="1248.59" data-end="1252.22">It doesn't have kind of the Clojure background brought in.</span> <span data-start="1252.22" data-end="1257.78">And that means it's got a more object-oriented style API, although it is still returning</span> <span data-start="1257.78" data-end="1265.91">new versions of data structures instead of changing mutable structures in place.</span> <span data-start="1265.91" data-end="1268.049">So let's see what those look like.</span> <span data-start="1268.049" data-end="1270.641">This is how you might use Mori to create what's called a vector.</span> <span data-start="1270.641" data-end="1278.83">A vector is the data structure from Mori that you'd probably be using as an array-type thing.</span> </p>
<p><span data-start="1278.83" data-end="1282.7">So I've got a vector that I'm calling A because it's sort of array-ish.</span> <span data-start="1282.7" data-end="1285.95">It's got one and two in it.</span> <span data-start="1285.95" data-end="1291.05">And if I want to push something onto that, the function that I'd use is conj.</span> <span data-start="1291.05" data-end="1294.65">This is from the Clojure called, Lisp-speak.</span> <span data-start="1294.65" data-end="1302.89">And what I would put in is the original A, and then what I want, which is, in this case,</span> <span data-start="1302.89" data-end="1304.09">three.</span> <span data-start="1304.09" data-end="1307.6">And you'll see that this creates this new structure on the right.</span> <span data-start="1307.6" data-end="1316.17">These vector, one, two, and one, two, three, they look different because they're not really</span> <span data-start="1316.17" data-end="1320.049">JavaScript arrays although you can convert back and forth.</span> <span data-start="1320.049" data-end="1327.2">But the point is this cong function returns a new value which I can catch as A2 and I</span> <span data-start="1327.2" data-end="1331.86">can prove to myself that my original A didn't change by using the count function to see</span> <span data-start="1331.86" data-end="1332.86">how many things are in it.</span> <span data-start="1332.86" data-end="1335.14">And there's only two things in it.</span> <span data-start="1335.14" data-end="1341.08">But I can prove that my version, A2, has the third thing by trying to access, by using</span> <span data-start="1341.08" data-end="1346.94">the get function to trying to get two, which it tells me, it is indeed three.</span> </p>
<p><span data-start="1346.94" data-end="1352.35">This is the same thing that you would use in Immutable.js.</span> <span data-start="1352.35" data-end="1358.89">Here you would use Immutable.js.list.of, that's interesting syntax.</span> <span data-start="1358.89" data-end="1363.6">But it creates something more like a JavaScript array.</span> <span data-start="1363.6" data-end="1369.9">Although it is not an array, it is a JS list.</span> <span data-start="1369.9" data-end="1376.67">That I'll call an array and if I want to add something onto a new version of A, I use this</span> <span data-start="1376.67" data-end="1379.62">sort of dot-method notation that we're used to.</span> <span data-start="1379.62" data-end="1383.299">I'd say a.push(3), but, importantly, this is not changing a.</span> <span data-start="1383.299" data-end="1393.049">It's just returning a new value of a, which I'm going to capture as a2 and I can prove</span> <span data-start="1393.049" data-end="1394.559">to myself that it didn't change.</span> </p>
<p><span data-start="1394.559" data-end="1402.35">A.size tells me it's two, and if I try to get the item at index two, I find that it's</span> <span data-start="1402.35" data-end="1406.39">three, as I expected.</span> <span data-start="1406.39" data-end="1413.679">So, similarly, for what are called maps, which is kind of the key-value object that we might</span> <span data-start="1413.679" data-end="1419.47">be using, if I create an object, o, which is going to be my Mori hashmap data structure,</span> <span data-start="1419.47" data-end="1425.23">I'm associating a is one, b with two, again, we see that the syntax is a little different</span> <span data-start="1425.23" data-end="1428.62">from our regular JavaScript beastlier not regular JavaScript objects.</span> <span data-start="1428.62" data-end="1432.25">They're super special immutable data structures, they need special syntax.</span> <span data-start="1432.25" data-end="1441.87">And so if I want to change the value of one of my keys, I can use this asoc function,</span> <span data-start="1441.87" data-end="1446.84">and then change the value of three in my new version, o2, and then I can prove to myself</span> <span data-start="1446.84" data-end="1452.2">that the original didn't change by using the get function to make sure that a in the original</span> <span data-start="1452.2" data-end="1458.32">one  —  o, is one, and the a in o2 is three, as I would expect.</span> <span data-start="1458.32" data-end="1463.49">And it looks quite similar in Immutable.js except the structure is called map, not hashmap,</span> <span data-start="1463.49" data-end="1471.19">and I can pass in a little JavaScript object, and it gives me a little o, a little more</span> </p>
<p><span data-start="1471.19" data-end="1473.19">JavaScript syntax than we're used to.</span> <span data-start="1473.19" data-end="1479.23">This has a bit more of a syntax and feel that you might be used to from JavaScript programming,</span> <span data-start="1479.23" data-end="1485.33">I can use the set method on o to create a new version where a is now three, and I can</span> <span data-start="1485.33" data-end="1490.87">use the get methods on my old version o, and my new-version o2 to prove to myself that</span> <span data-start="1490.87" data-end="1492.72">the old one didn't change.</span> <span data-start="1492.72" data-end="1495.15">So these are really immutable data structures.</span> <span data-start="1495.15" data-end="1502.03">They look really weird if you try to look at them in the console just as JavaScript</span> <span data-start="1502.03" data-end="1503.03">objects.</span> <span data-start="1503.03" data-end="1506.03">They're really fun to kind of poke down into because they have this complicated tree structure.</span> <span data-start="1506.03" data-end="1509.65">So I highly recommend that you try out these libraries and see what works for you.</span> <span data-start="1509.65" data-end="1515.34">I can tell you really just briefly before I run out of time here, that how they compare</span> <span data-start="1515.34" data-end="1522.83">is basically, again, Mori is from the Clojure world, it's ClojureScript.</span> </p>
<p><span data-start="1522.83" data-end="1532.37">But the Immutable.js has more of the o.get() kind of feel to it, if you're comfortable</span> <span data-start="1532.37" data-end="1534.429">writing JavaScript like that.</span> <span data-start="1534.429" data-end="1539.24">However, for me, it gives me a little bit of a cognitive dissonance there because it</span> <span data-start="1539.24" data-end="1546.22">looks like we're mutating things with those calls  —  we're not  —  but for me, to get more</span> <span data-start="1546.22" data-end="1550.88">into the mindset of functional programming, I prefer the functional programming of Mori</span> <span data-start="1550.88" data-end="1559.16">because it gets to the way that we conceive things as inputs and not just outs.</span> <span data-start="1559.16" data-end="1565.049">We don't want to be in the mindset of making changes in place to objects.</span> <span data-start="1565.049" data-end="1570">There's also some minor performance differences between the two, Mori is a bit faster, and</span> <span data-start="1570" data-end="1571.57">Immutable.js is a bit smaller.</span> <span data-start="1571.57" data-end="1576.09">But they're both great options, try them out, and I hope one of them works for you.</span> <span data-start="1576.09" data-end="1578.15">So that's my talk.</span> <span data-start="1578.15" data-end="1579.65">I hope it's been useful.</span> <span data-start="1579.65" data-end="1583.23">Go forth and don't mutate your data!</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
