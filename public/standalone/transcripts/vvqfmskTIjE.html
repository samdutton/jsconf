<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>vvqfmskTIjE</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/vvqfmskTIjE?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="3.1" data-end="6.64">Nidin Vinayakan — Shared Memory & Parallel Programming with JavaScript</span> <span data-start="6.64" data-end="22.4"Audience member: So we just had a panel discussion on the TV39 which is writing the living standard</span> <span data-start="22.4" data-end="27.74">of JavaScript, and one of the features that came out in the most recent spec was shared</span> <span data-start="27.74" data-end="29.31">array buffers and shared memory.</span> <span data-start="29.31" data-end="31.1">Please give a warm welcome to Nidin.</span> <span data-start="31.1" data-end="32.1">[Applause].</span> </p>
</section>

<section>
<p><span data-start="32.1" data-end="33.1"><span class="speaker">Nidin</span>: Good evening, everyone.</span> <span data-start="33.1" data-end="34.1">My name is Nidin Vinayakan.</span> <span data-start="34.1" data-end="35.579">I'm from India.</span> <span data-start="35.579" data-end="38.649">I'm mainly working on web technologies.</span> <span data-start="38.649" data-end="47.519">Right now, you can find me on Twitter — maybe some of you know me, like this thumbnail.</span> <span data-start="47.519" data-end="50.239">I'm on Twitter.</span> <span data-start="50.239" data-end="58.23">Right now, I'm working in a start-up company and we are trying to sell cars online, so</span> <span data-start="58.23" data-end="61.769">you can buy cars online with a mouse click.</span> </p>
<p><span data-start="61.769" data-end="65.92">If you don't like it, you can return it — yes.</span> <span data-start="65.92" data-end="73.08">So you will know we have web workers, and it is enabled mull think threading at some</span> <span data-start="73.08" data-end="81.34">extent, so, for example, if you have a memory in worker 1, and you have a memory in worker</span> <span data-start="81.34" data-end="88.049">2, if you want to serve this data, you can serve one bit by one using force — that's</span> <span data-start="88.049" data-end="91.18">not the efficient way.</span> <span data-start="91.18" data-end="97.109">Another thing you can actually post is the memory to the worker 2, then it will clone,</span> <span data-start="97.109" data-end="102.89">which actually copies the memory 1, and the memory block and creates a new memory, so,</span> <span data-start="102.89" data-end="108.109">in the memory, it will take like two blocks of memory.</span> <span data-start="108.109" data-end="111.649">Another thing is you can transfer this memory.</span> <span data-start="111.649" data-end="116.36">The problem is that it is fast, there is no cloning, just transfer the memory.</span> <span data-start="116.36" data-end="123.369">The problem it is de-attached from the CPU1 and no more axis.</span> </p>
<p><span data-start="123.369" data-end="131.83">If you have an object which is crazy, it will be serialised and be serialised during this</span> <span data-start="131.83" data-end="139.04">clone which is expensive for a real time shared memory — for the part of the programming,</span> <span data-start="139.04" data-end="141.64">this is not an option.</span> <span data-start="141.64" data-end="143.53">Yes, there's good news.</span> <span data-start="143.53" data-end="156.28">We are now at ES18, and there is a new feature — shared memory and Atomics by Lars T Hansen,</span> <span data-start="156.28" data-end="165.9">so we have a new RPA or buffer — so, when you create a buffer it will allocate a memory</span> <span data-start="165.9" data-end="171.07">block in the RAM and you can work with it, but the problem is you cannot share it.</span> <span data-start="171.07" data-end="176.87">To share the RA buffer is the same but the underlying memories shared between all the</span> <span data-start="176.87" data-end="178.92">workers.</span> <span data-start="178.92" data-end="183.58">So the API is similar.</span> <span data-start="183.58" data-end="192.36">It's the already shared between workers, so just post it, so will transfer the reference</span> <span data-start="192.36" data-end="197.63">to this memory to all the workers, and all the workers can act from the same memory,</span> <span data-start="197.63" data-end="208.7">read and write to this memory.</span> </p>
<p><span data-start="208.7" data-end="210.7">Let's do some executions.</span> <span data-start="210.7" data-end="216.06">We're actually counting 200 million numbers.</span> <span data-start="216.06" data-end="220.92">How long does this program take?</span> <span data-start="220.92" data-end="223.7">Time for 200 million iterations.</span> <span data-start="223.7" data-end="226.26">How can we make it faster?</span> <span data-start="226.26" data-end="230.89">Run iterations parallel.</span> <span data-start="230.89" data-end="238.52">It is hypothetical how we can run it in two CPUs.</span> <span data-start="238.52" data-end="240.08">We are expecting still above two.</span> <span data-start="240.08" data-end="241.92">Actually, it is slower.</span> <span data-start="241.92" data-end="242.92">Why?</span> <span data-start="242.92" data-end="260.459">Because we forgot this little thing because the CPU has its own cache and there is the</span> <span data-start="260.459" data-end="268.03">L1 cache and if you want to access the memory to copy to L1 cache, so if you're doing a</span> <span data-start="268.03" data-end="273.76">computation only in one thread it is faster because all the memories are immediately available</span> <span data-start="273.76" data-end="277.46">in the L1 cache so the accessing is really fast.</span> </p>
<p><span data-start="277.46" data-end="284.59">If you want to share operation between workers, you need to go through these things.</span> <span data-start="284.59" data-end="295.71">Also there's another set of problems, because it can cause data data arrays, then relevant</span> <span data-start="295.71" data-end="308.56">to CPU1, maybe CPU 2 has already fetched this data and implemented by one and it writes</span> <span data-start="308.56" data-end="310.2">to the memory.</span> </p>
<p><span data-start="310.2" data-end="312.95">But CPU1 doesn't know it.</span> <span data-start="312.95" data-end="316.53">What will CPU 1 do?</span> <span data-start="316.53" data-end="319.3">Increment by one and write to the memory.</span> <span data-start="319.3" data-end="328.5">At the end, you will get only one, but should get two, because there is no co-ordination</span> <span data-start="328.5" data-end="330.91">between CPU 1 and CPU2.</span> <span data-start="330.91" data-end="335.41">For that, we new a new set of APIs, called Atomics.</span> <span data-start="335.41" data-end="341.86">We can actually look at one particular line of memory access.</span> <span data-start="341.86" data-end="348.29">During the log, CPU cannot reading or write that operation — CP U2.</span> <span data-start="348.29" data-end="355.2">We lock the memory, we load it and we added and stored it to this memory and released</span> <span data-start="355.2" data-end="356.2">the log.</span> <span data-start="356.2" data-end="362.2">Then CP U2 can implement and read and write to this memory using log — or without log.</span> <span data-start="362.2" data-end="367.63">If it is not logging, the same problem might happen.</span> <span data-start="367.63" data-end="383.74">The new API atomics, only available in .. so we cannot do .. use when you do this Atomic</span> <span data-start="383.74" data-end="389.61">add in 3201, at the end, you get the expected result.</span> <span data-start="389.61" data-end="405.59">Let's do two small .. . This</span> <span data-start="405.59" data-end="410.55">is our symbol program, counting, so threats count in single thread.</span> </p>
<p><span data-start="410.55" data-end="417.46">So take around 400 milliseconds to count these 200 million numbers.</span> <span data-start="417.46" data-end="419.669">Then count in parallel.</span> <span data-start="419.669" data-end="423.63">It takes longer.</span> <span data-start="423.63" data-end="427.97">The — it it's not 200 million.</span> </p>
<p><span data-start="427.97" data-end="430.56">If you run it again, it is different.</span> <span data-start="430.56" data-end="436.02">Each time you run, it is different data because there's a data race.</span> <span data-start="436.02" data-end="441.93">It is not coordinated, they will write depending on the hardware, depending on the cycle, how</span> <span data-start="441.93" data-end="443.32">the CPU is busy.</span> </p>
<p><span data-start="443.32" data-end="448.11">The CPU will schedule this in sections independently.</span> <span data-start="448.11" data-end="452.27">We can run with Atomics.</span> <span data-start="452.27" data-end="459.51">It is quite slow because it is doing its kind of serial because it is logging the memory</span> <span data-start="459.51" data-end="467.139">and adding it, so during that lock state, the CPU1 cannot add it, so, yes.</span> <span data-start="467.139" data-end="472.669">You will get the expected result, but it takes like 13 seconds.</span> <span data-start="472.669" data-end="474.15">That's ridiculous.</span> <span data-start="474.15" data-end="478.65">It is actually very, very slower than single thread.</span> <span data-start="478.65" data-end="497.06">That problem is is I will show the code.</span> <span data-start="497.06" data-end="505.5">Formerly accessing this Atomics add any time, like 200 million times using Atomics.add because</span> <span data-start="505.5" data-end="508.54">it is logging 200 million times.</span> </p>
<p><span data-start="508.54" data-end="516.5">That's very, very slow.</span> <span data-start="516.5" data-end="520.769">Like the simple optimisation.</span> <span data-start="520.769" data-end="526.38">This is very fast.</span> <span data-start="526.38" data-end="529.01">You also get the expected result.</span> <span data-start="529.01" data-end="534.829">Then, when you run this single trip again, so, when you run a single trip again, it is</span> <span data-start="534.829" data-end="540.55">actually much faster now because it is actually V8 is optimising, it is 50 per cent faster</span> <span data-start="540.55" data-end="544.5">now and then you come back with these 400.</span> <span data-start="544.5" data-end="553.709">So, in the optimised version, what I'm doing is, because accessing memory is expensive.</span> <span data-start="553.709" data-end="564.899">When you distribute some data, so, I'm actually using a local count, then I'm actually counting</span> <span data-start="564.899" data-end="572.01">locally, because I have eight threads, and I tribute this 200 million counting to the</span> <span data-start="572.01" data-end="576.459">eight threads, so 200 million divided by eight.</span> </p>
<p><span data-start="576.459" data-end="581.559">So, in this loop, it only uses the registers, like this log.</span> <span data-start="581.559" data-end="590.26">The count is a variable so it will store it to the CPU register, then during in foreloop,</span> <span data-start="590.26" data-end="594.819">the access and implementing it's very fast.</span> <span data-start="594.819" data-end="604.329">After counting the local news, only using one Atomic.add, that's why it's faster.</span> <span data-start="604.329" data-end="612.72">If you're really doing any real power programming, yes, the Atomics is very good, but you should</span> <span data-start="612.72" data-end="633.11">not do it if you don't use it, or if you don't really need to synchronise the data.</span> <span data-start="633.11" data-end="650.98">So I was working on a GGS render engine so, using web gel it is very hard to mimic the</span> <span data-start="650.98" data-end="652.36">physics of light.</span> <span data-start="652.36" data-end="661.49">It is very hard to mimic these global illumination, and realistic shadows, and soft shadows, so</span> <span data-start="661.49" data-end="673.339">I develop a CPU version of red racing engine using shared memory.</span> </p>
<p><span data-start="673.339" data-end="686.29">This is a standard testing model, stand for dragon.</span> <span data-start="686.29" data-end="690.05">The Stanford dragon.</span> <span data-start="690.05" data-end="698.889">I need to built the tree, �is building a parallel, 2.8 milliseconds and I can start</span> <span data-start="698.889" data-end="700.029">rat racing.</span> <span data-start="700.029" data-end="701.029">Okay.</span> <span data-start="701.029" data-end="706.35">It is actually rat racing in real time in JavaScript.</span> <span data-start="706.35" data-end="714.649">So, it is actually splitting the scene into, or imagine to eight styles, and it is rat</span> <span data-start="714.649" data-end="718.089">racing eight styles at a time.</span> <span data-start="718.089" data-end="722.339">For JavaScript, that is quite fast in this case.</span> <span data-start="722.339" data-end="730.98">I can actually turn around.</span> <span data-start="730.98" data-end="756.62">When you toggle the versions, you can see the shadows are very nice, and also there</span> <span data-start="756.62" data-end="763.079">is colour bleeding here, the red one, and also green colours here, which is very hard</span> <span data-start="763.079" data-end="774.86">to mimic using web gel which is a rasterising web — it is flattening all the 3D data into</span> <span data-start="774.86" data-end="775.959">2D.</span> </p>
<p><span data-start="775.959" data-end="783.939">In this rat racing, we have a shooting race into the scene, and I'm intersecting into</span> <span data-start="783.939" data-end="789.809">the 3D model and depending on the normality of the flags and try to find out the accurate</span> <span data-start="789.809" data-end="790.809">colour.</span> <span data-start="790.809" data-end="796.639">So I left it running longer, we would get a realistic image.</span> <span data-start="796.639" data-end="814.459">So there is another three.js demo scene, it is opt data with materials and textures.</span> <span data-start="814.459" data-end="818.85">So, this is vanilla JavaScript.</span> <span data-start="818.85" data-end="824.029">And it was really tough developing something like this, because I have only shared memories,</span> <span data-start="824.029" data-end="825.949">and it is a linear memory.</span> </p>
<p><span data-start="825.949" data-end="832.499">Like there is no structure, or I cannot copy objects, so I need to put everything into</span> <span data-start="832.499" data-end="833.499">shared memory.</span> <span data-start="833.499" data-end="839.61">It is very linear, so I need to write objects into this memory, so doing it manually is</span> <span data-start="839.61" data-end="853.939">like, it is not sailable, and it's not — if there is a bug, it is hard to detect.</span> <span data-start="853.939" data-end="857.47">I have an object, and the object has some properties.</span> <span data-start="857.47" data-end="865.299">I cannot write or read directly to the shared memory, because it is a JavaScript object.</span> <span data-start="865.299" data-end="874.819">What I need to do is serialise the kind of end-code this object into normal binaries</span> <span data-start="874.819" data-end="881.889">like object ID and property value, so writing directly into this memory.</span> <span data-start="881.889" data-end="890.63">It is really not optimal, because for a little better project, it is not an option.</span> <span data-start="890.63" data-end="893.47">So I need something like okay an object.</span> <span data-start="893.47" data-end="898.73">I'm using Typescript now so I have an object, and I need to do this automatically.</span> <span data-start="898.73" data-end="902.329">What is the solution?</span> <span data-start="902.329" data-end="917.37">I didn't find any good solution, so I created a compiler, called Turbo — when we create</span> <span data-start="917.37" data-end="926.199">a task in the script, it will be a shared memory and then a pointer, so I can work with</span> <span data-start="926.199" data-end="929.11">the pointer.</span> </p>
<p><span data-start="929.11" data-end="933.389">So yeah, the turbo script looked like this.</span> <span data-start="933.389" data-end="940.73">So, for example, it is a vector, and the vector has x, y, z, so, for you, it looks like normal</span> <span data-start="940.73" data-end="942.48">typescript.</span> <span data-start="942.48" data-end="950.72">The only difference is you need to delete this allocated memory manually, like C++ so</span> <span data-start="950.72" data-end="952.429">it can create this object.</span> </p>
<p><span data-start="952.429" data-end="957.55">Here I'm creating this new vector, and I'm exporting this function.</span> <span data-start="957.55" data-end="962.199">When you export a function, it will actually export, it will create a module and export</span> <span data-start="962.199" data-end="968.049">this specific function from the JavaScript.</span> <span data-start="968.049" data-end="974.79">It will create a new vector and return a pointer, and later, you create two vectors, and you</span> <span data-start="974.79" data-end="976.3">use this function to add it.</span> </p>
<p><span data-start="976.3" data-end="983.079">It will add a new vector, then if you are done with that vector, destroy this vector,</span> <span data-start="983.079" data-end="990.29">otherwise it will leak the memory, and he will die!</span> <span data-start="990.29" data-end="1006.79">Turbo script is a subset of typescript.</span> <span data-start="1006.79" data-end="1012.449">It can come back to normal JavaScript.</span> <span data-start="1012.449" data-end="1019.639">In WebAssembly, it is not really useful, because WebAssembly doesn't have shared memory, so</span> <span data-start="1019.639" data-end="1023.899">WebAssembly 2 releases, I can really test the performance.</span> <span data-start="1023.899" data-end="1030.742">I can compile the same code to two or three different targets, normal like JavaScript,</span> <span data-start="1030.742" data-end="1039">and have some — it will be a really nice tool to compare how these three things are performing.</span> <span data-start="1039" data-end="1048.049">It's still a work in programme West, so I'm trying to implement it.</span> <span data-start="1048.049" data-end="1058.1">So a typescript like JavaScript, some combinations, in the future it is not supporting WebAssembly</span> <span data-start="1058.1" data-end="1064.929">or in order to support all the JavaScript features, I need to re-implement all the JavaScript</span> <span data-start="1064.929" data-end="1067.679">original machine inside WebAssembly.</span> <span data-start="1067.679" data-end="1070.799">That's not doable for now.</span> </p>
<p><span data-start="1070.799" data-end="1076.071">I can actually compile some functions into the WebAssembly and other functions into the</span> <span data-start="1076.071" data-end="1084.13">normal JavaScript and like connect together, for example, DOM access things I can come</span> <span data-start="1084.13" data-end="1086.669">back to the normal JavaScript, so it's easy.</span> <span data-start="1086.669" data-end="1092.549">Maybe some hard functions, number-crunching like that.</span> <span data-start="1092.549" data-end="1101.269">Then, you can utilise this WebAssembly, because normally when I talk about normal JavaScript</span> <span data-start="1101.269" data-end="1106.48">developers, they're not interested in WebAssembly because right now, own C++ can compare to</span> <span data-start="1106.48" data-end="1111.96">WebAssembly and when you talk about WebAssembly they don't know what is it, and they can't</span> <span data-start="1111.96" data-end="1113.53">really use it.</span> <span data-start="1113.53" data-end="1120.04">You can still write an expression in text format which is really not scaleable or it</span> <span data-start="1120.04" data-end="1121.04">is very low.</span> <span data-start="1121.04" data-end="1126.82">It is meant for debugging and no-one is writing a real big project in it.</span> </p>
<p><span data-start="1126.82" data-end="1136.269">So this is also a good tool for normal JavaScript developers because its syntax is similar.</span> <span data-start="1136.269" data-end="1141.36">So merge mark, and I'm useful normal JavaScript.</span> <span data-start="1141.36" data-end="1148.44">I need to — I mention I need to create a vector for race racing which is KD3.</span> <span data-start="1148.44" data-end="1158.1">To build it, it will take a little bit more time because it's actually splitting the 3D</span> <span data-start="1158.1" data-end="1161.309">space into different small, small pieces.</span> <span data-start="1161.309" data-end="1172.22">Normally, without TurboScript, I build once in the main thread or copy these objects through</span> <span data-start="1172.22" data-end="1178.96">both messages and then to actually clone and the performance was low, and it will take</span> <span data-start="1178.96" data-end="1183.26">more than one minute just to initialise this Standford Dragon.</span> <span data-start="1183.26" data-end="1187.09">Right now, I'm using turbo script.</span> </p>
<p><span data-start="1187.09" data-end="1199.61">It will compile and at the end get written a pointer to this 3D the workers has immediately</span> <span data-start="1199.61" data-end="1201.35">access to the KD3.</span> <span data-start="1201.35" data-end="1206.789">It can stop rat-racing.</span> <span data-start="1206.789" data-end="1228.259">I will show you some syntax.</span> <span data-start="1228.259" data-end="1251.03">There is an RAX sample in turbo script.</span> <span data-start="1251.03" data-end="1257.78">You can also export the class, so you export something like this.</span> <span data-start="1257.78" data-end="1266.36">We will open it so it is easy to read.</span> <span data-start="1266.36" data-end="1272.58">So it will declare like this, like data new and data search.</span> <span data-start="1272.58" data-end="1277.19">From the JavaScript, you can use data new so it will create a new instance of that data</span> <span data-start="1277.19" data-end="1279.559">class.</span> <span data-start="1279.559" data-end="1284.38">And one problem is I'm working on it, I'm working on a wrapper for these turbo classes</span> <span data-start="1284.38" data-end="1288.139">so from JavaScript, you can access like instance.properties.</span> <span data-start="1288.139" data-end="1295.809">Right now, you can't access properties, but you can access methods, so you can abscess</span> <span data-start="1295.809" data-end="1314.88">set method, or if you want to access a V1, so you need to, like, catch V1, you need to</span> <span data-start="1314.88" data-end="1320.2">do something like this to access the property, because when you — you're getting a pointer,</span> <span data-start="1320.2" data-end="1327.7">because it is in 32 number, you cannot dot it because it is a pointer.</span> </p>
<p><span data-start="1327.7" data-end="1329.779">Up need to do like this.</span> <span data-start="1329.779" data-end="1335.73">But I'm planning like a wrapper function around the turbo object so it can actually export</span> <span data-start="1335.73" data-end="1341.51">automatically a JavaScript wrapper, then you can use normal things, but I don't know how</span> <span data-start="1341.51" data-end="1347.45">fast because it will create an object, maybe for a bigger objects like if you have a queue,</span> <span data-start="1347.45" data-end="1354.669">for example, a big scene of millions of triangles, you can create wrapper objects for the main</span> <span data-start="1354.669" data-end="1359.419">route objects like a scene, so from the scene, you can access a lot of the properties.</span> <span data-start="1359.419" data-end="1363.84">That will be useful.</span> <span data-start="1363.84" data-end="1364.95">Yes.</span> <span data-start="1364.95" data-end="1375.72">And also, I'm using this wasm tool, I can format this text format and debug what is</span> <span data-start="1375.72" data-end="1377.529">going on in my assembly.</span> <span data-start="1377.529" data-end="1379.24">It is easy for debugging.</span> <span data-start="1379.24" data-end="1388.08">Also, I have a log, so to limit all the data like what bytes are retaining, so it is easy</span> <span data-start="1388.08" data-end="1398.919">for debugging, everything in the log file, but it is formatted.</span> <span data-start="1398.919" data-end="1404.66">And yes, any more questions right now?</span> </p>
<p><span data-start="1404.66" data-end="1407.21">No.</span> <span data-start="1407.21" data-end="1409.76">Okay.</span> <span data-start="1409.76" data-end="1417.41">Yes, that's it.</span> <span data-start="1417.41" data-end="1419.96">[Applause].</span> <span data-start="1419.96" data-end="1430.179"Audience member: Thank you so much, Nidin, for the excellent talk.</span> <span data-start="1430.179" data-end="1431.95">We have a break scheduled now.</span> <span data-start="1431.95" data-end="1435.419">15 minutes, and then the last two talks of the conference.</span> <span data-start="1435.419" data-end="1437.52">We also have our last community event.</span> <span data-start="1437.52" data-end="1440.22">If you want to go and check out another \{ live : JS \} performance and a meet-and-greet session</span> <span data-start="1440.22" data-end="1441.22">with the representatives.</span> <span data-start="1441.22" data-end="1442.22">So, one more talk there, and then two more talks here.</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
