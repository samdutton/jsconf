<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Fg7niTmNNLg</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/Fg7niTmNNLg?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="3.139" data-end="10.58">Marja Hoeltta Parsing JavaScript — better lazy than eager.</span> </p>
</section>

<section>
<p><span data-start="27.32" data-end="30.119"><span class="speaker">Marja</span>: Hi, everybody.</span> <span data-start="30.119" data-end="32.84">I'm super excited to be here.</span> <span data-start="32.84" data-end="38.079">I work in the V8 team as a software engineer and I will talk about parsing JavaScript.</span> <span data-start="38.079" data-end="44.039">This talk is going to be about V8, the engine behind Google Chrome and how we parse JavaScript.</span> <span data-start="44.039" data-end="49.039">I figure if I'm going to give a parser talk, I should tell you what parsing is to get everybody</span> <span data-start="49.039" data-end="53.29">on the same page and why you should care about it.</span> <span data-start="53.29" data-end="59.17">I'm going to talk about how V8 parses JavaScript and what you as a web developer can do to</span> <span data-start="59.17" data-end="62.94">help us parse better.</span> <span data-start="62.94" data-end="64.62">What is parsing?</span> <span data-start="64.62" data-end="69.72">So, for those who didn't see the previous talk, the parser gets the JavaScript source</span> <span data-start="69.72" data-end="75.259">code and constructs data structures called AST and scopes based on it.</span> <span data-start="75.259" data-end="77.98">I will tell you in a minute what those are.</span> <span data-start="77.98" data-end="82.52">Then the bytecode generator walks those structures and generates bytecode.</span> </p>
<p><span data-start="82.52" data-end="88.28">It is then interpreted by the interpreter and the optimising compiler also gets the</span> <span data-start="88.28" data-end="95.799">bytecode and machine code based on it and the machine code is executed directly.</span> <span data-start="95.799" data-end="99.5">So let's look at some simple source code and what the parser does with it.</span> <span data-start="99.5" data-end="104.909">The parser constructs an AST, an abstract syntax tree, that describes the structure</span> <span data-start="104.909" data-end="106.49">of the source code.</span> <span data-start="106.49" data-end="112.539">For the function, there is a function literal and there is a variable declaration and an</span> <span data-start="112.539" data-end="114.31">an assignment.</span> </p>
<p><span data-start="114.31" data-end="118.89">Every time we see a variable name, we create a variable proxy for it.</span> <span data-start="118.89" data-end="124.82">We don't know what proxy it is, it represents the variable.</span> <span data-start="124.82" data-end="127.92">The zero is the literal.</span> <span data-start="127.92" data-end="129.52">Then there is an if statement.</span> <span data-start="129.52" data-end="135.81">It has the condition which is empty here.</span> <span data-start="135.81" data-end="138.09">The "then" part contains for code.</span> </p>
<p><span data-start="138.09" data-end="142.92">There is another variable declaration and an assignment and we create variable proxy</span> <span data-start="142.92" data-end="148.31">objects to recreate the name of the available and then there is a return statement again</span> <span data-start="148.31" data-end="150.54">with a variable proxy.</span> <span data-start="150.54" data-end="154.819">This is the AST that the parser generates based on the code.</span> <span data-start="154.819" data-end="162.431">In addition to the AST, the parser also generates scopes where the variables are declared, so</span> <span data-start="162.431" data-end="167.76">now for the function, there is one declaration scope, and for the if-statement body, there</span> <span data-start="167.76" data-end="169.83">is another scope.</span> <span data-start="169.83" data-end="174.23">The declaration scope Danes the variable A and the if statement contains the variable</span> <span data-start="174.23" data-end="184.62">B. The variable proxies occur in the code which belongs to that scope.</span> </p>
<p><span data-start="184.62" data-end="185.709">Then we do scope analysis.</span> <span data-start="185.709" data-end="192.97">This means we connect the variable proxies to the declared variables, so, in this phase,</span> <span data-start="192.97" data-end="198.9">we figure out that all references to A actually mean the variable declared in the function,</span> <span data-start="198.9" data-end="203.5">and all references to B mean a different variable.</span> <span data-start="203.5" data-end="208.48">And, to do this, it's not enough to just look at the current scope where we are in, for</span> <span data-start="208.48" data-end="213.209">example, with the returns statement, there is return A but A is not declared in that</span> <span data-start="213.209" data-end="214.209">scope.</span> <span data-start="214.209" data-end="219.621">Instead, what we need to do is that we walk up the scope chain to find where the variable</span> <span data-start="219.621" data-end="223.569">is declared and now we find it in the parent scope in the declaration scope.</span> <span data-start="223.569" data-end="228.83">Okay, so, this is quite a lot of detail on one side, and, in reality, it is even more</span> <span data-start="228.83" data-end="229.83">interconnected.</span> <span data-start="229.83" data-end="232.319">I just couldn't draw all the arrows on the slide.</span> </p>
<p><span data-start="232.319" data-end="236.99">This was exhausting to make and also probably super exhausting to look at.</span> <span data-start="236.99" data-end="246.159">Look at this for a second!</span> <span data-start="246.159" data-end="249.629">Why should you care about parsing?</span> <span data-start="249.629" data-end="254.599">Here is a diagram where real world spend their time in V8.</span> <span data-start="254.599" data-end="262.07">Parsing is the orange blob on the left and turns out the web pages around 15 to 20 per</span> <span data-start="262.07" data-end="265.69">cent of their V8 time in parsing.</span> <span data-start="265.69" data-end="271.01">Parsing is on the critical path for web page start-up.</span> <span data-start="271.01" data-end="281.63">According to Google's production web app study a typical page spends around 370 milliseconds</span> <span data-start="281.63" data-end="286.76">passing it on mobile, so that's quite a lot of time, if you think about it.</span> <span data-start="286.76" data-end="291.96">So this means that our parsing speed is roughly one megabyte per second on mobile.</span> <span data-start="291.96" data-end="297.44">How does V8 parse JavaScript?</span> <span data-start="297.44" data-end="303.41">I'm going to talk about the two parsing modes, eager and lazy, and why parsing is hard and</span> <span data-start="303.41" data-end="307.88">why benchmarking it is hard.</span> </p>
<p><span data-start="307.88" data-end="311.4">We don't actually have one parsers, we have two.</span> <span data-start="311.4" data-end="316.45">They are called parser and pre-parser, for historical reasons.</span> <span data-start="316.45" data-end="322.44">Parser is the full eager one.</span> <span data-start="322.44" data-end="331.22">It builds the AST and the scopes and finds the syntax errors in the code.</span> <span data-start="331.22" data-end="336.43">The pre-parser is the fast, lazy one.</span> <span data-start="336.43" data-end="344.35">So, it basically just finds where the function ends so that we can carry on.</span> <span data-start="344.35" data-end="346.72">It doesn't build an AST.</span> <span data-start="346.72" data-end="351.69">It build scopes but it doesn't put variable references or variable declarations in the</span> <span data-start="351.69" data-end="352.69">scopes.</span> <span data-start="352.69" data-end="358.43">It is approximately twice as fast as parser, and it only finds a restricted set of errors,</span> <span data-start="358.43" data-end="362.97">so it doesn't actually comply with the ECMAScript spec but we are somehow getting away with</span> <span data-start="362.97" data-end="366.75">it!</span> <span data-start="366.75" data-end="371.57">Here's an example of how we use the two parsers to parse your JavaScript code.</span> <span data-start="371.57" data-end="373.32">All top-level code is eager.</span> </p>
<p><span data-start="373.32" data-end="376.21">We use an actual parser to parse it.</span> <span data-start="376.21" data-end="389.13">We see an —  in there example, there is a — this is because</span> <span data-start="389.13" data-end="391.95">you want to call the function right after.</span> <span data-start="391.95" data-end="393">So we should eager-parse that.</span> <span data-start="393" data-end="399.25">In this case, the guess is correct, and there actually is a call to this function so this</span> <span data-start="399.25" data-end="401.27">is eager parse.</span> </p>
<p><span data-start="401.27" data-end="406.31">Other top-level function are lazy parsed.</span> <span data-start="406.31" data-end="410.25">So we use the pre-parser for parsing that function body.</span> <span data-start="410.25" data-end="415.77">Later on, at some point in time, you might want to call this function so at that point</span> <span data-start="415.77" data-end="423.49">when you call the function, it is eager-parsed, compiled and executed.</span> </p>
<p><span data-start="423.49" data-end="425.42">There are some other heuristics.</span> <span data-start="425.42" data-end="430.3">If there is an exclamation before the function, it turns it eager.</span> <span data-start="430.3" data-end="436.98">If there is another comma, it turns it eager.</span> <span data-start="436.98" data-end="439.06">These are all eager.</span> <span data-start="439.06" data-end="443.41">Here are some trickier lazy versus eager cases.</span> <span data-start="443.41" data-end="448.47">The problem is we need to make the decision which parser to use before we use the function</span> <span data-start="448.47" data-end="451.74">body or anything that follows it.</span> <span data-start="451.74" data-end="456.38">We need to see it when we see the function took.</span> <span data-start="456.38" data-end="458.24">We assign a function to a variable.</span> <span data-start="458.24" data-end="460.25">This function is lazy.</span> <span data-start="460.25" data-end="462.33">There is no par 11 before it.</span> <span data-start="462.33" data-end="466.13">We use the — there is no paren before it.</span> <span data-start="466.13" data-end="472.61">The second example looks just like the first one except we call this function an assigned</span> <span data-start="472.61" data-end="479.24">return value of that call to F2, but we cannot know it when we need to make decision on whether</span> <span data-start="479.24" data-end="483.85">to parse or pre-parse, or whether to eager parse or lazy-parse this function, so we end</span> <span data-start="483.85" data-end="490.65">up making the exact same decision in both cases, so, in the second one, we also lazy-parse</span> <span data-start="490.65" data-end="497.88">this, and, when this line is execute the, we need to eager-parse it right after and</span> <span data-start="497.88" data-end="500.64">compile it.</span> </p>
<p><span data-start="500.64" data-end="504.39">But it was kind of the wrong decision but we just couldn't know based on the code that</span> <span data-start="504.39" data-end="507.28">we have seen so far.</span> <span data-start="507.28" data-end="511.48">So these lazy versus eager rules are not specified in the spec.</span> <span data-start="511.48" data-end="515.68">Each engine is free to implement them as they see fit, or they don't need to implement lazy</span> <span data-start="515.68" data-end="518">parsing at all if they don't like to.</span> <span data-start="518" data-end="524.65">V8 just tries to guess based on the syntax which functions are probably called and then</span> <span data-start="524.65" data-end="529.18">eager-parse those functions and lazy-parse the rest.</span> </p>
<p><span data-start="529.18" data-end="531.45">So why is this relevant for you?</span> <span data-start="531.45" data-end="536.63">So, it turns out we need lazy-parsing because web pages ship a lot of code they don't execute</span> <span data-start="536.63" data-end="544.3">- at least not on start-up — so we want to use as little work for doing, to do as little</span> <span data-start="544.3" data-end="547.54">work for processing that code that is not needed.</span> <span data-start="547.54" data-end="551.96">It is also important that we pick the right unto use.</span> <span data-start="551.96" data-end="557.07">If we eager-parse something that is not needed, we're just wasting time, it is not necessary.</span> <span data-start="557.07" data-end="562.67">On the other hand, if we lazy-parse something that's needed then we pay the cost at pre-parse</span> <span data-start="562.67" data-end="565.5">at the cost of parse.</span> <span data-start="565.5" data-end="572.02">The pre-parse is half the cost cost, so it's like nun and a half times the parse cost we</span> <span data-start="572.02" data-end="574.39">need to pay.</span> <span data-start="574.39" data-end="579.21">The problem is knowing what code is executed at start-up.</span> <span data-start="579.21" data-end="583.752">You can also force eager parsing by wrapping function that is are critical functions for</span> <span data-start="583.752" data-end="589.9">start-up in parens.</span> <span data-start="589.9" data-end="598.43">There is a library called optimise- just that does this so it should have use and that results</span> <span data-start="598.43" data-end="609.92">in speed -ups with most of the browsers  —  optimize-just.</span> <span data-start="609.92" data-end="614.93">We should also minimise the cost for cases where cases where we get the guess wrong.</span> </p>
<p><span data-start="614.93" data-end="618.56">This is an area where we are actively working on in the attempt.</span> <span data-start="618.56" data-end="627.46">Lazy parse be inner function assist nor complicated than lazy-parsing top-level code top to understand</span> <span data-start="627.46" data-end="630.74">why, we need to look at context allocation.</span> <span data-start="630.74" data-end="632.67">Here is some example code.</span> <span data-start="632.67" data-end="639.83">There is a function outer which is an so we eager-parse.</span> <span data-start="639.83" data-end="645.12">That is a local variable called a.</span> <span data-start="645.12" data-end="650.32">Then it has an inner function that returns this local variable.</span> <span data-start="650.32" data-end="655.06">And then this function outer returns a reference to the inner function.</span> <span data-start="655.06" data-end="659.55">Now we call this function and assign the return fall to f.</span> <span data-start="659.55" data-end="663.75">Now, f will be a reference to inner.</span> <span data-start="663.75" data-end="666.74">And then we call f and we print out the return value.</span> </p>
<p><span data-start="666.74" data-end="673.21">So, this will print out to any, as you might expect, but where is it coming from?</span> <span data-start="673.21" data-end="679.33">Normally, when you call a function, it is local or variables are put on the stack, but</span> <span data-start="679.33" data-end="685.24">here, when we are calling f, we're not inside a call to outer, so it definitely cannot be</span> <span data-start="685.24" data-end="686.97">on the stack.</span> <span data-start="686.97" data-end="688.05">So where is it?</span> <span data-start="688.05" data-end="691.96">The answer is it is in the function context.</span> <span data-start="691.96" data-end="697.68">So a function context is an object which the inner function also refers to and keeps it</span> <span data-start="697.68" data-end="701.29">alive, so now we have the reference to the inner function because f is a reference to</span> <span data-start="701.29" data-end="705.33">it, so that is how the function context is then kept alive.</span> </p>
<p><span data-start="705.33" data-end="716.36">When f accesses when inner accesses the variable a, it reads it from the function context.</span> <span data-start="716.36" data-end="721.279">If you want to lazy-parse inner in this case, we need to know which variables they refer</span> <span data-start="721.279" data-end="727.35">to so that we can put those variables in the function context and not put other variables</span> <span data-start="727.35" data-end="728.35">there.</span> <span data-start="728.35" data-end="732.15">We don't want to put all variables to the function context because accessing them from</span> <span data-start="732.15" data-end="737">there, it just is way slower than accessing them from the stack.</span> <span data-start="737" data-end="746.38">So normally, .. need to, so we need something like lazy parsing with names, and the speed</span> <span data-start="746.38" data-end="750.88">for doing that is somewhere between parser and pre-parser.</span> <span data-start="750.88" data-end="756.54">So this means that lazy-parsing inner functions will always be heavier than top-level functions</span> <span data-start="756.54" data-end="758.67">just because of the semantics.</span> <span data-start="758.67" data-end="767.49">Modern JavaScript is heavily nested.</span> <span data-start="767.49" data-end="770.93">Everything is wrapped in functions, everything is a module now.</span> <span data-start="770.93" data-end="776.779">This is a price you have to pay for, nesting functions like that.</span> <span data-start="776.779" data-end="782.07">In some situations, V8 has to reparse code that it has already lazy-parsed.</span> <span data-start="782.07" data-end="788.97">In this example, there is a lazy outer function, no paren before the function so we lazy-parse</span> <span data-start="788.97" data-end="794.29">it and lazy-parse everything inside the function too.</span> </p>
<p><span data-start="794.29" data-end="799.38">When we call this lazy outer function, we need to do something for inner, and how it</span> <span data-start="799.38" data-end="804.85">currently works is that we need to pre-parse or lazy-parse inner again even though we have</span> <span data-start="804.85" data-end="807.75">done it already once.</span> <span data-start="807.75" data-end="810.93">It gets even worse if you nest more.</span> <span data-start="810.93" data-end="817.94">So now, in the first run, when we go through the code, we lazy-parse lazy outer and lazy-parse</span> <span data-start="817.94" data-end="828.87">everything in it, at some point, you call lazy outer, so we eager-parse lazy outer and</span> <span data-start="828.87" data-end="833.97">then lazy lazy-parse parse inner 2.</span> <span data-start="833.97" data-end="840.9">We inner parse, and need to lazy-parse inner 2 for the third time.</span> <span data-start="840.9" data-end="842.23">Obviously, this is quite bad.</span> <span data-start="842.23" data-end="843.6">This is not how it should work.</span> <span data-start="843.6" data-end="846.42">This is something I'm working on.</span> <span data-start="846.42" data-end="853.1">Instead of lazy-parsing we should keep those functions if we have already lazy-parsed them</span> <span data-start="853.1" data-end="854.32">once.</span> <span data-start="854.32" data-end="856.19">Why is parsing hard?</span> <span data-start="856.19" data-end="861.36">The JavaScript grammar is not ambiguous as such, but it contains some constructs where</span> <span data-start="861.36" data-end="864.279">we don't know up front what we are parsing.</span> </p>
<p><span data-start="864.279" data-end="868.31">One is parameter list and comma expressions.</span> <span data-start="868.31" data-end="870.64">They just the same.</span> <span data-start="870.64" data-end="875.589">If you see (abc), you don't know what that is.</span> <span data-start="875.589" data-end="879.44">Maybe it is a comma expression.</span> <span data-start="879.44" data-end="884.31">It is also possible that it is a valid comma expression but not a valid error function</span> <span data-start="884.31" data-end="885.529">parameter list.</span> </p>
<p><span data-start="885.529" data-end="894.23">If you see A12, that's a valid comma expression, but A12 is not a valid comma parameter list.</span> <span data-start="894.23" data-end="901.279">We don't know if it is an expression or not until we see an arrow following the expression.</span> <span data-start="901.279" data-end="903.27">We cannot know.</span> <span data-start="903.27" data-end="905.45">For example, when we see the 1.</span> <span data-start="905.45" data-end="912.69">The other way round is also possible, the A, B is okay.</span> <span data-start="912.69" data-end="921.83">It is arrow function with the rest, but a.B is not okay and this is not something we can</span> <span data-start="921.83" data-end="925.94">know when we are parsing, we don't know whether the user intends to use it as an arrow function</span> <span data-start="925.94" data-end="927.8">list.</span> <span data-start="927.8" data-end="932.39">How the parser solves this is it never rewinds.</span> <span data-start="932.39" data-end="939.95">Instead, when it is parsing an unknown construct, it is parsing a very permissive grammar that</span> <span data-start="939.95" data-end="945.9">allows both kinds of constructs, and then it records whether it has seen something that</span> <span data-start="945.9" data-end="951.39">makes it the invalid function list or an invalid comma expression.</span> <span data-start="951.39" data-end="956.77">Then, when we see the closing paren we can check if there is an arrow, and if there is</span> <span data-start="956.77" data-end="965.87">an arrow was it — so we just the check of information that we recorded when we — we</span> <span data-start="965.87" data-end="972.85">don't jump back and reparse it or anything like that.</span> </p>
<p><span data-start="972.85" data-end="978.149">So the parser has high-feature complexity and new language features are added to it</span> <span data-start="978.149" data-end="979.63">all the tile.</span> <span data-start="979.63" data-end="982.33">Here is a typical parser bug that I found some time ago.</span> <span data-start="982.33" data-end="989.2">It is eager parsing failings with that code, but like what is this even?</span> <span data-start="989.2" data-end="994.92">So, there is a variable g, and we assign to g an arrow function.</span> <span data-start="994.92" data-end="998.89">The arrow function has two parameters.</span> <span data-start="998.89" data-end="1007.899">There is the destructuring x and then there is g, and the parameter g has a default value.</span> <span data-start="1007.899" data-end="1015.339">That's again an arrow function with a body, and the body is eval x.</span> <span data-start="1015.339" data-end="1023.66">So now, if I force eager parsing, if I disable lazy-parsing, this fails.</span> <span data-start="1023.66" data-end="1030.14">We call the function g without providing a value for g, so the default value kicks in</span> <span data-start="1030.14" data-end="1034.38">and this eval is confused and says, "I have no idea what are you talking about?</span> <span data-start="1034.38" data-end="1039.89">What is this x even though it should resolve to the parameter x."</span> <span data-start="1039.89" data-end="1045.78">The features involved in this bug are lazy versus eager, a destructuring — destructuring</span> <span data-start="1045.78" data-end="1055.53">x, turns out this is not relevant — there are default parameters, there are arrow functions,</span> <span data-start="1055.53" data-end="1061.03">and now an arrow function is used as a default parameter to another rather row function and</span> <span data-start="1061.03" data-end="1066.65">then there is eval, and it's important that the eval is in the body of an arrow function</span> <span data-start="1066.65" data-end="1071.27">which is a default parameter, so this is to give you an idea of the complexity we are</span> <span data-start="1071.27" data-end="1076.52">dealing with in our everyday work.</span> </p>
<p><span data-start="1076.52" data-end="1079.9">Benchmarking parsing is also also non-trivial.</span> <span data-start="1079.9" data-end="1082.309">Here I have some mock benchmarks.</span> <span data-start="1082.309" data-end="1086.43">Benchmark one is not a bench — parsing benchmark.</span> <span data-start="1086.43" data-end="1088.92">It is lots of function with lots of code.</span> <span data-start="1088.92" data-end="1096">It is it looks like a lazy function, there is no paren before it, and then the actual</span> <span data-start="1096" data-end="1102.13">benchmark starts the timer, calls this function, and measures how long it took.</span> </p>
<p><span data-start="1102.13" data-end="1108.38">But now, if you implement lazy parsing the way I described, we need to parse the function</span> <span data-start="1108.38" data-end="1113.05">when the timer is running, and this is really bad for the benchmark, for the benchmark,</span> <span data-start="1113.05" data-end="1118.85">it would way better just to do as much work upfront as we can, and like parse and compile</span> <span data-start="1118.85" data-end="1123.55">everything when the timer is not running yet.</span> <span data-start="1123.55" data-end="1128.62">Even though we need lazy-parsing for the web, it really makes the benchmark score here worse.</span> <span data-start="1128.62" data-end="1132.23">It's a tiff trade-off.</span> <span data-start="1132.23" data-end="1139.33">There is another benchmark, benchmark 2, that tries to be a benching bench marsh.</span> <span data-start="1139.33" data-end="1145.88">We start the timer, eval a lot of code and then measure how long it took.</span> </p>
<p><span data-start="1145.88" data-end="1153.47">Okay, this is fair, like this definitely exercises parsing when the timer is running, but this</span> <span data-start="1153.47" data-end="1156.61">is totally not how you load JavaScript.</span> <span data-start="1156.61" data-end="1161.62">When you load JavaScript from a file from a resource, a wholly different code path kicks</span> <span data-start="1161.62" data-end="1163.52">in as in here.</span> <span data-start="1163.52" data-end="1169.06">And, for example, there are some improvements we do for the standard code path for the normal</span> <span data-start="1169.06" data-end="1175.46">code path, for example, we download and parse scripts in parallel, and these kind of improvements</span> <span data-start="1175.46" data-end="1180.679">don't benefit this kind of benchmark at all, because eval is just not using the same code</span> <span data-start="1180.679" data-end="1182.39">path.</span> <span data-start="1182.39" data-end="1187.13">So, what can you do to help us parse better?</span> <span data-start="1187.13" data-end="1192.41">So, none of the stuff I talk about can be sort of black and white, like, "Do this or</span> <span data-start="1192.41" data-end="1196.91">absolutely don't do that," I can only tell you how things look from the parser point</span> <span data-start="1196.91" data-end="1200.73">of view and then you can sort of figure out what's the good trade-off for you and your</span> <span data-start="1200.73" data-end="1202.87">use case.</span> <span data-start="1202.87" data-end="1210.01">So, a lot of this stuff you can find in a blog post called "JavaScript start-up performance".</span> <span data-start="1210.01" data-end="1218.43">The first is sheetless JavaScript so we don't need to parse so much.</span> <span data-start="1218.43" data-end="1222.36">[Applause].</span> </p>
<p><span data-start="1222.36" data-end="1228.98">You can also the code coverage, functionality in dev tools to see what parts of your codes</span> <span data-start="1228.98" data-end="1233.73">are not needed or not needed on start-up so maybe it is possible to lazy-load some of</span> <span data-start="1233.73" data-end="1235.43">that code.</span> <span data-start="1235.43" data-end="1241.76">You can measure the parse of your code and the dependencies with the Chrome tracing and</span> <span data-start="1241.76" data-end="1248.54">runtime stats in it and you can see the concrete number of milliseconds that it spends parsing</span> <span data-start="1248.54" data-end="1251.44">your code.</span> <span data-start="1251.44" data-end="1266.2">We have the code-caching, when you load the same script, V8 detects that and butts it</span> <span data-start="1266.2" data-end="1267.66">in the cache.</span> </p>
<p><span data-start="1267.66" data-end="1273.2">The next time you load the script, we don't need to parse it, compile it, we just read</span> <span data-start="1273.2" data-end="1275.4">the bytecode directly from the cache.</span> <span data-start="1275.4" data-end="1277.929">This affects bundling.</span> <span data-start="1277.929" data-end="1283.28">If you bundle a lot of your JavaScript libraries into one file and then you want to update</span> <span data-start="1283.28" data-end="1286.75">one part of it, you lose the code cache for the full bundle.</span> <span data-start="1286.75" data-end="1291.27">We won't be able to figure out that you have updated just one part of the bundle, so this</span> <span data-start="1291.27" data-end="1296.57">is something to be aware of when bundling and updating your code.</span> <span data-start="1296.57" data-end="1299.42">I already mentioned streaming.</span> <span data-start="1299.42" data-end="1304.77">That means we start parsing a script while it's downloading, before it has finishing</span> <span data-start="1304.77" data-end="1310.95">downloading the full script, so it makes sense to use this for big scripts, and to use them</span> <span data-start="1310.95" data-end="1315.31">optimally, you should load them as early as possible and async and so the streamer kicks</span> <span data-start="1315.31" data-end="1324.19">in, and you can also make sure that the streamer is streaming your with Chrome tracing.</span> </p>
<p><span data-start="1324.19" data-end="1329.89">In the event thread, there will be a background and you can see the name of the script that</span> <span data-start="1329.89" data-end="1334.049">got streamed.</span> <span data-start="1334.049" data-end="1336.26">There is very little we can do for eval.</span> <span data-start="1336.26" data-end="1338.76">So, there won't be streaming for that.</span> <span data-start="1338.76" data-end="1340.47">There won't be code cache for that.</span> <span data-start="1340.47" data-end="1348.51">It makes sense to avoid it, avoid evaling big chunks of code if you can.</span> <span data-start="1348.51" data-end="1354.42">In some situations it makes sense to use the parens hack to force the compilation of the</span> <span data-start="1354.42" data-end="1357.04">critical path in your code.</span> <span data-start="1357.04" data-end="1361.16">This makes sense, for example, in if you need to support older Chrome versions.</span> <span data-start="1361.16" data-end="1366.17">If you need performance across browsers or if you need performance right now and can</span> <span data-start="1366.17" data-end="1369.42">wait for us to fix our — can't wait for us to fix our code.</span> <span data-start="1369.42" data-end="1377.03">We are working on making these hacks less and less relevant in the future.</span> <span data-start="1377.03" data-end="1378.71">There is time for bonus content.</span> <span data-start="1378.71" data-end="1381.82">This is code from the V8 parser.</span> <span data-start="1381.82" data-end="1400.059">It is a hand-written recurse descent parser, so here we are inside this parsing statement.</span> <span data-start="1400.059" data-end="1402.88">So the return of that is statement.</span> </p>
<p><span data-start="1402.88" data-end="1407.91">And the first thing we expect to see is token "if".</span> <span data-start="1407.91" data-end="1414.97">This is already checked above for calling this function, and then we expect to see a</span> <span data-start="1414.97" data-end="1416.5">left paren.</span> <span data-start="1416.5" data-end="1428.96">If there is no left paren, then this is a syntax error and we bail out of this function.</span> <span data-start="1428.96" data-end="1430.7">So then we recurse.</span> <span data-start="1430.7" data-end="1440.33">We call a function called ParseExpression and then we expect the right paren after it.</span> <span data-start="1440.33" data-end="1444.59">We recurse again.</span> <span data-start="1444.59" data-end="1458.65">Now it is possible that the if part — thin part — we check is in a token: ELSE?</span> <span data-start="1458.65" data-end="1462.929">If there is, we recurse again for parsing the ELSE part.</span> <span data-start="1462.929" data-end="1471.059">If there is no ELSE, we do nothing, and in the end, we construct the node for the statement.</span> <span data-start="1471.059" data-end="1479.36">It is handwritten, not generated by any rule file or anything like that.</span> <span data-start="1479.36" data-end="1482">Here are some things you might want to remember from the talk.</span> </p>
<p><span data-start="1482" data-end="1486.46">If you have further questions or comments or want to talk about parsing in general,</span> <span data-start="1486.46" data-end="1487.669">just please get in in touch.</span> <span data-start="1487.669" data-end="1488.669">Thanks for listening.</span> <span data-start="1488.669" data-end="1489.669">[Applause].</span> <span data-start="1489.669" data-end="1490.669">[Music].</span> <span data-start="1490.669" data-end="1491.669"Audience member: Hello, everyone, as you're going for the break for the wonderful coffee, remember that</span> <span data-start="1491.669" data-end="1492.669">we have a community track.</span> </p>
<p><span data-start="1492.669" data-end="1493.669">There will be a lightning talk from a couple of local meet-ups, including Up Front, and</span> <span data-start="1493.669" data-end="1494.669">a few user groups.</span> <span data-start="1494.669" data-end="1495.669">If you're curious how we organise events in Berlin, go and check out the community lounge.</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
