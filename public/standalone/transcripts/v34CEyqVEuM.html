<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>v34CEyqVEuM</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/v34CEyqVEuM?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="20.92" data-end="23.88">Thanks for the charmful introduction.</span> <span data-start="23.88" data-end="29.65">Well yeah, my talk is called JavaScript level 9000, because I had no idea how to name the</span> <span data-start="29.65" data-end="34.91">talk otherwise and yeah, let's get started.</span> <span data-start="34.91" data-end="40.98">So, as he said, I was previously working for Zynga doing the benchmarking stuff there and</span> <span data-start="40.98" data-end="51.19">putting out products like the Zynga jukebox, but — after that — I founded by own project</span> <span data-start="51.19" data-end="56.36">called lycheeJS, which is something like a JavaScript engine, but it's a bit more of</span> <span data-start="56.36" data-end="61.82">a game engine. And there's SkyN4T, which is an artificial intelligence that is clustered</span> <span data-start="61.82" data-end="67.57">and stuff like that, it's something like a hobby for me, and, I was previously also fixing</span> <span data-start="67.57" data-end="76.909">some Linux stuff, so I was also implementing fixes for the radeon driver or fixing or supporting</span> <span data-start="76.909" data-end="80.01">the HD cards back then.</span> </p>
<p><span data-start="80.01" data-end="89.61">I got into V8 because I thought back then it's hard to push out a game onto different</span> <span data-start="89.61" data-end="95.52">other platforms if they're not supporting HTML5, so basically I started to realize it</span> <span data-start="95.52" data-end="103.969">would be much more awesome when I could just use OpenGL there or use freeGLUT for it. Then</span> <span data-start="103.969" data-end="109.38">I put out a prototype for V8GL, which was basically V8 combined with OpenGL bindings</span> <span data-start="109.38" data-end="113.99">and I was using it to cross-compile it to other platforms like Android or IOS (with</span> <span data-start="113.99" data-end="121.509">the Node.app stuff). The advantage is that you can even cross compile it to Xbox 360</span> <span data-start="121.509" data-end="124.39">or PS 4.</span> </p>
<p><span data-start="124.39" data-end="129.69">Basically I'm currently focusing on SDL stuff, so my new runtime is based on NodeJS and using</span> <span data-start="129.69" data-end="134.81">SDL there, because that's much easier when it comes to networking stuff.</span> <span data-start="134.81" data-end="144.96">So, this talk will be starting low and trying to give you an idea how the data types inside</span> <span data-start="144.96" data-end="152.06">a VM are implemented and is focusing on a garbage collection concepts or what the problems</span> <span data-start="152.06" data-end="157.75">in JavaScript are compared to other block scoped languages for example.</span> <span data-start="157.75" data-end="161.319">It's trying to increase the level straight and linearly.</span> <span data-start="161.319" data-end="165.67">First, Data types.</span> <span data-start="165.67" data-end="171.59">Primitives are the basic understandings of data types and in JavaScript it's a bit complicated</span> <span data-start="171.59" data-end="177.989">because Primitives are also Objects, but they're not.</span> <span data-start="177.989" data-end="182.83">So in these examples the Primitives are like Numbers, Boolean, null and . They're</span> <span data-start="182.83" data-end="189.68">Primitives and defined as Primitives. Strings and Regular Expressions are not, because they</span> <span data-start="189.68" data-end="193.87">have a length property (and other properties), so they are real Objects, but they're handled</span> <span data-start="193.87" data-end="200.81">as Primitives. I will explain that later.</span> </p>
<p><span data-start="200.81" data-end="206.17">The Strings are primarily handled in the Runtime memory, which means they are deallocated after</span> <span data-start="206.17" data-end="213.59">the call stack is finished or after the scope was destructed, and there's so‑called Hidden</span> <span data-start="213.59" data-end="218.72">Classes idea behind the implementations. They use Hidden Classes to implement everything</span> <span data-start="218.72" data-end="222.739">for you, and the Hidden Classes are something like the abstraction that you need for your</span> <span data-start="222.739" data-end="225">memory allocation stuff.</span> <span data-start="225" data-end="230.42">Aldo, unique static Strings (if you write down the same String over your code multiple</span> <span data-start="230.42" data-end="238.159">times) are only linked as a String Symbol inside the JIT VM.</span> <span data-start="238.159" data-end="246.709">Primitives, if you use the native constructor, like calling "new Number()", then you create</span> <span data-start="246.709" data-end="252">an Object instance, and the Object instance is handled differently than the literals of</span> <span data-start="252" data-end="253.489">the Number itself.</span> <span data-start="253.489" data-end="261">If you type like the y variable here (y = 123), it is handled differently handled in the VM.</span> </p>
<p><span data-start="261" data-end="267.61">It is then no instance of Object if you use the "instanceof" operator.</span> <span data-start="267.61" data-end="275.85">Arrays and Objects are basically all Object instances, even the literals ("[], \"). For</span> <span data-start="275.85" data-end="281.16">example, Arrays are an instance of Array but they're also an instance of Object. Objects</span> <span data-start="281.16" data-end="287.39">themselves are always instances of Object because the literals are defined that way.</span> <span data-start="287.39" data-end="295.1">The difference here is that the Primitives are not reference-able after the scope and</span> <span data-start="295.1" data-end="300.44">the Objects are reference-able after the scope was closed or after the Function scope was</span> <span data-start="300.44" data-end="302.95">closed and destructed.</span> <span data-start="302.95" data-end="310.15">That's basically the idea of the Garbage Collector in JavaScript.</span> <span data-start="310.15" data-end="317.56">The hard topics is the dynamic typing stuff because previously, before the WebGL Standard</span> <span data-start="317.56" data-end="323.88">you had no possibility to use something like typed Arrays.</span> <span data-start="323.88" data-end="329.85">The idea behind the JIT VM was that they wanted to optimize everything as far as possible,</span> <span data-start="329.85" data-end="336.06">so, in this example, both examples have like the same values and the Array has the same</span> <span data-start="336.06" data-end="340.25">content afterwards but they're optimized in a completely different way.</span> <span data-start="340.25" data-end="345.701">The Foo example here is optimized at compile time because the JIT knows "Oh, the array</span> <span data-start="345.701" data-end="350.66">has this length and it's closed afterwards so it's finished at this stage".</span> </p>
<p><span data-start="350.66" data-end="361.1">The Bar example is allocating everything dynamically, so, at first (the 13 and 37 values) will just</span> <span data-start="361.1" data-end="365.12">allocate everything. After that, if you change the type (0.5 value), it will convert everything</span> <span data-start="365.12" data-end="369.68">to doubles. That's the so‑called Unboxing, it then has to be unboxed, converted, and</span> <span data-start="369.68" data-end="372.53">boxed again.</span> <span data-start="372.53" data-end="377.25">Everything will be converted to Doubles, that means the precision of 13 and 37 would be</span> <span data-start="377.25" data-end="384.63">something like dot 0 (13.0 and 37.0) and then it's still handled as an (un/signed) Integer.</span> <span data-start="384.63" data-end="388.53">If you allocate something differently from the existing values like "true" — which is</span> <span data-start="388.53" data-end="396.38">an Object — then it will convert everything to Objects or to references. I will explain</span> <span data-start="396.38" data-end="399.19">later how that is solved.</span> <span data-start="399.19" data-end="403.94">That's basically the difference about the Objects and Array stuff in JavaScript.</span> <span data-start="403.94" data-end="412.23">What is also important is that Objects have unique identifiers, even if they have the</span> <span data-start="412.23" data-end="419.61">identical contents. So you can use the deep equals comparison ("===") and they will always</span> <span data-start="419.61" data-end="424.64">be different because of the identifier.</span> </p>
<p><span data-start="424.64" data-end="428.33">But they share the same Hidden Class behind them, these examples (foo and bar) are identically</span> <span data-start="428.33" data-end="433.86">typed and have identical properties and the Hidden Classes algorithm inside the VM will</span> <span data-start="433.86" data-end="439.66">use the same Hiddel Class in that case.</span> <span data-start="439.66" data-end="448.69">Hidden Classes are basically based on the data types or the values of those; and the</span> <span data-start="448.69" data-end="454.33">order of the values or the properties. So, for example, in this case, the Foo and Bar</span> <span data-start="454.33" data-end="459.44">example is identical. The Qux example is identical when it comes to the values but the properties</span> <span data-start="459.44" data-end="467.681">are ordered in a different way. If the properties are annotated or assigned to the object in</span> <span data-start="467.681" data-end="472.18">a different order, it will create automatically a new Hidden Class.</span> <span data-start="472.18" data-end="476.64">So that is bad, don't do that!</span> <span data-start="476.64" data-end="480.89">Hidden Classes are also an abstraction for Functions, because function templates are</span> <span data-start="480.89" data-end="487.96">basically (if they are constructed) creating Object instances. In that case, Foo and Bar</span> <span data-start="487.96" data-end="494.341">have, when they're assigned, the same hidden class of Point, but it will create a new Hidden</span> <span data-start="494.341" data-end="501.03">Class for the bar example because you're assigning it a property externally to it. So the JIT</span> <span data-start="501.03" data-end="504.83">is recognizing it: "Oh, that's a completely different thing and I have to create a new</span> <span data-start="504.83" data-end="513.51">hidden class for it". So bar is a fork of foo then.</span> <span data-start="513.51" data-end="518.69">When you want to implement custom Primitives in JavaScript, there's the concept behind</span> <span data-start="518.69" data-end="527.69">the valueOf() method and the toString() method. If the valueOf() method is called on binary</span> <span data-start="527.69" data-end="537.81">operators (e.g. an addition), it will try to find out its arithmetic value. If the valueOf()</span> <span data-start="537.81" data-end="545.06">method returns null, the data type has no arithmetic value at all. It will be just 0,</span> <span data-start="545.06" data-end="549.009">that is the reason why when you add the Foo and Bar examples together, it would be 0.</span> </p>
<p><span data-start="549.009" data-end="556.83">If you add another number to it (e.g. foo + 123) then it'll be the number value of 123</span> <span data-start="556.83" data-end="563.11">plus 0 — which is — of course, 123.</span> <span data-start="563.11" data-end="571.22">valueOf() is used for the arithmetic value and if you return a Number value instead of</span> <span data-start="571.22" data-end="579.579">null — so it has\hnumeric value — you can add it to other Strings or Numbers and it</span> <span data-start="579.579" data-end="583.089">will automatically convert the data type dependent on the other variable's data type.</span> <span data-start="583.089" data-end="589.55">That is the same problem with NaN (Not-a-Number), if you add a Number to a String it will give</span> <span data-start="589.55" data-end="596.82">you a different result because it will be the other way around before the conversion.</span> <span data-start="596.82" data-end="602.009">In that case, it's just like if you want to add a String to it — then you have, of course,</span> <span data-start="602.009" data-end="606.2">String conversion from the Number, so the Numbers and the values will be identical except</span> <span data-start="606.2" data-end="609.05">the types.</span> <span data-start="609.05" data-end="615.47">After the valueof() method is called the VM will try to determine (if there's no arithmetic</span> <span data-start="615.47" data-end="620.7">value) if it's a String or if it can be converted to a String.</span> <span data-start="620.7" data-end="624.11">That's reason why you see something like "[object Object]" all the time when you try the dump</span> <span data-start="624.11" data-end="635.649">it into the console or something like that. When you are returning an Object instance</span> <span data-start="635.649" data-end="639.73">in the valueOf() method, it means that the data type is a high level Object and not a</span> </p>
<p><span data-start="639.73" data-end="645.98">Primitive anymore. That means the toString() method is called and if you add those two</span> <span data-start="645.98" data-end="652.23">examples together or do binary additions on them, you will get different results, because</span> <span data-start="652.23" data-end="656.81">the VM is just converting everything to a String then.</span> <span data-start="656.81" data-end="661.509">And, yeah. That's basically how it works.</span> <span data-start="661.509" data-end="667.75">Now I have to dig into the Function stuff and what Function Templates, Function Instances</span> <span data-start="667.75" data-end="671.629">and Prototypes are.</span> <span data-start="671.629" data-end="676.569">Functions in JavaScript, of course, have a Prototype. The Prototype means there's something</span> <span data-start="676.569" data-end="680.209">like a Smart Pointer to the Memory.</span> <span data-start="680.209" data-end="684.81">If you have an example like this and are constructing a "new Vector()" there, then the "instanceof</span> <span data-start="684.81" data-end="694.519">Vector" will, of course, be true. But the prototype lookup (.__proto__ which is a non-standard</span> <span data-start="694.519" data-end="702.49">behaviour for looking up the Prototype Hierarchy upwards) will point to Vector. Then (.__proto__.__proto__)</span> <span data-start="702.49" data-end="707.939">it will point to Object, because everything is an Object instance. Of course, it's not</span> <span data-start="707.939" data-end="717.05">an instance of Function. The __proto__.__proto__.__proto lookup will be null, then the prototype chain</span> <span data-start="717.05" data-end="723.6">is over and the JIT knows there's no inheritance level upwards.</span> </p>
<p><span data-start="723.6" data-end="726.939">That's basically how Prototyping works. So, if you have something like a new instance</span> <span data-start="726.939" data-end="733.93">from a Function, then, the direct __proto__ lookup will point to the Function.prototype,</span> <span data-start="733.93" data-end="743.66">and that will point to the Object.prototype and so on.</span> <span data-start="743.66" data-end="749.55">If you want to implement something like Entities (because I'm a game developer, I want to use</span> <span data-start="749.55" data-end="754.671">vectors and stuff like that), I'm implementing a basic Entity and I want to reuse the Vector</span> <span data-start="754.671" data-end="759.56">methods there. In this case there's a problem: You need instances on the prototype in order</span> <span data-start="759.56" data-end="767.089">to have it fully integrated with the JavaScript VM. If I'm just pointing the Entity.prototype</span> <span data-start="767.089" data-end="774.24">to the Vector.prototype, I have the same methods, but I don't have an instance of a Vector,</span> <span data-start="774.24" data-end="780.379">because the getPrototypeOf() method called on the Entity instance itself will not point</span> <span data-start="780.379" data-end="783.94">to the Vector itself, it will point to the Vector.prototype.</span> </p>
<p><span data-start="783.94" data-end="792.1">So, yeah, that's basically how the "instanceof" operator works.</span> <span data-start="792.1" data-end="799.449">When you create a new Vector() instance, like in this example, this is the way. When the</span> <span data-start="799.449" data-end="805.24">prototype of instances or the prototype of Function template is pointing to a new instance,</span> <span data-start="805.24" data-end="812.019">you get the correct behaviour with the "instanceof" operator.</span> <span data-start="812.019" data-end="817.579">So yeah, that's basically how Function Templates are implemented in a VM. I hope it was easy</span> <span data-start="817.579" data-end="819.43">to follow.</span> <span data-start="819.43" data-end="824.36">When it comes to Hoisting and Closures stuff, it's pretty important to understand hosting</span> <span data-start="824.36" data-end="832.16">and closures are not easy to backtrace when it comes to memory optimizations. Let's get</span> <span data-start="832.16" data-end="835.55">started with that topic.</span> <span data-start="835.55" data-end="845.529">(..) So, the explanation of hoisting is like: When you have a variable inside the own Function</span> <span data-start="845.529" data-end="851.089">Scope, but it's not accessible or bound inside this scope, it (the VM) will go upwards and</span> <span data-start="851.089" data-end="855.73">try to use the next Function Scope on the outer side (upwards) for that variable.</span> <span data-start="855.73" data-end="863.869">In that example I'm binding foo and bar, but with different names. So it's the other way</span> <span data-start="863.869" data-end="867.839">around when I'm calling the outer Function. I'm using the "bar" parameter inside the outer</span> <span data-start="867.839" data-end="873.04">Function as "foo" (so bar is inside it really foo) and the "qux" parameter as "bar" (so</span> <span data-start="873.04" data-end="878.7">qux is inside it really bar). That outer Function is a closure, but if I'm reassigning the foo</span> <span data-start="878.7" data-end="884.97">variable, I'm not reassigning the "bar" in the outer scope. It will just delete the reference</span> <span data-start="884.97" data-end="890.829">of the Global Scope's foo. It behaves like that because it's not referencing to the original</span> <span data-start="890.829" data-end="898.11">foo, it's always referencing to the "state" of foo when the method was called. That also</span> <span data-start="898.11" data-end="902.829">means that "foo === bar" will be false afterwards.</span> <span data-start="902.829" data-end="907.269">(Next Topic) Closures</span> </p>
<p><span data-start="907.269" data-end="915.98">A typical problem is when you are iterating over an Array with Objects and you do an asynchronous</span> <span data-start="915.98" data-end="921.49">loader (like loading an Image with an onload() method that is called afterwards) and you</span> <span data-start="921.49" data-end="927.16">want to use the "a" iterator variable (of the example), it will always have the last</span> <span data-start="927.16" data-end="935.399">value of the loop. It's like that because probably the Asset will be loaded slower than</span> <span data-start="935.399" data-end="936.399">the iteration.</span> <span data-start="936.399" data-end="940.559">That's a typical problem in JavaScript, a fix for that is just using a Closure to hold</span> <span data-start="940.559" data-end="943.939">every variable of the loop, so they have the same state as they had when you wanted it</span> <span data-start="943.939" data-end="953.369">to be and you can just reuse the property (or the variable) at that state.</span> </p>
<p><span data-start="953.369" data-end="957.869">That's basically how Closure work. There's always a Function that binds the variables</span> <span data-start="957.869" data-end="966.74">to their own Sub Scope or their own Handle Scope in which they are binding a variable</span> <span data-start="966.74" data-end="972.129">or a property inside their own Scope when they would be free otherwise (after their</span> <span data-start="972.129" data-end="973.129">destruction).</span> <span data-start="973.129" data-end="977.22">So.. that leads us to the following problem.</span> <span data-start="977.22" data-end="985.019">We need something like a Garbage Collector because we have instances of Objects, we want</span> <span data-start="985.019" data-end="988.369">to delete them afterwards — because otherwise our Memory will be totally bloated.</span> <span data-start="988.369" data-end="994.389">The basic knowledge about Memory Management or Garbage Collectors are that we have the</span> </p>
<p><span data-start="994.389" data-end="996.11">Runtime Memory and Heap Memory.</span> <span data-start="996.11" data-end="1000.139">The Runtime Memory consists of Primitives. They're cleared directly after your Scope</span> <span data-start="1000.139" data-end="1005.179">has ended. If your Scope is being called and after that the Scope is destructed, then all</span> <span data-start="1005.179" data-end="1009.339">the allocated Runtime Memory will be just deallocated. How that works is not important.</span> <span data-start="1009.339" data-end="1015.55">It's just important that it's deleted afterwards and that it can't be reused afterwards. Regular</span> <span data-start="1015.55" data-end="1019.369">Expressions and Strings are somehow exceptions, because they have a length property (and behave</span> <span data-start="1019.369" data-end="1023.679">like Object instances), but they're still treated as Runtime allocations inside the</span> <span data-start="1023.679" data-end="1027.12">VM. They are basically Primitives while they're not.</span> <span data-start="1027.12" data-end="1036.11">The Heap Memory is something like the memory that is available afterwards, but you're not</span> <span data-start="1036.11" data-end="1043.17">able to use it if you're not referencing it. It contains Function instances, Object instances,</span> </p>
<p><span data-start="1043.17" data-end="1050.88">Array instances, and that's basically what is inside the Heap Memory. If the references</span> <span data-start="1050.88" data-end="1056.58">that you use are not needed anymore and can be unreferenced, they are cleared up by the</span> <span data-start="1056.58" data-end="1061.25">Garbage Collector.</span> <span data-start="1061.25" data-end="1065.54">You're creating Garbage every time you have something overwriting the original reference</span> <span data-start="1065.54" data-end="1071.5">with a new Object. An example is when I assing an Object to foo</span> <span data-start="1071.5" data-end="1077.97">and assigning a new Object to it afterwards (var foo = \; foo = \).</span> </p>
<p><span data-start="1077.97" data-end="1083.65">That means unreferenced Object instances always create Garbage and unreferenced variables</span> <span data-start="1083.65" data-end="1088.47">or named properties or arguments inside the current Scope will trigger the Garbage Collector.</span> <span data-start="1088.47" data-end="1094.84">So the GC knows "Oh, I have to clean something up". After the Scope was destructed, the Garbage</span> <span data-start="1094.84" data-end="1101.22">Collector checks if the references are still there or if they need to be cleared up.</span> <span data-start="1101.22" data-end="1108">You can do hints for Garbage Collector, a cheap trick is to set everything to "null",</span> <span data-start="1108" data-end="1113.17">it's non-referenceble and a Primitive. If you would set it to "0" as well, that would</span> <span data-start="1113.17" data-end="1121.41">be a Number and optimization stuff is a bit weird here. Just remember: if you have a variable</span> <span data-start="1121.41" data-end="1127.71">foo and you have an Object instance allocated to it, you can dereference it by setting it</span> <span data-start="1127.71" data-end="1133.39">to null and then you can assign the new Object instance to it afterwards. The Garbage Collector</span> <span data-start="1133.39" data-end="1139.53">and JavaScript Code Optimizer will know that "This is the state where we can clear up everything,</span> <span data-start="1139.53" data-end="1147.34">afterwards it's a plain Object" and it can resort everything (the optimized code branches).</span> <span data-start="1147.34" data-end="1155.46">That leads us to the Garbage Collection implementation itself or How It Works inside VMs. I'm mostly</span> <span data-start="1155.46" data-end="1159.33">referencing here to the Java stuff because it was one of the first languages to implement</span> <span data-start="1159.33" data-end="1169.96">a Garbage Collector, but most methods are used in V8 or the Monkey variants of Mozilla.</span> </p>
<p><span data-start="1169.96" data-end="1170.96">When it comes to Terminology:</span> <span data-start="1170.96" data-end="1177.89">A Garbage is an Object in your program that your program cannot reference anymore, so</span> <span data-start="1177.89" data-end="1180.25">it's not usable at all.</span> <span data-start="1180.25" data-end="1189">A so‑called Root Node is inside graph and any direct reference your program can access,</span> <span data-start="1189" data-end="1194.84">that means for example local variables on a stack or static class variables, like the</span> <span data-start="1194.84" data-end="1200.56">length property on an Array or something like that.</span> <span data-start="1200.56" data-end="1206.33">Object instances are Live if they're not Garbage, that's basically the opposite.</span> <span data-start="1206.33" data-end="1212.01">Live Objects (or Live Object instances) are referenced by a Root or referenced by another</span> <span data-start="1212.01" data-end="1218.93">Object instance that is inside the Root.</span> <span data-start="1218.93" data-end="1227.29">You can detect Garbage by basically (..) If you have a Graph where all the Nodes are referencing</span> <span data-start="1227.29" data-end="1234.52">each other, then you have to different ways to determine if they're still referencing.</span> <span data-start="1234.52" data-end="1240.9">One of the algorithms is a Depth-First, the other a Breadth-First search. Both of them</span> <span data-start="1240.9" data-end="1251.94">will lead to the same result. The Depth-First search algorithm will go to each SubNode first</span> <span data-start="1251.94" data-end="1257.06">and then try to determine where's a back-reference. The Breadth-First search algorithm will go</span> <span data-start="1257.06" data-end="1261.85">down the tree and look for references of the Neighbors of each Node. They are both used</span> <span data-start="1261.85" data-end="1267.21">because you have two-dimensional linking Objects (in the tree structure).</span> </p>
<p><span data-start="1267.21" data-end="1273.78">Local Variables are something like named Pointer that is pointing to somehow anywhere inside</span> <span data-start="1273.78" data-end="1275.78">the black hole to a memory address.</span> <span data-start="1275.78" data-end="1281.87">JavaScript has basically only pointers you can use, so everything inside your high level</span> <span data-start="1281.87" data-end="1288.11">language is only a pointer or a number if it's optimized or basically the Primitives</span> <span data-start="1288.11" data-end="1294.84">and the Hidden Classes are the so‑called abstractions for that.</span> <span data-start="1294.84" data-end="1302.28">One method for detecting Garbage is the Mark and Sweep algorithm. It has two different</span> <span data-start="1302.28" data-end="1303.28">phases.</span> </p>
<p><span data-start="1303.28" data-end="1311.63">The first is the Mark Phase and the second is the Sweep Phase. To determine Garbage inside</span> <span data-start="1311.63" data-end="1318.6">the Graph, it walks along all Roots that it knows and tries to mark every Object that</span> <span data-start="1318.6" data-end="1321.85">is reference-able from each Root Node.</span> <span data-start="1321.85" data-end="1328.8">So your program will pause, it is completely stopped. Then the Mark Phase is running and</span> <span data-start="1328.8" data-end="1334.23">tries to determine all Objects that are reference-able. (Program Pause > Mark Phase > Program Resume)</span> <span data-start="1334.23" data-end="1337.71">Afterwards the Sweep Phase is going on.</span> <span data-start="1337.71" data-end="1345.3">The Sweep Phase is traversing all the marked Objects and deallocates them and does all</span> <span data-start="1345.3" data-end="1351.36">the Garbage Collection Stuff. So it marks everything and calls delete inside the low</span> <span data-start="1351.36" data-end="1360.97">level C++ code (etc.) and tries to free up the memory as far as possible.</span> <span data-start="1360.97" data-end="1368.791">In Garbage Collection languages you have also the problem with fragmentation. These two</span> <span data-start="1368.791" data-end="1373.51">examples are identical Hidden Classes and they have two different properties with the</span> <span data-start="1373.51" data-end="1377.901">same values and they are identical. Afterwards you're deleting one of the properties of one</span> <span data-start="1377.901" data-end="1385.94">of the instances. Then you cause Memory Fragmentation. Fragmentation means Memory is free at this</span> <span data-start="1385.94" data-end="1391.36">specific address inside the Memory and could be used otherwise.</span> </p>
<p><span data-start="1391.36" data-end="1397.61">So there's so‑called Compaction going on that is trying to re‑order all the Object</span> <span data-start="1397.61" data-end="1403.75">references that are implemented "high-level" and re-points them to new memory addresses.</span> <span data-start="1403.75" data-end="1406.78">(Oh, three minutes)</span> <span data-start="1406.78" data-end="1414.012">So, in this example, I'm having references to (..) I'm trying to explain the references</span> <span data-start="1414.012" data-end="1421.07">that are so-called Handles inside a JIT Compiler. It's basically in the VM something like a</span> <span data-start="1421.07" data-end="1425.6">Pointer to a Pointer. If you're using your bar your foo (in the example) inside your</span> <span data-start="1425.6" data-end="1430.61">code, then it'll be basically a pointer to another pointer. The reason to have it so</span> <span data-start="1430.61" data-end="1435.25">is that pointers can be allocated with a fixed size. They are a fixed sized Memory Array,</span> <span data-start="1435.25" data-end="1439.98">so it's easier to optimize them and you don't have to guess what kind of Memory Size it</span> <span data-start="1439.98" data-end="1442.214">will use later (after the compaction and resorting).</span> </p>
<p><span data-start="1442.214" data-end="1449.37">The Lifetime is determined by the Handle Scope. Those Handle Scope inside the Function context</span> <span data-start="1449.37" data-end="1454.59">are destructed afterwards if the Function call is over and they result in Garbage Collector</span> <span data-start="1454.59" data-end="1456.19">trying to clear up everything.</span> <span data-start="1456.19" data-end="1460.92">So, each time a Scope is closed, the Garbage Collector runs over it and tries to determine</span> <span data-start="1460.92" data-end="1465.46">the references there.</span> <span data-start="1465.46" data-end="1469.64">Another algorithm to Mark and Sweep is Copying Garbage Collection. It's something like a</span> <span data-start="1469.64" data-end="1476.85">basic concept where you have two different static sizes of Memory and you have the Pointers</span> <span data-start="1476.85" data-end="1484.31">referencing to somewhere in your code. If you are deleting a reference or creating a</span> <span data-start="1484.31" data-end="1488.403">reference, it's just copying it vice versa. So that means for the Memory A (in the example)</span> <span data-start="1488.403" data-end="1492.76">it just uses everything it finds and uses the first allocation in the other Memory.</span> <span data-start="1492.76" data-end="1496.87">Second time it runs it uses everything in the Memory B and it will go the same way over</span> <span data-start="1496.87" data-end="1498.98">and over again.</span> <span data-start="1498.98" data-end="1502.31">The advantage is that it's super fast and easy to implement because you have only like</span> <span data-start="1502.31" data-end="1507.44">ten lines of codes to implement it. But, it's of course, bad, because you have so much to</span> <span data-start="1507.44" data-end="1514.71">do and the amount of the references is getting bigger and bigger.</span> <span data-start="1514.71" data-end="1521.53">A Generational Garbage Collector, like in V8 (or I guess in Monkey variants, too) is</span> <span data-start="1521.53" data-end="1526.83">using both of those algorithms and try to have a Lifetime determination algorithm trying</span> <span data-start="1526.83" data-end="1533.9">to find out if your code can access other Objects on previous states in the timeline</span> <span data-start="1533.9" data-end="1536.02">and if they're still referenceble or not.</span> </p>
<p><span data-start="1536.02" data-end="1540.27">If they are not referenceable, that means they have a Younger age, because it's just</span> <span data-start="1540.27" data-end="1544.98">like one second old and it can be cleared afterwards. Older Objects are the ones that</span> <span data-start="1544.98" data-end="1550.35">can be accessed any time, if you have something like Objects on a Global Scope, you can guess</span> <span data-start="1550.35" data-end="1556.95">that they are\halso referenceble ten seconds afterwards. So that means Older Objects can</span> <span data-start="1556.95" data-end="1561.81">be used and optimized by the Mark and Sweep algorithm and Younger Objects are optimized</span> <span data-start="1561.81" data-end="1565.13">by the Copying Garbage Collector algorithm.</span> <span data-start="1565.13" data-end="1569.25">(*Yay* 30 seconds left)</span> <span data-start="1569.25" data-end="1574.04">That's the end, basically that was the introduction on how Garbage Collection works, I hope you</span> <span data-start="1574.04" data-end="1575.04">enjoyed it.</span> <span data-start="1575.04" data-end="1576.04">(Applause)</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
