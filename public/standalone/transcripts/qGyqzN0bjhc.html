<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>qGyqzN0bjhc</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/qGyqzN0bjhc?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="1.64" data-end="27.07">Thank you, I'm a software develop per at bark box in New York City where we develop apps</span> <span data-start="27.07" data-end="35.51">to keep dogs happy and healthy. This is a picture of my dog, SmallTalk and</span> <span data-start="35.51" data-end="43.32">me, this is a picture of a picture of me eating noodles, and this is a picture of SmallTalk</span> <span data-start="43.32" data-end="52.739">eating noodles, now that you know all about me, let's talk about type coercion in JavaScript</span> <span data-start="52.739" data-end="56.899">I've been programming predominantly with JavaScript for the past couple of years and I've gotten</span> <span data-start="56.899" data-end="63.82">pretty familiar with many of it's quirks, one of it's quirks being type coercion, I</span> <span data-start="63.82" data-end="69.32">hope to provide a better understanding how JavaScript converts between types and the</span> <span data-start="69.32" data-end="73.24">various situations in which it performs type coercion.</span> <span data-start="73.24" data-end="80.21">Butt let's back up, let's talk about type conversion in general. Wikipedia says that</span> <span data-start="80.21" data-end="87.149">type conversion, otherwise known as typecasting or type coercion, is implicitly or explicitly</span> <span data-start="87.149" data-end="93.43">changing an entity of one data type into another. So, what does that mean more simply? That's</span> <span data-start="93.43" data-end="100.88">taking a type for example an Int and converting it the another type, a string. So, how does</span> </p>
<p><span data-start="100.88" data-end="106.86">JavaScript handle type conversion? JavaScript is dynamically typed, as many of you know,</span> <span data-start="106.86" data-end="111.789">which means that variable types are determined during script execution at Runtime.</span> <span data-start="111.789" data-end="118.359">So, here, type conversion can happen in two ways. They can be explicitly specified by</span> <span data-start="118.359" data-end="124.14">the developer in the code, like for example, directly calling Parsint which converts a</span> <span data-start="124.14" data-end="134.26">string to an integer or to string or implicitly performed with type JavaScript. This type</span> <span data-start="134.26" data-end="139.09">of conversion is typically referred to as type coercion, and type coercion is what we're</span> <span data-start="139.09" data-end="145.709">focusing on today. So, why do I have to learn this? Honestly, it's very much built into</span> <span data-start="145.709" data-end="150.55">the language. It kind of comes with the territory of JavaScript being die familiarically type</span> <span data-start="150.55" data-end="151.55">language.</span> <span data-start="151.55" data-end="158.37">The example type coercion is happening even with something as simple as a basic "if" statement.</span> <span data-start="158.37" data-end="165.261">In this example here we know that if successful value.length will return an integer that would</span> <span data-start="165.261" data-end="171.05">be the length of the value. However, the if statement here is expecting a pool Leon condition</span> <span data-start="171.05" data-end="179.86">integer is not a Boolean. It converts it into a Boolean in order to evaluate this expression.</span> <span data-start="179.86" data-end="185.33">Type expression can also offer more flexibility and can be convenient at times like when you're</span> <span data-start="185.33" data-end="191.14">dealing with user input. And finally, get to know your language better, it's always</span> <span data-start="191.14" data-end="196.599">important to understand what's happening underneath the hood. So let's build some foundational</span> <span data-start="196.599" data-end="197.599">knowledge.</span> </p>
<p><span data-start="197.599" data-end="204.241">Let's talk about converting types. There are two categories of types in JavaScript, you</span> <span data-start="204.241" data-end="210.409">have the simple types, which are numbers, strings, Boolean, the values true and false</span> <span data-start="210.409" data-end="217.9">Nul will and  everything else is an October, arrays, functions, regular expressions</span> <span data-start="217.9" data-end="225.62">and of course objects. In the next three slides I'm going to try to define JavaScript typically</span> <span data-start="225.62" data-end="230.331">implicitly converts between different types and use this knowledge for the remainder of</span> <span data-start="230.331" data-end="237.329">the talk. So how does JavaScript convert from simple types to numbers, for strings there's</span> <span data-start="237.329" data-end="244.39">an attempt to parse the string to a number, otherwise it returns an NaN or not a number.</span> <span data-start="244.39" data-end="246.799">Boolean is converted to one, false is cob verdicted to positive zero. \h‑‑ converted</span> <span data-start="246.799" data-end="257.51">to positive zero. Nu is converted to positive zero and  is converted to not a number.</span> <span data-start="257.51" data-end="263.96">What about converting simple types to Boolean, numbers are converted to true unless the value</span> <span data-start="263.96" data-end="270.43">is positive zero, negative zero or not a number these are converted to false, and strings</span> <span data-start="270.43" data-end="275.44">converted to true unless the value is the empty string which is converted to false,</span> </p>
<p><span data-start="275.44" data-end="280.69">Nul and  are both converted to false.</span> <span data-start="280.69" data-end="285.69">And and finally what about objects, how are objects converted. When converting objects</span> <span data-start="285.69" data-end="291.13">to numbers and strineses JavaScript will try to convert the objects\h‑‑ by implicitly</span> <span data-start="291.13" data-end="297.65">calling value of on the object. Or if value of isn't defined or didn't return a primitive</span> <span data-start="297.65" data-end="304.19">type when called it will try to call two string on the object inside. Converting objects to</span> <span data-start="304.19" data-end="310.33">Booleans is a bit simpler, they're converted to true. So let's take these guidelines and</span> <span data-start="310.33" data-end="315.92">apply them to a few situations and let's start with conditional statements first.</span> <span data-start="315.92" data-end="321.92">But let's quickly just make sure we're all on the same page about truth and falsey values</span> <span data-start="321.92" data-end="332.24">in JTPA. Some examples of values that translate to true is 123, the string "smallTalk" the</span> <span data-start="332.24" data-end="338.86">Boolean true, and objects. Some examples of values that evaluate to false in JTPA are</span> <span data-start="338.86" data-end="348.1">the integer 0, not a number, the empty string, the Boolean fault, null and of course .</span> </p>
<p><span data-start="348.1" data-end="353.65">The conditional statements if for wile and do while aliening to valuablee valuable conditions,</span> <span data-start="353.65" data-end="361.41">if it does not return a Boolean openerands are implicitly converted to ball listens,</span> <span data-start="361.41" data-end="373.05">if example in this example Var equals document.get element by ID SmallTalk, it looks for an element</span> <span data-start="373.05" data-end="379.17">with a particular ID in a DOM. Wit return an object if it finds an element or it will</span> <span data-start="379.17" data-end="384.07">return null, if an object is returned the if statement will implicitly return it to</span> <span data-start="384.07" data-end="391.84">true, null will return if implicitly converted to false.</span> <span data-start="391.84" data-end="398.24">So switch statements are a bit special here, similar to an if statement the expected valuable</span> <span data-start="398.24" data-end="406.7">Boolean condition, unlike the if, when evaluating the switch cases statements no type coercion</span> <span data-start="406.7" data-end="414.66">is performed, so, in the previous if statement, values coerce to true or false depending on</span> <span data-start="414.66" data-end="423.18">whether or not get element by I D returns an object or not. Here value will not be coerce</span> <span data-start="423.18" data-end="429.74">true or false it will be treated as it's original type, because of that it will never satisfy</span> <span data-start="429.74" data-end="435.21">case statement true since neither object nor null are equal to the Boolean true and it</span> <span data-start="435.21" data-end="447.36">will instead enter the default case. Logical operators, which are of course, and, and or.</span> </p>
<p><span data-start="447.36" data-end="455.78">Let the conditional operators convert to Booleans depending on the context, unlike conditional</span> <span data-start="455.78" data-end="462.54">operators the operator is returned not the Boolean value. So incidentally this can be</span> <span data-start="462.54" data-end="469.8">great for setting default values. In this example, Var value is equal to zero or apple,</span> <span data-start="469.8" data-end="474.83">value is\h‑‑ sorry the or operator is looking from left to right for the first true</span> <span data-start="474.83" data-end="480.91">open aerator to undere return, it's converted to false, apple is converted to true and some</span> <span data-start="480.91" data-end="484.58">value is set to the string apple. T</span> <span data-start="484.58" data-end="490.7">omohiro Matsuyamacal operators, which are, of course, the addition and subtraction sign,</span> <span data-start="490.7" data-end="497.41">multiplication and division sign and of course the module operator. Opener ands are converted</span> <span data-start="497.41" data-end="504.99">to numbers, except for dates, which for some reason are converted to string, Var values</span> <span data-start="504.99" data-end="512.94">equal the true plus null plus 5, true is converted to one, null converted to zero and one + the</span> <span data-start="512.94" data-end="520.909">zero + five is six, value set to six: The interesting operator the take a look at here</span> <span data-start="520.909" data-end="526.64">is the addition sign. The addition sign is overload in the JavaScript, so that means</span> <span data-start="526.64" data-end="534.57">not only can it do addition between two numbers it can do string Concotenati no, when one</span> <span data-start="534.57" data-end="540.14">is a string and the other opener and isn't, the other opener and is converted to a string.</span> </p>
<p><span data-start="540.14" data-end="547.91">In this first clam example Var example is converted to the string maul talk + 2, the</span> <span data-start="547.91" data-end="556.05">value set to SmallTalk + 2 is converted to a string 2 and then Concatenated this is happening</span> <span data-start="556.05" data-end="563.43">left to run, 1 + 2 is add together because JavaScript isn't aware of the string that</span> <span data-start="563.43" data-end="577.27">follows, then 1 + 2 equal to 3 is Concatenated to 3 small talk. Relational operator time.</span> <span data-start="577.27" data-end="581.771">Those are greater than,less than, greater than equal to, or less than and equal to.</span> <span data-start="581.771" data-end="588.66">Similar to the mathematical operator, opener ands are converted to numberser here even</span> <span data-start="588.66" data-end="594.7">dates are converted to numbers an exception is strings are compared via lex graphical</span> <span data-start="594.7" data-end="602.75">string comparison. Compared sequentially, similar to how you oridance e words in a dictionary.</span> <span data-start="602.75" data-end="608.221">Keep in mind here any comparison involving not a number will evaluate to false. In this</span> <span data-start="608.221" data-end="615.05">example, Var values equal to false, less than the string 1, 2, 3, false is converted to</span> <span data-start="615.05" data-end="622.58">0, the string 1, 2, 3 is converted to 123, and value set to true. Because, of course,</span> <span data-start="622.58" data-end="634.94">0 is less than 123. Now for the more Meaty stuff, equality operator. Equality means in</span> <span data-start="634.94" data-end="642.65">JTPA\h‑‑ values are considered equal if they are identical Boolean values, true is</span> <span data-start="642.65" data-end="649.09">equal to true, note call to false, if they're identical strings, the string ABC is equal</span> <span data-start="649.09" data-end="656.92">to string ABC but not to say ABCD. There are also considered equal if they're numerically</span> <span data-start="656.92" data-end="664.93">equivalent numbers 1 is equal to is 1, positive 0 is equal to negative 0 in this case.</span> </p>
<p><span data-start="664.93" data-end="671.25">Values are considered equal if they're the same object. And, again, not-a-number is special</span> <span data-start="671.25" data-end="678">here, it's not equal to anything, including itself. And as you all probably know there</span> <span data-start="678" data-end="685.06">are two sets of equality open pert or in JavaScript\h‑‑ the double equal op perai to and triple. Dot</span> <span data-start="685.06" data-end="694.17">double equal operator\h‑‑ if it determines that the types are different. The double equals</span> <span data-start="694.17" data-end="700.44">operator follows what's known as the abstracts equality comparison algorithm, a series of</span> <span data-start="700.44" data-end="704.42">22 steps used to determine the quality.</span> <span data-start="704.42" data-end="708.25">When the expression meets one of the step conditions, JavaScript will return true or</span> <span data-start="708.25" data-end="714.47">false accordingly, otherwise if it reaches the end of the series, it will return false.</span> <span data-start="714.47" data-end="720.73">We'll get into a bit more detail about how type coercions are performed here, but first</span> <span data-start="720.73" data-end="730.42">let's walk through an example. So, Var value is equal to null greater than or equal to</span> <span data-start="730.42" data-end="736.75">zero. Using the knowledge that we obtained about relational operators this seems pretty</span> <span data-start="736.75" data-end="743.85">straightforward, the relational operator implicitly converts to numbers, so null will be converted</span> <span data-start="743.85" data-end="750.71">to zero, and, of course, steer row is greater than or equal to zero, so values set to true.</span> <span data-start="750.71" data-end="760.84">But let's look at another example, offed Var value is equal to null, bobble call zero.</span> <span data-start="760.84" data-end="767.11">This returns false. What the hell?! How does that make sense? Everything we've learned</span> <span data-start="767.11" data-end="774.03">so far implies that null will be converted to zero here. But in short null is treating</span> <span data-start="774.03" data-end="780.49">ad in a special way by a double equals operator, it only corresponds to . There is</span> <span data-start="780.49" data-end="785.91">only one of the many strange cases that involve the double equal operator. All due to and</span> <span data-start="785.91" data-end="790.34">can be explained by following the abstract equality algorithm.</span> </p>
<p><span data-start="790.34" data-end="799.59">So, the abstract quality algorithm is defined really quite clearly in the if\h‑‑ language</span> <span data-start="799.59" data-end="806.2">specification, I don't want to bore you with all 22 steps, by I did want to walk through</span> <span data-start="806.2" data-end="810.53">what happens after JavaScript has determined that the two types are different and attempts</span> <span data-start="810.53" data-end="822.7">to type course, which are incidentally steps 14‑22 in the algorithm. Null equals</span> <span data-start="822.7" data-end="829.59">and if one opener and is a string and the other opener and is a number the string will</span> <span data-start="829.59" data-end="835.27">be implicitly converted to a number. If one of the opener and s is a Boolean, the Boolean</span> <span data-start="835.27" data-end="841.48">will be implicitly converted to a number, if one of the operands the string or the number</span> <span data-start="841.48" data-end="851.051">and the other operand is an object, the object will implicitly convert to a primitive. So</span> <span data-start="851.051" data-end="855.73">the triple equals open aerator behaves similar to to the double equals open aerator except</span> <span data-start="855.73" data-end="862.41">no type coercion is done, it uses straight equality comparison algorithm, nearly identical</span> <span data-start="862.41" data-end="871.5">to the first thirteen steps comparison algorithm. But leaves out all the bits related type coercion,</span> <span data-start="871.5" data-end="876.09">types must be the same initially in order to be considered equal. Otherwise the triple</span> <span data-start="876.09" data-end="878.94">equals operator returns false.</span> </p>
<p><span data-start="878.94" data-end="883.35">Since there are no unexpected type coercions being done, when using the triple equals operator\h‑‑</span> <span data-start="883.35" data-end="892.3">equals results and it can be mump safer. So the tool I cam across preparing for my talk</span> <span data-start="892.3" data-end="898.75">was this JavaScript equality table. A graphically displays the results of comparisons using</span> <span data-start="898.75" data-end="904.22">the double qualms and triple equals operator, so green means expression of evaluator to</span> <span data-start="904.22" data-end="918.8">true, white means expression evaluator false. Of so ininclusion\h‑‑ as amentioned earlier</span> <span data-start="918.8" data-end="923.54">it can be dangerous to use the double equal operator if you're not sure what you're doing,</span> <span data-start="923.54" data-end="928.16">try to perform explicit type conversion when you're able to do so, so that was from my</span> <span data-start="928.16" data-end="933.149">earlier slide, calls parse in or two string.</span> </p>
<p><span data-start="933.149" data-end="939.33">And use the JavaScript console and ECMA script language resources this was provide foundational</span> <span data-start="939.33" data-end="947.37">knowledge, but it's of course missing detail, the ECMA script language goes into this in</span> <span data-start="947.37" data-end="953.95">depth. It's not too terrible love a read, surprisingly. Thanks, guys, come chat with</span> <span data-start="953.95" data-end="956.4">me later if you'd like the discuss any of this or tell me about your dogs (Applause)</span> <span data-start="956.4" data-end="957.4">ask cool, so we're early, you guys get the jump on the lunch queue. So .. head on out,</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
