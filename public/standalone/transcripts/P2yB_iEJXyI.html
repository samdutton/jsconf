<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>P2yB_iEJXyI</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/P2yB_iEJXyI?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="9.56" data-end="10.78">So, hello, everybody.</span> <span data-start="10.78" data-end="15.34">My name is Adrien Trauth, I'm a frontend engineer.</span> <span data-start="15.349" data-end="19.939">Our topic today is how to build advanced search experiences with a custom query language.</span> <span data-start="19.939" data-end="22.82">First, I will focus on the use case.</span> <span data-start="22.82" data-end="28.83">I will explain what it is and the benefits of introducing one in the search interface.</span> <span data-start="28.83" data-end="33.82">And then how to implement it in the code of your advanced search.</span> <span data-start="33.82" data-end="40.12">And finally, the solution for your users to make sure they are aware and how to write</span> <span data-start="40.12" data-end="41.12">their own queries.</span> <span data-start="41.12" data-end="47.26">So, let's get a bit more into the use case and why is an advanced search necessary and</span> <span data-start="47.26" data-end="51.23">custom query language, improves the user experience?</span> <span data-start="51.23" data-end="57.96">And spending most of my day marking the lab management tool and doing lab management is</span> <span data-start="57.96" data-end="64.68">about allowing the user to search for millions of events and find the right one.</span> <span data-start="64.68" data-end="69.8">This is the search.</span> </p>
<p><span data-start="69.8" data-end="75.43">Since it's about traversing, you run a lot of searches before finding the information.</span> <span data-start="75.43" data-end="81.79">The search needs to be efficient because you're running a lot of things and using the tool</span> <span data-start="81.79" data-end="84.54">a very long time.</span> <span data-start="84.54" data-end="89.04">Also, because you need to find the right log that will explain what's happening inside</span> <span data-start="89.04" data-end="98.63">of your infrastructure, your search has to be precise or you will not find the needle</span> <span data-start="98.63" data-end="99.63">in the haystack.</span> </p>
<p><span data-start="99.63" data-end="109.02">They can be system logs to database event to system logs, the data is not known.</span> <span data-start="109.02" data-end="115.509">So, you have to make yourself flexible enough to search all kinds of different data.</span> <span data-start="115.509" data-end="117.479">And so, those are our requirements for the search.</span> <span data-start="117.479" data-end="119.659">They're not really specific to log management.</span> <span data-start="119.659" data-end="123.26">But this is what we will be working with today.</span> <span data-start="123.26" data-end="126.67">And the common search interfaces match those requirements.</span> <span data-start="126.67" data-end="132.55">So, basically word search, you find on a lot of websites.</span> <span data-start="132.55" data-end="136.44">It's nice because it's simple and you can get start in a few seconds.</span> <span data-start="136.44" data-end="137.44">It's really efficient.</span> <span data-start="137.44" data-end="143.49">You type a few keywords, and, in a few seconds, you already have your first results.</span> <span data-start="143.49" data-end="147.33">But the limitation with that search is precision.</span> <span data-start="147.33" data-end="151.83">Because, for example, here, if I'm on the phone, I'm looking for a blue chair, I have</span> <span data-start="151.83" data-end="158.66">no way to tell the system that I'm not looking for either something that's blue or a chair.</span> </p>
<p><span data-start="158.66" data-end="160.48">And I'm looking for a chair that's specifically blue.</span> <span data-start="160.48" data-end="164.4">So, you have no way to give the system what your intent is.</span> <span data-start="164.4" data-end="167.13">And to give the context about what you're searching for.</span> <span data-start="167.13" data-end="174.55">So, the way a lot of websites solve this is that the sorry they introduce an advanced</span> <span data-start="174.55" data-end="175.55">search pattern.</span> <span data-start="175.55" data-end="183.83">And when you click on that pattern, you will see a lot of different inputs and everything.</span> <span data-start="183.83" data-end="189.26">And what this gives to you is a lot more precision because every input has its own intent.</span> <span data-start="189.26" data-end="194.42">If I select the color blue, all the results are blue this time.</span> <span data-start="194.42" data-end="197.48">What you notice here with that pattern is efficiency.</span> <span data-start="197.48" data-end="203.29">You went from a search where you could type a few words and get results to a search where</span> <span data-start="203.29" data-end="208.67">you have to click around a lot and find out which inputs are relevant to you.</span> <span data-start="208.67" data-end="214.01">And also, it makes this a lot less readable because you have to look if you want to know</span> <span data-start="214.01" data-end="218.26">exactly what you're searching for, you have to look at every input and the value of every</span> <span data-start="218.26" data-end="219.93">input.</span> <span data-start="219.93" data-end="222.37">And finally, it's not that flexible.</span> </p>
<p><span data-start="222.37" data-end="228.71">The way you set up the inputs defines the ways that searchers search for something.</span> <span data-start="228.71" data-end="233.78">Here I put one price range, and if the searcher wants to search across two price ranges, they</span> <span data-start="233.78" data-end="236.31">cannot do that.</span> <span data-start="236.31" data-end="241.5">As a developer, I know another way to search for results.</span> <span data-start="241.5" data-end="244.2">That's query languages.</span> </p>
<p><span data-start="244.2" data-end="249.18">You send to, for example, a database or an API some text that's going to return your</span> <span data-start="249.18" data-end="251.2">results.</span> <span data-start="251.2" data-end="259.46">The first query that you usually learn about when you start, I don't know, when you're</span> <span data-start="259.46" data-end="262.4">a child, is natural language.</span> <span data-start="262.4" data-end="264.72">That's asking a question in English.</span> <span data-start="264.72" data-end="266">It's very flexible.</span> <span data-start="266" data-end="270.34">Because you can ask any question in English and it's always making sense.</span> <span data-start="270.34" data-end="272.91">That's your own language.</span> <span data-start="272.91" data-end="276.5">The issue with natural language is that it's not made for computers.</span> <span data-start="276.5" data-end="279.15">So, computers, they struggle with nuances.</span> <span data-start="279.15" data-end="285.15">And also, the range of questions you will be able to ask is a lot bigger than the question</span> <span data-start="285.15" data-end="288.18">you can answer on your website.</span> <span data-start="288.18" data-end="291.11">And so, if you have Google or Facebook money, it may be fine.</span> </p>
<p><span data-start="291.11" data-end="293">You may be able to solve that problem.</span> <span data-start="293" data-end="299.56">But for your own tool and website, it's probably a little bit overkill.</span> <span data-start="299.56" data-end="302.72">The second query language that I encountered was SQL.</span> <span data-start="302.72" data-end="305.65">So, that's a query language for databases.</span> <span data-start="305.65" data-end="310.62">It's very powerful because it allows you to query any kind of structure data.</span> <span data-start="310.62" data-end="312.8">Also, it has great support.</span> <span data-start="312.8" data-end="317.11">You have a lot of databases supporting it and if you want to implement it, you basically</span> <span data-start="317.11" data-end="319.83">send the search through the server to the database.</span> <span data-start="319.83" data-end="322.95">You have nothing more to do.</span> <span data-start="322.95" data-end="329.14">But this is for us, it's not really good for our use case because you have to know how</span> <span data-start="329.14" data-end="333.36">the data is stored to be able to query it, and that's not something we want our users</span> <span data-start="333.36" data-end="336.47">to care about.</span> </p>
<p><span data-start="336.47" data-end="338.69">And it's a bit too complex.</span> <span data-start="338.69" data-end="341.86">And it's not what we want there.</span> <span data-start="341.86" data-end="347.72">And so, one of the systems that tries to solve this is GraphQL.</span> <span data-start="347.72" data-end="351.5">Since it's an abstraction of a data storage, it's a bit better because you don't have to</span> <span data-start="351.5" data-end="355.42">care about how the data is stored.</span> </p>
<p><span data-start="355.42" data-end="359.31">And what's really nice also is that you can define easily what kind of output you want</span> <span data-start="359.31" data-end="360.37">for your data.</span> <span data-start="360.37" data-end="363.82">But it's still very much targeted to APIs.</span> <span data-start="363.82" data-end="368.83">So, for example, if you see that query here and you would it's really nice if you want</span> <span data-start="368.83" data-end="372.19">to send it over HTTP, or if you write it in your code.</span> <span data-start="372.19" data-end="376.94">But if you want a user to write that query, it's a bit long, it's a bit verbose.</span> <span data-start="376.94" data-end="379.65">So, that's not really what we want here.</span> <span data-start="379.65" data-end="386.15">So, since we've not been about to able to form anything that matches our requirements,</span> <span data-start="386.15" data-end="389.57">since I'm a developer, I made my own query language.</span> <span data-start="389.57" data-end="393.19">I found companies that did that.</span> <span data-start="393.19" data-end="400.25">There's GQL, allows you to search through your tasks and issues.</span> <span data-start="400.25" data-end="405.12">There are some tools, they have their own way to create data.</span> </p>
<p><span data-start="405.12" data-end="415.21">And data that is there is another team that made its own query language to the query data</span> <span data-start="415.21" data-end="416.65">visualizations.</span> <span data-start="416.65" data-end="419.45">And so, we are two different teams finding the same way to solve problems.</span> <span data-start="419.45" data-end="427.83">So, one of the benefits of having your own custom query language.</span> <span data-start="427.83" data-end="430.31">First, it's as high level as you want.</span> </p>
<p><span data-start="430.31" data-end="435.45">So, you are able to decide what you want your users to care about or not.</span> <span data-start="435.45" data-end="440.23">So, for example, if you want your user to be able to define the output format, like</span> <span data-start="440.23" data-end="442.79">in GraphQL, you can include that in your language.</span> <span data-start="442.79" data-end="448.68">But you want to make it a bit more simple, you just choose that and do your own thing.</span> <span data-start="448.68" data-end="450.66">It's also very specific to our use case.</span> <span data-start="450.66" data-end="455.74">So, you can make sure that every word that the user types is relevant to your demand</span> <span data-start="455.74" data-end="461.52">and express what the user is looking for and there's not technical getting in the way.</span> <span data-start="461.52" data-end="467.55">And finally, since it's high level and user specific, it's readable.</span> <span data-start="467.55" data-end="472.889">The only in the query are about the domain and not technical.</span> <span data-start="472.889" data-end="477.23">So, this seems to be a good solution for our use case here.</span> <span data-start="477.23" data-end="484.81">So, to be and it's probably not perfect, but we'll get into the limitations a bit later.</span> <span data-start="484.81" data-end="490.13">Now that I know that I want to make my own query language, I have to define it.</span> <span data-start="490.13" data-end="494.46">And so, a language definition is called a grammar.</span> <span data-start="494.46" data-end="500.73">And so, that's going to be the set of rules that define what valid search is and the meaning</span> <span data-start="500.73" data-end="504.27">of each word in my valid search.</span> </p>
<p><span data-start="504.27" data-end="508.949">Two things you should care about when writing your grammar is you have to make it flexible</span> <span data-start="508.949" data-end="513.18">for the user to write any kind of different queries.</span> <span data-start="513.18" data-end="518.3">And make sure your most important concepts, the first thing the user is going to look</span> <span data-start="518.3" data-end="525.32">for is the first thing they have to write so that they can benefit from your query language</span> <span data-start="525.32" data-end="526.36">very fast.</span> <span data-start="526.36" data-end="530.76">Let's give you a quick example to give you a better idea of what a grammar is.</span> <span data-start="530.76" data-end="533.67">So, that's my simplified English grammar.</span> <span data-start="533.67" data-end="537.87">Obviously, we're not going to get into all the rules of English now.</span> <span data-start="537.87" data-end="543.77">But if I were to define grammar for English, the first rule is a sentence is a set of words</span> <span data-start="543.77" data-end="545.98">separated by spaces.</span> <span data-start="545.98" data-end="553.87">And if I use that rule, I'm going to be allowed to say, well, I have three words in this sentence.</span> <span data-start="553.87" data-end="556.36">I like meatballs.</span> <span data-start="556.36" data-end="560.56">And then I can use a second rule which would say that the first word is the subject, the</span> <span data-start="560.56" data-end="565.73">second is the verb and the third is the object to say that, oh, I is my subject, like is</span> <span data-start="565.73" data-end="568.87">my verb and meatballs is the object.</span> <span data-start="568.87" data-end="574.86">By defining the rules, you can extract words and the context of the words and find the</span> <span data-start="574.86" data-end="577.37">meaning of the sentence.</span> </p>
<p><span data-start="577.37" data-end="584.7">And we know that we and we can apply that to my example, which is still here.</span> <span data-start="584.7" data-end="590.58">If I were to write a grammar for my search language, I would be able to define a set</span> <span data-start="590.58" data-end="601.63">of rules that say, for example, a search query for my furniture would be furniture, separated.</span> <span data-start="601.63" data-end="607.54">And there is the type of the furniture and then brackets and inside the brackets there's</span> <span data-start="607.54" data-end="611.6">a list of attributes I care about for this furniture.</span> <span data-start="611.6" data-end="614.98">By using that, I can say, hey, I'm looking for a chair and a couch.</span> </p>
<p><span data-start="614.98" data-end="617.17">And the chair is blue.</span> <span data-start="617.17" data-end="620.77">And the couch has the attribute, green.</span> <span data-start="620.77" data-end="626.08">And if I want to go even further, I can say, well, actually in my attributes, every attribute</span> <span data-start="626.08" data-end="631.44">that starts with a hashtag will be a color, and every attribute that ends with a currency</span> <span data-start="631.44" data-end="632.88">will be a price.</span> <span data-start="632.88" data-end="636.27">So, that's how you get into writing your own query.</span> <span data-start="636.27" data-end="643.99">And once you have defined all those rules, you can once you have defined your grammar</span> <span data-start="643.99" data-end="648.93">the next step is actually to implement it in the code of your search.</span> <span data-start="648.93" data-end="654.98">And so, that's making the computer understand the set queries.</span> <span data-start="654.98" data-end="662.529">So, the goal here is to get from a string it an object that will be easier for my code</span> <span data-start="662.529" data-end="669.47">and contain all the context that was extracted from the string.</span> </p>
<p><span data-start="669.47" data-end="673.63">And then once I have an object that's very simple, I can use it anywhere.</span> <span data-start="673.63" data-end="678.17">If I want to create databases, if I want to extract information for the user or anything</span> <span data-start="678.17" data-end="679.17">like that.</span> <span data-start="679.17" data-end="684.391">Once you have an object, you're pretty much on all the jobs.</span> <span data-start="684.391" data-end="689.99">So, to go from the string to the object is actually called parsing.</span> <span data-start="689.99" data-end="695.47">And so, parsing will say, well, actually, from that query I extract that one word is</span> <span data-start="695.47" data-end="696.76">"Chair."</span> <span data-start="696.76" data-end="703.29">And since I have grammar rules, chair is not a color, it's the first word.</span> <span data-start="703.29" data-end="705.03">It's not inside brackets.</span> <span data-start="705.03" data-end="706.77">It's the type.</span> <span data-start="706.77" data-end="710.36">That's what parsing is.</span> </p>
<p><span data-start="710.36" data-end="715.01">The first thing I think about when I want to extract information from the string is</span> <span data-start="715.01" data-end="718.66">to try to raise the regular expression.</span> <span data-start="718.66" data-end="725.68">Regular expressions are really efficient when you are extracting information from emails</span> <span data-start="725.68" data-end="726.68">or telephones.</span> <span data-start="726.68" data-end="732.5">So, when you know the number of things you want to extract from the query, it's really</span> <span data-start="732.5" data-end="733.5">good.</span> <span data-start="733.5" data-end="737.23">But when you don't know, your expression gets really complex.</span> <span data-start="737.23" data-end="742.73">And also, it's hard to extract the element you extracted.</span> <span data-start="742.73" data-end="745.25">It's easy to extract, for example, the chair.</span> </p>
<p><span data-start="745.25" data-end="751.95">But if I want to extract it's a furniture type, that's more complex.</span> <span data-start="751.95" data-end="759.87">And I found this really good code on StackOverflow that says if you write to regular expression,</span> <span data-start="759.87" data-end="766.24">you go with a cup of coffee, then you come back, and you have no idea what you just wrote.</span> <span data-start="766.24" data-end="769.17">Maybe a regular expression is not the tool for you.</span> <span data-start="769.17" data-end="776.1">So, I think that's explaining really why this is not good for our use case here.</span> <span data-start="776.1" data-end="783.04">So, the other way to extract from a string is to generate from the language.</span> <span data-start="783.04" data-end="789.17">From the grammar I just explain in English, I can actually generate a parser from that.</span> </p>
<p><span data-start="789.17" data-end="794.55">And the way to do that is to write the grammar in another grammar.</span> <span data-start="794.55" data-end="800.18">So, there is actually a way to write grammars and there are rules to write grammars.</span> <span data-start="800.18" data-end="806.13">And so, the one we'll be using today is the passing expression grammar.</span> <span data-start="806.13" data-end="811.92">I found it to be one of the most readable ones, PEG.</span> <span data-start="811.92" data-end="812.92">How does that work in practice?</span> <span data-start="812.92" data-end="813.92">It seems hard now.</span> <span data-start="813.92" data-end="818.95">That's a grammar rule.</span> <span data-start="818.95" data-end="825.839">A grammar rule is made of first the name of the rule and then your parsing expression.</span> <span data-start="825.839" data-end="832.05">So, your parsing expression will define the input you want to match.</span> <span data-start="832.05" data-end="835.57">And the output you want to return from that match.</span> <span data-start="835.57" data-end="840.68">And so, here for our type rule, I'm matching a range of characters repeating any number</span> <span data-start="840.68" data-end="842.2">of times.</span> <span data-start="842.2" data-end="847.61">And then I'm using that much results which you will be an array of characters which is</span> <span data-start="847.61" data-end="851.97">the full string of the furniture type.</span> </p>
<p><span data-start="851.97" data-end="854.029">It looks like a regular expression, right?</span> <span data-start="854.029" data-end="861.96">Yes, but what is really nice with this way of writing different rules is that it's really</span> <span data-start="861.96" data-end="863.05">easy to combine them.</span> <span data-start="863.05" data-end="867.5">So, here, for example, if I want to extract my simple character match, it's actually adjusting</span> <span data-start="867.5" data-end="874.18">the new rule and using that new rule in my furniture type rule.</span> <span data-start="874.18" data-end="879.61">And what I see is really good about this is that it's really easy to reuse some and in</span> <span data-start="879.61" data-end="880.77">the other ones.</span> <span data-start="880.77" data-end="884.5">And also, it makes your numbers definition a lot more readable.</span> <span data-start="884.5" data-end="891.22">Because here I can read that my furniture type would be a set of characters and I don't</span> <span data-start="891.22" data-end="895.26">have to care about one type of character or not.</span> <span data-start="895.26" data-end="896.61">That's different rule.</span> <span data-start="896.61" data-end="902.899">So, it allows you to write really complex rules in a very simple way.</span> </p>
<p><span data-start="902.899" data-end="906.9">So, another way to combine different rules is to put them in sequence.</span> <span data-start="906.9" data-end="914.18">So, here, if I have to define a price, I just need to define first what the number is.</span> <span data-start="914.18" data-end="915.49">And then what a currency is.</span> <span data-start="915.49" data-end="916.602">So, number will be an integer.</span> <span data-start="916.602" data-end="922.31">And pound, Euro, anything you would want to.</span> <span data-start="922.31" data-end="927.209">And from that sequence of characters, my parser will try to match both.</span> <span data-start="927.209" data-end="930.67">If only one of them matches, it's just going to fail.</span> <span data-start="930.67" data-end="936.91">And once I have matched both those rules, I'm going to be able to use both match results</span> <span data-start="936.91" data-end="939.579">which I call here amount and currency.</span> <span data-start="939.579" data-end="945.98">And I will be able to combine both those match results actually inside the brackets.</span> <span data-start="945.98" data-end="948">That's valid JavaScript.</span> <span data-start="948" data-end="956.1">And to define a new match result for price, which is really a combination of the two others.</span> <span data-start="956.1" data-end="962.12">And a final way you can combine didn't rules is to put them separated by slashes.</span> </p>
<p><span data-start="962.12" data-end="968.59">And then you will be what that will do is that this is this object from the options.</span> <span data-start="968.59" data-end="975.06">So, if I define an attribute as a price or a color, what the parser will do here is going</span> <span data-start="975.06" data-end="977.329">to be to try to match price.</span> <span data-start="977.329" data-end="981.89">And if that succeeds, I'm going to return the same match result as for the price.</span> <span data-start="981.89" data-end="986.95">If that fails, I'm going to go to the next one and match the color and et cetera and</span> <span data-start="986.95" data-end="987.95">et cetera.</span> <span data-start="987.95" data-end="994.86">And once you have that way of writing different rules and to combine them in didn't ways,</span> <span data-start="994.86" data-end="1000.089">I can actually start defining my full grammar for my furniture store.</span> <span data-start="1000.089" data-end="1008.45">And here so, I said in any grammar, as I explained in English, the furniture will be a type,</span> <span data-start="1008.45" data-end="1011.76">brackets and any number of attributes.</span> </p>
<p><span data-start="1011.76" data-end="1016.38">What I think is really amazing here is exactly what I'm reading in the code.</span> <span data-start="1016.38" data-end="1017.38">That's valid code.</span> <span data-start="1017.38" data-end="1022.99">I wrote the full query grammar to make sure it's something that makes sense.</span> <span data-start="1022.99" data-end="1028.189">And so, here if you read the first, it's defining what a furniture is.</span> <span data-start="1028.189" data-end="1033.149">And I'm defining it as a furniture type and then a list of attributes.</span> <span data-start="1033.149" data-end="1037.439">And if I want to see what a list of attributes is, I can just go to the last line and see,</span> <span data-start="1037.439" data-end="1043.539">well, a list of attributes is just one opening bracket, any number of attributes, and one</span> <span data-start="1043.539" data-end="1045.189">closing bracket.</span> <span data-start="1045.189" data-end="1051.58">And so, what I think what I love about this is that I can every rule is actually quite</span> <span data-start="1051.58" data-end="1052.64">simple.</span> <span data-start="1052.64" data-end="1057.929">And you can go from very simple rules to a full query language in a way that's really</span> <span data-start="1057.929" data-end="1059.009">testable.</span> <span data-start="1059.009" data-end="1062.6">Really easy to improve on, really easy to extend.</span> <span data-start="1062.6" data-end="1067.27">That's good that's really readable and really simple.</span> <span data-start="1067.27" data-end="1073.2">And once you've done that, once of your full query language or your rules defined, you</span> <span data-start="1073.2" data-end="1076.169">just have to run it.</span> </p>
<p><span data-start="1076.169" data-end="1080.889">And that's going to generate a parser that will that you will able to import in your</span> <span data-start="1080.889" data-end="1081.889">code.</span> <span data-start="1081.889" data-end="1086.009">So, I'm just running it through the command line.</span> <span data-start="1086.009" data-end="1093.399">you can use the results in Webpack loader if you want to make it automatic.</span> <span data-start="1093.399" data-end="1097.75">And now that I'm generating my parser, I'm just importing it.</span> </p>
<p><span data-start="1097.75" data-end="1101.82">Running my queries through it and I'm going to be able to have the exact object I was</span> <span data-start="1101.82" data-end="1103.83">looking for.</span> <span data-start="1103.83" data-end="1109.889">So, I'm able to parse my different queries.</span> <span data-start="1109.889" data-end="1112.029">I can just use that in my search.</span> <span data-start="1112.029" data-end="1115.539">Hopefully type chair, hashtag blue.</span> <span data-start="1115.539" data-end="1118.2">And I'm only going to have a blue chair.</span> <span data-start="1118.2" data-end="1125.799">I used to have my keyword search that would return either chair or things that were blue.</span> <span data-start="1125.799" data-end="1127.549">There was a blue table in the results.</span> <span data-start="1127.549" data-end="1130.96">Now the query language provides intent.</span> <span data-start="1130.96" data-end="1134.36">Now I can say that the color is applied to chair.</span> <span data-start="1134.36" data-end="1142.859">And blue is actually a color.</span> </p>
<p><span data-start="1142.859" data-end="1146.799">I can implement it in my sorry.</span> <span data-start="1146.799" data-end="1148.169">It's matching all my requirements.</span> <span data-start="1148.169" data-end="1151.279">So, I have the intent, so, that's precise.</span> <span data-start="1151.279" data-end="1156.44">It's also efficient because I just have to do a few key strokes to get the results.</span> <span data-start="1156.44" data-end="1159.429">And it's readable, I have the full search in my query.</span> <span data-start="1159.429" data-end="1160.69">And it's flexible.</span> <span data-start="1160.69" data-end="1163.289">I can have any number of attributes.</span> <span data-start="1163.289" data-end="1165.57">Any number of furnitures.</span> <span data-start="1165.57" data-end="1172.559">Flexible is actually up to you when you design your search language.</span> <span data-start="1172.559" data-end="1175.419">It's a balance to find.</span> <span data-start="1175.419" data-end="1178.58">So, did we solve the search problem forever?</span> <span data-start="1178.58" data-end="1180.39">Well, not really.</span> <span data-start="1180.39" data-end="1187.299">Because I think a custom query language comes with one big limitation, and that's user onboarding.</span> </p>
<p><span data-start="1187.299" data-end="1190.429">Because know that you have a language that is valid or not.</span> <span data-start="1190.429" data-end="1194.909">The first experience you can give to your user is that before they would type anything</span> <span data-start="1194.909" data-end="1197.98">and that would always work.</span> <span data-start="1197.98" data-end="1202.249">But now what they can do is the first search they type is not valid and you won't be able</span> <span data-start="1202.249" data-end="1204.399">to parse it and they won't get any results.</span> <span data-start="1204.399" data-end="1207.499">And that's really frustrating for your users.</span> <span data-start="1207.499" data-end="1212.57">So, you need to teach them two things before they are able to write their own queries.</span> <span data-start="1212.57" data-end="1213.999">And the first thing is the grammar.</span> <span data-start="1213.999" data-end="1215.74">What is a valid query?</span> </p>
<p><span data-start="1215.74" data-end="1217.889">And the possible attribute.</span> <span data-start="1217.889" data-end="1222.619">You want to tell them, you can search for a chair, a coat, anything you want.</span> <span data-start="1222.619" data-end="1227.129">You need to tell them what values they can put inside of the queries.</span> <span data-start="1227.129" data-end="1229.38">The first thing you need to do is add documentation.</span> <span data-start="1229.38" data-end="1230.38">That's really important.</span> <span data-start="1230.38" data-end="1231.749">You always need documentation.</span> </p>
<p><span data-start="1231.749" data-end="1235.019">And to give quick access to the documentation.</span> <span data-start="1235.019" data-end="1241.369">But that's not enough because to make them want to go to the documentation you need to</span> <span data-start="1241.369" data-end="1245.96">give them a few valid searches, so they know that, oh, that's really useful.</span> <span data-start="1245.96" data-end="1248.33">I want to learn more about that.</span> <span data-start="1248.33" data-end="1255.7">And so, one way that's worked for us is to have a playground, like an advanced search.</span> <span data-start="1255.7" data-end="1259.229">We are adding back some inputs.</span> </p>
<p><span data-start="1259.229" data-end="1263.559">But the difference is this time you are not using the inputs to make queries to the back</span> <span data-start="1263.559" data-end="1264.559">end.</span> <span data-start="1264.559" data-end="1268.669">You're using inputs to modify the search bar and make a valid search inside your search</span> <span data-start="1268.669" data-end="1269.669">bar.</span> <span data-start="1269.669" data-end="1274.169">So, let's see how that would look.</span> <span data-start="1274.169" data-end="1275.169">Yeah.</span> <span data-start="1275.169" data-end="1279.34">So, here I select chair, and adding chair to my queries and then blue.</span> </p>
<p><span data-start="1279.34" data-end="1284.379">And once you have a valid send, the user will be able to by himself to improve upon it and</span> <span data-start="1284.379" data-end="1288.389">start typing his own search queries.</span> <span data-start="1288.389" data-end="1290.39">Because it's stitching by example.</span> <span data-start="1290.39" data-end="1291.39">And that's really good.</span> <span data-start="1291.39" data-end="1295.82">You want to show him what it looks like and show him, oh, it's really simple.</span> <span data-start="1295.82" data-end="1297.69">I can do it myself now.</span> <span data-start="1297.69" data-end="1301.649">It's progressive because you start doing it, and when you feel ready, you can start modifying</span> <span data-start="1301.649" data-end="1303.13">your search.</span> <span data-start="1303.13" data-end="1310.509">And if you feel like you're even more ready, you can sorry you can write your own search</span> <span data-start="1310.509" data-end="1312.249">and hide their playground.</span> <span data-start="1312.249" data-end="1313.34">You cannot use it anymore.</span> <span data-start="1313.34" data-end="1315.419">And it adapts to the user.</span> <span data-start="1315.419" data-end="1318.57">Because if they want to learn more about it, they can type things.</span> </p>
<p><span data-start="1318.57" data-end="1322.889">But they never want to run it because they only come on the website once.</span> <span data-start="1322.889" data-end="1330.369">They can click the inputs and never care about the query language.</span> <span data-start="1330.369" data-end="1334.899">It's really not an advanced search because you don't need to use the chat box anymore.</span> <span data-start="1334.899" data-end="1335.899">You can use them or not.</span> <span data-start="1335.899" data-end="1340.58">You don't have to have all the attributes.</span> <span data-start="1340.58" data-end="1343.2">You can add them in the documentation.</span> <span data-start="1343.2" data-end="1348.22">And since the state is synchronized with the search bar, you don't need to read the state</span> <span data-start="1348.22" data-end="1353.639">of every selected patch, so it's still very readable.</span> <span data-start="1353.639" data-end="1360.129">And since I have a parser, it's easy to implement because I know how to extract information</span> <span data-start="1360.129" data-end="1364.139">from my query to select the field.</span> <span data-start="1364.139" data-end="1372.279">And I need to click to add the value to my query and to print it again.</span> <span data-start="1372.279" data-end="1374.929">And that's kind of easy to implement because think object is simple.</span> <span data-start="1374.929" data-end="1378.45">So, I just need to push a value inside the object.</span> <span data-start="1378.45" data-end="1379.51">And then to define a print function.</span> <span data-start="1379.51" data-end="1385.799">And the print function is actually it's great because all the context is in the object.</span> </p>
<p><span data-start="1385.799" data-end="1389.559">So, it's really easy to go from all the context back to a string.</span> <span data-start="1389.559" data-end="1394.889">So here, for example, I say furniture will be a furniture name and the print value of</span> <span data-start="1394.889" data-end="1396.61">all the attributes.</span> <span data-start="1396.61" data-end="1400.6">And for attributes, it seems in the attribute name it contains a lot of context too.</span> <span data-start="1400.6" data-end="1404.61">I can say, well, if it's a color, you print it as a hashtag and the attribute value.</span> <span data-start="1404.61" data-end="1410.809">We have a way to generate this, but if you're writing it by yourself, it's actually fairly</span> <span data-start="1410.809" data-end="1412.44">straightforward.</span> </p>
<p><span data-start="1412.44" data-end="1415.429">And a few things you can add is error reporting.</span> <span data-start="1415.429" data-end="1419.169">Telling the user, why is such queries not valid?</span> <span data-start="1419.169" data-end="1421.679">Syntax highlight if you want to have the information.</span> <span data-start="1421.679" data-end="1426.399">And autocomplete showing what values they can type.</span> <span data-start="1426.399" data-end="1430.059">Set of colors or chair when they start typing the query.</span> <span data-start="1430.059" data-end="1432.35">So, autocomplete is really efficient.</span> <span data-start="1432.35" data-end="1439.269">So, the benefits of having some query language is it's efficient, it's precise, it's readable</span> <span data-start="1439.269" data-end="1440.619">and it's flexible.</span> <span data-start="1440.619" data-end="1445.849">The drawback is that you are teaching your users and it becomes crucial and you have</span> <span data-start="1445.849" data-end="1449.649">to care about that a lot more than with a simple keyword search.</span> <span data-start="1449.649" data-end="1455.179">So, good use cases for custom query language would be a tool that's used repeatedly.</span> <span data-start="1455.179" data-end="1462.21">If you have a tool that's spent a lot of time on, being efficient becomes a lot more important.</span> <span data-start="1462.21" data-end="1463.95">Also, sharing.</span> <span data-start="1463.95" data-end="1468.519">Because it's always nicer to share a small search that's readable than a full object</span> <span data-start="1468.519" data-end="1469.929">when it's inexact.</span> <span data-start="1469.929" data-end="1475.21">And if you want to have integrations like APIs or integrate results, it's nice for the</span> <span data-start="1475.21" data-end="1480.509">developers to be able to type the query, copy and paste it in the HTTP request and that's</span> <span data-start="1480.509" data-end="1482.58">just going to work.</span> </p>
<p><span data-start="1482.58" data-end="1484.809">Thank you for listening.</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
