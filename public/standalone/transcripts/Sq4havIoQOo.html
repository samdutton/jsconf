<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Sq4havIoQOo</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/Sq4havIoQOo?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="21.05" data-end="22.69">Hello everybody.</span> <span data-start="22.69" data-end="24.09">Thank you for introduction.</span> <span data-start="24.09" data-end="27.89">This will be very interesting talk because I'm going to show you how to make</span> <span data-start="27.89" data-end="30.59">your JavaScript programmes faster.</span> <span data-start="30.59" data-end="32.689">But let me first introduce myself.</span> </p>
<p><span data-start="32.689" data-end="42.68">I am coming from academia, I'm a student at a university in Germany, and</span> <span data-start="42.68" data-end="49">they work in research group which main goal is to build</span> <span data-start="49" data-end="54.57">techniques to make it more secure, reliable and efficient,</span> <span data-start="54.57" data-end="60.19">and we're now focusing on JavaScript, but if you ask</span> <span data-start="60.19" data-end="64.67">me where do you use JavaScript, and why do you use JavaScript,</span> <span data-start="64.67" data-end="71.75">I will tell you we build JavaScript tools, and we found</span> <span data-start="71.75" data-end="78.071">JavaScript really interesting language, challenging, but</span> <span data-start="78.071" data-end="80.5">also very unusual.</span> <span data-start="80.5" data-end="87.27">So don't take this literally, but there are still many things in JavaScript</span> <span data-start="87.27" data-end="92.43">coded, you have to be improved.</span> <span data-start="92.43" data-end="96.27">This is my first time at the JSconf and I'm happy to</span> <span data-start="96.27" data-end="102.22">be here because I personally believe that whatever we do</span> <span data-start="102.22" data-end="105.41">on the research side should be also very beneficial for</span> <span data-start="105.41" data-end="107.72">the community.</span> <span data-start="107.72" data-end="109.58">And now let's start.</span> </p>
<p><span data-start="109.58" data-end="114.38">Who have a experienced JavaScripts programmes that</span> <span data-start="114.38" data-end="116.71">are like this?</span> <span data-start="116.71" data-end="121.16">Can you raise your hand?</span> <span data-start="121.16" data-end="126.39">In this talk I'm going to tell you how to make JavaScript programmes like</span> <span data-start="126.39" data-end="132.85">this, and believe me, it is not very difficult.</span> <span data-start="132.85" data-end="138.31">But let's first agree on importance of JavaScript performance.</span> <span data-start="138.31" data-end="143.66">And I would remind you that 90 per cent of almost</span> <span data-start="143.66" data-end="148.45">all websites nowadays are powered with some amount</span> <span data-start="148.45" data-end="152.82">of JavaScript, and having efficient and highly</span> <span data-start="152.82" data-end="156.7">optimised JavaScript is very important to keep your</span> <span data-start="156.7" data-end="159.67">web applications responsive.</span> <span data-start="159.67" data-end="165.98">But when we talk about mobile world, we also can see that many mobile applications</span> <span data-start="165.98" data-end="168.87">nowadays are written partially or entirely in</span> <span data-start="168.87" data-end="172.98">JavaScript, and we don't want mobile applications that</span> <span data-start="172.98" data-end="175.09">drain our battery.</span> </p>
<p><span data-start="175.09" data-end="180.69">So highly performing JavaScript is also crucial for energy efficiency.</span> <span data-start="180.69" data-end="186.97">I hope that I convince you why JavaScript performance is important.</span> <span data-start="186.97" data-end="192.14">But probably some of you would ask me why would we care about optimisation</span> <span data-start="192.14" data-end="194.84">of JavaScript, especially in the presence of</span> <span data-start="194.84" data-end="198.86">highly optimised JIT compilers and almost every browser</span> <span data-start="198.86" data-end="203.45">or platform that has JavaScript nowadays has</span> <span data-start="203.45" data-end="209.06">some sort of JIT compiler  —  even Internet Explorer, yes.</span> <span data-start="209.06" data-end="213.53">For example, Chrome, Opera, now Js, they employ</span> <span data-start="213.53" data-end="223.23">V8, Firefox has SpiderMonkey, Internet Explorer has chakra</span> <span data-start="223.23" data-end="226.65">and JIT compilers are known to be very powerful.</span> <span data-start="226.65" data-end="228.17">And that's true.</span> </p>
<p><span data-start="228.17" data-end="231.36">But I would remind you that optimisations are</span> <span data-start="231.36" data-end="232.49">limited.</span> <span data-start="232.49" data-end="237.59">When I say limited, I don't mean number of optimisations are limited, but I mean the</span> <span data-start="237.59" data-end="241.72">situations in which certain compiler optimisation can take</span> <span data-start="241.72" data-end="246.51">place because compilers, JIT compilers, optimise</span> <span data-start="246.51" data-end="249.93">JavaScript code in runtime, and they make certain assumptions</span> <span data-start="249.93" data-end="254.64">of JavaScript code, if they're not met in the</span> <span data-start="254.64" data-end="259.62">runtime, simply compilers refuse to optimise JavaScript</span> <span data-start="259.62" data-end="264.16">code, or they optimise previously optimised JavaScript</span> <span data-start="264.16" data-end="265.85">code.</span> </p>
<p><span data-start="265.85" data-end="270.84">So, because JavaScript performance is obviously</span> <span data-start="270.84" data-end="276.56">very important, and optimisations are limited,</span> <span data-start="276.56" data-end="281.639">developers still manually optimise their code.</span> <span data-start="281.639" data-end="286.539">And to understand what type of optimisations developers apply</span> <span data-start="286.539" data-end="293.169">and what do they consider, as important optimisations,</span> <span data-start="293.169" data-end="298.55">we did analysis of performance issue reports from</span> <span data-start="298.55" data-end="302.86">popular JavaScript projects, and here I would mention</span> <span data-start="302.86" data-end="308.229">only three of them so we started backtracking system</span> <span data-start="308.229" data-end="314.33">of angular project, amber react to JQuery_ and many more.</span> </p>
<p><span data-start="314.33" data-end="318.25">Because for those projects we understood that performance</span> <span data-start="318.25" data-end="320.639">is significant concern.</span> <span data-start="320.639" data-end="327.8">And we analyse in total and reproduce successfully 98 performance issues.</span> <span data-start="327.8" data-end="331.669">Now I am going to give you some examples of the real</span> <span data-start="331.669" data-end="335.629">world JavaScript performance issues and how developers</span> <span data-start="335.629" data-end="337.49">fix them.</span> </p>
<p><span data-start="337.49" data-end="348.659">So let's first start from the most prevalent ones I don't know, would you guess this, but</span> <span data-start="348.659" data-end="352.18">please don't be surprised if I show you that most</span> <span data-start="352.18" data-end="357.409"> —  the significant amount of performance issues we</span> <span data-start="357.409" data-end="367.289">analysed are related to this, and this not surprising because</span> <span data-start="367.289" data-end="372.069">compilers in many cases are not successfully optimise</span> <span data-start="372.069" data-end="374.41">this statement.</span> </p>
<p><span data-start="374.41" data-end="379.42">And this particular piece of code iterates over properties of some object, and</span> <span data-start="379.42" data-end="386.44">checks whether the properties are new numeriable,</span> <span data-start="386.44" data-end="395.65">so they solved this problem and traditional, and to</span> <span data-start="395.65" data-end="401.099">convince the developer to apply certain optimisations,</span> <span data-start="401.099" data-end="405.749">people  —  what they usually do, they create micro-benchmarks</span> <span data-start="405.749" data-end="410.039">and they run that on JSperf.</span> </p>
<p><span data-start="410.039" data-end="412.83">I hope you're familiar with that?</span> <span data-start="412.83" data-end="415.229">Can you raise your hand?</span> <span data-start="415.229" data-end="420.449">Okay, almost all of you are familiar, but this online benchmark to compare</span> <span data-start="420.449" data-end="425.61">performance of different code snippets written in</span> <span data-start="425.61" data-end="427.25">JavaScript.</span> <span data-start="427.25" data-end="434.099">As you know, it represents how many operations per second one code can execute</span> <span data-start="434.099" data-end="438.719">and the higher value is better one.</span> <span data-start="438.719" data-end="443.899">So for some input you can save almost 60 per cent of</span> <span data-start="443.899" data-end="453.529">the execution time by using object keys built in Forlin.</span> </p>
<p><span data-start="453.529" data-end="458.069">This is another example of performance issue in</span> <span data-start="458.069" data-end="463.169">JavaScript, and yeah, it is not really performance wise</span> <span data-start="463.169" data-end="466.689">to create regular expression every time when split</span> <span data-start="466.689" data-end="471.8">method is called, and for this particular project the</span> <span data-start="471.8" data-end="476.199">split method was called many times during the execution.</span> <span data-start="476.199" data-end="483.94">So it is much more efficient to start a computation of</span> <span data-start="483.94" data-end="490.719">regular expression creation and to reuse this computation later in your code.</span> <span data-start="490.719" data-end="496.819">And by running these two codes on JS Perf, we</span> <span data-start="496.819" data-end="503.119">managed to save for some input 15 per cent of execution</span> <span data-start="503.119" data-end="507.71">time in Firefox.</span> <span data-start="507.71" data-end="511.759">Another example shows how you can copy elements from</span> <span data-start="511.759" data-end="515.7">binary to another, so what you can do is just iterate</span> <span data-start="515.7" data-end="520.46">over elements, and append new array with every original</span> <span data-start="520.46" data-end="523.45">element of the array, but it is much more efficient and</span> <span data-start="523.45" data-end="528.52">smarter to call built-in prototype slice method.</span> <span data-start="528.52" data-end="534.839">For this particular example, we saved almost 200</span> <span data-start="534.839" data-end="540.94">per cent execution time in both browsers, Chrome and</span> </p>
<p><span data-start="540.94" data-end="541.94">Firefox.</span> <span data-start="541.94" data-end="549.23">In the last example, it is about how JavaScript</span> <span data-start="549.23" data-end="555.32">developers use sometimes, not always, JavaScript API</span> <span data-start="555.32" data-end="557.1">in inefficient way.</span> <span data-start="557.1" data-end="561.49">So a couple of years ago it was really popular to</span> <span data-start="561.49" data-end="565.529">use split and join calls for doing search and replace in</span> <span data-start="565.529" data-end="571.15">JavaScript, and nowadays, since replace method is very</span> <span data-start="571.15" data-end="574.1">well optimised by many browsers, it is much more</span> <span data-start="574.1" data-end="578.56">efficient to use, the built-in method, and please keep</span> <span data-start="578.56" data-end="583.31">in mind this example I will come to this later on.</span> </p>
<p><span data-start="583.31" data-end="589.44">And on JSperf we could save 44 per cent of execution</span> <span data-start="589.44" data-end="597.19">time in Chrome for this particular optimisation.</span> <span data-start="597.19" data-end="603.449">So what I would like to discuss now is, well, it's</span> <span data-start="603.449" data-end="609.67">common belief that having optimised code would sacrifice</span> <span data-start="609.67" data-end="615.16">maintainability of your code, which is for some</span> <span data-start="615.16" data-end="619.449">optimisations true, but if you could remind yourself of</span> <span data-start="619.449" data-end="623.91">the previous example you could see that many optimisations were pretty simple and they</span> <span data-start="623.91" data-end="628.94">didn't change complexity of the source code, almost at all.</span> <span data-start="628.94" data-end="633.879">So, is this really the case for real world optimisations</span> <span data-start="633.879" data-end="635.519">in JavaScript?</span> </p>
<p><span data-start="635.519" data-end="640.269">Well, I would not say that.</span> <span data-start="640.269" data-end="647.329">And to prove this, we measured for every optimisations</span> <span data-start="647.329" data-end="651.2">how many statements the optimisation change in the</span> <span data-start="651.2" data-end="657.35">source code and what is the difference between original</span> <span data-start="657.35" data-end="660.23">and optimised version of the program?</span> <span data-start="660.23" data-end="664.43">And if you could see most of the optimisations, almost are not</span> <span data-start="664.43" data-end="668.04">changed complexity at all.</span> <span data-start="668.04" data-end="680">So, here in this, I would say that yeah, optimisation are relatively simple, that by</span> <span data-start="680" data-end="685.87">relatively simple changes you can optimise your JavaScript</span> <span data-start="685.87" data-end="690.329">codes significantly, and we also observe that many</span> <span data-start="690.329" data-end="693.35">optimisations are instances of recurring partners which</span> <span data-start="693.35" data-end="697.709">means that one type of optimisation we found in multiple</span> <span data-start="697.709" data-end="700.16">projects.</span> <span data-start="700.16" data-end="702.44">Imagine the following situations you use your split</span> <span data-start="702.44" data-end="706.99">and join pattern all over your codebase and you use it</span> <span data-start="706.99" data-end="708.899">many places.</span> </p>
<p><span data-start="708.899" data-end="714.839">Optimising this particular pattern would require a lot of manual effort and maybe some</span> <span data-start="714.839" data-end="717.769">of you would give up of this optimisation.</span> <span data-start="717.769" data-end="724.97">But we wanted to answer, is it possible to outmain the process</span> <span data-start="724.97" data-end="729.97">of optimising JavaScript programme?</span> <span data-start="729.97" data-end="734.07">I don't have general answer to this question, but I can say for</span> <span data-start="734.07" data-end="740.389">many optimisations we succeeded to do this in almost</span> <span data-start="740.389" data-end="743.01">fully automatic way.</span> </p>
<p><span data-start="743.01" data-end="750.12">So what we did, we built a tool for semi-automatic refactorings, and general idea</span> <span data-start="750.12" data-end="754.97">of this is to provide as you input something that we</span> <span data-start="754.97" data-end="758.79">already have, and this the program we want to optimise and</span> <span data-start="758.79" data-end="762.54">some set of tests, they can be functional tests on which</span> <span data-start="762.54" data-end="764.93">you will check the reference of your code.</span> </p>
<p><span data-start="764.93" data-end="769.31">To use it as input and output, you have optimised program.</span> <span data-start="769.31" data-end="774.81">It sounds really promising.</span> <span data-start="774.81" data-end="779.12">So let's take a closer look into the tools  —  into</span> <span data-start="779.12" data-end="782.1">the structure of the tool and what tool actually does.</span> <span data-start="782.1" data-end="786.579">So, as I mentioned, you use your program, set-up test,</span> <span data-start="786.579" data-end="791.139">and you describe the pattern you want to optimise, you</span> <span data-start="791.139" data-end="795.94">want to refactor, and our tool is based on estimating</span> <span data-start="795.94" data-end="800.24">and rewriting, and I hope most of you are familiar with</span> <span data-start="800.24" data-end="808.47">the AST term, and simply speaking it is a true</span> <span data-start="808.47" data-end="812.579">representation of your JavaScript code, and in addition</span> <span data-start="812.579" data-end="820.92">to this, we wanted to report only those optimisations that actually provide some performance benefit,</span> <span data-start="820.92" data-end="825.959">and that's why we do performance measurement for</span> <span data-start="825.959" data-end="830.44">every optimisation that our tool applies, and of</span> <span data-start="830.44" data-end="834.649">course, as output you have optimised program.</span> <span data-start="834.649" data-end="837.5">So what is pattern specification?</span> <span data-start="837.5" data-end="843.069">We wanted to keep it simple, so we said our pattern will be</span> <span data-start="843.069" data-end="846.98">two fragments of JavaScript code, how the original will</span> <span data-start="846.98" data-end="852.18">look like and how the optimised code should look like, but</span> <span data-start="852.18" data-end="856.5">we also wanted somehow to make this pattern up struck,</span> <span data-start="856.5" data-end="860.62">which means you don't have to write pattern for</span> <span data-start="860.62" data-end="864.99">every project so you can make your pattern specification</span> <span data-start="864.99" data-end="869.72">once in a general way, and we use it for many projects</span> <span data-start="869.72" data-end="871.49">later on.</span> </p>
<p><span data-start="871.49" data-end="875.509">And we also wanted to make the pattern enough so you can</span> <span data-start="875.509" data-end="877.69">cover as many cases as possible.</span> <span data-start="877.69" data-end="882.24">So to do this, we introduced placeholder for some constructs</span> <span data-start="882.24" data-end="886.379">in JavaScript, I don't see this list of placeholders</span> <span data-start="886.379" data-end="888.16">you can see now is exhaustive.</span> </p>
<p><span data-start="888.16" data-end="890.1">It is not.</span> <span data-start="890.1" data-end="896.5">We are working on adding more placeholders in our tool, but</span> <span data-start="896.5" data-end="901.93">for now, our tool supports placeholders for expressions,</span> <span data-start="901.93" data-end="905.199">identifiers and literals.</span> <span data-start="905.199" data-end="909.66">And if you remember, the example of split and join, we can say okay,</span> <span data-start="909.66" data-end="913.939">the split can be called on any expression JavaScript,</span> <span data-start="913.939" data-end="917.55">which means not only on identifier or some stream, it</span> <span data-start="917.55" data-end="921.199">can also be on some property access can be called on that,</span> <span data-start="921.199" data-end="924.41">some result of the function call, and so on, and as I</span> <span data-start="924.41" data-end="927.999">input to the  —  as the permitter of the split, we can</span> <span data-start="927.999" data-end="932.149">have any identifier later, all the same with join.</span> <span data-start="932.149" data-end="936.04">So you can see how the optimised code should look like.</span> <span data-start="936.04" data-end="945.329">Based on the pattern specification, our tool generates the ASTs for each code fragments,</span> <span data-start="945.329" data-end="950.93">and for generating ASTs we use existing parser, but</span> <span data-start="950.93" data-end="959.029">yeah, the idea about the transformation is not specific</span> <span data-start="959.029" data-end="966.059">to the outlook, and can be applied to any other parser.</span> </p>
<p><span data-start="966.059" data-end="972.97">So having two ASTs, our tool actually generates</span> <span data-start="972.97" data-end="980.85">the programs ASTs and tries to find a match between</span> <span data-start="980.85" data-end="986.029">AST of the first fragment of our pattern specification</span> <span data-start="986.029" data-end="990.66">and subsub in program AST and once the match is</span> <span data-start="990.66" data-end="996.22">found, it rewrites the AST of the original program as</span> <span data-start="996.22" data-end="1000.42">our AST of optimised code.</span> <span data-start="1000.42" data-end="1003.54">Looks like this, sorry.</span> <span data-start="1003.54" data-end="1004.86">Okay.</span> <span data-start="1004.86" data-end="1012.3">I would illustrate the first step of our tool on the</span> <span data-start="1012.3" data-end="1013.99">examples.</span> <span data-start="1013.99" data-end="1019.36">So given the first fragment of our pattern specification</span> <span data-start="1019.36" data-end="1024.079">we generate the AST, it usually looks like something</span> <span data-start="1024.079" data-end="1026.5">like this.</span> </p>
<p><span data-start="1026.5" data-end="1033.26">And for some program we try to find match between the first AST and some subtree of</span> <span data-start="1033.26" data-end="1039.459">it, and we say the two ASTs match if the number of nodes</span> <span data-start="1039.459" data-end="1044.23">position and the types also match, but we have special</span> <span data-start="1044.23" data-end="1048.95">rules for the placeholders, for example, this expression</span> <span data-start="1048.95" data-end="1055.69">one placeholder can match to any tree structure,</span> <span data-start="1055.69" data-end="1059.78">that represents some expression, and also all in</span> <span data-start="1059.78" data-end="1064.25">this identifier can match to any identifier in</span> <span data-start="1064.25" data-end="1068.33">JavaScript, and the same with the $y.</span> <span data-start="1068.33" data-end="1076.68">So now we all have the subtrees or program AST that match the pattern</span> <span data-start="1076.68" data-end="1078.49">specification.</span> <span data-start="1078.49" data-end="1083.54">The next step is to rewrite all those subtrees.</span> <span data-start="1083.54" data-end="1084.9">What we first use?</span> <span data-start="1084.9" data-end="1093.25">We first generate the AST of the second fragment or optimised code of</span> <span data-start="1093.25" data-end="1100.641">our pattern specification, and as you can see here, there</span> <span data-start="1100.641" data-end="1102.87">are some nodes that should be resolved.</span> </p>
<p><span data-start="1102.87" data-end="1107.84">I mean, all nodes that represent the placeholders.</span> <span data-start="1107.84" data-end="1114.93">We just use what you found, replace placeholders with the real nodes,</span> <span data-start="1114.93" data-end="1122.14">insert this AST instead of the found AST and generate</span> <span data-start="1122.14" data-end="1124.22">a new code.</span> <span data-start="1124.22" data-end="1127.62">Yeah, that's how the optimisation takes place.</span> <span data-start="1127.62" data-end="1129.22">But is it worked?</span> <span data-start="1129.22" data-end="1132.3">Does it bring some performance benefit?</span> </p>
<p><span data-start="1132.3" data-end="1138.44">Well it depends on the tests that are given as input, so</span> <span data-start="1138.44" data-end="1144.22">we use those tests to run the original and modified</span> <span data-start="1144.22" data-end="1147.37">optimised version of the program.</span> <span data-start="1147.37" data-end="1152.01">And we show to the developer only optimisations that really bring</span> <span data-start="1152.01" data-end="1155.13">some performance benefits.</span> <span data-start="1155.13" data-end="1160.87">So we run every test, repeatedly, until some meaningful measurable execution</span> <span data-start="1160.87" data-end="1166.76">time is reached and we compare the execution times</span> <span data-start="1166.76" data-end="1170.36">of the original and optimised program.</span> </p>
<p><span data-start="1170.36" data-end="1171.95">It's nice.</span> <span data-start="1171.95" data-end="1176.26">We have a tool, is it useful?</span> <span data-start="1176.26" data-end="1180.78">Well, we didn't always find it useful, really, but we decided to run this</span> <span data-start="1180.78" data-end="1187">tool on some real world JavaScript projects and on some</span> <span data-start="1187" data-end="1194.44">patterns we found, so we made a specification for six</span> <span data-start="1194.44" data-end="1199.7">patterns that change at most one statement in JavaScript,</span> <span data-start="1199.7" data-end="1205.93">and we run this tool against 10 JS libraries, which we</span> <span data-start="1205.93" data-end="1208.07">extracted from NPM repository.</span> </p>
<p><span data-start="1208.07" data-end="1216.8">And yes, we found the optimisations, we found 35 potential optimisations</span> <span data-start="1216.8" data-end="1220.9">and 24 of them actually show some speed up.</span> <span data-start="1220.9" data-end="1225.9">Now I am going to give you example of one optimisation we</span> <span data-start="1225.9" data-end="1227.52">perform by our tool.</span> <span data-start="1227.52" data-end="1235.86">So in this particular function, the type of the input is checked, by using class comparison,</span> <span data-start="1235.86" data-end="1240.47">class comparison in JavaScript is done by calling</span> <span data-start="1240.47" data-end="1244.79">to string method on object.</span> <span data-start="1244.79" data-end="1250">So the developers first use class comparison to</span> <span data-start="1250" data-end="1255.95">check the type of the input, and if it is not true, they</span> <span data-start="1255.95" data-end="1257.97">use instanceof operator.</span> <span data-start="1257.97" data-end="1261.51">It does the same thing.</span> </p>
<p><span data-start="1261.51" data-end="1263.4">But it seems to be more efficient.</span> <span data-start="1263.4" data-end="1271.66">So it is more efficient to use first instanceof than class comparison.</span> <span data-start="1271.66" data-end="1276.2">And we found ten potential optimisations of this</span> <span data-start="1276.2" data-end="1280.52">pattern, six of them showed actual speed-up.</span> <span data-start="1280.52" data-end="1287.67">And we reported this optimisation as a pull request to JS library,</span> <span data-start="1287.67" data-end="1291.53">and they accepted this pull request to merge and optimise</span> <span data-start="1291.53" data-end="1295.18">their code as we proposed.</span> <span data-start="1295.18" data-end="1304.5">So I would conclude this talk by saying that yeah,</span> <span data-start="1304.5" data-end="1308.68">you can reach really nice performance benefit by using</span> <span data-start="1308.68" data-end="1314.8">very simple optimisations and semi-automatic refactorings can help you to achieve these</span> <span data-start="1314.8" data-end="1317.06">goals, so in stead of a slow turtle we can have a rocket</span> <span data-start="1317.06" data-end="1318.24">turtle.</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
