<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Ls27mCiYsQo</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/Ls27mCiYsQo?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="1.64" data-end="21.829">Hello, everyone, thanks for the introduction.</span> <span data-start="21.829" data-end="28.48">I will be talking about Parallel JavaScript, before I tell you more about it, why Parallel</span> <span data-start="28.48" data-end="29.48">JavaScript?</span> <span data-start="29.48" data-end="35.37">Well, simple the hardware you have is getting more and more parallel, you have more cores,</span> <span data-start="35.37" data-end="43.14">you is wider vector units, your GPUs are increasing in performance since 2006 there's been a 75</span> <span data-start="43.14" data-end="53.24">X increase of par are legal use\h‑‑ at the same time, the kinds of applications would</span> <span data-start="53.24" data-end="55.68">you write with JavaScript has changed.</span> <span data-start="55.68" data-end="62.239">Now you have physics and fluid simulations you have path tracing, real‑time game engines</span> <span data-start="62.239" data-end="66.799">at the same time JavaScript programs have access to device sensors, on board sensors,</span> <span data-start="66.799" data-end="71.49">multimedia streams, so the kind of applications are changing, many sophisticated more computing</span> <span data-start="71.49" data-end="74.31">intensive.</span> </p>
<p><span data-start="74.31" data-end="77.09">But there's no support for parallel computing.</span> <span data-start="77.09" data-end="80.75">Why do we wanton vent a new parallel programming model</span> <span data-start="80.75" data-end="86.43">'s so many, so many people have invented so many, why not take it and bolt it on top of</span> <span data-start="86.43" data-end="87.549">JavaScript, right.</span> <span data-start="87.549" data-end="97.7">Turns out the web has specific requirements that make this approach undesirable.</span> <span data-start="97.7" data-end="101.43">First thing we want to preserve is ease of use, whatever programming, whatever parallel</span> <span data-start="101.43" data-end="105.8">programming model we use should fit in well with JavaScript.</span> <span data-start="105.8" data-end="112.939">So the programmerrer should haven't to two different mental model, one for the sequential</span> <span data-start="112.939" data-end="117.35">parts of the program and another for the parallel part of the program, it should all just be</span> <span data-start="117.35" data-end="118.35">JavaScript.</span> </p>
<p><span data-start="118.35" data-end="123.88">We want to have a very high level API, we don't want the programmer to worry about and</span> <span data-start="123.88" data-end="132.41">exchange primitives, or even threads, we want a very high level API fitting with the Ethos</span> <span data-start="132.41" data-end="133.739">of JavaScript.</span> <span data-start="133.739" data-end="138.55">We want to be deterministic where possible, this is hard for parallel programming, but</span> <span data-start="138.55" data-end="142.31">the determinism is awesome for debugging and deployment.</span> <span data-start="142.31" data-end="148.769">We also want to be platform indent, we want to run on all kind of platforms, from single</span> <span data-start="148.769" data-end="155.73">core, mobile phones to the most powerful desktop computer, we want the leverage different kinds</span> <span data-start="155.73" data-end="165.97">of particularism, could be multicore or GPU, not just that, we want the program to write</span> <span data-start="165.97" data-end="171.11">the same code for all of these different kinds of parallelism, we don't want the programmer</span> <span data-start="171.11" data-end="178.349">to write one kind of code and another for GPUs, e we want that to be abstract away,</span> <span data-start="178.349" data-end="184.86">our goal is to extract reasonable performance from parallel hardware.</span> <span data-start="184.86" data-end="191.769">it's a secondary goal and this should not be completely to the developer, the browser</span> <span data-start="191.769" data-end="197.209">Runtime should share a lot of this burden of extracting performance, we want to make</span> <span data-start="197.209" data-end="204.019">the expression of parallelism easy but not exactly how you implement it .</span> </p>
<p><span data-start="204.019" data-end="209.069">Finally we want to make it suitable for the open web, we want to\h‑‑ we don't want</span> <span data-start="209.069" data-end="215.37">to increase the attack service for JavaScript, we don't want native execution of native code</span> <span data-start="215.37" data-end="222.45">for example, we still want to preserve the sand boxed execution environment of JavaScript,</span> <span data-start="222.45" data-end="223.569">right.</span> <span data-start="223.569" data-end="229.48">So, this is a brief overview of the Parallel JavaScript API, it's built on 3 pillars, the</span> <span data-start="229.48" data-end="236.06">first is collections, these collections in JavaScript are just JavaScript arrays, and,</span> <span data-start="236.06" data-end="241.189">typed object, which are going to be in an ES 7.</span> <span data-start="241.189" data-end="246.409">Then you have high level data par are legal methods that operate on these collections,</span> <span data-start="246.409" data-end="253.799">some of these may already be familiar, map, reduce, filter, scatter, the PAR suffix simply</span> <span data-start="253.799" data-end="259.97">conveys the programmers intention that he would like this method called to operate in</span> <span data-start="259.97" data-end="261.25">parallel.</span> <span data-start="261.25" data-end="264.91">It may not, as we will see, but he would like it to be.</span> </p>
<p><span data-start="264.91" data-end="266.39">So very high level.</span> <span data-start="266.39" data-end="268.45">No threads.</span> <span data-start="268.45" data-end="274.29">The third component is elemental functions, these are just regular JavaScript functions</span> <span data-start="274.29" data-end="280.43">that are the things that are execute in the par are legal across cores, GPUs and so on,</span> <span data-start="280.43" data-end="284.82">there's one important caffuate, that have to be side effect free, they cannot alter</span> <span data-start="284.82" data-end="286.17">global state.</span> <span data-start="286.17" data-end="292.78">So global state may for example be a global variable, right, in a parallel region, you</span> <span data-start="292.78" data-end="298.1">not, in an elemental function, you cannot change global state, right, you can read it,</span> <span data-start="298.1" data-end="299.91">but you cannot write to it.</span> <span data-start="299.91" data-end="304.67">To there are also more subtle kind of side effects in JavaScript program which is are</span> <span data-start="304.67" data-end="311.15">engine level side effects, so, for example just\h‑‑ two strings, though it appears</span> <span data-start="311.15" data-end="317.95">at a surface level has engine level side effects, but it's not up to the programmer to worry</span> <span data-start="317.95" data-end="322.97">about those things, it's about the browser Runtime were tory about that.</span> <span data-start="322.97" data-end="329.69">So let's look at some code example (To worry about that) this is a very simple example</span> <span data-start="329.69" data-end="335">of how you would use the MapPar, you have a tie any array, one, two, three, four, you</span> <span data-start="335" data-end="342.66">give mapPar an elemental function, that fat arrow function over there.</span> </p>
<p><span data-start="342.66" data-end="349.16">And that increments each element in the input array, this looks exactly like map, if you</span> <span data-start="349.16" data-end="352.38">load this using map it would look exactly the same.</span> <span data-start="352.38" data-end="357.66">The different here the elemental function is execute in the parallel for each element</span> <span data-start="357.66" data-end="358.66">in this array.</span> <span data-start="358.66" data-end="362.55">If you\h‑‑ of course in this case you don't need parallelism, it's only four elements</span> <span data-start="362.55" data-end="366.93">if you is a million elements and your elemental function is doing something more sophisticated</span> <span data-start="366.93" data-end="370.12">you imagine how this would be useful.</span> <span data-start="370.12" data-end="377">Reduce looks similar, you give it, again, an elemental function that takes two values</span> <span data-start="377" data-end="382.87">and returns one value so you're reducing A and B to produce B, when applied to this array</span> <span data-start="382.87" data-end="389.21">produce ten this is exactly the semantics that normal Java can produce as well.</span> </p>
<p><span data-start="389.21" data-end="397.01">By adding Par you're marking it parallel 's an important caveat here, determinism,</span> <span data-start="397.01" data-end="403.69">when you do reduce, determinism is guaranteed only when the elemental function is associated,</span> <span data-start="403.69" data-end="410.56">right, if the elemental function is not associative, then, you'll get, you'll transparently get</span> <span data-start="410.56" data-end="413.85">sequential execution, it will be equal in to just reduce.</span> <span data-start="413.85" data-end="421.25">In other words, the programmer does the best job he can to write code that is paraism friendly,</span> <span data-start="421.25" data-end="427.87">if not, if it's not paraelism friendly he'll get sequential execution, without changing</span> <span data-start="427.87" data-end="429.52">any code.</span> <span data-start="429.52" data-end="436.34">So let's say you have an input image which is a 3 dimensional width times height times</span> <span data-start="436.34" data-end="442.66">four, right, four is RGB alpha, this is how you would convert it into gray scale, you</span> <span data-start="442.66" data-end="449.75">do a mapPar, ignore 2 over there and give it an elemental function that averages the</span> <span data-start="449.75" data-end="457.6">first three channels, the RGB values and returns an array with this so this is a simple averageaing</span> <span data-start="457.6" data-end="460.65">gray scale operation.</span> </p>
<p><span data-start="460.65" data-end="467.38">The two here is the depth at which you want the mapPar to operate, if you have a 3 dimensional</span> <span data-start="467.38" data-end="473.85">collection, sometimes would you like to operate on rows of an image, sometimes would you like</span> <span data-start="473.85" data-end="480.13">the operate on fix els, sometimes would you like to operate on individual color channels</span> <span data-start="480.13" data-end="486.69">in an image, the depth parameter would allow you to select what slice you want to do this</span> <span data-start="486.69" data-end="490.53">parallel operation on, in an input collection, okay.</span> <span data-start="490.53" data-end="495.51">You don't have to worry about all the details, theu just to give you an idea of what the</span> </p>
<p><span data-start="495.51" data-end="502.66">APL looks like, so reversing an array, simple exact million you create an ray for build</span> <span data-start="502.66" data-end="512.74">par\h‑‑ in parallel it constructs an array that just contains 0123 and scatter Par takes</span> <span data-start="512.74" data-end="520.61">a function that maps elements in the input array to the out put away.</span> <span data-start="520.61" data-end="528.89">ScatterPar is taking the first element putting it in the last index and so on.</span> <span data-start="528.89" data-end="537.44">Filter works exactly the same way as\h‑‑ filterPar works exactly the same way as\h‑‑</span> <span data-start="537.44" data-end="543.16">just give it an elemental function this returns the Boolean, it determines whether it stay</span> <span data-start="543.16" data-end="546.97">in the out put array or not.</span> <span data-start="546.97" data-end="551.67">Typed objects are a new proposal.</span> <span data-start="551.67" data-end="557.84">I believe there are\h‑‑ there's a preliminary implementation in fire fox.</span> <span data-start="557.84" data-end="564.28">The API just works on typed objects I dentically to JavaScript objects, the same gray scale</span> <span data-start="564.28" data-end="570.12">operation I showed you earlier, it's very similar, except it's returning the JavaScript</span> <span data-start="570.12" data-end="573.21">array, you're returning a new typed object.</span> </p>
<p><span data-start="573.21" data-end="578.19">So, this is what I mean by feeding in with the rest of JavaScript, you don't want to</span> <span data-start="578.19" data-end="585.61">introduce new types or concepts, you want to kind of build upon what is already there.</span> <span data-start="585.61" data-end="591.72">Of Parallel JavaScript is an ES 7 proposal at this point.</span> <span data-start="591.72" data-end="597.51">We're discussing the API in the committee and with the browser\h‑‑ there's a specification</span> <span data-start="597.51" data-end="598.72">you can look at.</span> <span data-start="598.72" data-end="607.24">And a preliminary implementation is in fire fox nightly the API I just showed you is the</span> <span data-start="607.24" data-end="614.68">result of a collaboration between my team and the Mozilla team that is implements JPS</span> <span data-start="614.68" data-end="617.01">in Nightly.</span> </p>
<p><span data-start="617.01" data-end="624.55">So in order to get parallel execution, they had to solve several challenges I'll briefly</span> <span data-start="624.55" data-end="630.58">describe them, first was JIT support, so you want for parallelism you want to go in IC</span> <span data-start="630.58" data-end="638.84">side effect freedom, how do you make sure they Donahue state global state T way they</span> <span data-start="638.84" data-end="644.26">do this is theyv a static safety analysis that inspects your JavaScript and figures</span> <span data-start="644.26" data-end="649.54">out whether there's a violation of the side effect freedom requirement.</span> <span data-start="649.54" data-end="654.58">They also have right guard which is are dynamic checks that check whether you're following</span> <span data-start="654.58" data-end="655.93">the rule.</span> <span data-start="655.93" data-end="662.49">They have a pretty cool work stealing scheduler that tries to schedule work on hardware threads</span> <span data-start="662.49" data-end="670.66">in the way that reduces imbalances on threads, if you have hypothreading, you have many hardware</span> <span data-start="670.66" data-end="674.77">threats, it tries to keep all of them busy.</span> </p>
<p><span data-start="674.77" data-end="680.04">And there's a new garbage collection scheme just for Parallel JavaScript that is kind</span> <span data-start="680.04" data-end="686.43">of integrated with the spider monkey, fire foxes generational garbage collector, and</span> <span data-start="686.43" data-end="692.44">cool thing about this is it actually exploits the programming model, the property of the</span> <span data-start="692.44" data-end="696.5">programming model, which is that you can't have side effects, and this fact makes garbage</span> <span data-start="696.5" data-end="700.16">collection fast, it turns out, which is cool.</span> <span data-start="700.16" data-end="705.44">Finally there's a lot of work on providing retail reasons for why something did not execute</span> <span data-start="705.44" data-end="706.44">in parallel.</span> <span data-start="706.44" data-end="717.32">For example in the mapPar, if I were to insert some Dom, which is not side effect free, then</span> <span data-start="717.32" data-end="721.12">the program will bail out of parallel execution and you'll just get sequential execution,</span> <span data-start="721.12" data-end="726.35">but your console will tell you that this is the operation at this line number in your</span> <span data-start="726.35" data-end="731.02">program, that is the reason for you not getting parallel speed ups, right.</span> </p>
<p><span data-start="731.02" data-end="737.21">They also provide complete stack frames at bailout points so that you can actually debug</span> <span data-start="737.21" data-end="743.23">why things didn't flan parallel this is really important\h‑‑ didn't run in parallel.</span> <span data-start="743.23" data-end="751.96">I would like to take a few minutes to talk about parallel JavaScript on GPUs, hugely</span> <span data-start="751.96" data-end="759.05">important resource that I think we should use more in JavaScript programs in the non‑graphical</span> <span data-start="759.05" data-end="766.65">portions of JavaScript programs, I mean GPGPU, general programming context.</span> <span data-start="766.65" data-end="773.93">But, compiling Parallel JavaScript to GPUs is not easy, it's challenging,I I'llout line</span> <span data-start="773.93" data-end="785.56">a few reasons why, GPUs have a separate address space than CPU,\h‑‑ how do you make that</span> <span data-start="785.56" data-end="789.56">available to a JavaScript program running on the GPU?</span> </p>
<p><span data-start="789.56" data-end="796.79">You have copy it, which would be hugely expensive otherwise you would have to map it somehow.</span> <span data-start="796.79" data-end="800.06">So this is a non‑trivial problem.</span> <span data-start="800.06" data-end="808">Even though in some new chips, physical memory is shared, virtual memory is not shared, this</span> <span data-start="808" data-end="816.73">makes the problem of mapping non‑contiguous parts of the heap on your device very challenging.</span> <span data-start="816.73" data-end="825.1">Then there are a number of paths to the actual GPU hardware, there's directX,there's openCL</span> </p>
<p><span data-start="825.1" data-end="827.839">Kernels and there are tons more.</span> <span data-start="827.839" data-end="834.2">Each of these have slightly different semantics, each of these is\h‑‑ allows a different</span> <span data-start="834.2" data-end="840.08">subset of JavaScript, so I'm talking about compiling JavaScript to one of these, right.</span> <span data-start="840.08" data-end="844.43">So, as you can imagine, you can compile a different subset of JavaScript, so you have</span> <span data-start="844.43" data-end="849.58">to reconcile these together in your browser Runtime.</span> </p>
<p><span data-start="849.58" data-end="856.79">So, some things that would be possible to express in, let's say openCL would not be</span> <span data-start="856.79" data-end="862.49">possible to express in OpenGL, right, just because of the programming model.</span> <span data-start="862.49" data-end="866.85">You have to keep that in mind when you're compiling.</span> <span data-start="866.85" data-end="872.9">Then there's no dynamic location on northwest GPUs there, is no notion overheap, as such,</span> <span data-start="872.9" data-end="879.589">it's just scratch pad memory, the star there indicates that on kind of more recent GPUs</span> <span data-start="879.589" data-end="888.93">there is actually, I think Kuda, 2.0 has Mallac, it's not wide limply meanted on all GPUs,</span> <span data-start="888.93" data-end="896.18">there's no general notion of a stack either, rite on a GPU, so most interesting JavaScript</span> <span data-start="896.18" data-end="901.48">programs would like to do heap allocations, I presume, this would be hard to support,</span> <span data-start="901.48" data-end="908.62">you would have to build a dynamic memory managerrer, and a collector that runs completely on the</span> <span data-start="908.62" data-end="909.62">GPU.</span> <span data-start="909.62" data-end="915.77">There are also no function pointers in most GPU programming models, this makes things</span> <span data-start="915.77" data-end="920.85">like dynamic dispatch difficult to impresent.</span> <span data-start="920.85" data-end="924.03">And polymorphism is also difficult oimpresent.</span> </p>
<p><span data-start="924.03" data-end="929.87">And getting final performance is not easy, the developer has to keep track of different</span> <span data-start="929.87" data-end="941.67">families of GPUs, this is a fourth generation GPU with Open CL, and this is a Coda, so it's</span> <span data-start="941.67" data-end="946.649">very, it's an intractable problem and unreasonable to expect the programmer to keep track of</span> <span data-start="946.649" data-end="947.649">all of these things.</span> <span data-start="947.649" data-end="953.29">So our approach is to basically take this high level specification in PGS and let the</span> <span data-start="953.29" data-end="958.27">browser Runtime\h‑‑ the browser Runtime has perfect knowledge of what the platform</span> <span data-start="958.27" data-end="965.08">is, it can query GP capabilities, it can do all of that, the idea is to threat browser</span> <span data-start="965.08" data-end="968.67">run time do it, transparently.</span> </p>
<p><span data-start="968.67" data-end="976.02">We've implemented a back end that takes your JavaScript and compiles it to run on GPU,</span> <span data-start="976.02" data-end="979.339">we have impresented it within fire fox.</span> <span data-start="979.339" data-end="984.06">So, this is an overview of what it looks like, the blue parts are what would happen with</span> <span data-start="984.06" data-end="989.83">normal parallel Java execution, CPU, would you run for a little while with an at the</span> <span data-start="989.83" data-end="996.26">present timer, baseline JIT, once your code has been hit a few times, it's hot, you know</span> <span data-start="996.26" data-end="1001.88">all the type information, then you would go to the Ion monkey JIT that would spend more</span> <span data-start="1001.88" data-end="1008.94">time optimizing, it's that the point doing parallel safety analysis, checking to see</span> <span data-start="1008.94" data-end="1012.23">if it's safe to run in parallel or not.</span> </p>
<p><span data-start="1012.23" data-end="1016.64">Then lower it a few times then you get just native code,right.</span> <span data-start="1016.64" data-end="1024.85">In the GPU case, we take MIR, which is the mid‑level intermediary rep evennation in</span> <span data-start="1024.85" data-end="1032.459">JavaScript in Ion monkey, we do GPU specific safety analysis, this checke checks whether</span> <span data-start="1032.459" data-end="1039.88">all the byte codes can be supported on the GPU, for example, if you're compiling to GSLL,</span> <span data-start="1039.88" data-end="1044.27">then maybe some particular byte codes are not supported</span> <span data-start="1044.27" data-end="1048.28">are no equal lens in GLL for some Java code.</span> </p>
<p><span data-start="1048.28" data-end="1055.21">Then we do some simple type inference, this is basically taking the JIT, ION monkey git</span> <span data-start="1055.21" data-end="1061.67">information and translating it to type that open CL understands, and we do some optimizations</span> <span data-start="1061.67" data-end="1068.66">for exploiting local memory, which is very fast on GPs, and then finally we generate</span> <span data-start="1068.66" data-end="1080.06">open CL, and then Open CL is built into a CPU binary and we reuse that binary, as long</span> <span data-start="1080.06" data-end="1085.5">as type information doesn't change, the types flowing your you JavaScript program doesn't</span> <span data-start="1085.5" data-end="1090.75">change, the Kernel is valid and we keep reusing it.</span> <span data-start="1090.75" data-end="1093.679">So what does all of this buy us, right?</span> <span data-start="1093.679" data-end="1099.15">Let's look at the energy and\h‑‑ let's look at performance first, verse parallel</span> <span data-start="1099.15" data-end="1107.66">execution on a CPU, remember, the baseline here is Parallel JavaScript execution on a</span> <span data-start="1107.66" data-end="1112.83">CPU, which is already depending on mow cores you is, which is already faster than regular</span> <span data-start="1112.83" data-end="1115.35">sequential JavaScript, right.</span> <span data-start="1115.35" data-end="1126.28">So the blue access, the blue white access performance relative to CPU, so these are\h‑‑</span> <span data-start="1126.28" data-end="1128.65">these are some simple benchmarks that I picked.</span> </p>
<p><span data-start="1128.65" data-end="1134.87">We have more, I can show them to you later, so this MM is dense matrix, it does 8 times</span> <span data-start="1134.87" data-end="1142.98">better than on the GPU than on parallel CPU, this is written in JavaScript using PGS, and</span> <span data-start="1142.98" data-end="1156.99">2D‑Conv which you use for image sharpening, finding contours or optical flow, it's a fairly</span> <span data-start="1156.99" data-end="1165.12">important ‑‑ it does 2.8 times faster on GPU than parallel CP, you all know the</span> </p>
<p><span data-start="1165.12" data-end="1173.25">Mandel set, it does 6.2 times better in terms of performance than CPU.</span> <span data-start="1173.25" data-end="1174.75">What about energy?</span> <span data-start="1174.75" data-end="1184.27">So for dense matrix multiply, GPU execution the 7.7 times lower in energy than CPU execution,</span> <span data-start="1184.27" data-end="1191.42">than parallel CPU execution, it's 3 times and Mandel is 7.7 times lower, not only are</span> <span data-start="1191.42" data-end="1199.3">you getting huge increases from par are legal execution on GPU, over what is already fast</span> <span data-start="1199.3" data-end="1210.93">parallel CP um, you're also getting huge decrees in total energy consumption, this is big.</span> <span data-start="1210.93" data-end="1220.11">The matrix multiplier programs runs\h‑‑ runs 22 times faster.</span> <span data-start="1220.11" data-end="1225.58">So this 8 X is over that.</span> <span data-start="1225.58" data-end="1236.11">Ever 6\h‑‑ this would be 2.8 times faster than that.</span> <span data-start="1236.11" data-end="1237.11">Okay.</span> <span data-start="1237.11" data-end="1259.559">Let me quickly show you a quick demo\h‑‑ this is a simple program of so there are a</span> <span data-start="1259.559" data-end="1266.549">burner bunch of bugs the goal of the game is to move them using my hand to the frog,</span> <span data-start="1266.549" data-end="1269.62">feed them to the frog or take them to their house, right.</span> <span data-start="1269.62" data-end="1276.13">So, I probably should be standing closer, so, it's using\h‑‑ it's doing optical</span> <span data-start="1276.13" data-end="1281.75">flow on the image stream captured by the camera to basically figure out which way I'm moving</span> <span data-start="1281.75" data-end="1290.02">so you can see tall bugs settling on my face (Laughing) so it basically detects changes</span> <span data-start="1290.02" data-end="1291.99">in energy in the image.</span> </p>
<p><span data-start="1291.99" data-end="1296.28">So if I were to just run the sequential version of this today.</span> <span data-start="1296.28" data-end="1299.68">It would run like this.</span> <span data-start="1299.68" data-end="1303.91">Right this is pretty slow.</span> <span data-start="1303.91" data-end="1312.38">Let's go back to the parallel version.</span> <span data-start="1312.38" data-end="1325.24">(Applause) so, let me go back to my presentation, I can show you this in more detail, if you're</span> <span data-start="1325.24" data-end="1326.26">interested.</span> <span data-start="1326.26" data-end="1331.77">Okay, so the implementation is in fire fox Nightly there's a ECMA script proposal, we</span> <span data-start="1331.77" data-end="1337.52">would like the feedback, this is the time to influence when the API looks like and how</span> <span data-start="1337.52" data-end="1344.54">it's specified, if you is comments write to me or participate in the discussion on ECMAS</span> <span data-start="1344.54" data-end="1346.02">discuss.</span> </p>
<p><span data-start="1346.02" data-end="1347.37">Try it out and let us know what you think.</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
