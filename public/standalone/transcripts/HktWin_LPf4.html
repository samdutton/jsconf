<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HktWin_LPf4</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/HktWin_LPf4?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="3.139" data-end="12.799">Lin Clark — A Cartoon Intro to WebAssembly</span> <span data-start="12.799" data-end="15.5"Audience member: All right.</span> <span data-start="15.5" data-end="32.015">We are going to wait for a few people to get settled and continue on with our next talk.</span> <span data-start="32.015" data-end="33.015">How many people use various different ways to get their information about how things</span> <span data-start="33.015" data-end="34.015">work on the internet?</span> <span data-start="34.015" data-end="35.015">I know I use comics pretty often, I find them accessible, and I've read Lin Clark's comics.</span> <span data-start="35.015" data-end="36.015">Let's hear it for Lin!</span> <span data-start="36.015" data-end="37.015">[Applause].</span> </p>
</section>

<section>
<p><span data-start="37.015" data-end="38.015"><span class="speaker">Lin</span>: Thank you, and hi, everyone.</span> <span data-start="38.015" data-end="39.015">I'm Lin Clark and I make code cartoons.</span> <span data-start="39.015" data-end="40.015">I work at Mozilla.</span> <span data-start="40.015" data-end="45.93">The things like the Rust programming language and Servo and WebAssembly which is what I'm</span> <span data-start="45.93" data-end="48.19">going to be talking about today.</span> <span data-start="48.19" data-end="55.14">Since this is JSConf, I'm guessing most of you are JavaScript developers, so you know</span> <span data-start="55.14" data-end="58.7">that, in JavaScript circles today, there's a lot of hype about WebAssembly.</span> </p>
<p><span data-start="58.7" data-end="64.25">People are talking about how blazingly fast it is and how it is going to completely change</span> <span data-start="64.25" data-end="66.77">the way we do web development.</span> <span data-start="66.77" data-end="70.9">But a lot of these conversations don't go into details about exactly what it is about</span> <span data-start="70.9" data-end="75.71">WebAssembly that makes it fast and I hear this kind of rhetoric, but I don't hear the</span> <span data-start="75.71" data-end="77.54">details to back it up.</span> <span data-start="77.54" data-end="79.579">The inner sceptic in me comes out.</span> <span data-start="79.579" data-end="83.39">In this talk, I don't want to tell you about how fast WebAssembly is going to be, but I</span> <span data-start="83.39" data-end="88.299">want to help you understand what it is about WebAssembly what makes it fast and in what</span> <span data-start="88.299" data-end="91.84">circumstances it is fast.</span> </p>
<p><span data-start="91.84" data-end="96.07">But first, what is WebAssembly?</span> <span data-start="96.07" data-end="100.4">WebAssembly is a way to run programming languages other than JavaScript in your web pages.</span> <span data-start="100.4" data-end="104.909">So, in the past, when you wanted to run code on a web page, you had to use JavaScript.</span> <span data-start="104.909" data-end="109.75">If you wanted to change the DOM in response to an event or run a calculation, you were</span> <span data-start="109.75" data-end="112.08">using JavaScript.</span> <span data-start="112.08" data-end="115.939">With WebAssembly it will be possible to do these things with other languages besides</span> <span data-start="115.939" data-end="118.52">JavaScript.</span> <span data-start="118.52" data-end="122.38">So when people say that WebAssembly is fast, what they're comparing it to is JavaScript</span> <span data-start="122.38" data-end="124.82">- that's the apples to apples comparison.</span> <span data-start="124.82" data-end="130.74">Now, I don't want to imply it is an either or decision, you're going to be using WebAssembly</span> <span data-start="130.74" data-end="133.8">or you're going to be using JavaScript.</span> <span data-start="133.8" data-end="139.19">We think that people will be using these two hand in hand in their applications, but it</span> <span data-start="139.19" data-end="144.17">is useful to compare the two, so that you understand what this improved performance</span> <span data-start="144.17" data-end="149.05">of code running on the web could mean.</span> <span data-start="149.05" data-end="153.41">In order to understand this, let's look at a little bit of performance history of code</span> <span data-start="153.41" data-end="156.08">running on the web.</span> </p>
<p><span data-start="156.08" data-end="160.87">JavaScript was created in 1995, and it wasn't designed to be fast.</span> <span data-start="160.87" data-end="168.819">There are a number of features in JavaScript that make it hard to make it fast, and — types</span> <span data-start="168.819" data-end="174.629">where you have a string or an integer, you don't know, that even at runtime, that variable</span> <span data-start="174.629" data-end="176.65">could change.</span> <span data-start="176.65" data-end="180.81">But these features also make it easy for developers to get up and running with JavaScript really</span> <span data-start="180.81" data-end="184.7">quickly, so JavaScript developers accepted this trade-off.</span> <span data-start="184.7" data-end="188.34">They accepted that their code was going to run a little bit slower because of this ease</span> <span data-start="188.34" data-end="190.629">of use.</span> <span data-start="190.629" data-end="196.17">And for the first decade of JavaScript, that was true, that JavaScript was pretty slow,</span> <span data-start="196.17" data-end="199.23">and then the browsers started get more competitive.</span> <span data-start="199.23" data-end="205.549">And about 2008, a period started called the Performance Wars, the browser vendors started</span> <span data-start="205.549" data-end="209.94">improving their JSLint engines to make things of faster.</span> <span data-start="209.94" data-end="215.26">The technique they used was introducing JIT compilers to the JavaScript engine, and I</span> <span data-start="215.26" data-end="218.73">will explain more about that later.</span> </p>
<p><span data-start="218.73" data-end="223.22">Let's look at the impact that the JIT compilers had.</span> <span data-start="223.22" data-end="227.65">With the introduction of the JITs, you see an inflection point in the performance of</span> <span data-start="227.65" data-end="228.65">JavaScript.</span> <span data-start="228.65" data-end="233.79">All of a sudden, JavaScript code was running about ten times faster than it had previously.</span> </p>
<p><span data-start="233.79" data-end="240.519">And these performance improvements continued over the next decade.</span> <span data-start="240.519" data-end="241.709">With this improved performance.</span> <span data-start="241.709" data-end="246.62">You start seeing JavaScript being used for things that you never expected like Node and</span> <span data-start="246.62" data-end="249.76">Electron.</span> <span data-start="249.76" data-end="253.819">These new applications are possible because of this improvement in performance, because</span> <span data-start="253.819" data-end="260.29">of this inflection point ten years ago that we have the applications that we do today.</span> <span data-start="260.29" data-end="264.11">That's why it's interesting that we may be approaching another one of these inflection</span> <span data-start="264.11" data-end="273.34">points and the speed of code running on the web with WebAssembly [sound cut] to do this,</span> <span data-start="273.34" data-end="279.14">I need to explain a little bit where JavaScript spends its time today.</span> <span data-start="279.14" data-end="285.14">Here's a diagram of where the JS engine spends its time for an hypothetical app.</span> <span data-start="285.14" data-end="288.41">Any app will be different.</span> </p>
<p><span data-start="288.41" data-end="290.71">We can use it to build up a mental model.</span> <span data-start="290.71" data-end="296.17">You may have seen diagrams like this one before and be confused why there are fewer categories</span> <span data-start="296.17" data-end="297.17">in this one.</span> <span data-start="297.17" data-end="301.01">I've condensed the number of categories so that is it easier to talk about it.</span> <span data-start="301.01" data-end="308.61">These categories are parsing, compiling and optimising, re-optimising, executing the code,</span> <span data-start="308.61" data-end="310.59">and garbage collection.</span> </p>
<p><span data-start="310.59" data-end="315.43">Now, let's look at what this diagram would look like for WebAssembly.</span> <span data-start="315.43" data-end="319.73">You will notice that some of the bars are shorter, and some are missing.</span> <span data-start="319.73" data-end="327.2">In this talk, I want to explain what WebAssembly changes, how it makes the amount of time that</span> <span data-start="327.2" data-end="333.04">the engine spends in these tasks shorter or gets rid of them altogether.</span> <span data-start="333.04" data-end="340.44">But first, let's look at where JS engines would be if we had not introduced the JIT.</span> <span data-start="340.44" data-end="344.07">In the early days of JavaScript, this diagram would have looked more like this.</span> <span data-start="344.07" data-end="347.87">There was parsing, running the code, and garbage collection.</span> </p>
<p><span data-start="347.87" data-end="350.36">We're maybe an execution bar shorter.</span> <span data-start="350.36" data-end="356.25">What made that rub faster was the introduction of a JIT, the overhead it added, the compiling</span> <span data-start="356.25" data-end="358.81">and optimising.</span> <span data-start="358.81" data-end="363.15">Now with WebAssembly, we want to make these bars even shorter in in order to see how we</span> <span data-start="363.15" data-end="367.59">can do that, we are going to need to dive into the work that the JIT does.</span> <span data-start="367.59" data-end="373.38">I'm going into a quick crashing course of Just In Time compilers.</span> <span data-start="373.38" data-end="375.91">This is an overview.</span> <span data-start="375.91" data-end="379.68">Different engines have different architectures and those architectures have changed over</span> <span data-start="379.68" data-end="384.66">time but most apply to most of them right now.</span> <span data-start="384.66" data-end="386.81">This is be review for some of you but I will be quick.</span> <span data-start="386.81" data-end="391.3">I want to make sure we are all up to speed on this.</span> <span data-start="391.3" data-end="394.81">When you're developing, you have a goal and a problem.</span> <span data-start="394.81" data-end="400.2">Your goal is that you want to tell the computer what to do.</span> <span data-start="400.2" data-end="404.79">The problem is that you speak a human language and the machine speaks a machine language.</span> <span data-start="404.79" data-end="409.27">Even if you don't think of JavaScript as a human language, it really is.</span> </p>
<p><span data-start="409.27" data-end="416.3">Because it's been designed for human cognition, not for machine cognition.</span> <span data-start="416.3" data-end="419.09">I think of this like the movie Arrival.</span> <span data-start="419.09" data-end="423.33">We have aliens and humans trying to communicate with one another.</span> <span data-start="423.33" data-end="429.44">It's not as easy as translating word-for-word from one language to the other because the</span> <span data-start="429.44" data-end="433.12">two groups actually have different ways of seeing the world, and that's true of humans</span> <span data-start="433.12" data-end="434.46">and machines too.</span> <span data-start="434.46" data-end="440.09">I will explain more about the differences in the way we think later, but let's look</span> <span data-start="440.09" data-end="443.65">at the process of translating.</span> <span data-start="443.65" data-end="447.22">In programming, there are generally two ways of translating.</span> <span data-start="447.22" data-end="450.46">You can either use an interpreter or a compiler.</span> <span data-start="450.46" data-end="455.83">With an interpreter, the translation happens pretty much on the fly, line-by-line.</span> </p>
<p><span data-start="455.83" data-end="462.02">A compiler, on the other hand, doesn't translate on the fly.</span> <span data-start="462.02" data-end="467.86">It takes time ahead of time to create that translation and then hand it off.</span> <span data-start="467.86" data-end="472.36">There are pros and cons to each of these ways of handling this translation.</span> <span data-start="472.36" data-end="476.24">So, for an interpreter, some of the pros are that it is quick to get up and running.</span> <span data-start="476.24" data-end="479.46">You get that immediate feedback loop.</span> </p>
<p><span data-start="479.46" data-end="483.081">So an interpreter seems like a natural fit for something like JavaScript where you want</span> <span data-start="483.081" data-end="485.94">the developer to see their progress really quickly.</span> <span data-start="485.94" data-end="491.81">And that's why, in the beginning, browsers used JavaScript interpreters, but the trade-off</span> <span data-start="491.81" data-end="495.37">is that, when you're doing something like a loop where you have to run the same code</span> <span data-start="495.37" data-end="500.34">over and over again, you're doing that translation over and over again.</span> <span data-start="500.34" data-end="503.12">The compiler has opposite trade-offs.</span> <span data-start="503.12" data-end="506.36">It takes a little bit more time to start up because it has to go through that compilation</span> <span data-start="506.36" data-end="507.46">step ahead of time.</span> </p>
<p><span data-start="507.46" data-end="511.3">But then you don't incur that translation cost in loops where you're running the code</span> <span data-start="511.3" data-end="512.99">over and over again.</span> <span data-start="512.99" data-end="518.62">And another difference is that interpreters are running during the execution of the code,</span> <span data-start="518.62" data-end="522.52">so they can't take too much time to actually think about how the machine thinks and what</span> <span data-start="522.52" data-end="526.11">the optimal way to communicate with the machine is.</span> </p>
<p><span data-start="526.11" data-end="529.08">Since compilers are working ahead of time, they can take that little bit of extra time</span> <span data-start="529.08" data-end="531.57">and think about how best to communicate with the machine.</span> <span data-start="531.57" data-end="536.4">You will hear that referred to as optimisation.</span> <span data-start="536.4" data-end="540.8">To get the best of both worlds, browsers mixed compilers in.</span> </p>
<p><span data-start="540.8" data-end="548.11">They added a new part of the JavaScript engine called a monitor or a profiler.</span> <span data-start="548.11" data-end="550.84">The monitor watches the code as it runs.</span> <span data-start="550.84" data-end="555.32">It keeps track of things, like how often a function has been executed.</span> <span data-start="555.32" data-end="560.04">At first, the monitor just runs everything through the interpreter.</span> <span data-start="560.04" data-end="565.77">If the same function is run a few times, that function is called "warm".</span> <span data-start="565.77" data-end="570.21">As a function warms up, it gets it off the baseline compiler to create a compiled version</span> <span data-start="570.21" data-end="571.94">of it.</span> <span data-start="571.94" data-end="577.17">The baseline compiler will do it in chunks.</span> <span data-start="577.17" data-end="581.13">Each operation in the function is going to be compiled to one or more Stubbs.</span> <span data-start="581.13" data-end="585.2">So, for example, the plus and equals sign will be an operation.</span> <span data-start="585.2" data-end="589.4">The compiler would create a stub for that and the stub would be specific to whatever</span> <span data-start="589.4" data-end="593.11">types are being used on either side of that operator.</span> <span data-start="593.11" data-end="601.26">So, if the sum in the array element here were integers, it would compile to integer addition.</span> <span data-start="601.26" data-end="606.27">If the monitor has set operation again with the same variable time, so with integers again,</span> <span data-start="606.27" data-end="609.27">it pulls out the stub it has and uses that.</span> <span data-start="609.27" data-end="615.07">If it runs into operation with different variable types, it will create another stub and store</span> <span data-start="615.07" data-end="617.15">that one as well.</span> </p>
<p><span data-start="617.15" data-end="622.22">As the code runs, more baseline Stubbs for more operations will be filled in and this</span> <span data-start="622.22" data-end="626.45">will save on translation time and help speed, up.</span> <span data-start="626.45" data-end="629.81">Like I mentioned, there is more a compiler can do.</span> <span data-start="629.81" data-end="633.24">It can take some time thinking about how the machine thinks go and how best to think with</span> <span data-start="633.24" data-end="637.59">the machine.</span> </p>
<p><span data-start="637.59" data-end="643.21">The baseline compiler will make some optimisations, but it doesn't want to take up too much time</span> <span data-start="643.21" data-end="647.08">because the code is executing at the same time.</span> <span data-start="647.08" data-end="651.89">But if the code is really hot, if it has been run a whole bunch, then it can be worthwhile</span> <span data-start="651.89" data-end="655.95">to go through and take the time to make that optimisation.</span> <span data-start="655.95" data-end="660.83">So, when a part of the code is very hot, the monitor will send it to the optimising compiler</span> <span data-start="660.83" data-end="665.91">and this will create another even faster version of that function.</span> <span data-start="665.91" data-end="670.04">In order to make the faster version of the function, the optimising compiler has to make</span> <span data-start="670.04" data-end="672.28">some assumptions.</span> <span data-start="672.28" data-end="675.76">For example, if it can assume that all of the objects that are created by a particular</span> <span data-start="675.76" data-end="681.44">constructor had the same shape, so the object has the same property names, and they've been</span> <span data-start="681.44" data-end="687.51">added in the same order, then it can cut some corners based on that.</span> <span data-start="687.51" data-end="692.12">So the optimising compiler uses the information that the monitor has been gathering to make</span> <span data-start="692.12" data-end="693.12">these judgments.</span> <span data-start="693.12" data-end="697.22">If something has been true for all previous passes through the code, then it assumes it's</span> <span data-start="697.22" data-end="700.22">going to continue to be true.</span> <span data-start="700.22" data-end="704.73">Of course, with JavaScript there are never any guarantees.</span> </p>
<p><span data-start="704.73" data-end="710.131">You could have 99 objects that all have the same shape but then the 100th object has a</span> <span data-start="710.131" data-end="714.22">different property, or a property has been deleted on it.</span> <span data-start="714.22" data-end="718.23">So the compiled code needs to check before it runs to see whether the assumptions are</span> <span data-start="718.23" data-end="721.91">valid, and if they are, then the compiled code runs.</span> <span data-start="721.91" data-end="728.17">But if not, the JIT assumes it made the wrong assumptions and trashes the optimised code.</span> </p>
<p><span data-start="728.17" data-end="733.9">At this point the it goes back to the compiled version and this is called de-optimisation</span> <span data-start="733.9" data-end="737.29">or bailing out.</span> <span data-start="737.29" data-end="741.62">Usually optimising compilers will save you time, they will actually make the code run</span> <span data-start="741.62" data-end="743.23">faster.</span> <span data-start="743.23" data-end="749.5">But if you have code that keeps gets optimised and then gets bailed out on and then gets</span> <span data-start="749.5" data-end="754.5">optimised again, if you get into the cycles, it can actually take more time than it would</span> <span data-start="754.5" data-end="758.73">have just running through the baseline compiled version of the videoed.</span> <span data-start="758.73" data-end="763.03">So a jot of JITs will keep track of how many times they've tried to optimise a function,</span> <span data-start="763.03" data-end="768.61">and if it keeps not working out, then will he will mark it as don't even try optimising</span> <span data-start="768.61" data-end="771.96">this again.</span> <span data-start="771.96" data-end="774.029">So that is the JIT in a nutshell.</span> <span data-start="774.029" data-end="777.94">Code starts off running in an interpreter and the monitor collects information about</span> <span data-start="777.94" data-end="778.94">it.</span> <span data-start="778.94" data-end="783.1">Then it will send code off to be compiled depending how often that part of the code</span> <span data-start="783.1" data-end="786.1">is being run.</span> </p>
<p><span data-start="786.1" data-end="791.251">Now that we understand more about the work that the JavaScript engine is doing, let's</span> <span data-start="791.251" data-end="797.24">look at ways to maybe make this execution go a little faster.</span> <span data-start="797.24" data-end="801.65">One way would be to get rid of some of the overhead, so we can move some of this ahead</span> <span data-start="801.65" data-end="804.05">of time.</span> <span data-start="804.05" data-end="806.52">But in order to do that, we would need to get rid of the dynamic types.</span> </p>
<p><span data-start="806.52" data-end="810.99">If we are going to be optimising ahead of time, we need the types to be explicit in</span> <span data-start="810.99" data-end="815.79">the code, because we aren't going to be monitoring it at runtime and see what types are running</span> <span data-start="815.79" data-end="816.79">through it.</span> <span data-start="816.79" data-end="821.55">These dynamic types that can change at runtime are a problem.</span> <span data-start="821.55" data-end="827.52">I already suggested that is what made JavaScript successful: the dynamic types help developers</span> <span data-start="827.52" data-end="829.79">get up and running quickly.</span> <span data-start="829.79" data-end="834.25">Why we would want to change something that made JavaScript successful?</span> <span data-start="834.25" data-end="838.21">I want to be clear here that we don't have to change anything in JavaScript to take advantage</span> <span data-start="838.21" data-end="843.17">of the benefits of WebAssembly, but there is a change that's already happening which</span> <span data-start="843.17" data-end="848.73">we can take advantage of, and that is the move towards modularity.</span> <span data-start="848.73" data-end="853.91">Over the past few years, both with PHM and the 2015 module expect, JavaScript has become</span> <span data-start="853.91" data-end="862.1">a more methodised ecosystem, and the nice thing about modules is they provide boundaries.</span> <span data-start="862.1" data-end="865.54">You don't really need to know about the inner details of a module that you're depending</span> <span data-start="865.54" data-end="870.96">on, so these modules, they could compiled ahead of time using a language that doesn't</span> <span data-start="870.96" data-end="875.44">have these flexible types that JavaScript does, and it wouldn't affect how you code.</span> </p>
<p><span data-start="875.44" data-end="882.48">Take, for example, React which has a lot of different consumers.</span> <span data-start="882.48" data-end="888.18">The React core team has already been working on making their reconciliation algorithm faster.</span> <span data-start="888.18" data-end="895.13">An option for them would be to write the new reconciliation algorithm and something like</span> <span data-start="895.13" data-end="899.34">C and then compile it ahead of time.</span> <span data-start="899.34" data-end="904.22">But as long as they keep the API the same, consumers of React actually wouldn't notice</span> <span data-start="904.22" data-end="905.22">this.</span> </p>
<p><span data-start="905.22" data-end="910.63">When they update the code, the only thing they would notice is any performance improvements.</span> <span data-start="910.63" data-end="914.55">So this is what WebAssembly does: it makes it possible for library authors and application</span> <span data-start="914.55" data-end="919.15">developers to code in languages that are more consistently conformant, but then to have</span> <span data-start="919.15" data-end="923.16">that code run on the web like JavaScript does and to integrate with existing JavaScript.</span> <span data-start="923.16" data-end="928.31">This means that you will be able to benefit from WebAssembly without having to understand</span> <span data-start="928.31" data-end="934">it or why it's fast, but I always find it more rewarding when I do understand that stuff.</span> <span data-start="934" data-end="938.87">So I'm going ahead and walk you through how WebAssembly works.</span> <span data-start="938.87" data-end="942.35">In order to do that, I'm going to have through another crash course, this time in assembly</span> <span data-start="942.35" data-end="944.279">and compilers.</span> <span data-start="944.279" data-end="950.54">I talked about how communicating with the machine is like communicating with an alien.</span> <span data-start="950.54" data-end="954.31">I want to take a look now at how that alien brain works.</span> <span data-start="954.31" data-end="958.36">How the communication that is coming into it gets parsed and understood.</span> <span data-start="958.36" data-end="966.31">There is a part of this alien brain that is dedicated to the thinking — like adding, subtracting,</span> <span data-start="966.31" data-end="967.31">and logic.</span> </p>
<p><span data-start="967.31" data-end="970.43">There is also a part of the brain near that which is the short-term memory.</span> <span data-start="970.43" data-end="974.48">Those parts are pretty close together in the same part of the brain.</span> <span data-start="974.48" data-end="980.08">Then there are some longer-term memory.</span> <span data-start="980.08" data-end="982.81">These different parts have different names.</span> <span data-start="982.81" data-end="989.05">So the part that does the thinking is the earth, medic, and logic unit, the ALIO.</span> <span data-start="989.05" data-end="990.73">The short-term memory, those are called registers.</span> <span data-start="990.73" data-end="996.12">That is encapsulated in the central processing unit, or the CPO.</span> <span data-start="996.12" data-end="1001.33">The longer term memory, that's random access memory or RAM.</span> <span data-start="1001.33" data-end="1006.66">Each part of the short-term memory has a name and this makes it easy for the brain to understand</span> <span data-start="1006.66" data-end="1011.07">what it should be working on at any given time.</span> <span data-start="1011.07" data-end="1013.75">The sentence is in machine instructions.</span> <span data-start="1013.75" data-end="1020.81">When a sentence gets into the brain, it gets split in a way that means different things.</span> </p>
<p><span data-start="1020.81" data-end="1025.43">The way the sentence will be split up will be very specific to the wiring of this particular</span> <span data-start="1025.43" data-end="1026.939">brain.</span> <span data-start="1026.939" data-end="1030.74">For example, this brain might take the fourth through the tenth bit and pipe it through</span> <span data-start="1030.74" data-end="1036.73">the ALIO and based on where there are ones and zeroes, the ALIO will figure out what</span> <span data-start="1036.73" data-end="1041.24">it is supposed to do for this instruction.</span> <span data-start="1041.24" data-end="1046.16">Then the brain would take the next two chunks to figure out what it needs to do that operation</span> <span data-start="1046.16" data-end="1052.29">on and these will be the addresses of registers.</span> <span data-start="1052.29" data-end="1056.98">You will see I've been adding annotations above the machine code here, which makes it</span> <span data-start="1056.98" data-end="1060.07">easier for us as humans to know what is going on with this machine code.</span> <span data-start="1060.07" data-end="1064.6">That is what the assembly is — symbolic machine code.</span> <span data-start="1064.6" data-end="1070.91">It is a way of human beings being able to read and understand machine code.</span> <span data-start="1070.91" data-end="1075.29">You can see here there is a one-to-one relationship between the assembly and the machine code</span> <span data-start="1075.29" data-end="1078.06">for this machine.</span> <span data-start="1078.06" data-end="1081.01">Something you might have figured out from that is that you actually have a different</span> <span data-start="1081.01" data-end="1086.93">kind of assembly for each kind of wiring you have for a machine.</span> </p>
<p><span data-start="1086.93" data-end="1090.29">Any time that you have a different architecture inside of a machine, any time there's a different</span> <span data-start="1090.29" data-end="1095.54">kind of brain in the machine, there's a good chance it will have its own assembly.</span> <span data-start="1095.54" data-end="1098.99">So we're not talking about the targets this translation just being one thing, just being</span> <span data-start="1098.99" data-end="1104.26">one kind of machine code, it is many different kinds of machine code.</span> <span data-start="1104.26" data-end="1108.89">Just as we speak different languages as humans, machines speak different languages.</span> <span data-start="1108.89" data-end="1115.53">So, if we are talking human to alien translation, you may be going from English or Russian,</span> <span data-start="1115.53" data-end="1123.17">or Mandarin to alien language A or alien language B. In programming terms, this is like going</span> <span data-start="1123.17" data-end="1126.97">from C plus, CLL or Rust to ARM.</span> </p>
<p><span data-start="1126.97" data-end="1133.17">If you want to go down to the high-level programming languages down to assembly languages, you're</span> <span data-start="1133.17" data-end="1137.96">going to have to create a whole bunk of different translators.</span> <span data-start="1137.96" data-end="1139.91">That would be pretty inefficient.</span> <span data-start="1139.91" data-end="1142.99">Most compilers put at least one layer in between.</span> <span data-start="1142.99" data-end="1147.27">The compiler will take the high-lex programming language and translate it down to something</span> <span data-start="1147.27" data-end="1154.23">that's not quite as high level but not as low level as machine code.</span> <span data-start="1154.23" data-end="1157.48">And this is called an intermediate representation.</span> <span data-start="1157.48" data-end="1160.99">The compiler will take any one of the higher level programming languages and go down to</span> <span data-start="1160.99" data-end="1165.75">the single intermediate representation and go from the intermediate representation to</span> <span data-start="1165.75" data-end="1168.39">any one of the assembly languages.</span> </p>
<p><span data-start="1168.39" data-end="1171.73">The thing that goes from the higher level programming language to the intermediate representation</span> <span data-start="1171.73" data-end="1176.38">is called the front-end; anything that goes from the intermediate representation down</span> <span data-start="1176.38" data-end="1181.37">to the assembly is called the back-end.</span> <span data-start="1181.37" data-end="1185">Now where does WebAssembly fit into this picture?</span> <span data-start="1185" data-end="1192.05">You might think that it is one of these target assembly languages which is kind of true except</span> <span data-start="1192.05" data-end="1196.66">that each one of those languages corresponded to a particular architecture, and when you're</span> <span data-start="1196.66" data-end="1200.36">delivering code across the web, you don't actually know what architecture you're going</span> <span data-start="1200.36" data-end="1202.27">to be running on.</span> <span data-start="1202.27" data-end="1205.5">So WebAssembly's a little bit different from normal assembly.</span> </p>
<p><span data-start="1205.5" data-end="1212.6">It is a machine language for a conceptual machine, not an actual physical machine.</span> <span data-start="1212.6" data-end="1216.95">Once the browser downloads the WebAssembly, it can make the short hop between the WebAssembly</span> <span data-start="1216.95" data-end="1222.45">code and the actual assembly code for that particular architecture.</span> <span data-start="1222.45" data-end="1226.56">Let's walk through the tools that a developer of a library like React would use to make</span> <span data-start="1226.56" data-end="1229.73">their code WebAssembly.</span> <span data-start="1229.73" data-end="1234.24">The compiler has a lot of work to go into it for web assembly called LLVM.</span> </p>
<p><span data-start="1234.24" data-end="1239.25">There are a number of different frontends and backends.</span> <span data-start="1239.25" data-end="1248.12">If we wanted to go from C to WebAssembly we might use Clang taking us down to the representation,</span> <span data-start="1248.12" data-end="1254.42">and once the code is in the intermediate representation, LLVM can do some optimisation for us because</span> <span data-start="1254.42" data-end="1256.56">it understands it at that point.</span> <span data-start="1256.56" data-end="1260.51">Then we want to go from the intermediate representation down to WebAssembly.</span> <span data-start="1260.51" data-end="1267.8">There is a process that will go all the way from LLVM to WebAssembly but you might not</span> <span data-start="1267.8" data-end="1276.48">want to use it until it's fully finished and there is another tool which has a FA Cup finished</span> <span data-start="1276.48" data-end="1281.35">WebAssembly backend, using a fork of LLVM under the hood.</span> <span data-start="1281.35" data-end="1286.429">Even when the LLVM back-up is done, you might want to use some script in to compile your</span> <span data-start="1286.429" data-end="1287.429">code at present.</span> <span data-start="1287.429" data-end="1293.64">It can be useful to pack in useful libraries, things like a file system that works on top</span> <span data-start="1293.64" data-end="1296.23">of index.db.</span> <span data-start="1296.23" data-end="1303.67">Regardless of whether you're using LLVM or sciptum together, the end resulted is .wazm</span> <span data-start="1303.67" data-end="1306.9">for web assembly.</span> <span data-start="1306.9" data-end="1311.79">This can be loaded in JavaScript.</span> <span data-start="1311.79" data-end="1315.54">Right now, the way that you load it in JavaScript is a little bit complicated.</span> </p>
<p><span data-start="1315.54" data-end="1317.66">We're making that easier.</span> <span data-start="1317.66" data-end="1323.5">Webpack has plans to work on it and other module owners plan to work on it.</span> <span data-start="1323.5" data-end="1329.429">Once the browser has a built-in module support, WebAssembly can use that too.</span> <span data-start="1329.429" data-end="1333.98">It should be as easy as loading a JavaScript module.</span> <span data-start="1333.98" data-end="1336.65">When I say that, though, I should add a caveat.</span> <span data-start="1336.65" data-end="1341.25">Loading a WebAssembly module should be as he's an as loading a JavaScript 1 but working</span> <span data-start="1341.25" data-end="1345.59">with it is going to be a little bit different.</span> <span data-start="1345.59" data-end="1350.05">Let's say you're calling a WebAssembly function from JavaScript, and this is the JavaScript</span> <span data-start="1350.05" data-end="1351.23">function.</span> <span data-start="1351.23" data-end="1355.19">And this is the WebAssembly function.</span> </p>
<p><span data-start="1355.19" data-end="1359.62">Functions in WebAssembly can only take WebAssembly types as parameters, and at the moment, that's</span> <span data-start="1359.62" data-end="1365.88">numbers, so integers, floats, that's what you're working with.</span> <span data-start="1365.88" data-end="1369.92">That's different from regular JavaScript modules.</span> <span data-start="1369.92" data-end="1372.64">And the same restriction applies to return values as well.</span> <span data-start="1372.64" data-end="1377.12">But what if you want to be able to return a string?</span> <span data-start="1377.12" data-end="1379.11">You can't do it.</span> <span data-start="1379.11" data-end="1384.29">For any data types that are more complex, you need to put them in the WebAssembly module's</span> <span data-start="1384.29" data-end="1387.43">memory.</span> <span data-start="1387.43" data-end="1389.1">So this memory is an array buffer.</span> <span data-start="1389.1" data-end="1392.96">It is just a JavaScript object that simulates a heap.</span> <span data-start="1392.96" data-end="1397.75">The integers that get passed back and forth can be used kind of like pointers into this</span> <span data-start="1397.75" data-end="1399.36">heap.</span> <span data-start="1399.36" data-end="1403.41">So the C code can use that to write to the memory as if it were an address and then the</span> <span data-start="1403.41" data-end="1407.33">JavaScript can use that number to figure out the array index that it needs to pull the</span> <span data-start="1407.33" data-end="1410.21">value from.</span> </p>
<p><span data-start="1410.21" data-end="1414.23">It's likely that anybody who's developing a WebAssembly module for developers is going</span> <span data-start="1414.23" data-end="1418.32">to create a wrapper around it so you don't actually need to know about that.</span> <span data-start="1418.32" data-end="1422.95">I think it helps to understand the performance characteristics, understanding how the memory</span> <span data-start="1422.95" data-end="1424.07">works.</span> <span data-start="1424.07" data-end="1430.62">What I want to do now is go back to the diagram and look at what it is about WebAssembly that</span> <span data-start="1430.62" data-end="1432.49">can make things run faster.</span> </p>
<p><span data-start="1432.49" data-end="1437.81">So, first off, this isn't actually shown in the diagram, but it can take less time to</span> <span data-start="1437.81" data-end="1444.59">download WebAssembly than JavaScript because it is more compact.</span> <span data-start="1444.59" data-end="1450.19">It was designed specifically to be compact, and it can also be translated into a binary</span> <span data-start="1450.19" data-end="1455.52">form, even though JavaScript is pretty small, if you have equivalent code in WebAssembly,</span> <span data-start="1455.52" data-end="1459.58">it is likely it will be smaller.</span> <span data-start="1459.58" data-end="1462.58">Parsing takes less time than JavaScript too.</span> <span data-start="1462.58" data-end="1467.07">JavaScript needs to be parsed from the source into an abstract syntax tree and then usually</span> <span data-start="1467.07" data-end="1475.76">converted into an intermediate engine called bytecode.</span> <span data-start="1475.76" data-end="1477.5">WebAssembly is already a bytecode.</span> <span data-start="1477.5" data-end="1484.85">It just needs to be decoded from that binary version, and decoding is faster than parsing.</span> <span data-start="1484.85" data-end="1488.169">Compiling takes less time, because a lot of it has been done ahead of time before the</span> <span data-start="1488.169" data-end="1490.75">file was even put up to the server.</span> </p>
<p><span data-start="1490.75" data-end="1494.11">Plus the compiler doesn't have to dominate pile those multiple baseline Stubbs that it</span> <span data-start="1494.11" data-end="1496.75">was doing before for the dynamic types.</span> <span data-start="1496.75" data-end="1504.11">And you don't get into the optimise and de-optimisation cycles that you did with the JIT.</span> <span data-start="1504.11" data-end="1509.429">Running your code is fast because many of the optimisations that JIT makes to JavaScript</span> <span data-start="1509.429" data-end="1512.99">just aren't necessary with WebAssembly.</span> <span data-start="1512.99" data-end="1517.309">Plus WebAssembly itself provides many instructions that are just faster.</span> <span data-start="1517.309" data-end="1522.211">Human programmers don't need to program WebAssembly directly so that means its designers can create</span> <span data-start="1522.211" data-end="1527.919">something closer to how machines think so depending on what kind of code your code is</span> <span data-start="1527.919" data-end="1534.79">doing, these instructions can run anywhere to 800 per cent faster.</span> </p>
<p><span data-start="1534.79" data-end="1540.28">As for bar engage collection, the manuals now use memory management.</span> <span data-start="1540.28" data-end="1541.28">This is likely to change.</span> <span data-start="1541.28" data-end="1543.64">I will explain more about that later.</span> <span data-start="1543.64" data-end="1547.91">For now, you don't need to worry about garbage collection.</span> </p>
<p><span data-start="1547.91" data-end="1551.85">So what is the status of WebAssembly right now?</span> <span data-start="1551.85" data-end="1555.74">In late February, the browser vendors announced that WebAssembly was ready to ship all by</span> <span data-start="1555.74" data-end="1558.179">defaults in browsers.</span> <span data-start="1558.179" data-end="1562.82">We started ship it on by default in Firefox the next week, and then Chrome did the week</span> <span data-start="1562.82" data-end="1567.56">after that, and it's in preview versions in Edge and Safari.</span> <span data-start="1567.56" data-end="1572.22">With this, developers can start shipping WebAssembly code for.</span> <span data-start="1572.22" data-end="1577.23">For earlier versions of browsers that don't support WebAssembly, you can ship down an</span> <span data-start="1577.23" data-end="1578.23">as JS version.</span> <span data-start="1578.23" data-end="1580.179">It is the precursor to web assembly.</span> <span data-start="1580.179" data-end="1583.21">It is fully JS.</span> <span data-start="1583.21" data-end="1587.86">What is in browsers is the MVP — the minimum viable product.</span> <span data-start="1587.86" data-end="1591.799">The MVP doesn't contain all the features that the community group wants but with it, WebAssembly</span> <span data-start="1591.799" data-end="1593.919">is reasonably fast and usable.</span> <span data-start="1593.919" data-end="1597.76">However, it should get even faster in the future through a combination of fixes in the</span> <span data-start="1597.76" data-end="1600.16">engines and new features in the spec.</span> <span data-start="1600.16" data-end="1605.1">For example, a fix that needs to happen in Firefox specifically is that currently calling</span> <span data-start="1605.1" data-end="1610.34">a web assembly function in JS code is slower than it needs to be because of something called</span> <span data-start="1610.34" data-end="1611.34">trampolining.</span> </p>
<p><span data-start="1611.34" data-end="1616.91">Instead of the JIT knowing how to deal with WebAssembly code it has to go through a transfer</span> <span data-start="1616.91" data-end="1621.559">function controlling from JavaScript to WebAssembly.</span> <span data-start="1621.559" data-end="1626.59">This is a lot slower than it would if the JIT knew how to handle this function itself.</span> <span data-start="1626.59" data-end="1627.59">Slower is relative.</span> <span data-start="1627.59" data-end="1629.94">We're only talking nanoseconds here.</span> <span data-start="1629.94" data-end="1634.11">But if you have lots of back-and-forth communication between WebAssembly and JavaScript, you can</span> <span data-start="1634.11" data-end="1636.79">notice that.</span> </p>
<p><span data-start="1636.79" data-end="1640.01">So that's the kind of fix that you can expect in the engine.</span> <span data-start="1640.01" data-end="1644.13">As for the spec, there are a number of features that are coming soon.</span> <span data-start="1644.13" data-end="1647.99">One that is expected reasonably soon is threading.</span> <span data-start="1647.99" data-end="1651.11">One way to speed up the code is to make it possible for different parts of the code to</span> <span data-start="1651.11" data-end="1656.13">run at the same time in parallel, but this can staples backfire since the overhead of</span> <span data-start="1656.13" data-end="1661.14">communication between threads can take up more than time it would have to just run that</span> <span data-start="1661.14" data-end="1662.7">all sequentially.</span> <span data-start="1662.7" data-end="1667.3">But if you share memory between the threads, it reduces this overhead.</span> <span data-start="1667.3" data-end="1672.65">To do this, WebAssembly will use the new shared array buffer that's being shipped?</span> <span data-start="1672.65" data-end="1674.07">Browsers shortly.</span> <span data-start="1674.07" data-end="1678.679">Once that is in place in browsers, the community group can start specifying how WebAssembly</span> <span data-start="1678.679" data-end="1680.44">will use it.</span> <span data-start="1680.44" data-end="1685.03">On feature in a needs to be standardised is direct ARM access.</span> <span data-start="1685.03" data-end="1692.89">Currently, there's no way to interact it the DOM doing element.htmls.</span> </p>
<p><span data-start="1692.89" data-end="1699.4">Instead, you have to go through JS to set that value.</span> <span data-start="1699.4" data-end="1704.37">The community group is currently working on adding DOM support, though.</span> <span data-start="1704.37" data-end="1710.63">One last feature that has a lot of folks excited is integration with the browser's bar engage</span> <span data-start="1710.63" data-end="1711.63">collection.</span> <span data-start="1711.63" data-end="1716.91">So, today, you can ship down your own garbage collector with code if you want to but is</span> <span data-start="1716.91" data-end="1725.62">slow for a few reasons and the community group isn't making it possible for WebAssembly code</span> <span data-start="1725.62" data-end="1731.49">to be used with just the built-in GC which is a highly optimised one that the browsers</span> <span data-start="1731.49" data-end="1735.34">have been working on, so it will run fast and you will have that integration.</span> <span data-start="1735.34" data-end="1738.71">Unfortunately, that's all I have time talk about today, so I'm going to have to wrap</span> <span data-start="1738.71" data-end="1745.059">it up I had a fantastic technical review on this from Luke Wagner.</span> <span data-start="1745.059" data-end="1751.53">He is the person who came up with the way to add types in azm.js and did a lot of the</span> <span data-start="1751.53" data-end="1753.08">work to push WebAssembly forward.</span> </p>
<p><span data-start="1753.08" data-end="1759.79">He is with us today and will be doing a Q and A about WebAssembly in the Mozilla space</span> <span data-start="1759.79" data-end="1760.79">about lunch.</span> <span data-start="1760.79" data-end="1766.559">Feel free to ask us questions, orb you can ask on Twitter or we will both be at the party</span> <span data-start="1766.559" data-end="1767.559">tonight.</span> <span data-start="1767.559" data-end="1769.57">Thank you to him.</span> <span data-start="1769.57" data-end="1770.57">And thank you all for listening.</span> <span data-start="1770.57" data-end="1771.57">[Cheering].</span> <span data-start="1771.57" data-end="1772.57">[Applause].</span> <span data-start="1772.57" data-end="1773.57"Audience member: Thank you for the fantastic talk.</span> <span data-start="1773.57" data-end="1774.57">We're going to continue right on to the next talk.</span> <span data-start="1774.57" data-end="1775.57">If anybody wants to move to the side track, there is going to be a great talk about sharing</span> <span data-start="1775.57" data-end="1777.12">is caring, patterns for JavaScript library design, and give us a minute to set up and</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
