<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>99QyAz3Wfqc</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/99QyAz3Wfqc?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="9.5" data-end="10.269">So, hello, everyone.</span> <span data-start="10.269" data-end="15.909">My name is Miguel Jimenez and I work for the JavaScript Foundation team for Facebook London.</span> <span data-start="15.909" data-end="20.49">And I'm going to be talking to you today about scaling JavaScript build systems.</span> <span data-start="20.49" data-end="23.519">And more specifically, I'm going to be talking about Metro.</span> <span data-start="23.519" data-end="31.08">I would like to show you a video about what the development process of React Native is.</span> <span data-start="31.08" data-end="38.69">For those who don't know what React Native is, it's a framework by Facebook to use JavaScript</span> <span data-start="38.69" data-end="45.199">to create hybrid mobile applications and uses React as well in order to represent the layout.</span> <span data-start="45.199" data-end="46.949">This is the process.</span> <span data-start="46.949" data-end="49.219">You change things into your editor.</span> </p>
<p><span data-start="49.219" data-end="53.5">We have the iOS and the emulator catching it immediately.</span> <span data-start="53.5" data-end="58.91">You can change layouts and colors.</span> <span data-start="58.91" data-end="62.539">Those emulators will reflect your changes almost immediately.</span> <span data-start="62.539" data-end="68.45">And the piece of infrastructure that is powering off of these interactions is actually Metro.</span> <span data-start="68.45" data-end="74.42">So, to define it in a more formal way, we can say it's the development platform for</span> <span data-start="74.42" data-end="75.42">React Native.</span> <span data-start="75.42" data-end="83.65">And does that by exposing an HTTP server so client, layers can communicate and exposes</span> <span data-start="83.65" data-end="86.52">a web socket server.</span> <span data-start="86.52" data-end="93.11">It can build JavaScript and does other stuff.</span> <span data-start="93.11" data-end="94.88">It deals with assets.</span> <span data-start="94.88" data-end="100.899">When you want to add a photo or video, Metra adds this.</span> <span data-start="100.899" data-end="107.52">It provides hot loading and it's extensible because the main interface is a function that</span> <span data-start="107.52" data-end="109.829">works with Node's callback.</span> </p>
<p><span data-start="109.829" data-end="115.07">Use that on the Node project or an express object.</span> <span data-start="115.07" data-end="119.09">And last, but not least, it's used in the building process.</span> <span data-start="119.09" data-end="124.45">If you have the app ready and you want to ship to the building source.</span> <span data-start="124.45" data-end="134.61">Part of the building process whether it's X code for iOS or Android Studio, the process</span> <span data-start="134.61" data-end="142.64">of taking your JavaScript application and putting that inside already done by Metra.</span> <span data-start="142.64" data-end="147.63">Based on what we just explained, it look like there are a lot of alternatives in the open</span> <span data-start="147.63" data-end="151.77">source world that pretty much fulfill all of these goals.</span> <span data-start="151.77" data-end="153.99">Why is Facebook building Metro?</span> <span data-start="153.99" data-end="155.23">There are a couple of reasons.</span> <span data-start="155.23" data-end="158.36">We to want make it fast.</span> <span data-start="158.36" data-end="160.89">And by fast, I mean, really fast.</span> </p>
<p><span data-start="160.89" data-end="165.14">Our scale currently is at the tens of thousands of JavaScript modules.</span> <span data-start="165.14" data-end="169.01">And we're aiming to be able to perform reloads on a sub second basis.</span> <span data-start="169.01" data-end="174.5">So, dealing with such a large amount of code in so small time requires you to have a specific</span> <span data-start="174.5" data-end="178.01">setup that we'll discuss in a minute.</span> <span data-start="178.01" data-end="180.87">The second thing is we want it to be scalable.</span> <span data-start="180.87" data-end="184.12">You're probably aware that JavaScript is kind of a trending language.</span> <span data-start="184.12" data-end="185.78">You can see that based on the audience.</span> <span data-start="185.78" data-end="190.9">So, the amount of times we have at Facebook just keeps growing.</span> <span data-start="190.9" data-end="195.42">It has to work not only for today's requirements for these tens of thousands of JavaScript</span> <span data-start="195.42" data-end="200.22">modules, but it also has to work for tomorrow.</span> </p>
<p><span data-start="200.22" data-end="203.17">And the third reason is we want it to be integrated.</span> <span data-start="203.17" data-end="212.12">So, Metra shaped a set of cool features that are integrated into the system.</span> <span data-start="212.12" data-end="217.65">And my preferred one to explain this is the ability of red loading your React Native applications</span> <span data-start="217.65" data-end="221.86">with command RR.</span> <span data-start="221.86" data-end="228.2">The way it works is it brings up a global hot key listener.</span> <span data-start="228.2" data-end="234.41">This gets inside and pushes toward the emulator, so they have to reload.</span> <span data-start="234.41" data-end="238.01">This is for developers in most of the web.</span> <span data-start="238.01" data-end="240.73">It gives them a seamless experience.</span> <span data-start="240.73" data-end="246.54">And you need to have specific control on what your bundler is doing.</span> <span data-start="246.54" data-end="249.65">And last, there's also a little bit of history.</span> <span data-start="249.65" data-end="252.48">React Native was a project started five years ago.</span> </p>
<p><span data-start="252.48" data-end="255.77">And back then, there weren't that many open source solutions.</span> <span data-start="255.77" data-end="260.38">The first iteration for Metra was JS app server.</span> <span data-start="260.38" data-end="271.43">Which was the React Native packager and we made it into what Metra is today.</span> <span data-start="271.43" data-end="277.16">Now that we know what Metra is doing and why we're building it, I would like to get into</span> <span data-start="277.16" data-end="279.59">the technical details of it.</span> <span data-start="279.59" data-end="283.98">We're going to do that by covering all the different processes that are involved in creating</span> <span data-start="283.98" data-end="284.98">a bundle.</span> </p>
<p><span data-start="284.98" data-end="289.34">From the point where you have your code up until you get your app shipped into the app</span> <span data-start="289.34" data-end="292.22">stores and executed by your customers.</span> <span data-start="292.22" data-end="298.07">So, the first part is about monitoring the files on a project.</span> <span data-start="298.07" data-end="301.22">As we said, we have quite a large code base at Facebook.</span> <span data-start="301.22" data-end="304.16">And dealing with such number of files can be slow.</span> <span data-start="304.16" data-end="308.2">Imagine that every single time you had to change a file you needed to re traverse your</span> <span data-start="308.2" data-end="310.13">whole dependency graph.</span> <span data-start="310.13" data-end="314.51">If we're talking about big code bases, this can take quite a lot of time.</span> <span data-start="314.51" data-end="325.72">So, the way it works inside Metra is by using the module from a front project, which is</span> <span data-start="325.72" data-end="326.72">Jest.</span> <span data-start="326.72" data-end="327.72">We use Jest haste map.</span> <span data-start="327.72" data-end="332.59">One of the features is it has the ability of monitoring your file changes and telling</span> <span data-start="332.59" data-end="337.56">you of changes every time it detects something on your file system.</span> </p>
<p><span data-start="337.56" data-end="342.41">Now, in order to achieve this, it uses Watchman as much as possible.</span> <span data-start="342.41" data-end="348.41">This is another open source project from Facebook that monitors the file systems, but as a daemon</span> <span data-start="348.41" data-end="351.06">process.</span> <span data-start="351.06" data-end="356.9">If Metra gets killed and you restart, you don't have to query all of it again.</span> <span data-start="356.9" data-end="362.57">You can query Watchman and get the changes that happened since the last time it was live</span> <span data-start="362.57" data-end="366.74">which dramatically reduces the startup time.</span> <span data-start="366.74" data-end="373.36">However, like all open source projects and general development, people do not have Watchman</span> <span data-start="373.36" data-end="374.53">installed.</span> <span data-start="374.53" data-end="378.33">If we don't see it on the file system, we fall back.</span> <span data-start="378.33" data-end="384.25">This has a startup cost overhead, but after that, they're pretty much the same.</span> <span data-start="384.25" data-end="389.31">So, now that we know all the files that are going to get into our project, the next thing</span> <span data-start="389.31" data-end="392.5">is to transform them.</span> <span data-start="392.5" data-end="399.8">And in that aspect Metra does what any other bundler will do, which is we use Babel.</span> <span data-start="399.8" data-end="404.03">The thing that is a bit different in Metra compared to other bundling systems is the</span> <span data-start="404.03" data-end="405.84">way we execute Metra.</span> </p>
<p><span data-start="405.84" data-end="410.38">Transformation is an expensive process and it can take a lot of time.</span> <span data-start="410.38" data-end="416.74">So, most bundlers will have their main process and they will execute the transpilation process</span> <span data-start="416.74" data-end="418.87">one after another.</span> <span data-start="418.87" data-end="423.58">Take A and B and so on and so forth.</span> <span data-start="423.58" data-end="429.36">If you have a very large code base, this can take actually minutes to happen.</span> <span data-start="429.36" data-end="432.11">Metra uses a different approach.</span> <span data-start="432.11" data-end="438.48">Instead the main process doesn't transform a file, but spawns child professions called</span> <span data-start="438.48" data-end="439.48">workers.</span> <span data-start="439.48" data-end="442.04">Files are sent to the workers.</span> <span data-start="442.04" data-end="448.19">The transpilation happens at the same time and then we return the result back.</span> <span data-start="448.19" data-end="454.98">Now, we spawn approximately one worker per core, meaning a time reduction of 6 7X on</span> <span data-start="454.98" data-end="457.15">a Macbook with eight cores.</span> <span data-start="457.15" data-end="460.96">This cuts building time from minutes to seconds.</span> <span data-start="460.96" data-end="464.68">Which is pretty good.</span> <span data-start="464.68" data-end="469.05">The problem of transpilation has now problems.</span> <span data-start="469.05" data-end="473.871">Imagine worker number one is dealing with a complex file and it turns out you change</span> <span data-start="473.871" data-end="476.639">again A.JS.</span> </p>
<p><span data-start="476.639" data-end="482.26">The naive approach is taking A and sending it to the first available worker which turns</span> <span data-start="482.26" data-end="485.24">out to be worker number two.</span> <span data-start="485.24" data-end="490.449">Part of the transpilation process, they tend to have intermediate caches to make further</span> <span data-start="490.449" data-end="493.3">transpilations faster.</span> <span data-start="493.3" data-end="499">If you remember, A was transformed by worker number one, we set the cache on worker number</span> <span data-start="499" data-end="500.19">one.</span> <span data-start="500.19" data-end="505.73">If you send A.JS to worker two, you have the same cache on worker two.</span> <span data-start="505.73" data-end="509.25">This is bad in terms of space and time.</span> <span data-start="509.25" data-end="510.88">Bad in terms of space.</span> <span data-start="510.88" data-end="512.71">Memory between workers is not shared.</span> <span data-start="512.71" data-end="515.33">You are going to duplicate the same data structure.</span> <span data-start="515.33" data-end="517.56">And bad in terms of time.</span> <span data-start="517.56" data-end="522.37">Because you didn't have a cache, you are going to re transpile from scratch.</span> </p>
<p><span data-start="522.37" data-end="527.01">Instead, Metra has a queue for the workers.</span> <span data-start="527.01" data-end="530.18">Once you transpile a file, it's sent to the worker.</span> <span data-start="530.18" data-end="536.05">And once it's returned, it will stick to the worker that transformed it.</span> <span data-start="536.05" data-end="541.52">If you want to retransform it, put it into the queue of worker number one and wait for</span> <span data-start="541.52" data-end="546.82">it finish to send to the right worker.</span> <span data-start="546.82" data-end="554.48">This is an oversimplification, it looks like worker two and three are idling and we could</span> <span data-start="554.48" data-end="556.75">have taken that one.</span> <span data-start="556.75" data-end="561.38">In real life what happens is that worker number two and three, they're busy with their own</span> <span data-start="561.38" data-end="562.68">set of files.</span> </p>
<p><span data-start="562.68" data-end="567.42">It is not that we just have one worker super busy and the rest idling, but the load is</span> <span data-start="567.42" data-end="569.9">actually distributed across all of them.</span> <span data-start="569.9" data-end="575.07">And the module that powers this, once again, borrowed from another project.</span> <span data-start="575.07" data-end="581.28">It's just a worker that has a very simple API to create these kinds of forms of workers.</span> <span data-start="581.28" data-end="585.12">We have an example on the repository about paralyzing left part.</span> <span data-start="585.12" data-end="590.04">Which is not interesting from the practical point of view but shows how easy you can do</span> <span data-start="590.04" data-end="591.33">things.</span> <span data-start="591.33" data-end="592.62">Cool.</span> <span data-start="592.62" data-end="598.73">So, we've transformed our files and with the prioritization, it becomes pretty fast.</span> <span data-start="598.73" data-end="602.24">But we want to be faster than this.</span> <span data-start="602.24" data-end="607">And in order to achieve this, Metra shapes with an internal cache.</span> </p>
<p><span data-start="607" data-end="613.4">This cache is a multi layer cache and it is located inside the main process.</span> <span data-start="613.4" data-end="616.26">The way it works with you go into the first cache layer.</span> <span data-start="616.26" data-end="618.24">If the as a result there, you will return it.</span> <span data-start="618.24" data-end="625.08">If not, go to the second cache layer and repeat the process through all the layers.</span> <span data-start="625.08" data-end="629.12">Every time you want to transform something inside of Metra, you will go through a function</span> <span data-start="629.12" data-end="631.27">called transform.</span> <span data-start="631.27" data-end="634.73">And this transform will got go into the caching layers.</span> <span data-start="634.73" data-end="637.12">The first is a local cache.</span> <span data-start="637.12" data-end="643.67">This lives inside your laptop and used in both open source and internally at Facebook.</span> <span data-start="643.67" data-end="647.46">Now, it could be that the thing you're looking for is not on that cache.</span> <span data-start="647.46" data-end="653.13">For instance, you just checked out the code and you have never seen that file, so it was</span> <span data-start="653.13" data-end="654.48">never transpiled.</span> <span data-start="654.48" data-end="659.04">So, for that, we have a second cache layer, a centralized database.</span> <span data-start="659.04" data-end="661.77">That one is only available at Facebook.</span> <span data-start="661.77" data-end="666.69">But the code is open source, so you could in theory use that as well.</span> </p>
<p><span data-start="666.69" data-end="670.94">And this centralized cache is accessed by all developers.</span> <span data-start="670.94" data-end="673.97">We go into the cache and look for the file.</span> <span data-start="673.97" data-end="681.029">Could be the file is not there because it's a local change you have just done.</span> <span data-start="681.029" data-end="685.51">The only thing we can do there is go into the worker and transpile the file.</span> <span data-start="685.51" data-end="690.68">Once the file is transpiled, we put that into the local cache.</span> <span data-start="690.68" data-end="692.94">But we don't write to the global cache.</span> <span data-start="692.94" data-end="696.82">And the reason for that is that if we save every change that every developer is doing</span> <span data-start="696.82" data-end="699.2">through the day, we're going to end up loading the cache.</span> <span data-start="699.2" data-end="701.16">And there is no benefit for that.</span> <span data-start="701.16" data-end="706.03">No other person makes the same modification over the same file and in approximately the</span> <span data-start="706.03" data-end="707.03">same commit.</span> <span data-start="707.03" data-end="712.399">Instead, at Facebook, the centralized cache is fulfilled by a continuous integration job</span> <span data-start="712.399" data-end="713.71">that runs on master.</span> </p>
<p><span data-start="713.71" data-end="721.53">Which every time we see a new file, or a modified file and restore the file.</span> <span data-start="721.53" data-end="725.83">In order to restore something, you need a cache key and a value.</span> <span data-start="725.83" data-end="729.56">The cache key is built by Metra by combining two parts.</span> <span data-start="729.56" data-end="732.37">We take your source file and we hash it.</span> <span data-start="732.37" data-end="737.61">But we also take every single part involved into the process of transpiling the file and</span> <span data-start="737.61" data-end="739.339">we also hash it.</span> <span data-start="739.339" data-end="743.68">And the result, the cache that we use, is the union of both.</span> <span data-start="743.68" data-end="748.61">The cool thing about this is whether if you change the file itself or change the way you</span> <span data-start="748.61" data-end="751.47">transpile, you don't have to worry about invalidating the cache.</span> <span data-start="751.47" data-end="755.98">So, if you didn't have the second part and you changed the way you transformed, either</span> <span data-start="755.98" data-end="760.66">you had to invalidate the whole cache, which can suck for people that is not yet on to</span> <span data-start="760.66" data-end="767.01">that commit, or you would be serving state results for some time, which is not good either.</span> <span data-start="767.01" data-end="770.83">So, that was for the key.</span> <span data-start="770.83" data-end="771.83">For the value.</span> <span data-start="771.83" data-end="774.2">The value is the result of the transpilation process.</span> <span data-start="774.2" data-end="778.75">If we take this model, for instance, and we transpile it, it would end up looking something</span> <span data-start="778.75" data-end="779.93">like that.</span> </p>
<p><span data-start="779.93" data-end="783.399">So, converted into var.</span> <span data-start="783.399" data-end="786.22">It got wrapped into the function.</span> <span data-start="786.22" data-end="790.8">And we got the define coal, et cetera.</span> <span data-start="790.8" data-end="796.68">Now, inside Metra we do not use string identifiers for modules.</span> <span data-start="796.68" data-end="800.06">Instead we use numeric identifiers.</span> <span data-start="800.06" data-end="807.16">Other bundling systems like Webpack or Browserify can do that, but in Metra this is built in</span> <span data-start="807.16" data-end="808.16">the core.</span> <span data-start="808.16" data-end="812.18">For performance reasons, it's faster to do a lookup through a number.</span> <span data-start="812.18" data-end="813.34">And for size reasons.</span> <span data-start="813.34" data-end="816.16">A number is always smaller than a string.</span> <span data-start="816.16" data-end="821.91">Now, if you cache this, you're going to have some issues because these numbers are local</span> <span data-start="821.91" data-end="822.91">to your build.</span> </p>
<p><span data-start="822.91" data-end="827.35">So, while this could work for your local cache, for the centralized cache when someone else</span> <span data-start="827.35" data-end="832.74">is going to pick that module, they're built with crash because left pad could be a complete</span> <span data-start="832.74" data-end="835.089">different module than number 42.</span> <span data-start="835.089" data-end="838.42">So, Metra does not really hard code numbers.</span> </p>
<p><span data-start="838.42" data-end="843.85">It adds one layer of indirection by using an array of numbers.</span> <span data-start="843.85" data-end="848.41">And each of the modules is changed each of the reference of the modules is changed into</span> <span data-start="848.41" data-end="850.88">a position into this array.</span> <span data-start="850.88" data-end="856.36">Now, side to the module, we also store that position number zero is left pad and position</span> <span data-start="856.36" data-end="858.52">number one is five.</span> </p>
<p><span data-start="858.52" data-end="861.72">And when you build, we make a lookup into the table.</span> <span data-start="861.72" data-end="866.35">We extract which is your local number for these modules and we add this array to the</span> <span data-start="866.35" data-end="868.55">defined call.</span> <span data-start="868.55" data-end="870.24">Okay.</span> <span data-start="870.24" data-end="876.76">So, we've got all the files transpiled and we're ready to produce a bundle.</span> <span data-start="876.76" data-end="883.959">Metra produces bundles sorry through something called serializers where you receive the graph</span> <span data-start="883.959" data-end="886.25">and you can manipulate it any way you want.</span> <span data-start="886.25" data-end="889.32">Now, there are two default serializers shipped with Metra.</span> <span data-start="889.32" data-end="891.84">The first is a plain JavaScript bundle.</span> <span data-start="891.84" data-end="897.6">When you're developing in native and open source, it is the one you're most likely using.</span> <span data-start="897.6" data-end="900.67">It produces the same format of any other bundling system.</span> <span data-start="900.67" data-end="906.76">Take one module, one another, concatenate them and at the end, add a startup code.</span> <span data-start="906.76" data-end="911.41">The startup code is 99% of the time requiring zero.</span> <span data-start="911.41" data-end="918.51">Because we assign numbers in the look alike when we traverse the graph and the entry point</span> <span data-start="918.51" data-end="922.45">is almost always the first module.</span> <span data-start="922.45" data-end="927.43">Now, there is a second form which is called random access module bundles, and this is</span> <span data-start="927.43" data-end="931.34">not a text file, but a binary file.</span> </p>
<p><span data-start="931.34" data-end="933.25">This file is sections.</span> <span data-start="933.25" data-end="937.95">The first one is the magic number.</span> <span data-start="937.95" data-end="949.14">[audio is echoing for captioner] it stands for something like that.</span> <span data-start="949.14" data-end="950.27">Of the code.</span> <span data-start="950.27" data-end="953.33">Now, after that, we have a table of contents.</span> <span data-start="953.33" data-end="958.82">The table of contents has the amount of modules that are shipped into this big block.</span> <span data-start="958.82" data-end="963.42">The startup length, remember the startup code was this require zero.</span> <span data-start="963.42" data-end="970.06">And references to where each of the modules are located into this giant and after that,</span> <span data-start="970.06" data-end="971.71">we just write the code.</span> <span data-start="971.71" data-end="974.12">Starting with the startup section and each of the modules.</span> <span data-start="974.12" data-end="978.69">And we put after them a new character and I'll explain to you in a second why we do</span> <span data-start="978.69" data-end="979.69">that.</span> <span data-start="979.69" data-end="983.589">Now, the amount of modules let us know how big the table of contents is.</span> </p>
<p><span data-start="983.589" data-end="986.56">The startup length is how big the initial length is.</span> <span data-start="986.56" data-end="993">And each of the five are there in within the file.</span> <span data-start="993" data-end="999.279">The format might look cumbersome, but thanks to the table of contents, we can access in</span> <span data-start="999.279" data-end="1002.92">real time and where it is located.</span> <span data-start="1002.92" data-end="1008.11">and this is especially relevant to execute code on devices.</span> </p>
<p><span data-start="1008.11" data-end="1009.98">This is very specific to React native as well.</span> <span data-start="1009.98" data-end="1011.48">And it's a little bit tricky.</span> <span data-start="1011.48" data-end="1016.04">I'm going to explain first how we execute, how we require modules that are previously</span> <span data-start="1016.04" data-end="1020.3">required and then thousand load a module for the first time.</span> <span data-start="1020.3" data-end="1025.329">So, when the module was previously required, you will have into memory you require implementation</span> <span data-start="1025.329" data-end="1028.6">and all the files, all the modules that were previously loaded.</span> <span data-start="1028.6" data-end="1033.389">Now, when you want to require something, you will call into the require implementation</span> <span data-start="1033.389" data-end="1036.799">and the require implementation has its own internal cache.</span> <span data-start="1036.799" data-end="1041.859">For instance, because requiring twice the same module has to return the same instance.</span> <span data-start="1041.859" data-end="1044.36">It can query the cache.</span> <span data-start="1044.36" data-end="1047.539">And since the module is there, it will just return it.</span> <span data-start="1047.539" data-end="1050.159">Now, this is a pretty straightforward process.</span> <span data-start="1050.159" data-end="1054.549">And, again, literally every single bundling system does the same.</span> <span data-start="1054.549" data-end="1060.519">Now, when you require something that was never required, the process gets a little bit trickier.</span> <span data-start="1060.519" data-end="1065.02">We have once again a require and the modules that were previously loaded and our require</span> <span data-start="1065.02" data-end="1067.399">call to something that we've never seen.</span> </p>
<p><span data-start="1067.399" data-end="1069.379">The process starts in the same way.</span> <span data-start="1069.379" data-end="1071.129">We go into require.</span> <span data-start="1071.129" data-end="1073.629">We make a lookup into the cache.</span> <span data-start="1073.629" data-end="1076.41">And then 622 in this case is not there.</span> <span data-start="1076.41" data-end="1079.279">So, we've got to load it.</span> <span data-start="1079.279" data-end="1083.639">And this happens with a little trick.</span> <span data-start="1083.639" data-end="1088.2">For loading 622 in the case of React Native, we do not use JavaScript.</span> <span data-start="1088.2" data-end="1090.11">We use the Native sign.</span> <span data-start="1090.11" data-end="1093.269">The native sign has native require.</span> <span data-start="1093.269" data-end="1100.27">Hey, can you load that into the Java virtual machine?</span> <span data-start="1100.27" data-end="1108.549">It will go into the disk, look at the gigantic blob, do the maths, take the first number</span> <span data-start="1108.549" data-end="1114.45">622, will extract where it is located and inject it in the virtual machine.</span> <span data-start="1114.45" data-end="1119.88">Now, this is the reason why there is a byte at the end of every module.</span> <span data-start="1119.88" data-end="1125.47">Because all implementations of JavaScript built in machines are C++ based, or at least</span> <span data-start="1125.47" data-end="1127.36">they use ASCIIs and strings.</span> </p>
<p><span data-start="1127.36" data-end="1131.539">By putting the character at the end of the module, we don't have to worry about the length</span> <span data-start="1131.539" data-end="1134.059">nor coping it into a separate buffer.</span> <span data-start="1134.059" data-end="1139.48">We can tell the virtual machine to load JavaScript from there.</span> <span data-start="1139.48" data-end="1144.289">Once the model is loaded inside of the virtual machine, it will self register inside the</span> <span data-start="1144.289" data-end="1148.46">require implementation and it will appear into the cache.</span> <span data-start="1148.46" data-end="1152.09">And the only thing that it's left is the release the need if require.</span> <span data-start="1152.09" data-end="1156.48">And now require will be able to return that module.</span> <span data-start="1156.48" data-end="1164.33">This process pretty much like the format looks a little bit cumbersome, but it has some benefits.</span> <span data-start="1164.33" data-end="1168.49">You have to pay off every single time that you cross from the JavaScript side into the</span> <span data-start="1168.49" data-end="1169.95">native side.</span> <span data-start="1169.95" data-end="1173.779">But on the other side, you are only loading the minimum amount of JavaScript that you</span> <span data-start="1173.779" data-end="1174.83">need.</span> <span data-start="1174.83" data-end="1179.83">And you're not consuming as much memory as you would consume otherwise.</span> <span data-start="1179.83" data-end="1184.179">Loading a plain JavaScript bundle will still be possible, but it will take a lot of time</span> <span data-start="1184.179" data-end="1185.71">and a lot of memory.</span> </p>
<p><span data-start="1185.71" data-end="1188.549">And not all devices are capable to handle this.</span> <span data-start="1188.549" data-end="1193.529">You're only putting inside the inside the virtual machine the code that you really need</span> <span data-start="1193.529" data-end="1196.28">to execute.</span> <span data-start="1196.28" data-end="1201.529">So, we've talked a lot about how we bundle code.</span> <span data-start="1201.529" data-end="1202.809">How we execute code.</span> <span data-start="1202.809" data-end="1204.179">A lot of the building process.</span> <span data-start="1204.179" data-end="1206.69">But what happens with developers?</span> <span data-start="1206.69" data-end="1211.239">Because we said that we're looking for sub second reloads for our developers.</span> <span data-start="1211.239" data-end="1215.13">So, how have we made this work internally?</span> <span data-start="1215.13" data-end="1221.09">A couple of months ago, approximately four months ago, we developed something that is</span> <span data-start="1221.09" data-end="1222.72">called a Dev bundler.</span> <span data-start="1222.72" data-end="1226.429">This is open source and it is part of Metra.</span> <span data-start="1226.429" data-end="1230.97">In order to figure out how that works, let's take this graph as an example where your entry</span> <span data-start="1230.97" data-end="1232.97">point is module number one.</span> </p>
<p><span data-start="1232.97" data-end="1235.94">And the arrows mean the first one is requiring the second one.</span> <span data-start="1235.94" data-end="1240.74">Module number one requires the seconds and sixth, module two requires three and four,</span> <span data-start="1240.74" data-end="1242.009">so on and so forth.</span> <span data-start="1242.009" data-end="1246.809">The first time you want to load this inside the device you will take all the files, put</span> <span data-start="1246.809" data-end="1249.679">them all together and send to the device.</span> <span data-start="1249.679" data-end="1257.32">Now, if you change module number six, but most do, they will re traverse to number one,</span> <span data-start="1257.32" data-end="1258.549">get all the dependencies.</span> <span data-start="1258.549" data-end="1261.71">Create a new bundle and ship that to the client.</span> <span data-start="1261.71" data-end="1265.94">But the truth is, out of the six modules, only number six changed.</span> <span data-start="1265.94" data-end="1271.97">The delta bundler creates a delta just with that module and sends that into the client.</span> </p>
<p><span data-start="1271.97" data-end="1274.1">Now, the difference is massive.</span> <span data-start="1274.1" data-end="1280.009">Because of instead of having an open operation every time you have a reload, you have an</span> <span data-start="1280.009" data-end="1281.029">O1.</span> <span data-start="1281.029" data-end="1287.139">Once it's loaded on the device, you don't have to worry about sending everything over</span> <span data-start="1287.139" data-end="1291.379">and over through the network.</span> <span data-start="1291.379" data-end="1294.1">The process works like this for most of the changes.</span> </p>
<p><span data-start="1294.1" data-end="1297.59">There are slight modifications when you add or remove a require.</span> <span data-start="1297.59" data-end="1302.799">So, when you add a require, we have to extract that require and start crawling again from</span> <span data-start="1302.799" data-end="1304.46">that require.</span> <span data-start="1304.46" data-end="1309.429">And through the through the crawling process, we only extract the modules, that is the first</span> <span data-start="1309.429" data-end="1310.429">time we visit.</span> </p>
<p><span data-start="1310.429" data-end="1312.82">So, for instance, module number one required number seven.</span> <span data-start="1312.82" data-end="1316.119">And seven requires four, eight and nine to work.</span> <span data-start="1316.119" data-end="1325.049">One was in the virtual machine, so, it will only contain one, seven, eight and nine.</span> <span data-start="1325.049" data-end="1331.239">In a similar fashion, when we are move a require, we have to verify this was the last require</span> <span data-start="1331.239" data-end="1332.289">going into the file.</span> <span data-start="1332.289" data-end="1337.34">In that case, module number three stopped requiring module number five.</span> <span data-start="1337.34" data-end="1340.059">But module four depends on it.</span> <span data-start="1340.059" data-end="1343.97">What it means is that the delta that we can send is only module number three.</span> <span data-start="1343.97" data-end="1349.789">Now, if we change module number four and remove the require, five becomes an orphan module</span> <span data-start="1349.789" data-end="1351.909">and we can safely delete it.</span> <span data-start="1351.909" data-end="1357.99">And the resulting delta for this is patching module number four, but also deleting module</span> <span data-start="1357.99" data-end="1359.61">number five.</span> <span data-start="1359.61" data-end="1366.169">So, to summarize this, most code changes only require patching a single file.</span> </p>
<p><span data-start="1366.169" data-end="1371.379">So, we've gone through having to create a gigantic bundle with megabytes of JavaScript</span> <span data-start="1371.379" data-end="1375.639">into filling just a few kilobytes.</span> <span data-start="1375.639" data-end="1380.35">We just triggered that search through all the new requires that we might visit and take</span> <span data-start="1380.35" data-end="1384.029">only the ones that is the first time we see.</span> <span data-start="1384.029" data-end="1388.409">On the other side, removing a require does the inverse operations.</span> <span data-start="1388.409" data-end="1393.289">So, instead of depending on direct dependencies, we depend on what we call inverse dependencies.</span> <span data-start="1393.289" data-end="1397.809">So, we look at who is depending on a module in order to know if we can safely delete it</span> <span data-start="1397.809" data-end="1398.809">or not.</span> <span data-start="1398.809" data-end="1402.899">If no one is depending on the module, you can safely delete it.</span> <span data-start="1402.899" data-end="1412.5">Now, as a quick recap, we can say that Metra is a building platform where the scaling issues</span> <span data-start="1412.5" data-end="1415.15">are put on every part of the process.</span> </p>
<p><span data-start="1415.15" data-end="1417.25">We made transformations in parallel.</span> <span data-start="1417.25" data-end="1423.299">We have multi cache systems in order to avoid re transpiling files that someone else transpiled</span> <span data-start="1423.299" data-end="1424.83">before.</span> <span data-start="1424.83" data-end="1431.799">And then we have the code execution in the most optimal way both in development and in</span> <span data-start="1431.799" data-end="1433.239">production.</span> <span data-start="1433.239" data-end="1439.269">So, if you want to try Metra, if you're developing a React Native application you're already</span> <span data-start="1439.269" data-end="1441.69">trying it.</span> <span data-start="1441.69" data-end="1449.009">All the parts except for the global cache because we cannot ship the global public cache.</span> </p>
<p><span data-start="1449.009" data-end="1454.139">All the features I described are in there.</span> <span data-start="1454.139" data-end="1459.279">And we're also working into making it for suitable or other platforms.</span> <span data-start="1459.279" data-end="1461.58">There are really cool examples about this.</span> <span data-start="1461.58" data-end="1467.029">This is a video of a React Native application working on a browser.</span> <span data-start="1467.029" data-end="1470.399">The thing that is powering this, I would totally recommend you to check the video.</span> <span data-start="1470.399" data-end="1472.309">This is just 5 seconds.</span> <span data-start="1472.309" data-end="1474.899">This is also powered by Metra.</span> <span data-start="1474.899" data-end="1481.51">And in fact, we're currently working in making Metra suitable as well for web.</span> <span data-start="1481.51" data-end="1486.659">And for that, we have a very simple application that a colleague of my team made.</span> <span data-start="1486.659" data-end="1489.519">So, you can just go and download it.</span> </p>
<p><span data-start="1489.519" data-end="1492.289">Everything works on that app except for the delta bundler.</span> <span data-start="1492.289" data-end="1496.309">We are still figuring out how we're going implement this on the web.</span> <span data-start="1496.309" data-end="1497.96">Might be service workers.</span> <span data-start="1497.96" data-end="1500.08">But this is definitely not there yet.</span> <span data-start="1500.08" data-end="1505.32">But in any case, it's actually powered by Metra.</span> <span data-start="1505.32" data-end="1506.32">And that was all for today.</span> <span data-start="1506.32" data-end="1507.32">Thank you very much.</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
