<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>lil4YCCXRYc</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/lil4YCCXRYc?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="14.889" data-end="16.67">All right, everybody!</span> <span data-start="16.67" data-end="18.89">Welcome to my talk.</span> <span data-start="18.89" data-end="21.32">ES2016, the evolution of JavaScript.</span> <span data-start="21.32" data-end="22.32">First a little bit about me.</span> <span data-start="22.32" data-end="23.32">My name is Jafar Husain.</span> </p>
<p><span data-start="23.32" data-end="27.11">I'm a tech lead at Netflix, I work for Falcor, an upcoming</span> <span data-start="27.11" data-end="36.53">open data platform, which we intend to release pretty soon, and I'm</span> <span data-start="36.53" data-end="40.949">also one of Netflix's representatives on TC-39, which is JavaScript's</span> <span data-start="40.949" data-end="42.16">standard's committee.</span> <span data-start="42.16" data-end="46.82">This talk used to be called ES7, the evolution</span> <span data-start="46.82" data-end="49.57">of JavaScript, but something happened a couple of committee meetings ago.</span> <span data-start="49.57" data-end="59.71">We decided to change ES6 to ES2015 and ES7 to ES2016.</span> <span data-start="59.71" data-end="62.6">I want to explain this name change.</span> <span data-start="62.6" data-end="65.11">We as a committee want to start shipping JavaScript</span> <span data-start="65.11" data-end="68.72">every year.</span> <span data-start="68.72" data-end="71.03">Just the way you would ship software in an agile way, we want</span> <span data-start="71.03" data-end="73.72">to add features and ship them quickly.</span> </p>
<p><span data-start="73.72" data-end="77.45">That's why we have this new name.</span> <span data-start="77.45" data-end="82.29">The language formerly known as ES6 is ES2015 and the upcoming language version</span> <span data-start="82.29" data-end="84.25">is ES2016.</span> <span data-start="84.25" data-end="88.61">ES2016 features are already starting to roll on the browsers.</span> <span data-start="88.61" data-end="92.43">For example, there's object.observe in Chrome right now.</span> <span data-start="92.43" data-end="99.049">And it's important to know that ES2015 and ES2016 were developed concurrently.</span> <span data-start="99.049" data-end="104.57">So although there was this big  —  many, many years between ES5 and ES2015,</span> <span data-start="104.57" data-end="106.869">what the committee is doing is they're developing new features.</span> <span data-start="106.869" data-end="109.969">In the latest version of the language, at the same time that they're developing features</span> <span data-start="109.969" data-end="111.55">in the next version of the language.</span> </p>
<p><span data-start="111.55" data-end="114.86">And that's exciting, because it actually helps us plan the future of</span> <span data-start="114.86" data-end="115.86">JavaScript.</span> <span data-start="115.86" data-end="117.2">We don't have to do everything in one release.</span> <span data-start="117.2" data-end="120.64">We can add features today to ES2015 and we can build</span> <span data-start="120.64" data-end="124.95">on them, with the hopes of building on them later in ES2016.</span> <span data-start="124.95" data-end="131.17">So the big story about ES2016 is: how do we make</span> <span data-start="131.17" data-end="132.58">async programming easier?</span> <span data-start="132.58" data-end="134.59">I think there's probably some folks out there who</span> <span data-start="134.59" data-end="136.72">think this is kind of a hard problem.</span> <span data-start="136.72" data-end="137.72">Right?</span> <span data-start="137.72" data-end="139.04">Any pain out there, about async programming?</span> <span data-start="139.04" data-end="142.37">Quite a few people, I'm guessing.</span> <span data-start="142.37" data-end="146.4">So starting with ES5, we introduced something to make your life a little</span> <span data-start="146.4" data-end="147.78">bit easier, which is arrow functions.</span> </p>
<p><span data-start="147.78" data-end="152.43">I'm not going to dwell on this too long, but as of ES2015,</span> <span data-start="152.43" data-end="155.78">you're now able to write this way.</span> <span data-start="155.78" data-end="158.92">A lot of people are familiar with arrow functions.</span> <span data-start="158.92" data-end="162.39">I'm not going to spend too long on this.</span> <span data-start="162.39" data-end="165.61">This definitely helps when you have a lot of callback.</span> <span data-start="165.61" data-end="170.73">Arrow functions are an improvement, but can we do better?</span> <span data-start="170.73" data-end="175.63">What if you can write async programs without any callbacks at</span> <span data-start="175.63" data-end="176.63">all?</span> <span data-start="176.63" data-end="180.14">How does that sound?</span> <span data-start="180.14" data-end="181.29">Right?</span> <span data-start="181.29" data-end="182.45">Yeah?</span> <span data-start="182.45" data-end="184.65">So we all know that blocking is easy.</span> <span data-start="184.65" data-end="185.65">Right?</span> <span data-start="185.65" data-end="186.87">Blocking is no problem.</span> <span data-start="186.87" data-end="189.62">Blocking  —  let's imagine for a moment this function which gets a stock</span> <span data-start="189.62" data-end="194.461">price, calls, gets stock symbol, which makes a blocking XHR request, one</span> <span data-start="194.461" data-end="196.36">of those things we're never supposed to do.</span> </p>
<p><span data-start="196.36" data-end="198.17">Never make a blocking request.</span> <span data-start="198.17" data-end="203.75">But it's easy, because we can wait for the request to come back, block when it</span> <span data-start="203.75" data-end="207.54">does, and pass the symbol for that stock and get the price for it.</span> <span data-start="207.54" data-end="209.5">We know blocking is easy but it produces a terrible</span> <span data-start="209.5" data-end="210.72">User Experience.</span> <span data-start="210.72" data-end="214.01">Because user might be sitting there and our UI is not responding</span> <span data-start="214.01" data-end="216.95">to mouse clicks while we're making our request.</span> <span data-start="216.95" data-end="218.9">So that's something you're not supposed to do in JavaScript.</span> <span data-start="218.9" data-end="224.95">But when I say blocking, I want you to think pulling.</span> <span data-start="224.95" data-end="227.83">When we call a function and receive the output in the return</span> <span data-start="227.83" data-end="232.75">position of that functioning, we're pulling the value of that function.</span> <span data-start="232.75" data-end="235.83">To the left hand side, pulling the value out.</span> </p>
<p><span data-start="235.83" data-end="239.409">So when I say blocking, I mean pulling, and that means data is delivered</span> <span data-start="239.409" data-end="241.299">in the return position of the function.</span> <span data-start="241.299" data-end="243.26">That's how most functions are in JavaScript.</span> <span data-start="243.26" data-end="245.76">Most functions return their data in the return position.</span> <span data-start="245.76" data-end="249.879">But what if we decide that we want to wait instead of block?</span> <span data-start="249.879" data-end="252.689">We don't want to block the UI, waiting for the output and not</span> <span data-start="252.689" data-end="254.7">being able to respond to user input.</span> <span data-start="254.7" data-end="256.18">We want to be able to just wait.</span> <span data-start="256.18" data-end="260.51">Well, in order to wait in JavaScript, waiting means pushing.</span> <span data-start="260.51" data-end="265.32">What it means is you hand the callback to that function and that function pushes the</span> <span data-start="265.32" data-end="269.07">value, the result of that function, in the argument position of your</span> <span data-start="269.07" data-end="270.07">callback.</span> <span data-start="270.07" data-end="272.21">So this is a thing you would see in node.</span> <span data-start="272.21" data-end="278.23">You hand the function to callback and it pushes the value, the result, in the argument position.</span> <span data-start="278.23" data-end="281.6">So as soon as we try to do that, as soon as we try to wait in JavaScript,</span> <span data-start="281.6" data-end="284.25">we very rapidly find ourselves in the pyramid of doom.</span> </p>
<p><span data-start="284.25" data-end="286.61">If you've done a lot of node.js programming, you</span> <span data-start="286.61" data-end="287.79">probably know what I mean.</span> <span data-start="287.79" data-end="290.419">Your code takes on this pyramid-like structure that</span> <span data-start="290.419" data-end="293.849">you see there on the left hand side.</span> <span data-start="293.849" data-end="297.9">So on the left hand side here, with get stock price, we're doing a</span> <span data-start="297.9" data-end="298.9">blocking function.</span> <span data-start="298.9" data-end="300.9">Just the same function you saw earlier.</span> <span data-start="300.9" data-end="303.01">But as soon as you want to move to waiting on the right hand</span> <span data-start="303.01" data-end="307.219">side, take a look at how much more complicated our function becomes.</span> <span data-start="307.219" data-end="309.099">Why is there so much more code here?</span> <span data-start="309.099" data-end="312.07">For one thing, it's because we're doing the job that JavaScript usually</span> <span data-start="312.07" data-end="313.34">does for us.</span> <span data-start="313.34" data-end="317.06">If an error is encountered anywhere in this function, now as</span> <span data-start="317.06" data-end="320.69">soon as we're using callbacks to forward on those errors, we're responsible.</span> </p>
<p><span data-start="320.69" data-end="323.14">For making sure that those errors get forwarded up.</span> <span data-start="323.14" data-end="326.349">Whereas when we're doing blocking code, we have try/catch to</span> <span data-start="326.349" data-end="327.349">rely on.</span> <span data-start="327.349" data-end="330.089">So as soon as  —  the problem really, what's going on here, is since</span> <span data-start="330.089" data-end="334.57">JavaScript doesn't expect functions to wait, in JavaScript, they sort</span> <span data-start="334.57" data-end="338.01">of expect functions to block  —  there's no support for reporting errors</span> <span data-start="338.01" data-end="341.219">this way, and the language can't provide you with any sort of support, whether</span> <span data-start="341.219" data-end="345.28">it's loops or try/catch, so you're kind of on your own.</span> <span data-start="345.28" data-end="348.09">But what if waiting were just as easy as blocking?</span> </p>
<p><span data-start="348.09" data-end="350.68">What if JavaScript understood this concept of functions that</span> <span data-start="350.68" data-end="354.93">waited, and it could provide you syntactical support just like try/catch, and</span> <span data-start="354.93" data-end="357.88">you could use loops, for example, to repeat asynchronous functions?</span> <span data-start="357.88" data-end="362.91">Well, in ES2015, we got a little closer to this vision, with promises.</span> <span data-start="362.91" data-end="366.87">Now, the way I think most of you are probably familiar with promises  —  most of</span> <span data-start="366.87" data-end="368.13">you have been exposed to them at this point.</span> <span data-start="368.13" data-end="370.31">But the way to think about a promise is that it's an</span> <span data-start="370.31" data-end="374.31">object that represents the eventual value of an asynchronous operation.</span> <span data-start="374.31" data-end="377.41">So if you want to get the value from a promise,</span> <span data-start="377.41" data-end="380.74">you call then and pass to callbacks.</span> <span data-start="380.74" data-end="383.4">One is for receiving data if the asynchronous operation</span> <span data-start="383.4" data-end="384.57">succeeded.</span> </p>
<p><span data-start="384.57" data-end="386.24">That's on the left hand side there.</span> <span data-start="386.24" data-end="389.94">And the other callback is for receiving the error if the asynchronous operation</span> <span data-start="389.94" data-end="390.94">failed.</span> <span data-start="390.94" data-end="392.872">So it's sort of like a promise is like a present that you</span> <span data-start="392.872" data-end="396.28">unwrap, and great  —  if everything worked out, you get a value.</span> <span data-start="396.28" data-end="399.06">But if things go bad, you can get an error.</span> <span data-start="399.06" data-end="401.1">So now let's take a look at that same previous</span> <span data-start="401.1" data-end="404.46">example, waiting with callbacks, and that pyramid of doom structure</span> <span data-start="404.46" data-end="409.69">you see there, and let's see how we can now do the same thing with promises.</span> <span data-start="409.69" data-end="414.56">So what's happened here is promises actually take care  —  they catch any</span> <span data-start="414.56" data-end="419.32">errors that occur, and forward them up until they're actually caught,</span> <span data-start="419.32" data-end="422.33">where you pass an error handler, notice on get stock price, we pass an</span> <span data-start="422.33" data-end="423.33">error handler.</span> <span data-start="423.33" data-end="425.599">We don't have to catch errors at every possible step in the</span> <span data-start="425.599" data-end="426.599">function.</span> <span data-start="426.599" data-end="429.88">We just catch errors in one place and the promise type will catch</span> <span data-start="429.88" data-end="433.5">errors and forward it up until  —  there's a function provided to handle</span> <span data-start="433.5" data-end="434.5">that error.</span> </p>
<p><span data-start="434.5" data-end="437.44">So what's actually happening is that type is doing the job that</span> <span data-start="437.44" data-end="439.5">try/catch does for you in the language.</span> <span data-start="439.5" data-end="442.66">So that's how we got back down to that nice little piece of code.</span> <span data-start="442.66" data-end="444.28">That's an improvement.</span> <span data-start="444.28" data-end="445.729">No more pyramid of doom.</span> <span data-start="445.729" data-end="447.24">It's not bad.</span> <span data-start="447.24" data-end="452.039">But why can't we just write code that looks pretty much the same, regardless of whether</span> <span data-start="452.039" data-end="454.08">it's waiting or blocking, right?</span> </p>
<p><span data-start="454.08" data-end="457.74">What if we could just write our algorithm and make it easy to switch that</span> <span data-start="457.74" data-end="459.44">algorithm between waiting and blocking?</span> <span data-start="459.44" data-end="463.45">That promise code you saw on the previous slide looks different from the synchronous</span> <span data-start="463.45" data-end="465.76">blocking code you saw earlier.</span> <span data-start="465.76" data-end="472">As of ES2015, you will now be able to wait like this.</span> <span data-start="472" data-end="475.68">So using generator functions and the yield keyword, which is something</span> <span data-start="475.68" data-end="478.86">I'm going to tell but later, you can actually write code that looks</span> <span data-start="478.86" data-end="482.62">pretty much exactly like the blocking code, but instead waits.</span> <span data-start="482.62" data-end="483.839">It doesn't block.</span> <span data-start="483.839" data-end="487.51">And so you can allow handling of user input, but you can write</span> <span data-start="487.51" data-end="489.24">your code top to bottom.</span> <span data-start="489.24" data-end="496.28">More, you can take advantage of looping constructs to block flow in an asynchronous</span> <span data-start="496.28" data-end="497.28">way.</span> </p>
<p><span data-start="497.28" data-end="503.279">So on the right hand side I can use loops and I can even use try/catch.</span> <span data-start="503.279" data-end="505.91">How do we make this work in JavaScript?</span> <span data-start="505.91" data-end="509.13">In order to explain that to you, I have to explain generators.</span> <span data-start="509.13" data-end="513.69">But the metapoint I want you to understand here is that pulling and pushing</span> <span data-start="513.69" data-end="516.71">are symmetrical.</span> <span data-start="516.71" data-end="518.69">You can do the exact same thing  —  write your code</span> <span data-start="518.69" data-end="521.729">precisely the same way, whether it's pulling or pushing.</span> <span data-start="521.729" data-end="522.729">It's kind of a detail.</span> <span data-start="522.729" data-end="525.89">Somehow be able to write your logic and after the fact decide</span> <span data-start="525.89" data-end="529.26">whether you want that function to push or you want it to be a pulling</span> <span data-start="529.26" data-end="530.26">function.</span> <span data-start="530.26" data-end="532.62">Anything that you can push, you can pull out of a function.</span> <span data-start="532.62" data-end="534.44">I'm going to demonstrate that in just a moment.</span> </p>
<p><span data-start="534.44" data-end="537.28">So in order to understand how that works, I'm going to explain you to the</span> <span data-start="537.28" data-end="542.27">most powerful and most misunderstood feature in ES2015, and that is</span> <span data-start="542.27" data-end="543.27">generator functions.</span> <span data-start="543.27" data-end="544.27">Hands up  —  quick, how many people have heard of</span> <span data-start="544.27" data-end="545.27">generator functions?</span> <span data-start="545.27" data-end="546.27">Great.</span> <span data-start="546.27" data-end="548.88">Quite a few people.</span> <span data-start="548.88" data-end="551.64">How many people understand them?</span> <span data-start="551.64" data-end="552.64">Right.</span> <span data-start="552.64" data-end="553.64">Okay.</span> <span data-start="553.64" data-end="555.96">So that's  —  hopefully I want to rectify that today.</span> <span data-start="555.96" data-end="557.71">If you get one thing out of this talk, it'll</span> <span data-start="557.71" data-end="560.74">at least be a slightly better understanding of what generator functions</span> <span data-start="560.74" data-end="562.65">are, because as I said, they're really powerful.</span> </p>
<p><span data-start="562.65" data-end="565.83">At a high level, this is how I want you to think about</span> <span data-start="565.83" data-end="566.83">generator functions.</span> <span data-start="566.83" data-end="570.49">It's a function that can return multiple values.</span> <span data-start="570.49" data-end="574.4">Well, you can already make a function that returns multiple values.</span> <span data-start="574.4" data-end="576.51">Throw a few values in an array.</span> <span data-start="576.51" data-end="581.78">But this allows you to do that more efficiently.</span> <span data-start="581.78" data-end="587.27">This is what generator functions look like in ES2015.</span> <span data-start="587.27" data-end="591.72">This yield keyword is like an intermediary return.</span> <span data-start="591.72" data-end="596.08">It runs in the middle and you can return more values.</span> <span data-start="596.08" data-end="600.83">So if you're consuming the data from a generator function, this is what it looks like.</span> <span data-start="600.83" data-end="603.89">In order to get the data out, you request an iterator.</span> </p>
<p><span data-start="603.89" data-end="605.4">By calling that function, what comes out is an</span> <span data-start="605.4" data-end="606.53">iterator.</span> <span data-start="606.53" data-end="611">An iterator is what you can call next on, and then what happens</span> <span data-start="611" data-end="616.65">is the function evaluates to the first yield, and then stops and returns that</span> <span data-start="616.65" data-end="617.65">value.</span> <span data-start="617.65" data-end="620.37">And then it pops out of its little tuple which contains the value</span> <span data-start="620.37" data-end="623.29">that was returned and a Boolean telling you whether or not there are</span> <span data-start="623.29" data-end="624.42">more values.</span> </p>
<p><span data-start="624.42" data-end="629.571">So if done is False, we can call next again, and execution is</span> <span data-start="629.571" data-end="633.85">going to resume and move to the next yield and then pause and then return</span> <span data-start="633.85" data-end="636.94">you another tuple, saying that value  —  we know we have more to do, so I'm</span> <span data-start="636.94" data-end="642.14">going to keep calling next, until finally we get return and we get our last</span> <span data-start="642.14" data-end="647">value, and we know we're done, because done is True.</span> </p>
<p><span data-start="647" data-end="652.31">If I want you to write a get numbers function today in ES2015,</span> <span data-start="652.31" data-end="656.04">you would probably roll a sync machine.</span> <span data-start="656.04" data-end="660.6">Calls next and I get the next value.</span> <span data-start="660.6" data-end="663.46">Let's look at this Fibonacci sequence function here.</span> <span data-start="663.46" data-end="671.28">And I'm going to show you what it desugars to, from ES2015 to ES5.</span> <span data-start="671.28" data-end="673.57">So you can see I've got this stink variable on the</span> <span data-start="673.57" data-end="676.75">left hand side and that's keeping track on of where I am.</span> <span data-start="676.75" data-end="680.41">And I'm returning the object with this method, that's</span> <span data-start="680.41" data-end="682.67">the iterator you saw earlier.</span> <span data-start="682.67" data-end="688.43">Now, what this function actually is doing  —  you can see here what generator</span> <span data-start="688.43" data-end="692.79">functions do is they figure out every possible state that that function</span> <span data-start="692.79" data-end="696.25">can be in and they build a state machine.</span> <span data-start="696.25" data-end="700.46">So this get Fibonacci sequence can be in three different states when you call</span> <span data-start="700.46" data-end="701.46">next.</span> <span data-start="701.46" data-end="704.69">Where it's supposed to return zero at the beginning, where it's supposed</span> <span data-start="704.69" data-end="709.32">to return one, and finally whatever it returned last time, whatever it</span> <span data-start="709.32" data-end="713.04">returned before that, add them together, and return them.</span> </p>
<p><span data-start="713.04" data-end="717.29">In JavaScript, in ES2015, this generator function is actually smart enough</span> <span data-start="717.29" data-end="720.76">to figure that out and build this state machine for you.</span> <span data-start="720.76" data-end="723.3">And what it's really doing is it's turning what</span> <span data-start="723.3" data-end="724.98">looks like a push.</span> <span data-start="724.98" data-end="728.41">Notice on the left hand side here  —  yield kind of looks</span> <span data-start="728.41" data-end="729.41">like a push.</span> <span data-start="729.41" data-end="731.44">Imagine yield was a callback.</span> <span data-start="731.44" data-end="732.44">Right?</span> <span data-start="732.44" data-end="734.29">And there was brackets around that yield.</span> <span data-start="734.29" data-end="736.98">The code looks like we're pushing the data.</span> </p>
<p><span data-start="736.98" data-end="740.55">But the compiler turns it into code that pulls by</span> <span data-start="740.55" data-end="743.04">building a state machine on the left hand side.</span> <span data-start="743.04" data-end="744.99">So that's effectively what generator functions do.</span> <span data-start="744.99" data-end="746.97">They let you write code that looks like you're pushing</span> <span data-start="746.97" data-end="751.91">information when in fact it turns it inside out and then it uses pull</span> <span data-start="751.91" data-end="753.54">for the control flow.</span> </p>
<p><span data-start="753.54" data-end="758.08">So for each one of these yields, we have that return which returns the</span> <span data-start="758.08" data-end="761.73">tuple, the value, and the done, and increments the state variables, as it goes</span> <span data-start="761.73" data-end="765.42">along, and that's how we move through the states.</span> <span data-start="765.42" data-end="766.42">This allows us to use iteration.</span> <span data-start="766.42" data-end="771.99">The whole process of pulling a value out of it until you're done</span> <span data-start="771.99" data-end="772.99">is called iteration.</span> <span data-start="772.99" data-end="776.06">And it involves a consumer and a producer.</span> <span data-start="776.06" data-end="780.56">The consumer requests an iterator from the producer,</span> <span data-start="780.56" data-end="783.84">and then it pulls the value out by calling next.</span> <span data-start="783.84" data-end="785.79">So the producer emits a value.</span> <span data-start="785.79" data-end="786.79">Right?</span> <span data-start="786.79" data-end="787.79">And why do I say it's pull?</span> <span data-start="787.79" data-end="790.97">Well, notice I'm getting the value out in the return position</span> <span data-start="790.97" data-end="791.97">of next.</span> </p>
<p><span data-start="791.97" data-end="793.09">So I'm pulling functions out.</span> <span data-start="793.09" data-end="794.54">I'm pulling values out.</span> <span data-start="794.54" data-end="798.18">I keep pulling values out, until finally I pull out a value</span> <span data-start="798.18" data-end="799.59">and the producer says you're done.</span> <span data-start="799.59" data-end="800.77">So that's how iteration works.</span> <span data-start="800.77" data-end="803.86">You keep pulling values out until the producer says I'm done.</span> <span data-start="803.86" data-end="805.26">No more data.</span> <span data-start="805.26" data-end="809.64">So if generator functions return iterators, why are they called generator</span> <span data-start="809.64" data-end="810.64">functions?</span> <span data-start="810.64" data-end="812.779">Why don't we just call them iterator functions?</span> </p>
<p><span data-start="812.779" data-end="816.09">There's more than meets the eye when it comes to generator</span> <span data-start="816.09" data-end="817.09">functions.</span> <span data-start="817.09" data-end="820.67">A generator is actually built out of two different interfaces.</span> <span data-start="820.67" data-end="823.73">The iterator you saw earlier, where you can call next and get out</span> <span data-start="823.73" data-end="827.26">the little tuple saying what the value is and whether you're done  —  it</span> <span data-start="827.26" data-end="831.9">also has an entirely other side, a split personality, which is an observer</span> <span data-start="831.9" data-end="835.13">interface, which gets push values.</span> </p>
<p><span data-start="835.13" data-end="837.8">So a generator is both a source of data, which you can pull data out</span> <span data-start="837.8" data-end="841.92">of, but it's also a sync which you can push data into.</span> <span data-start="841.92" data-end="846.04">So these two sources combined create a generator.</span> <span data-start="846.04" data-end="847.63">A generator is an iterator.</span> <span data-start="847.63" data-end="850.36">You can pull a value out.</span> <span data-start="850.36" data-end="853.05">If you attempt to pull a value out, you can get an error, because</span> <span data-start="853.05" data-end="854.68">it might throw if you call next.</span> <span data-start="854.68" data-end="859.93">And finally you can pull a value out and get that done:true in that little tuple.</span> <span data-start="859.93" data-end="863.59">So there's three types of notifications that a producer can tell you</span> <span data-start="863.59" data-end="864.59">during iteration.</span> <span data-start="864.59" data-end="865.839">I've got some data.</span> <span data-start="865.839" data-end="866.98">An error.</span> <span data-start="866.98" data-end="869.67">And here's your final value.</span> <span data-start="869.67" data-end="874.69">You can see all of those notifications in reverse on the observer side.</span> <span data-start="874.69" data-end="879.62">So when you call next on a generator, you can also push a value in by</span> <span data-start="879.62" data-end="882.69">passing a value in the argument position of next.</span> </p>
<p><span data-start="882.69" data-end="887.089">You can also send an error in, by calling throw, and finally, you can send</span> <span data-start="887.089" data-end="890.35">in a final value by calling return.</span> <span data-start="890.35" data-end="893.82">So why does an observer have this sort of split personality of both being a source of</span> <span data-start="893.82" data-end="896.089">data and sync?</span> <span data-start="896.089" data-end="897.8">It's to solve a little problem.</span> <span data-start="897.8" data-end="900.96">And that's that iteration only allows data to flow in one</span> <span data-start="900.96" data-end="902.37">direction.</span> <span data-start="902.37" data-end="905.87">Whereas with generators, two functions can effectively have a</span> <span data-start="905.87" data-end="906.87">conversation.</span> <span data-start="906.87" data-end="908.47">Have a long running conversation.</span> <span data-start="908.47" data-end="909.71">I put a value out.</span> <span data-start="909.71" data-end="910.93">I push a value back in.</span> <span data-start="910.93" data-end="914.07">I pull a value out, I push a value back in.</span> <span data-start="914.07" data-end="915.15">Why would I want to do that?</span> <span data-start="915.15" data-end="916.96">What does that buy me?</span> <span data-start="916.96" data-end="920.83">It allows us to use a very powerful pattern that I think a lot of people in the room are</span> <span data-start="920.83" data-end="924.77">going to be using in the next few years called asynchronous iteration.</span> </p>
<p><span data-start="924.77" data-end="928.91">So we have our generator function and the first thing I want you to notice is that</span> <span data-start="928.91" data-end="931.36">I told you to use a mental model for understanding yield.</span> <span data-start="931.36" data-end="935.29">The model I gave you was  —  it's sort of like an intermediary return.</span> <span data-start="935.29" data-end="940.52">But in this particular piece of code, it's used like an expression.</span> <span data-start="940.52" data-end="943.899">We're siding to the result of a yield.</span> <span data-start="943.899" data-end="946.16">So what's that about?</span> <span data-start="946.16" data-end="947.68">Here we have a producer function.</span> </p>
<p><span data-start="947.68" data-end="949.62">And what it's actually going to produce if you notice what's on the right</span> <span data-start="949.62" data-end="953.25">hand side of those yields  —  it's going to be an iterator of promises.</span> <span data-start="953.25" data-end="957.339">So we're going to pull promises out of this iterator,</span> <span data-start="957.339" data-end="960.99">and then what we're going to do is we're going to resolve those promises</span> <span data-start="960.99" data-end="963.87">and then push the value back in.</span> <span data-start="963.87" data-end="966.76">And so we need a consumer to go along with this producer.</span> </p>
<p><span data-start="966.76" data-end="968.87">The consumer's job is just going to be to pull</span> <span data-start="968.87" data-end="973.18">out, by calling next, pull out promises, resolve those promises, and push</span> <span data-start="973.18" data-end="974.18">the value back in.</span> <span data-start="974.18" data-end="976.29">And what you're going to see later is when you push</span> <span data-start="976.29" data-end="981.08">a value back into the generator, the whole yield expression gets replaced with</span> <span data-start="981.08" data-end="982.79">the value that you put back in.</span> <span data-start="982.79" data-end="983.79">And this is the key.</span> <span data-start="983.79" data-end="986.56">This is the recipe to allow you guys to write code that</span> <span data-start="986.56" data-end="989.29">looks  —  that looks like it blocks, but actually waits.</span> <span data-start="989.29" data-end="990.75">So let's take a look at how this works.</span> <span data-start="990.75" data-end="992.601">We have this spawn function, which I'm going to define</span> <span data-start="992.601" data-end="993.61">in just a moment.</span> <span data-start="993.61" data-end="995.779">Think about as the consumer  —  it's pulling promises out</span> <span data-start="995.779" data-end="998.39">of this iterator promise.</span> </p>
<p><span data-start="998.39" data-end="1000.34">So if I run this, what spawn is going to do is</span> <span data-start="1000.34" data-end="1004.089">it's going to produce a promise which will be the eventual result of get</span> <span data-start="1004.089" data-end="1007.83">stock price, after we resolve the get stock symbol promise and the get stock</span> <span data-start="1007.83" data-end="1009.26">symbol price promise.</span> <span data-start="1009.26" data-end="1012.07">So when I run this code eventually it's going to</span> <span data-start="1012.07" data-end="1014.81">run the price of an individual stock.</span> <span data-start="1014.81" data-end="1016.95">In this case, Pfizer stock.</span> <span data-start="1016.95" data-end="1018.45">Well, asynchronous iteration works this way.</span> <span data-start="1018.45" data-end="1021.01">You've got a consumer and a producer.</span> <span data-start="1021.01" data-end="1024.959">The consumer requests a generator from the producer.</span> <span data-start="1024.959" data-end="1028.369">And then calls next, pulls out the first value, but notice</span> <span data-start="1028.369" data-end="1032.65"> —  execution suspends at the first yield.</span> <span data-start="1032.65" data-end="1035.299">And what we're yielding back is a promise.</span> <span data-start="1035.299" data-end="1038.76">It's a promise that will eventually resolve to the symbol</span> <span data-start="1038.76" data-end="1039.76">for Pfizer.</span> <span data-start="1039.76" data-end="1042.52">And so that promise is handed to the consumer, and the consumer</span> <span data-start="1042.52" data-end="1044.12">and the producer have an agreement.</span> </p>
<p><span data-start="1044.12" data-end="1047.53">The consumer says  —  every promise I pull out, I'm going to</span> <span data-start="1047.53" data-end="1052.03">resolve, and then I'm going to push the value back into the producer.</span> <span data-start="1052.03" data-end="1057.04">So the consumer calls then on the promise, waits until it's resolved, and</span> <span data-start="1057.04" data-end="1061.55">then calls next again, on the generator, from the producer, except this time</span> <span data-start="1061.55" data-end="1066.82"> —  notice we pass PFE in the argument position of next.</span> <span data-start="1066.82" data-end="1070.25">We're effectively pushing a value in, at the same time as we're</span> <span data-start="1070.25" data-end="1071.93">pulling a value out.</span> <span data-start="1071.93" data-end="1074.44">So we send PFE back in, and now I want you to look</span> <span data-start="1074.44" data-end="1075.93">at what happens to the yield expression.</span> <span data-start="1075.93" data-end="1080.19">It effectively gets replaced with a value that we get pushed</span> <span data-start="1080.19" data-end="1084.96">in, and then execution resumes, and pauses at the next yield.</span> <span data-start="1084.96" data-end="1087.9">So now the consumer's pushed in a value, and at the same</span> <span data-start="1087.9" data-end="1090.03">time, they're pulling out another promise.</span> </p>
<p><span data-start="1090.03" data-end="1092.809">This time for the price of that particular stock.</span> <span data-start="1092.809" data-end="1094.679">So agreement between the consumer and the producer</span> <span data-start="1094.679" data-end="1097.76"> —  the consumer is going to resolve that promise.</span> <span data-start="1097.76" data-end="1099.79">And when it gets a value, it's going to call next</span> <span data-start="1099.79" data-end="1104.8">again, and this time, push 2783 back into the producer.</span> </p>
<p><span data-start="1104.8" data-end="1108.02">That replaces yield.</span> <span data-start="1108.02" data-end="1111.74">And we continue and stop at the final return value.</span> <span data-start="1111.74" data-end="1113.46">So now we've actually returned  —  it's not a promise.</span> <span data-start="1113.46" data-end="1115.15">It's just a plain old value.</span> <span data-start="1115.15" data-end="1116.15">Back to the consumer.</span> <span data-start="1116.15" data-end="1117.15">And we said  —  hey, we're done.</span> <span data-start="1117.15" data-end="1118.31">We're not going to give you any more data.</span> <span data-start="1118.31" data-end="1121.07">At this point, the consumer takes the promise that it</span> <span data-start="1121.07" data-end="1127.02">returned, the spawn function, and it resolves it to the final value, 2783.</span> <span data-start="1127.02" data-end="1128.55">So pictures are great.</span> </p>
<p><span data-start="1128.55" data-end="1130.3">But let's take a look at some code.</span> <span data-start="1130.3" data-end="1132.84">So here I have get stock price.</span> <span data-start="1132.84" data-end="1135.9">And then I have this spawn function, which consumes it.</span> <span data-start="1135.9" data-end="1139.37">So notice at the bottom I'm calling spawn, but I'm passing in</span> <span data-start="1139.37" data-end="1141.95">the generator that comes out of get stock price into spawn.</span> <span data-start="1141.95" data-end="1144.36">And what's going to come out of that is a promise that's</span> <span data-start="1144.36" data-end="1147.53">eventually going to resolve to the final price of that stock.</span> <span data-start="1147.53" data-end="1148.97">So I run this.</span> <span data-start="1148.97" data-end="1151.961">And what happens is we immediately create a promise inside of the</span> <span data-start="1151.961" data-end="1153.01">spawn function.</span> <span data-start="1153.01" data-end="1155.92">And execution runs to the very bottom and hits this onresult</span> <span data-start="1155.92" data-end="1156.92">function.</span> <span data-start="1156.92" data-end="1160.08">And this function is basically my way of asynchronously looping</span> <span data-start="1160.08" data-end="1161.49">and continuing to resolve promises.</span> <span data-start="1161.49" data-end="1164.72">You're going to see me recursively call this function again and</span> <span data-start="1164.72" data-end="1167.52">again, every single time I get a new value out of a promise.</span> </p>
<p><span data-start="1167.52" data-end="1172.66">So we go up here, first time around, the last result is</span> <span data-start="1172.66" data-end="1177.45">, haven't gotten any yet, as soon as I call next, notice up</span> <span data-start="1177.45" data-end="1182.95">there at the top, execution stops at the first yield and we return a promise</span> <span data-start="1182.95" data-end="1185.61">that symbolizes the eventual stock symbol.</span> </p>
<p><span data-start="1185.61" data-end="1187.79">And that gets returned to the consumer.</span> <span data-start="1187.79" data-end="1191.65">If it's a promise, the consumer calls then on it.</span> <span data-start="1191.65" data-end="1194.94">Notice here we're passing on the onresult function we started with.</span> <span data-start="1194.94" data-end="1198.8">If but this time when the on result function is called it's going to get the result</span> <span data-start="1198.8" data-end="1200.12">of that promise.</span> <span data-start="1200.12" data-end="1203.16">So as soon as I do this, we're going to hop up back here,</span> <span data-start="1203.16" data-end="1206.9">and the last promise result is going to be whatever came out of that promise.</span> <span data-start="1206.9" data-end="1207.9">JNJ.</span> <span data-start="1207.9" data-end="1209.95">So now I got the result of the promise as a producer, but I</span> <span data-start="1209.95" data-end="1213.809">want to push it back  —  excuse me, the consumer.</span> <span data-start="1213.809" data-end="1215.48">I want to push it book back to the producer.</span> <span data-start="1215.48" data-end="1216.51">So I call next.</span> <span data-start="1216.51" data-end="1220.03">I pass back in JNJ as the argument, you look</span> <span data-start="1220.03" data-end="1224.499">at the top there, notice what happens to the yield symbol promise expression</span> <span data-start="1224.499" data-end="1228.5"> —  it gets replaced with JNJ and execution resumes and stops at the next</span> <span data-start="1228.5" data-end="1229.85">yield point.</span> </p>
<p><span data-start="1229.85" data-end="1232.87">So get symbol price is a promise that eventually resolves to the</span> <span data-start="1232.87" data-end="1234.74">price.</span> <span data-start="1234.74" data-end="1236.74">That's what comes out to the consumer.</span> <span data-start="1236.74" data-end="1237.74">Another promise.</span> <span data-start="1237.74" data-end="1238.809">We call then on it again.</span> <span data-start="1238.809" data-end="1241.95">Pass in on result, that recursively gets resolved to</span> <span data-start="1241.95" data-end="1245.97">the next promise, which is the price.</span> </p>
<p><span data-start="1245.97" data-end="1251.17">We call next, yield gets replaced with that price, and then we continue</span> <span data-start="1251.17" data-end="1254.18">on to the very end of the generator function, at which point it comes out</span> <span data-start="1254.18" data-end="1255.18">and says  —  you know what?</span> <span data-start="1255.18" data-end="1256.18">Done is true.</span> </p>
<p><span data-start="1256.18" data-end="1257.65">We're not going to get any more values.</span> <span data-start="1257.65" data-end="1259.53">Consumer takes that, doesn't need to resolve it, it's not a</span> <span data-start="1259.53" data-end="1263.65">promise, and then resolves the overall promise that was returned from</span> <span data-start="1263.65" data-end="1266.51">spawn to that final value.</span> </p>
<p><span data-start="1266.51" data-end="1269.39">And that's how asynchronous iteration works.</span> <span data-start="1269.39" data-end="1272.21">And that's how you can write code at the top, right?</span> <span data-start="1272.21" data-end="1276.27">That looks like it blocks, but it actually waits.</span> <span data-start="1276.27" data-end="1278.75">So there is this spawn function actually defined</span> <span data-start="1278.75" data-end="1281.74">in a library that you can go and try, which is called task.js.</span> <span data-start="1281.74" data-end="1286.42">If you're using a transpiler that allows you to use yield in your code or you're using</span> <span data-start="1286.42" data-end="1291.16">a browser that is ES2015 capable, lucky you, you can do this today.</span> <span data-start="1291.16" data-end="1296.45">You can download the spawn function, which is in task.js.</span> <span data-start="1296.45" data-end="1300.929">So that's how asynchronous functions work and how generators interact with promises</span> <span data-start="1300.929" data-end="1303.48">to produce this pretty impressive code.</span> </p>
<p><span data-start="1303.48" data-end="1306.99">But why should we have to download a library to do</span> <span data-start="1306.99" data-end="1307.99">this?</span> <span data-start="1307.99" data-end="1313.88">This is going to be a common expression in JavaScript.</span> <span data-start="1313.88" data-end="1315.1">Why do we need a library?</span> <span data-start="1315.1" data-end="1318.23">Why can't we have direct support in the JavaScript language for</span> <span data-start="1318.23" data-end="1319.23">this?</span> <span data-start="1319.23" data-end="1324.15">And that is our first feature today from ES2016, and its async</span> <span data-start="1324.15" data-end="1325.15">functions.</span> <span data-start="1325.15" data-end="1326.6">And now you guys know everything you need to know about how</span> <span data-start="1326.6" data-end="1327.95">async functions need to work.</span> <span data-start="1327.95" data-end="1330.67">They are like sugar over what you just saw.</span> <span data-start="1330.67" data-end="1335">This combination of spawn and yield  —  soon in the next version of JavaScript</span> <span data-start="1335" data-end="1338.51">you'll be able to write code like this, on the left hand side.</span> <span data-start="1338.51" data-end="1340.84">For those of you who are familiar with C#, this feature</span> <span data-start="1340.84" data-end="1342.49">is there as well.</span> </p>
<p><span data-start="1342.49" data-end="1347.82">You can just put the word async in front of any function</span> <span data-start="1347.82" data-end="1350.45">and then inside of there, any time you want to pause until a promise has</span> <span data-start="1350.45" data-end="1353.5">been resolved, you can throw a wait in there.</span> <span data-start="1353.5" data-end="1356.36">So that's what's coming in the next version of JavaScript.</span> <span data-start="1356.36" data-end="1360.34">So we're getting closer to this vision of symmetrical</span> <span data-start="1360.34" data-end="1363.04">support for blocking and waiting in JavaScript.</span> <span data-start="1363.04" data-end="1364.04">Right?</span> </p>
<p><span data-start="1364.04" data-end="1365.89">If I want to wait, I throw an async in front of that function.</span> <span data-start="1365.89" data-end="1367.08">I throw a few waits in there.</span> <span data-start="1367.08" data-end="1370.81">If I want to block, I take them out.</span> <span data-start="1370.81" data-end="1372.59">In order to talk about any features in the next version</span> <span data-start="1372.59" data-end="1377.81">of JavaScript, responsibly, we have talk about the ES feature maturity stages.</span> <span data-start="1377.81" data-end="1381.61">So as we develop new protocols in JavaScript committee, we have to give time</span> <span data-start="1381.61" data-end="1386">to move them out.</span> <span data-start="1386" data-end="1391">So I'm going to tell you about which stage it is in maturity.</span> <span data-start="1391" data-end="1393.38">So async functions are in the draft stage.</span> </p>
<p><span data-start="1393.38" data-end="1396.24">That means that the committee expects the feature to be</span> <span data-start="1396.24" data-end="1397.71">developed and included in the standard.</span> <span data-start="1397.71" data-end="1400.429">I think it's very, very likely we're going to see async functions in the</span> <span data-start="1400.429" data-end="1402.13">next version of JavaScript.</span> <span data-start="1402.13" data-end="1403.54">It's definitely something you can play with today</span> <span data-start="1403.54" data-end="1407">if you use Babel or a transpiler, like Tracer.</span> <span data-start="1407" data-end="1408.34">Right now.</span> <span data-start="1408.34" data-end="1409.63">If you want to.</span> <span data-start="1409.63" data-end="1411.35">Go ahead, try it out.</span> <span data-start="1411.35" data-end="1412.35">That's why it's there.</span> <span data-start="1412.35" data-end="1415.09">And give us your feedback.</span> <span data-start="1415.09" data-end="1420.059">You can try it in Babel, if you want to try it in Regenerator as well</span> <span data-start="1420.059" data-end="1424.14"> —  I think they're in the main branch.</span> <span data-start="1424.14" data-end="1427.89">Babel is probably the easiest and most likely way by which you're</span> <span data-start="1427.89" data-end="1429.809">going to try this feature.</span> <span data-start="1429.809" data-end="1432.12">The await keyboard makes it easy to await one</span> <span data-start="1432.12" data-end="1434.37">asynchronous value.</span> </p>
<p><span data-start="1434.37" data-end="1436.809">What if you want to wait on multiple values?</span> <span data-start="1436.809" data-end="1439.39">We await multiple values all the time.</span> <span data-start="1439.39" data-end="1441.39">Web sockets, DOM events.</span> <span data-start="1441.39" data-end="1445.51">Lots of streams of information that are being pushed at us, and</span> <span data-start="1445.51" data-end="1449.44">there's no real language support for traversing those streams of information.</span> <span data-start="1449.44" data-end="1453.13">Now, in ES6, all collections became iterable.</span> <span data-start="1453.13" data-end="1456.3">And it's a contract.</span> <span data-start="1456.3" data-end="1458.28">If you walk up to the array, for example, it means</span> <span data-start="1458.28" data-end="1462.26">you can ask that array for an iterator, and gradually consume its items</span> <span data-start="1462.26" data-end="1464.39">one at a time by pulling them out.</span> <span data-start="1464.39" data-end="1466.01">Here's an example.</span> <span data-start="1466.01" data-end="1471.09">I can call this symbol.iterator method and get out an</span> <span data-start="1471.09" data-end="1473.34">iterator and keep looping and calling next.</span> </p>
<p><span data-start="1473.34" data-end="1477.88">That's annoying, a lot of boilerplate, which is why in ES2016 we introduced</span> <span data-start="1477.88" data-end="1484.04">this for of loop.</span> <span data-start="1484.04" data-end="1486.14">So there's a couple of new collections coming</span> <span data-start="1486.14" data-end="1490.69">in ES6 as well, like maps, and you can use this  —  to consume that data.</span> <span data-start="1490.69" data-end="1491.69">Progressively.</span> <span data-start="1491.69" data-end="1493.28">So that's what the new for of loop is for.</span> <span data-start="1493.28" data-end="1496.11">It just desugars to what you see on the left hand side.</span> <span data-start="1496.11" data-end="1500.929">Now, if we can wait for values that we can pull out, for streams</span> <span data-start="1500.929" data-end="1504.4">of values that we can pull out, why can't we wait for streams of values that</span> <span data-start="1504.4" data-end="1506.23">are being pushed at us?</span> <span data-start="1506.23" data-end="1508.65">Why can't we have an equal support, like a loop for</span> <span data-start="1508.65" data-end="1512.4">consuming data that comes out of a web socket, or comes out of async IO, for</span> <span data-start="1512.4" data-end="1513.83">example?</span> <span data-start="1513.83" data-end="1518.1">That's the logic behind the proposed for on loop for the next</span> <span data-start="1518.1" data-end="1519.46">version of JavaScript.</span> <span data-start="1519.46" data-end="1521.711">If you can have a for of, why can't you have a for</span> <span data-start="1521.711" data-end="1522.79">on?</span> </p>
<p><span data-start="1522.79" data-end="1527.92">So I'm creating an async function and inside I'm consuming the prices</span> <span data-start="1527.92" data-end="1529.1">from a web socket.</span> <span data-start="1529.1" data-end="1531.72">And the very first price differential that's over a</span> <span data-start="1531.72" data-end="1534.77">certain threshold  —  I'm going to resolve the promise and grab that</span> <span data-start="1534.77" data-end="1538.45">particular diff between the previous price and the next price.</span> <span data-start="1538.45" data-end="1539.809">No callbacks required.</span> <span data-start="1539.809" data-end="1542.59">I'm just looping over a stream of information being</span> <span data-start="1542.59" data-end="1545.03">pushed at me.</span> <span data-start="1545.03" data-end="1546.52">So this would be great to do.</span> <span data-start="1546.52" data-end="1547.52">Right?</span> </p>
<p><span data-start="1547.52" data-end="1549.38">Now when I run this, it resolves to a promise to give you the next</span> <span data-start="1549.38" data-end="1551.4">price spike in this stream of stock prices.</span> <span data-start="1551.4" data-end="1553.01">But there's a little problem.</span> <span data-start="1553.01" data-end="1555.97">There's a reason we can't have nice things just yet.</span> </p>
<p><span data-start="1555.97" data-end="1556.97">Right?</span> <span data-start="1556.97" data-end="1560.84">The problem is that the web has no standard observable interface.</span> <span data-start="1560.84" data-end="1561.84">We have iterable.</span> <span data-start="1561.84" data-end="1566.75">As of ES6, this contract you saw earlier, what you call symbol.iterator.</span> <span data-start="1566.75" data-end="1571.51">But today we have this proliferation of different APIs that push</span> <span data-start="1571.51" data-end="1572.929">us streams of data.</span> <span data-start="1572.929" data-end="1576.59">That push us data in a callback in a streamed way.</span> </p>
<p><span data-start="1576.59" data-end="1584.68">DOM events, web sockets, node streams, XHTML requests  —  can all push you</span> <span data-start="1584.68" data-end="1586.37">values.</span> <span data-start="1586.37" data-end="1588.94">But they don't implement one common interface.</span> <span data-start="1588.94" data-end="1595.36">So one thing proposed for ES2016 is the observable contract.</span> </p>
<p><span data-start="1595.36" data-end="1598.49">So here we have the iterable contract, introduced in</span> <span data-start="1598.49" data-end="1599.49">2015.</span> <span data-start="1599.49" data-end="1601.01">How are we going to get the observable contract?</span> <span data-start="1601.01" data-end="1604.25">It's hidden inside of this type.</span> <span data-start="1604.25" data-end="1609.481">If we just swap the arguments and the return type of the</span> <span data-start="1609.481" data-end="1613.179">iterable what pops out is an observable.</span> <span data-start="1613.179" data-end="1618.57">An observable accepts a generator, and then uses the push side of</span> <span data-start="1618.57" data-end="1623.53">the generator, and pushes multiple values in it until it finally calls</span> <span data-start="1623.53" data-end="1626.79">return to signal that no more values are coming.</span> <span data-start="1626.79" data-end="1631.02">If you think about it, iteration and observation are both about the same thing.</span> <span data-start="1631.02" data-end="1633.88">Both about a producer giving a consumer multiple values.</span> </p>
<p><span data-start="1633.88" data-end="1636.309">The difference is in one circumstance with DOM</span> <span data-start="1636.309" data-end="1639.47">events, the data is being pushed to you.</span> <span data-start="1639.47" data-end="1642.559">But when you're using an iterator to pull values out of an array, you're</span> <span data-start="1642.559" data-end="1643.559">pulling values.</span> <span data-start="1643.559" data-end="1644.559">Right?</span> <span data-start="1644.559" data-end="1646.46">In iteration, the consumer is in control, and in</span> <span data-start="1646.46" data-end="1648.64">observation, the producer is in control.</span> </p>
<p><span data-start="1648.64" data-end="1651.19">The web socket decides when it calls you.</span> <span data-start="1651.19" data-end="1653.45">So it's sort of like they're it rating you.</span> <span data-start="1653.45" data-end="1655.42">The producer is iterating you by calling your callback.</span> <span data-start="1655.42" data-end="1658.01">So how does observation work?</span> <span data-start="1658.01" data-end="1660.03">The consumer and producer and the relationship</span> <span data-start="1660.03" data-end="1664.47">with iteration  —  it's the exact same process but kind of the inverse.</span> </p>
<p><span data-start="1664.47" data-end="1669.73">So here the producer, instead of the consumer requesting a generator from the producer,</span> <span data-start="1669.73" data-end="1674.36">the producer  —  or the consumer hands a generator to the producer.</span> <span data-start="1674.36" data-end="1677.02">And in this context, just think about a generator as like three callbacks.</span> <span data-start="1677.02" data-end="1680.179">It's got the next, the throw, and the return callbacks.</span> </p>
<p><span data-start="1680.179" data-end="1682.48">Just like you're handing an API three callbacks and</span> <span data-start="1682.48" data-end="1686.01">expecting it to push information to you by calling your callbacks.</span> <span data-start="1686.01" data-end="1689.99">So the producer produces a value and calls the next</span> <span data-start="1689.99" data-end="1692.89">method on your generator, the one you provided to it, and that's how</span> <span data-start="1692.89" data-end="1697.94">it pushes 42 to you, and pushes another value and at its leisure, decides</span> <span data-start="1697.94" data-end="1700.94">to push 39 to you, until finally it says you know what?</span> <span data-start="1700.94" data-end="1702.37">There's no more data coming.</span> <span data-start="1702.37" data-end="1705.47">So it calls return to indicate to you no more data will</span> <span data-start="1705.47" data-end="1708.2">arrive.</span> <span data-start="1708.2" data-end="1711">So observation and iteration are actually deeply linked.</span> <span data-start="1711" data-end="1714.33">As we saw, we can turn one inside out and get the other.</span> </p>
<p><span data-start="1714.33" data-end="1719.62">So this is what it would look like to consume a web socket or a DOM event that implemented</span> <span data-start="1719.62" data-end="1720.62">this contract.</span> <span data-start="1720.62" data-end="1722.89">You could just walk up to any of these data sources and hand it a</span> <span data-start="1722.89" data-end="1727.09">generator, which is these three callbacks, and then it will just push</span> <span data-start="1727.09" data-end="1728.09">streams of data at you.</span> </p>
<p><span data-start="1728.09" data-end="1730.72">Until it tells you it's done.</span> <span data-start="1730.72" data-end="1735.26">So we can add sugar, just like we added sugar for iteration, for</span> <span data-start="1735.26" data-end="1738.84">that whole process of calling symbol.iterator, and that while loop, and</span> <span data-start="1738.84" data-end="1742.32">checking the done property, just like we can add sugar for that, we can add</span> <span data-start="1742.32" data-end="1744.45">sugar for observation.</span> <span data-start="1744.45" data-end="1747.289">A 4H method, for example, to an observer that returned</span> <span data-start="1747.289" data-end="1752.34">a promise when it resolved, or, as I showed you guys earlier, now that</span> <span data-start="1752.34" data-end="1758.299">we have a well defined method for observation, which we do, a for on loop.</span> <span data-start="1758.299" data-end="1762.59">So the push stream can be done entirely without callbacks.</span> <span data-start="1762.59" data-end="1767.53">So the hope would be if we introduce observable, all the push APIs on the web can implement</span> <span data-start="1767.53" data-end="1771.13">this contract and all of a sudden we can just add language support magically</span> <span data-start="1771.13" data-end="1773.88">for all of these different push data sources.</span> </p>
<p><span data-start="1773.88" data-end="1778.13">So if I wanted to consume an observable in ES2016, at least as the proposal</span> <span data-start="1778.13" data-end="1780.24">stands, I could do something like this.</span> <span data-start="1780.24" data-end="1783.97">And this is just going to keep printing out new sign-ups at Netflix.</span> <span data-start="1783.97" data-end="1786.63">Just going to keep going.</span> <span data-start="1786.63" data-end="1787.63">So..</span> <span data-start="1787.63" data-end="1791.46">If an async function returns a promise, and a function</span> <span data-start="1791.46" data-end="1797.059">star returns an iterator, we as language designers have a question to</span> <span data-start="1797.059" data-end="1800.16">answer.</span> <span data-start="1800.16" data-end="1802.19">What does an async function star return?</span> <span data-start="1802.19" data-end="1804.15">You can't just go adding features to languages and</span> <span data-start="1804.15" data-end="1807.82">not describing what happens when you put them together, when they</span> <span data-start="1807.82" data-end="1808.82">interact.</span> </p>
<p><span data-start="1808.82" data-end="1811.09">Well, there's a couple of different opinions about this.</span> <span data-start="1811.09" data-end="1812.33">And there's actually a couple different ways the</span> <span data-start="1812.33" data-end="1813.33">committee could go.</span> <span data-start="1813.33" data-end="1815.03">I'm here today to tell you about one particular</span> <span data-start="1815.03" data-end="1816.03">option.</span> <span data-start="1816.03" data-end="1818.35">So if we look at this table, we've got synchronous functions,</span> <span data-start="1818.35" data-end="1823.91">which return a value, synchronous generators, which return multiple values,</span> <span data-start="1823.91" data-end="1828.1">you can pull multiple values out of  —  but we also have asynchronous functions,</span> <span data-start="1828.1" data-end="1832.36">which return a promise, and a promise pushes you one value.</span> </p>
<p><span data-start="1832.36" data-end="1833.36">Right?</span> <span data-start="1833.36" data-end="1836.13">You give it a callback and it pushes the value on that callback.</span> <span data-start="1836.13" data-end="1838.44">But what goes here?</span> <span data-start="1838.44" data-end="1844.12">Well, if a function star returns multiple values, and an async function</span> <span data-start="1844.12" data-end="1851.44">pushes one value, maybe an async function star pushes multiple values.</span> <span data-start="1851.44" data-end="1854.57">And what type pushes us multiple values?</span> </p>
<p><span data-start="1854.57" data-end="1857.02">An observable.</span> <span data-start="1857.02" data-end="1859.12">So we can envision, in the next version of JavaScript,</span> <span data-start="1859.12" data-end="1864.16">an async function star, which pushes  —  which actually returns you an observable.</span> <span data-start="1864.16" data-end="1868.79">So you could build an asynchronous generator function,</span> <span data-start="1868.79" data-end="1873.89">which consumes data, stock data, for example, and then translates it and produces</span> <span data-start="1873.89" data-end="1876.06">new stock data.</span> <span data-start="1876.06" data-end="1879.159">So now, instead of just getting the next price spike</span> <span data-start="1879.159" data-end="1881.96">from a web socket, I want to get all the price spikes from a web socket.</span> <span data-start="1881.96" data-end="1887.33">I'm going to use the for on loop and yield inside of async function star, and this</span> <span data-start="1887.33" data-end="1891.48">whole thing is going to produce an observable that pushes me all the</span> <span data-start="1891.48" data-end="1894.98">price spikes, all the stock differences, when one stock comes along and</span> <span data-start="1894.98" data-end="1897.559">another stock comes along, and that price difference is over a certain</span> <span data-start="1897.559" data-end="1899.91">threshold, just going to push it on through to me.</span> </p>
<p><span data-start="1899.91" data-end="1902.909">And if I want to consume this, I can just use for</span> <span data-start="1902.909" data-end="1903.909">on, inside of an async function.</span> <span data-start="1903.909" data-end="1908.6">And print to the console.</span> <span data-start="1908.6" data-end="1909.6">So what does that mean?</span> <span data-start="1909.6" data-end="1912.88">It means symmetrical support for functions that return multiple</span> <span data-start="1912.88" data-end="1913.88">values.</span> <span data-start="1913.88" data-end="1915.63">Whether they're push or they're pull.</span> <span data-start="1915.63" data-end="1918.539">You guys can stop worrying about the machinery and the callbacks and just</span> <span data-start="1918.539" data-end="1920.419">focus on your code.</span> </p>
<p><span data-start="1920.419" data-end="1921.73">So..</span> <span data-start="1921.73" data-end="1925.03">This particular proposal  —  I just want to call out  —  is at the strawman phase.</span> <span data-start="1925.03" data-end="1927.16">The earliest phase of the process.</span> <span data-start="1927.16" data-end="1928.49">So we're definitely going to be thinking about</span> <span data-start="1928.49" data-end="1931.77">this more, and this may not make it through as a final feature.</span> <span data-start="1931.77" data-end="1933.03">Just want to make that clear.</span> <span data-start="1933.03" data-end="1935.34">It's very early in the feature stages.</span> <span data-start="1935.34" data-end="1936.84">We're looking for feedback on this.</span> <span data-start="1936.84" data-end="1939.45">So we want to hear from you about whether this works for you</span> <span data-start="1939.45" data-end="1941.59">and solves your problems.</span> <span data-start="1941.59" data-end="1942.94">So thanks very much, everybody.</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
