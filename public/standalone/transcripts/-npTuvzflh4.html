<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>-npTuvzflh4</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/-npTuvzflh4?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="10.889" data-end="11.889">Thank you.</span> <span data-start="11.889" data-end="12.94">Thank you, everyone.</span> <span data-start="12.94" data-end="17.46">Well, there's one thing I've learned working with my team that I would like to share and</span> <span data-start="17.46" data-end="27.019">that I will never forget is that we know that writing fast applications makes our users</span> <span data-start="27.019" data-end="29.25">and our customers happy.</span> <span data-start="29.25" data-end="31.269">So, who doesn't want to write fast code?</span> </p>
<p><span data-start="31.269" data-end="32.509">Raise your hand.</span> <span data-start="32.509" data-end="33.509">Naw.</span> <span data-start="33.509" data-end="35.059">That's interesting.</span> <span data-start="35.059" data-end="39.84">So, before we start, I have a couple of questions that I need to ask.</span> <span data-start="39.84" data-end="44.23">And then I'll see what the Internet tells us.</span> <span data-start="44.23" data-end="49.57">So, the first question is, if you go on your favorite web browser and your favorite search</span> <span data-start="49.57" data-end="53.149">engine and you type "Is JavaScript fast?</span> <span data-start="53.149" data-end="55.15">How fast is JavaScript?"</span> <span data-start="55.15" data-end="60.89">Probably get something like this that says, and I'm just quoting," Under the right circumstances</span> <span data-start="60.89" data-end="61.96">it is very fast.</span> <span data-start="61.96" data-end="65.78">Actually, as fast as C."</span> <span data-start="65.78" data-end="71.16">If you search again, another result would be, "Why is it so fast?</span> <span data-start="71.16" data-end="77.03">It is because as soon as you understand event loop and how it processes requests, you realize</span> <span data-start="77.03" data-end="78.68">it's so fast."</span> <span data-start="78.68" data-end="83.75">You start to see a pattern, because fast is because it's fast.</span> <span data-start="83.75" data-end="89.96">And you keep going on and you get stuff like, "How can it be so fast since it's a single</span> <span data-start="89.96" data-end="91.57">thread?"</span> </p>
<p><span data-start="91.57" data-end="98.049">And the answer, like in this example is because it's lightweight.</span> <span data-start="98.049" data-end="103.85">We keep going and then you find this interesting question."</span> <span data-start="103.85" data-end="106.34">How fast is it compared to Java?"</span> <span data-start="106.34" data-end="112.241">Well, because most recruiters think that Java and JavaScript is the same thing, which is</span> <span data-start="112.241" data-end="113.36">kind of interesting.</span> <span data-start="113.36" data-end="120.57">So, if you look around on the Internet, you see JS is and shines when it comes to a huge</span> <span data-start="120.57" data-end="125.159">amount of short connections.</span> <span data-start="125.159" data-end="131.22">And finally, I could be all day showing Google results.</span> <span data-start="131.22" data-end="133.23">But what does it make faster than Java?</span> <span data-start="133.23" data-end="140.51">Well, and the answer is because the sync ecosystem is more than 50,000 modules written in asynchronous</span> <span data-start="140.51" data-end="141.51">style.</span> <span data-start="141.51" data-end="144.04">It's kind of a strange answer to the question.</span> <span data-start="144.04" data-end="153.17">But giving all these questions, we need to ask, do we trust the Internet?</span> <span data-start="153.17" data-end="157.66">Like the Internet is full of stories, and like some Game of Thrones characters said</span> <span data-start="157.66" data-end="160.519">a few weeks ago, stories connect people.</span> </p>
<p><span data-start="160.519" data-end="164.03">However, stories are not exact science.</span> <span data-start="164.03" data-end="171.15">And above all, they should not drive us as a software engineer.</span> <span data-start="171.15" data-end="176.349">So, my interpretation is, do I trust the Internet?</span> <span data-start="176.349" data-end="177.349">No.</span> <span data-start="177.349" data-end="178.349">I don't.</span> <span data-start="178.349" data-end="179.53">And why?</span> <span data-start="179.53" data-end="185.8">Because I am a software engineer, as you can if you don't know who invented who coined</span> <span data-start="185.8" data-end="192.23">term you can go in our exhibition hall and there's an explanation there who did it.</span> <span data-start="192.23" data-end="199.909">And you see that if you look on the dictionary for software engineering, it says engineer</span> <span data-start="199.909" data-end="204.45">is the application of science and mathematics by which the properties of matter and the</span> <span data-start="204.45" data-end="208.37">sources of energy and nature are made useful to people.</span> </p>
<p><span data-start="208.37" data-end="215.9">So, as a software engineer, we should apply science and mathematics to solve our problems.</span> <span data-start="215.9" data-end="220.72">So, going back to the question, is JavaScript fast?</span> <span data-start="220.72" data-end="223.379">We need we must be able to reproduce a problem.</span> <span data-start="223.379" data-end="226.56">We must be able to explain the results.</span> <span data-start="226.56" data-end="228.4">And reproduce the results.</span> <span data-start="228.4" data-end="233.45">So, I think the right answer is, is JavaScript fast?</span> <span data-start="233.45" data-end="234.45">I don't know.</span> <span data-start="234.45" data-end="237.599">From these results, it's not clear.</span> <span data-start="237.599" data-end="241.43">So, starting now with the main topic.</span> </p>
<p><span data-start="241.43" data-end="244.44">Like when I was planning the talk, I needed a title.</span> <span data-start="244.44" data-end="249.02">So, I ended up with so things I learned make the fastest JavaScript server runtime in the</span> <span data-start="249.02" data-end="250.02">world.</span> <span data-start="250.02" data-end="254.15">I carefully decided to pick the word "Server."</span> <span data-start="254.15" data-end="259.739">Going to Wikipedia for a definition, a server is a computer in the network of users that</span> <span data-start="259.739" data-end="263.94">is used to provide services to other computers in the network.</span> <span data-start="263.94" data-end="271.95">So, what I'm about to tell you is not about command line applications or lambdas.</span> <span data-start="271.95" data-end="273.85">It's about long running processes.</span> <span data-start="273.85" data-end="277.08">So, we need to also define what is fast.</span> <span data-start="277.08" data-end="283.7">So, because when I say fast, I don't mean I'm fast because I put my server on a race</span> <span data-start="283.7" data-end="286.41">car and the car running around.</span> </p>
<p><span data-start="286.41" data-end="287.41">No.</span> <span data-start="287.41" data-end="291.2">What I mean by fast is we need to obtain a common set of metrics.</span> <span data-start="291.2" data-end="299.599">And for this, I'm using what the site reliability engineering has found out.</span> <span data-start="299.599" data-end="304.55">So, if don't know anything about site reliability engineering, there's this interesting link</span> <span data-start="304.55" data-end="306.159">with nice books from Google.</span> <span data-start="306.159" data-end="308.589">And Google has one of the biggest teams on SRE.</span> <span data-start="308.589" data-end="313.72">And SRE has identified five golden signals.</span> <span data-start="313.72" data-end="322.42">So, golden signals are critical to the monitoring teams to monitor their systems and identify</span> <span data-start="322.42" data-end="327.75">problems before they become really big problems.</span> <span data-start="327.75" data-end="331.08">So, there are many metrics to monitor.</span> <span data-start="331.08" data-end="340.41">But this team this team this SRE team showed that rate errors and latency, saturation utilization</span> <span data-start="340.41" data-end="346.71">contain virtually everything you need to know about what's going on and where.</span> </p>
<p><span data-start="346.71" data-end="351.86">Getting the signals is quite challenging and relies on a lot of the tools and services</span> <span data-start="351.86" data-end="354.18">you have at your disposal.</span> <span data-start="354.18" data-end="358.48">But for now, I'm just considering rate as in request per second.</span> <span data-start="358.48" data-end="361.19">Errors like in errors per second, of course.</span> <span data-start="361.19" data-end="365.159">And latency as in like response time including waiting and queuing.</span> <span data-start="365.159" data-end="368.33">So, focusing on wait, errors and latency.</span> </p>
<p><span data-start="368.33" data-end="370.209">I'm focusing on the software.</span> <span data-start="370.209" data-end="374.849">I'm not focusing on the hardware or in the operating system.</span> <span data-start="374.849" data-end="385.02">So, a typical server application has a wellset wellknown set of characteristics.</span> <span data-start="385.02" data-end="393.91">We need to know how the application behaves and only once we understand that, we can talk</span> <span data-start="393.91" data-end="394.91">about it.</span> <span data-start="394.91" data-end="396.12">So, what is a server application?</span> <span data-start="396.12" data-end="401.82">So, my definition of server application is a long running process that should be deployed</span> <span data-start="401.82" data-end="405.409">on a cloud or in bare metal.</span> </p>
<p><span data-start="405.409" data-end="407.45">And it should be attached to a fast network.</span> <span data-start="407.45" data-end="409.75">Otherwise the network becomes your bottleneck.</span> <span data-start="409.75" data-end="414.14">And, of course, should have enough CPU and memory.</span> <span data-start="414.14" data-end="418.99">So, your application is not strained by your hardware.</span> </p>
<p><span data-start="418.99" data-end="424.909">So, a longrunning process has different characteristics from a shortrunning process, of course.</span> <span data-start="424.909" data-end="432.33">So, in a longrunning process, the startup and warming up is not really relevant in the</span> <span data-start="432.33" data-end="436.65">fullspan life cycle of the server because it's a very tiny moment.</span> <span data-start="436.65" data-end="440.89">Again, this isn't true if you're talking about web applications on your browser.</span> <span data-start="440.89" data-end="445.31">Because you want to be as fast as possible because that's what's drives the happiness</span> <span data-start="445.31" data-end="446.99">of your users.</span> <span data-start="446.99" data-end="451.68">So, now we need to define our two major things.</span> </p>
<p><span data-start="451.68" data-end="454.25">Our two benchmark things.</span> <span data-start="454.25" data-end="458.479">Most Internet articles will tell you how fast something is.</span> <span data-start="458.479" data-end="463.73">But most of the time when you read the whole article, you see some graphs, really nice</span> <span data-start="463.73" data-end="464.73">graphs.</span> <span data-start="464.73" data-end="469.529">But the information about how the tests will perform and how the results were obtained</span> <span data-start="469.529" data-end="471.11">is needed.</span> <span data-start="471.11" data-end="474.26">From an engineering perspective, this is incorrect.</span> <span data-start="474.26" data-end="477.969">We should be able to reproduce the test and the results.</span> <span data-start="477.969" data-end="483.87">In a lab that gives you more or less exactly the same results of course.</span> <span data-start="483.87" data-end="493.019">On top of that, the experiment was we need to confirm that the results are not biased.</span> <span data-start="493.019" data-end="502.14">So, when I write a benchmark, I don't want to make it be my friend and enemy of the others.</span> <span data-start="502.14" data-end="504.43">It needs to be fair.</span> <span data-start="504.43" data-end="506.919">And writing benchmarks, of course, is hard.</span> </p>
<p><span data-start="506.919" data-end="513.84">Because first every benchmark you write will never represent a real-world use case.</span> <span data-start="513.84" data-end="517.76">It's always like a tiny subset that doesn't really represent your application.</span> <span data-start="517.76" data-end="522.9">So, you need to get into conclusions from just looking at the tiny bit of your life</span> <span data-start="522.9" data-end="524.06">cycle.</span> <span data-start="524.06" data-end="530.37">So, getting peers to review your code can be really hard to find.</span> <span data-start="530.37" data-end="539.58">And getting peers to that are willing to review what you wrote is even harder.</span> <span data-start="539.58" data-end="547.07">So, what I'm trying to tell is that benchmarking is hard.</span> <span data-start="547.07" data-end="557.7">And, however, there is a very popular benchmark out there that is called the tech and power</span> <span data-start="557.7" data-end="559.82">frameworks benchmark.</span> <span data-start="559.82" data-end="563.71">Why is this benchmark so interesting to me?</span> <span data-start="563.71" data-end="566.38">Well, to me it's like taking power.</span> </p>
<p><span data-start="566.38" data-end="572.41">A benchmark shows you the true nature of open source.</span> <span data-start="572.41" data-end="574.26">It has more than 500 contributors.</span> <span data-start="574.26" data-end="581.57">So, more than 500 different people have contributed to tests and reviewed the tests.</span> <span data-start="581.57" data-end="585">There are more than 3,000 merged pull requests.</span> <span data-start="585" data-end="594.67">So, lots of people spend time reviewing or adding new tests to the framework.</span> <span data-start="594.67" data-end="597.34">And they already have more than 10,000 commits.</span> <span data-start="597.34" data-end="601.46">So, it shows that it's kind of a big project.</span> <span data-start="601.46" data-end="605.13">It's not something that someone just planned in the weekend.</span> <span data-start="605.13" data-end="608.52">Oh, I want to check on my framework, how it works.</span> <span data-start="608.52" data-end="613.61">No, it's something that has been growing steadily for the last couple of years.</span> <span data-start="613.61" data-end="619.05">And it already tests more than 630 different frameworks.</span> <span data-start="619.05" data-end="622.35">And these frameworks are written in different languages.</span> <span data-start="622.35" data-end="629.2">So, this makes my life easier because I don't need to invent my own benchmark.</span> </p>
<p><span data-start="629.2" data-end="630.43">I don't need to explain it.</span> <span data-start="630.43" data-end="635.55">I can just use it to prove what I want to say.</span> <span data-start="635.55" data-end="640.7">So, if you want to have the link, this is like their GitHub repo.</span> <span data-start="640.7" data-end="645.37">And from the GitHub repo you can get to the main website, of course.</span> <span data-start="645.37" data-end="649.77">And as I said, there are like 630 different frameworks.</span> <span data-start="649.77" data-end="657.93">So, if I would try to print on the screen how it looks right now, well, it wouldn't</span> <span data-start="657.93" data-end="658.93">fit on the screen.</span> </p>
<p><span data-start="658.93" data-end="661.47">So, what I did, I just rotated my screen.</span> <span data-start="661.47" data-end="663.61">I took a screenshot.</span> <span data-start="663.61" data-end="665.82">And don't worry about the size.</span> <span data-start="665.82" data-end="667.57">It's not really relevant.</span> <span data-start="667.57" data-end="675.7">What I'm trying to say is that there are lots of frameworks that are already being tested.</span> <span data-start="675.7" data-end="681.65">And the quick question I want to ask the audience is, like, can you spot the best result for</span> <span data-start="681.65" data-end="685.29">the JavaScript framework on this graph?</span> <span data-start="685.29" data-end="687.52">So, probably you cannot because it's very small.</span> <span data-start="687.52" data-end="689.64">So, I have here a helper.</span> <span data-start="689.64" data-end="695.66">You'll find that as shocking as it can be, the first entry for JavaScript ranks at number</span> <span data-start="695.66" data-end="697.56">89.</span> <span data-start="697.56" data-end="705.53">Which performs at about 22.7% of the performance of the best result.</span> <span data-start="705.53" data-end="715.97">So, if you look at this, and think, well, we all have this idea that JavaScript is fast,</span> <span data-start="715.97" data-end="720.55">but results prove things wrong.</span> <span data-start="720.55" data-end="723.56">That it's not as fast as we think it is.</span> </p>
<p><span data-start="723.56" data-end="728.21">So, what we need to do is that we need to look under the hood.</span> <span data-start="728.21" data-end="732.47">So, before we can do any optimization, we need to understand what's going on.</span> <span data-start="732.47" data-end="736.97">And we shouldn't jump into conclusions and start tweaking the code of the benchmark.</span> <span data-start="736.97" data-end="739.54">Because otherwise we are just yak shaving.</span> <span data-start="739.54" data-end="741.65">And you're not really looking into the problem.</span> <span data-start="741.65" data-end="745.3">You're just trying to mitigate what could be the cause.</span> <span data-start="745.3" data-end="749.07">So, instead of this, we need to take a scientific approach.</span> <span data-start="749.07" data-end="753.21">And if you haven't learned anything about profiling in other applications, I would recommend</span> <span data-start="753.21" data-end="758.31">for you to look at the tutorial on the NodeJS website on profiling.</span> <span data-start="758.31" data-end="766.91">So, just to give you like in a nutshell the information from the from this tutorial.</span> <span data-start="766.91" data-end="773.61">That if you look at one of the tests of the benchmark, which is a very simple return,</span> <span data-start="773.61" data-end="777.54">hello world string from an HTTP server.</span> </p>
<p><span data-start="777.54" data-end="783.32">The best result that you could that you saw on the benchmark was implemented like this.</span> <span data-start="783.32" data-end="785.72">So, it uses the cluster module.</span> <span data-start="785.72" data-end="792.29">The cluster module will fork the node process for the number of CPUs that the environment</span> <span data-start="792.29" data-end="793.29">has.</span> <span data-start="793.29" data-end="800.65">And then it uses the express server to set the content type and send the response.</span> <span data-start="800.65" data-end="801.82">Okay.</span> <span data-start="801.82" data-end="807.67">Probably the express is not the most performant library out there.</span> <span data-start="807.67" data-end="810.12">But this is just for illustration.</span> <span data-start="810.12" data-end="817.44">So, once we do this and we do profiling, we get a flame graph.</span> <span data-start="817.44" data-end="822.02">So, flame graphs are really interesting too when we're talking about performance because</span> <span data-start="822.02" data-end="830.55">they give you a visual explanation on where your CPU time is spent.</span> <span data-start="830.55" data-end="835.69">The width of the bars or the coloring doesn't really matter.</span> </p>
<p><span data-start="835.69" data-end="841.17">The coloring is just to give it make it nice and it's called flame graphs because usually</span> <span data-start="841.17" data-end="844.44">we paint it from red to yellow like a flame.</span> <span data-start="844.44" data-end="851.36">But what is important to notice is that as you go from bottom up, you see where the code</span> <span data-start="851.36" data-end="856.4">is spending most time on your CPU.</span> </p>
<p><span data-start="856.4" data-end="863.131">So, if you observe this, you basically what the flame graph is telling you is that there</span> <span data-start="863.131" data-end="871.86">is a very tiny piece on the top where JavaScript code is being spent on.</span> <span data-start="871.86" data-end="875.87">And then there's lots of time where it's spent on native.</span> <span data-start="875.87" data-end="883.43">And native means the Node bindings, V8 will leave for the sync IO and also for the event</span> <span data-start="883.43" data-end="884.87">loop.</span> <span data-start="884.87" data-end="893.05">So, once we start trying to optimize this, the code, we end up like trying to optimize</span> <span data-start="893.05" data-end="894.77">just the tip of the iceberg.</span> <span data-start="894.77" data-end="896.35">You cannot optimize everything.</span> <span data-start="896.35" data-end="904.68">Because most of the time and if I would go back most of the time here is spent on native</span> <span data-start="904.68" data-end="905.68">code.</span> </p>
<p><span data-start="905.68" data-end="907.88">So, you're just optimizing the tip of the iceberg.</span> <span data-start="907.88" data-end="911.86">So, this makes you think, right?</span> <span data-start="911.86" data-end="912.86">This is interesting.</span> <span data-start="912.86" data-end="914.92">What can we do about this?</span> <span data-start="914.92" data-end="923.58">If you ask yourself, what is the first thing that comes on your mind when I say, JavaScript</span> <span data-start="923.58" data-end="924.92">engine?</span> <span data-start="924.92" data-end="926.97">Most of you will say V8.</span> <span data-start="926.97" data-end="933.47">So, if you look at the mission statement of the V8 project, it reads something like speed</span> <span data-start="933.47" data-end="938.63">up real world performance for more than JavaScript and enable developers to build a faster future</span> <span data-start="938.63" data-end="939.63">web.</span> <span data-start="939.63" data-end="942.92">So, performance on V8 is great.</span> <span data-start="942.92" data-end="945">But there are more engines out there.</span> </p>
<p><span data-start="945" data-end="951.19">So, if you look at the table, not an authority on JavaScript engines.</span> <span data-start="951.19" data-end="954.62">Just lists the compatibility of ES6 across many.</span> <span data-start="954.62" data-end="961.3">There you can see engines like ChakraCore, SpiderMonkey, Safari.</span> <span data-start="961.3" data-end="967.91">And there was a new one added last year, crowdjs.</span> <span data-start="967.91" data-end="974.92">So, what my experiment was all about is that, well, I should try other engines.</span> <span data-start="974.92" data-end="980.56">Because if most of the CPU is spent on native, probably I should look into engines that handle</span> <span data-start="980.56" data-end="984.02">this JavaScript runtime in a different way.</span> <span data-start="984.02" data-end="986.47">So, I decided to look into rawjs.</span> <span data-start="986.47" data-end="995">So, raw JS is an extension of the Java machine that supports more languages and execution</span> <span data-start="995" data-end="996">models.</span> <span data-start="996" data-end="1001.839">So, the project includes a new hey performance compiler called Raw because as you know the</span> <span data-start="1001.839" data-end="1007.01">most difficult thing in computer science and science is naming things.</span> <span data-start="1007.01" data-end="1010.75">You all it also Graal because it is interesting.</span> <span data-start="1010.75" data-end="1018.43">And the objective of Graal is to improve the performance of the machine on any language.</span> </p>
<p><span data-start="1018.43" data-end="1024.73">And another goal is to allow free form mixing of any programming language in a single program.</span> <span data-start="1024.73" data-end="1027.38">So, it allows you to do polyglot programming.</span> <span data-start="1027.38" data-end="1036.9">So, on the same program you can use Java, Scala, Ruby, Rust, C++.</span> <span data-start="1036.9" data-end="1041.89">And what's interesting about this is that because it's a new project and it's all up</span> <span data-start="1041.89" data-end="1049.04">to date, they offer a modern JavaScript runtime based on ES2019, ES2020, which isn't released</span> <span data-start="1049.04" data-end="1052.34">yet but they already implemented most of the features.</span> <span data-start="1052.34" data-end="1055.61">And the ultimate goal is a very fast server.</span> <span data-start="1055.61" data-end="1058.19">But I don't want to change my programming language.</span> <span data-start="1058.19" data-end="1059.97">I want to stay on JavaScript.</span> <span data-start="1059.97" data-end="1067.53">So, if I look at the definition of rawjs on their website, their goals are to execute</span> <span data-start="1067.53" data-end="1070.12">JavaScript code with the best possible performance.</span> <span data-start="1070.12" data-end="1074.86">They have full support for the latest ES specification.</span> </p>
<p><span data-start="1074.86" data-end="1082.92">And the fast interoperability with all the languages on either on the JVM or the language</span> <span data-start="1082.92" data-end="1092.05">supported by Graal like Ruby, Python and R. There is research around this because this</span> <span data-start="1092.05" data-end="1097.75">project, although it was open sourced last year, it's been running for more than eight</span> <span data-start="1097.75" data-end="1100.82">years behind closed doors.</span> <span data-start="1100.82" data-end="1108.13">It's just been opened now because now they feel that it's like in a real stable mature</span> <span data-start="1108.13" data-end="1109.56">project.</span> <span data-start="1109.56" data-end="1118.06">So, the people working and researching on this have already shown that the engine is</span> <span data-start="1118.06" data-end="1124">slightly better or on par with V8 for just pure language benchmarks.</span> <span data-start="1124" data-end="1126.45">And you can read more about the paper there.</span> <span data-start="1126.45" data-end="1132.97">So, and although you can even run like unmodified Node applications on it because it just allows</span> <span data-start="1132.97" data-end="1140.419">you to just replace V8 from Node, I need to formulate a hypothesis.</span> </p>
<p><span data-start="1140.419" data-end="1149.02">What if we create a project that I would call agnostic for X that first will replace V8</span> <span data-start="1149.02" data-end="1150.39">with a project.</span> <span data-start="1150.39" data-end="1155.46">Second, will replace the Eclipse vortex.</span> <span data-start="1155.46" data-end="1161">Will replace the V8 with a Graal compiler.</span> <span data-start="1161" data-end="1163.02">Will not have Node bindings.</span> <span data-start="1163.02" data-end="1165.18">It will have text definitions.</span> <span data-start="1165.18" data-end="1168.53">This will be discarded at runtime.</span> <span data-start="1168.53" data-end="1172.23">The code that you don't run is the best code, it's the fastest.</span> <span data-start="1172.23" data-end="1173.96">You don't need to run it.</span> <span data-start="1173.96" data-end="1181.27">And offer a basic JS and loader.</span> <span data-start="1181.27" data-end="1185.68">And basic compatibility and allows you to develop and profile the application with the</span> <span data-start="1185.68" data-end="1189.36">tools you already know like the Chrome DevTools.</span> </p>
<p><span data-start="1189.36" data-end="1199.64">So, if we were going to implement the previous example that I showed with Node and express</span> <span data-start="1199.64" data-end="1207.52">using this new style, this is how the old express code would look like.</span> <span data-start="1207.52" data-end="1210.77">I guess it's not that hard to understand what's happening here.</span> <span data-start="1210.77" data-end="1217.03">The important thing here to notice is that the library I chose, vortex, by default uses</span> <span data-start="1217.03" data-end="1221.71">all the available cores on your machine so you don't need to use a cluster module to</span> <span data-start="1221.71" data-end="1222.88">do forks.</span> <span data-start="1222.88" data-end="1225.47">This is all handled behind the scenes for you.</span> </p>
<p><span data-start="1225.47" data-end="1234.179">And Vortex provides us an optimized sync IO build on to have of an open source project</span> <span data-start="1234.179" data-end="1237.93">used by big names like Google, Twitter, Netflix just to name a few.</span> <span data-start="1237.93" data-end="1245.28">If you want to test this, first thing, well, you need to install a very simple application</span> <span data-start="1245.28" data-end="1250.559">called ES4XPM short for project manager.</span> <span data-start="1250.559" data-end="1252.41">We cannot run Node directly.</span> <span data-start="1252.41" data-end="1254.64">Need to run through ES first.</span> </p>
<p><span data-start="1254.64" data-end="1257.51">If I show you, this is how it looks.</span> <span data-start="1257.51" data-end="1261.67">If I create a project.</span> <span data-start="1261.67" data-end="1265.71">I can make it like with a new module syntax.</span> <span data-start="1265.71" data-end="1271.12">And I recorded this so because I'm afraid that I wouldn't have enough time.</span> </p>
<p><span data-start="1271.12" data-end="1272.88">So, just have a couple of dependencies.</span> <span data-start="1272.88" data-end="1275.98">This is pure npm stuff.</span> <span data-start="1275.98" data-end="1281.67">I just use Vortex and web because I want to do a web application.</span> <span data-start="1281.67" data-end="1285.67">So, I create and you can even do like the ES6 modules.</span> <span data-start="1285.67" data-end="1286.67">I can say, okay.</span> <span data-start="1286.67" data-end="1293.79">My home page is a function that I will export that will just say, hello.</span> <span data-start="1293.79" data-end="1297.179">Hello from Vortex Plus ES4X.</span> <span data-start="1297.179" data-end="1300.78">And, of course, now I need to bootstrap a server.</span> <span data-start="1300.78" data-end="1304.85">I get my index, which is like my main application.</span> <span data-start="1304.85" data-end="1311.94">And again, just import some code from the vortex library.</span> <span data-start="1311.94" data-end="1318.61">I now import my route from the module I just created.</span> <span data-start="1318.61" data-end="1320.16">Route.</span> <span data-start="1320.16" data-end="1325.04">And now I just bootstrap the bootstrap my application.</span> </p>
<p><span data-start="1325.04" data-end="1327.83">So, I create the router.</span> <span data-start="1327.83" data-end="1330">It's kind of the same idea as the express server.</span> <span data-start="1330" data-end="1335.94">So, I now create the router a route on home.</span> <span data-start="1335.94" data-end="1340.45">And I just paste my callback.</span> <span data-start="1340.45" data-end="1343.64">And now I create the server.</span> <span data-start="1343.64" data-end="1348.4">I specify who will handle my server request.</span> <span data-start="1348.4" data-end="1350.12">Who will be my router?</span> <span data-start="1350.12" data-end="1353.08">And I start listening on port 8080.</span> </p>
<p><span data-start="1353.08" data-end="1357.22">Same hello message.</span> <span data-start="1357.22" data-end="1361.36">So, I'm running.</span> <span data-start="1361.36" data-end="1370.929">So, now I can just install starting to make npm and doesn't really matter.</span> <span data-start="1370.929" data-end="1372.99">There are a couple of utilities.</span> <span data-start="1372.99" data-end="1377.79">I can quickly get all of my application running on VSCode.</span> <span data-start="1377.79" data-end="1380.59">You can see it's already bugging.</span> <span data-start="1380.59" data-end="1381.64">I can put a break point.</span> <span data-start="1381.64" data-end="1387.82">And if I put a break point and now make an HTTP request, you see that the request there</span> <span data-start="1387.82" data-end="1388.82">is stopped.</span> <span data-start="1388.82" data-end="1395.64">And what's interesting here to see is that due to the nature of GraalVM, you can see</span> <span data-start="1395.64" data-end="1402.34">on the debugger, the code from the Java side and the code that you wrote.</span> <span data-start="1402.34" data-end="1403.85">Everything is optimized.</span> <span data-start="1403.85" data-end="1412.1">So, the expectation is that once you write code in this way, your user code plus your</span> <span data-start="1412.1" data-end="1418.35">runtime plus your interop plus your engine plus your IO libraries plus the whole world</span> <span data-start="1418.35" data-end="1419.42">that runs your application.</span> </p>
<p><span data-start="1419.42" data-end="1422.22">In this case, the Graal JDK.</span> <span data-start="1422.22" data-end="1425.69">It will all be optimized by Graal.</span> <span data-start="1425.69" data-end="1426.95">Not just the script itself.</span> <span data-start="1426.95" data-end="1432.07">Not just optimizing the tip of the iceberg, you're optimizing everything.</span> <span data-start="1432.07" data-end="1439.81">To test it, I submitted to the tech and power implementation using this project.</span> <span data-start="1439.81" data-end="1444.67">It was reviewed and got accepted and this is how things are.</span> <span data-start="1444.67" data-end="1447.21">This is like the CI builds.</span> <span data-start="1447.21" data-end="1454.73">You see now ES4X is ranking on number five which brings JavaScript from number 86 if</span> </p>
<p><span data-start="1454.73" data-end="1464.25">I'm not mistaken to number five in simple database query test that gets results.</span> <span data-start="1464.25" data-end="1467.81">And ranked number six when doing multiple queries.</span> <span data-start="1467.81" data-end="1472.419">So, you see the parallel loading and testing.</span> <span data-start="1472.419" data-end="1479.26">So, if I have to compare now this experiment with all the frameworks that were already</span> <span data-start="1479.26" data-end="1482.35">on the benchmark, this is how it compares.</span> <span data-start="1482.35" data-end="1491.049">So, when working with JSON we see that the results give you like two times better results</span> <span data-start="1491.049" data-end="1493.49">than the previous best result.</span> <span data-start="1493.49" data-end="1497.98">When going on a post base, doing one query, it's three and a halftimes better.</span> <span data-start="1497.98" data-end="1503.21">But if you have to be fair, testing for the best previous one running on Postpress, it's</span> <span data-start="1503.21" data-end="1507.76">six times better doing multiple queries.</span> <span data-start="1507.76" data-end="1509.87">There's lots of concurrency going on.</span> <span data-start="1509.87" data-end="1513.39">It's still two and a halftimes better than the previous one.</span> </p>
<p><span data-start="1513.39" data-end="1521.01">And doing data updates where the query is really the issue, it's like five times better</span> <span data-start="1521.01" data-end="1522.12">than the previous one.</span> <span data-start="1522.12" data-end="1530.679">To put this in numbers if you think about request response, you see that IO is better,</span> <span data-start="1530.679" data-end="1532.09">of course.</span> <span data-start="1532.09" data-end="1535.3">I'm not talking about a very small improvement, tiny improvements.</span> <span data-start="1535.3" data-end="1538.64">I'm talking about huge numbers.</span> <span data-start="1538.64" data-end="1545.06">So, the final tip is that optimization is like a neverending job.</span> <span data-start="1545.06" data-end="1551.799">So, for example, we could get better results if we used an enterprise edition of Graal</span> <span data-start="1551.799" data-end="1554.98">instead of the open source edition.</span> <span data-start="1554.98" data-end="1558.07">That gives you like 20% better performance.</span> <span data-start="1558.07" data-end="1561.38">And because it's optimization, it's a neverending job.</span> <span data-start="1561.38" data-end="1567.86">You need to rinse and repeat and go just like that.</span> </p>
<p><span data-start="1567.86" data-end="1574.59">So, the key points I want to give is that there's nothing wrong with JavaScript.</span> <span data-start="1574.59" data-end="1576.78">JavaScript can be fast.</span> <span data-start="1576.78" data-end="1581.68">And probably you don't need to switch to Go, Rust, whatever, because you're having performance</span> <span data-start="1581.68" data-end="1582.68">issues.</span> <span data-start="1582.68" data-end="1587.929">You can still if you dare to experiment, you can still remain on JavaScript.</span> </p>
<p><span data-start="1587.929" data-end="1593.72">So, if you want to learn more you can.</span> <span data-start="1593.72" data-end="1601.4">Either find me on Twitter, GitHub, the source code forum on GitHub.</span> <span data-start="1601.4" data-end="1605.49">And if there are any questions, you can catch me later.</span> <span data-start="1605.49" data-end="1611">Thank you.</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
