<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>6Qx5ZAbfqjo</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/6Qx5ZAbfqjo?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="23.97" data-end="31.039">Hi, everyone, I'm a software engineer at Etsy, in my master I did a lot of functional programming</span> <span data-start="31.039" data-end="36.8">in Haskell. I wrote a type checker for a Compiler for a domain specific language, dynamic programming</span> <span data-start="36.8" data-end="42.18">problem. That's quite different, Haskell was also my first programming language, I might</span> <span data-start="42.18" data-end="48.42">be a bit unconventional. I still find functional programming amazing and all the power that</span> <span data-start="48.42" data-end="51.94">it has, and that's why I want to talk about it today, but the tool we'll be working with</span> <span data-start="51.94" data-end="59">is JavaScript. So together with my friends I started to think about how to make functional</span> <span data-start="59" data-end="63.18">programming more accessible because it's so powerful. And for this is great to start with</span> <span data-start="63.18" data-end="69.07">a language that's familiar so we can focus just on the concepts. Since new concepts can</span> <span data-start="69.07" data-end="73.57">be difficult, we will use cooking analogies to make things more understandable and learn</span> <span data-start="73.57" data-end="78.53">about curery cooking along the way: It's a very good example, because very algorithmic</span> <span data-start="78.53" data-end="87.83">and everybody has to eat. So cooking with curry frying spices in a pan. But, wait, let's</span> <span data-start="87.83" data-end="93.12">talk about programming deliciouses programming, programming is awesome, I love programming,</span> <span data-start="93.12" data-end="99.77">but also it's sometimes hard. It's hard when the code is too complex. So, in reality it</span> <span data-start="99.77" data-end="106.05">looks a bit more like this. We could say each problem brings it's own complexity, it's our</span> <span data-start="106.05" data-end="111.06">job as programmers to build a program to solve it. When we start we're creating some kind</span> <span data-start="111.06" data-end="117.52">over mental work space. But over time, things can get messy so we add unnecessary complexity</span> <span data-start="117.52" data-end="123.021">to the problem, we add things asster Rick reasons not because there's a problem. That's</span> <span data-start="123.021" data-end="130.64">not ideal. So let's create work space for curry recipe, it could look like this. We</span> <span data-start="130.64" data-end="136.9">need some spices. A base for the source, curry originally come from the word sauce, and we</span> <span data-start="136.9" data-end="143.4">need a main ingredient, which could be some of this. That's a lot of ingredients, wow!</span> </p>
<p><span data-start="143.4" data-end="148.97">Let's say we pick five spices one base for the sauce and one main infreed cent for our</span> <span data-start="148.97" data-end="153.94">recipe, that's already way more combinations than I can easily oversee, I don't know about</span> <span data-start="153.94" data-end="160.59">you. So, in functional programming and in cooking we like to decompose our problems</span> <span data-start="160.59" data-end="165.21">into smaller sub problems, so that we can leverage the power of combination of solutions</span> <span data-start="165.21" data-end="170.73">instead of drowning in combination of problems, oh my God. (Laughing) so here you can see</span> <span data-start="170.73" data-end="176.51">I have a function shuffle, which shuffles an array of stuff. I didn't write it out,</span> <span data-start="176.51" data-end="180.7">it's too long, but you can imagine, and then I have this function pick, which picks from</span> <span data-start="180.7" data-end="186.37">a shuffleeled array. Then I have the function print item that prints a thing with an asterisk</span> <span data-start="186.37" data-end="192.72">in front of it. I can pick five spices and map the print item function over them, which</span> <span data-start="192.72" data-end="199.011">looks pretty readable. For our composed recipe function, I would saw it's really human readable.</span> <span data-start="199.011" data-end="204.75">We pick from each infrequent group and print the resulting recipe with a bit of words around</span> <span data-start="204.75" data-end="211.45">it (Ingredient) what did we just do? We used two really good ideas to keep our work space</span> <span data-start="211.45" data-end="217.349">clean. First of all, having a good set of bah sick functions that we can compose and</span> <span data-start="217.349" data-end="222.28">combine to achieve something more complex. Also, it should be clear whether the order</span> <span data-start="222.28" data-end="227.58">of steps is important or not. Fit's not important, it should be up to us, so we would have them</span> <span data-start="227.58" data-end="233.97">as independent functions. And then the second thing was capturing all side effects in our</span> <span data-start="233.97" data-end="239.55">recipe to avoid sure praises, when I put the right ingredients into a recipe, I should</span> <span data-start="239.55" data-end="246.58">always be rewarded with the correct result, or the same delicious dish. So no secret side</span> <span data-start="246.58" data-end="252.29">effects? No, if temperature over ingredients isn't specified it shouldn't affect the result</span> <span data-start="252.29" data-end="258.909">if I change it. Secret side effects forbidden, no leaving of the recipe. So every program</span> <span data-start="258.909" data-end="263.28">in this way, we can often grasp what a function does by looking at it's input and output,</span> <span data-start="263.28" data-end="271.47">these all we need to know. Okay, let's really get started, let's talk about abstraction.</span> </p>
<p><span data-start="271.47" data-end="276.379">Some famous person in computer science once said the art of programming is the art of</span> <span data-start="276.379" data-end="282.72">organizing complexity of mastering multitude and avoiding it's bastard Chaos. I really</span> <span data-start="282.72" data-end="288.88">like that quote. And then he also said, we all know that the only mental tool by means</span> <span data-start="288.88" data-end="294.85">of which a very finite piece of reasoning can cover a myriad of cases is called abstraction</span> <span data-start="294.85" data-end="305.96">isn't that great in code we make decisions all the time to solve our problems, and they're</span> <span data-start="305.96" data-end="311.34">combinations of all these decisions, we're creating a huge space of possible paths through</span> <span data-start="311.34" data-end="316.37">the program Andorra the state of our work space. And we're supposed to keep all these</span> <span data-start="316.37" data-end="321.56">state in our head. And if we forget about one we create unexpected behavior, ranging</span> <span data-start="321.56" data-end="328.44">from a small bug to a gapping security hole. Our only tool for keeping this combinatorial</span> <span data-start="328.44" data-end="337.62">complexity at bay and without unnecessary complexity is abstraction. So, how can we</span> <span data-start="337.62" data-end="343.97">use it? The good news is we already use it. Functional programming heavily builds on abstractions</span> <span data-start="343.97" data-end="348.93">we know already, let's go through them real quick. So the basis of programming is often</span> <span data-start="348.93" data-end="353.94">so simple that we forget about it, but we all know it, it's abstracting from a value.</span> </p>
<p><span data-start="353.94" data-end="358.59">So it would lack like this, by assigning it to a variable I can give it a name, and I</span> <span data-start="358.59" data-end="363.87">can use it later by just calling that name, I don't have to write all the vennelbles there.</span> <span data-start="363.87" data-end="367.78">And in the functional programming world, I don't make a big difference between a value</span> <span data-start="367.78" data-end="373.43">and function when I name them. We can also assign a function to a variable. We say functions</span> <span data-start="373.43" data-end="379.36">are first class citizens, you've heard that before. But, wait, we didn't talk about functions</span> <span data-start="379.36" data-end="385.97">yet. So, building on this what's the next more abstract building block of the program,statements</span> <span data-start="385.97" data-end="391.06">and blocks of statements, to abstract from a Blog and give it a flame, we would create</span> <span data-start="391.06" data-end="396.48">a function. And\h‑‑ we would create a name and create a function. It's under valued</span> <span data-start="396.48" data-end="401.72">as the main means of code organization. It's at the core of functional programming, that's</span> <span data-start="401.72" data-end="407.181">why it's called like that, right. We could say we build toolboxes of functions, assign</span> <span data-start="407.181" data-end="412.84">them to variables, we pass them to other functions and we combine them. Wait, I just said we</span> <span data-start="412.84" data-end="419.28">pass functions to other functions? So functions that receive other functions as arguments</span> <span data-start="419.28" data-end="425.5">are called higher order functions. And they are the next level of abstraction, abstracting</span> <span data-start="425.5" data-end="432.82">from function abstractions. So, I'm passing another function into mySort function here.</span> </p>
<p><span data-start="432.82" data-end="437.949">Sorting my spices and bypassing a function as an argument I can supply a part of the</span> <span data-start="437.949" data-end="443.52">behavior. We could say we are configuring the behavior of the higher order function.</span> <span data-start="443.52" data-end="447.68">This technique is not possible in our programming languages, but in JavaScript higher order</span> <span data-start="447.68" data-end="452.05">functions are more common such as map and reduce, which we know in arrays, and all these</span> <span data-start="452.05" data-end="458.48">functions that accept call backs for asynchronous JavaScript. On the top level of our hierarchy</span> <span data-start="458.48" data-end="464.86">we have sets of functions, the functions are the tool in our toolbox, they are really important,</span> <span data-start="464.86" data-end="470.24">so abstraction gives us levels of detail to structure our programs, and on each level</span> <span data-start="470.24" data-end="476.52">we get contained building blocks. We didn't talk about data yet, but that's okay, bah</span> <span data-start="476.52" data-end="483.01">we're learning to think in terms of functions first. Okay. Functions, functions, functions.</span> </p>
<p><span data-start="483.01" data-end="490.479">Wait, with all these levels of abstraction don't I just have a tree‑like composition</span> <span data-start="490.479" data-end="497.819">for our program like in any imperative programming? How is it different? Don't I have something</span> <span data-start="497.819" data-end="503.41">like program and then\h‑‑ or ammonal yule and then functions, blocks, statements down</span> <span data-start="503.41" data-end="510.61">to variable declarations? Yeah, that's right. And that's why it was possible for me to move</span> <span data-start="510.61" data-end="516.37">around between functional and imperative work in my masters thesis. That's why I could take</span> <span data-start="516.37" data-end="521.51">a program that was expressed in reoccurance, that means recurrent of function that are</span> <span data-start="521.51" data-end="526.5">evaluated like in mathematics and I could Translate it into programs that fill tables</span> <span data-start="526.5" data-end="532.449">in an efficient way and in a smart order using loops. Most paradigms focus on very different</span> <span data-start="532.449" data-end="538.439">areas though. Let's have a look. So, every time I write a loop statement, I would need</span> <span data-start="538.439" data-end="543.999">a variable to evaluate whether it's time to leaf the lap. If we had no state we would</span> <span data-start="543.999" data-end="548.739">have to juice a recursive function instead. So,\h‑‑ we would have to use a recursive</span> <span data-start="548.739" data-end="554.689">function instead, we would focus more on functions than on statements, a function is a complete</span> <span data-start="554.689" data-end="560.56">literal package that captures a behavior. We can always swap it out with another one</span> <span data-start="560.56" data-end="566.269">to get a different behavior. A lot of magic is the stuff we can do with functions and</span> <span data-start="566.269" data-end="571.1">combine them and leverage their power. With special higher order functions, that's why</span> </p>
<p><span data-start="571.1" data-end="579">I made the higher order functions big. Okay, let's be honest, isn't this slow? I would</span> <span data-start="579" data-end="583.649">say, once you're in a loop or performance which you always should considering this we're</span> <span data-start="583.649" data-end="588.8">optimizing for some other time than computation time, we're optimizing for developer time.</span> <span data-start="588.8" data-end="593.929">By keeping the code elegant we can keep it maintainable because we can find stuff faster</span> <span data-start="593.929" data-end="599.569">and we can reuse it and recombine functionality. It's more fun to cook with a well kept food</span> <span data-start="599.569" data-end="608.8">pantry stocked with our functions. So, why do I talk about curry all the time? Wouldn't</span> <span data-start="608.8" data-end="614.249">it be great if we could start computing even before we have all our stuff ready? Let's</span> <span data-start="614.249" data-end="619.259">talk about curerying and partial application. I still have to eat more from the knowledge</span> <span data-start="619.259" data-end="626.679">tree. This is a curry tree. On our lucky day we might find it's leave in a curry spice</span> <span data-start="626.679" data-end="633.079">mixture, usually it's not in there. And this is Haskell curry, he ate so much from the</span> <span data-start="633.079" data-end="636.879">knowledge tree of combinatorial left‑hand lane Eck that he has his own function, the</span> <span data-start="636.879" data-end="646.989">curry function and he has programming languages named after his first and last name the literature,</span> <span data-start="646.989" data-end="657.089">curry is the transformation of the function of arguments with one argument each so let's</span> <span data-start="657.089" data-end="664.629">have a look, here we see a function with three arguments, ABC. It just prints them. The curryied</span> <span data-start="664.629" data-end="672.189">version consists of a function returning a function returning a function. And each one</span> <span data-start="672.189" data-end="678.179">of these has just one argument and returns a function that expects the remaining arguments.</span> </p>
<p><span data-start="678.179" data-end="681.759">The difference is visible in the call of the normal and the curried version, you already</span> <span data-start="681.759" data-end="692.67">see it here, but let's look in detail. So the function look like this. I can provide</span> <span data-start="692.67" data-end="699.95">the parameters ABC, one, by one, Haskell curry. I could also prefill my arguments up to a</span> <span data-start="699.95" data-end="705.589">specific death so I could just supply the Haskell and then I would have a function which</span> <span data-start="705.589" data-end="711.92">names everybody Haskell. (Laughs) so I could specialize a more general function, if that</span> <span data-start="711.92" data-end="717.949">makes sense. That's also re\h‑‑ let's revisit higher order functions, they can help</span> <span data-start="717.949" data-end="724.249">us do repeated work on data structure, map reduce and filter are some of the most prominent.</span> <span data-start="724.249" data-end="731.379">In JavaScript we know them from arrays. So map applies supplied unary function with one</span> <span data-start="731.379" data-end="738.42">argument to each array Element. How does that work? We already used it. We said pick three</span> <span data-start="738.42" data-end="744.089">spices and then map the print item function over them. So on the left we have our array</span> <span data-start="744.089" data-end="749.899">of the three spices and then on the right side we have the result, how does this work?</span> </p>
<p><span data-start="749.899" data-end="755.51">It works like this: Just for each array Element the print item function is executed and we</span> <span data-start="755.51" data-end="763.67">get this result. It's like a transformation of the array. And reduce, combines an array</span> <span data-start="763.67" data-end="769.759">of Elements into a single result via a repeated application of a supplied buy flair function,</span> <span data-start="769.759" data-end="776.339">the binary function input produces one output so we're reducing something. Let's look at</span> <span data-start="776.339" data-end="783.47">an example. Here we want to sum up all our items in our food pantry, so the individual</span> <span data-start="783.47" data-end="789.22">counts you can see here, remember we had ten spices, three soup bases and five main ingredients.</span> <span data-start="789.22" data-end="796.889">And plus as a pienary function I just rewrote it here because the operator works a bit differently.</span> <span data-start="796.889" data-end="802.699">And we applied repeatedly when we make a sound, clearly a pattern for reduce and would lack</span> <span data-start="802.699" data-end="808.279">like this. I do ten plus three get thirteen plus five and I get my overall result of 18</span> <span data-start="808.279" data-end="816.32">so it's reduced to one number. And filter, filters the Elements of an array based on</span> <span data-start="816.32" data-end="822.16">a predicate. Hao would that work, let's say we have an array of veggies and we want to</span> <span data-start="822.16" data-end="831.049">filter that's in stock so we can start cooking. (Vegetables) you can see there\h‑‑ so</span> <span data-start="831.049" data-end="836.589">how does it work, I have 25 okra so it is in stock and in the resulting array, the car</span> <span data-start="836.589" data-end="845.069">wrotes get filtered out because I have zero in stock. So we saw closure, currying, partial</span> <span data-start="845.069" data-end="849.449">application and higher order functions help us to build complex specialized functions</span> <span data-start="849.449" data-end="858.799">from more simple and more\h‑‑ from simple and more general functions. Let's build some</span> <span data-start="858.799" data-end="864.91">pipeline, function composition. A function transforms input into output as we said in</span> <span data-start="864.91" data-end="868.509">the beginning in the most straightforward way to build functions from other functions</span> <span data-start="868.509" data-end="875.279">is to just connect them into a pipeline. It would look like this, function composition.</span> </p>
<p><span data-start="875.279" data-end="880.19">We can write ourselves a higher order function for function composition. And it looks like</span> <span data-start="880.19" data-end="886.739">the definition from a math book, so you see the G of F of X in there. And with these tools</span> <span data-start="886.739" data-end="892.359">we're now ready to build us some functions, let's try it out. So here I count the pieces</span> <span data-start="892.359" data-end="898.8">of okra and chop them in half, remember we had 25 pieces of okra and I'm just chopping</span> <span data-start="898.8" data-end="905.029">them in half so I get double the amount of okra. (Laughs) so, I can compose the two,</span> <span data-start="905.029" data-end="915.41">and then I get 50 okra. And so we can see from this combination we were building something</span> <span data-start="915.41" data-end="920.759">new, and this style of programming can bring our programs closer to the declarative side</span> <span data-start="920.759" data-end="926.26">where we tell the computer what to do but not how to compute it step‑by‑step. Programs</span> <span data-start="926.26" data-end="930.839">in the declarative side are easier to read because we don't have to keep the space of</span> <span data-start="930.839" data-end="939.22">the work space in our head all the time. So I have to make a confession, I'm coming from</span> <span data-start="939.22" data-end="944.699">Haskell and some things are a bit different there. I'm just going to tell you for context.</span> <span data-start="944.699" data-end="950.589">In Haskell we have referential transparency, a function can be replaced with it's value,</span> <span data-start="950.589" data-end="955.959">it means the same thing. And this is mind boggling coming from JavaScript because there's</span> <span data-start="955.959" data-end="961.999">no such thing as call or return in Haskell. We have to think about functions in a sense</span> <span data-start="961.999" data-end="968.749">of mathematics where I can F of X equals Y I can replace the left‑hand side F of X</span> <span data-start="968.749" data-end="973.149">with the right‑hand side Y and vice versa without worrying if the function was called</span> <span data-start="973.149" data-end="978.91">and if the result is ready yet. This simplifies reasoning about the program for both the programmer</span> <span data-start="978.91" data-end="986.699">and the computer. Haskell is laity only computes values when needed and automatic currying</span> <span data-start="986.699" data-end="993.979">so it's normal to partially supply function arguments there. And Haskell is also purely</span> <span data-start="993.979" data-end="999.649">functional, that means we cannot have side effects that modify our environment in a Haskell</span> <span data-start="999.649" data-end="1004.519">program, even if we wanted to, we would have to use an explicit mechanism to perform side</span> <span data-start="1004.519" data-end="1012.009">effects. So that's a bit different. Wow! We already tricked ourself deep into functional</span> <span data-start="1012.009" data-end="1017.83">programming. We could say, if you understand the importance of functions and what we can</span> <span data-start="1017.83" data-end="1022.999">do with them, you understand functional programming. What we can do with them was pass them to</span> <span data-start="1022.999" data-end="1030.449">other functions, currying composition, but what else is there? Is there more? A question</span> <span data-start="1030.449" data-end="1035.059">that comes with statelessness when we try to avoid side effects is the question of how</span> <span data-start="1035.059" data-end="1040.29">to control our program flow. Usually we need a counter for our iterations and then we need</span> <span data-start="1040.29" data-end="1051.039">a variable to check if it's time to leave loop? So it's a side effect we want to avoid</span> <span data-start="1051.039" data-end="1056.2">it, it's bad. And few functional programming we would have to change our way of thinking</span> <span data-start="1056.2" data-end="1062.429">exactly for this reason. Instead of iterating, we would favor recursion, and that means we</span> <span data-start="1062.429" data-end="1068.6">use a function that calls itself for a smaller part of the problem. That sounds uncomfortable.</span> </p>
<p><span data-start="1068.6" data-end="1075.38">What's so bad about the loop? In fact nothing's bad about the lap, it's just a different way</span> <span data-start="1075.38" data-end="1081.19">of thinking about the problem. Iteration is usually bottom up, whereas recursion is top</span> <span data-start="1081.19" data-end="1086.1">down. And I'm very grateful that I had to move back and forth between these two words</span> <span data-start="1086.1" data-end="1091.62">in my masters thesis because it's a really good brain exercise. Restrictions are just</span> <span data-start="1091.62" data-end="1096.279">function made people construct really cool stuff like the Y‑combinator show that recursion</span> <span data-start="1096.279" data-end="1101.429">is possible with just functions and parameters you don't even need declarations I think that's</span> <span data-start="1101.429" data-end="1106.85">one of the coolest things in computer science. So if we restrict ourselves to the purely</span> <span data-start="1106.85" data-end="1111.549">functional style, everything is express in the the input and output of functions even</span> <span data-start="1111.549" data-end="1119.309">the program flow. It's a recursion over the input or out put of the data. Ooops (Laughs)</span> <span data-start="1119.309" data-end="1126.169">when we have to gale with the internet, asynchronous code can dramatically reduce the latency in</span> <span data-start="1126.169" data-end="1131.5">a distributed system, but it can be hard to write, we all know this because there's no</span> <span data-start="1131.5" data-end="1137.409">way vanilla JavaScript to say wait for the return of a function, we supply a call back</span> <span data-start="1137.409" data-end="1142.37">function and tell the function where to continue after it's done. If we have a cascade of call</span> <span data-start="1142.37" data-end="1148.5">back functions and we need to doer report handling things can get hairy. So this is\h‑‑</span> <span data-start="1148.5" data-end="1154.57">there's my favorite web site call back hell.com. You've all seen this code which looks like</span> <span data-start="1154.57" data-end="1160.89">a pyramid and it's horrible. So functional programming technique for explicit error handling</span> <span data-start="1160.89" data-end="1166.409">would be using Monads. Imagine we would be in the purely functional world where functions</span> <span data-start="1166.409" data-end="1171.5">behave look mathematical functions. So the order in which we write our functions doesn't</span> <span data-start="1171.5" data-end="1178.36">matter in this world. But in JavaScript we can execute expressions and sequence by writing</span> <span data-start="1178.36" data-end="1184.661">one after the other with a semicolon in between, so it's different. How does that work? How</span> <span data-start="1184.661" data-end="1193.99">about making our own semicolon? Let's observe what it does for us. So what does the semicolon</span> <span data-start="1193.99" data-end="1200.299">do in this function? So .. here first the given string is printed and then the length</span> <span data-start="1200.299" data-end="1206.309">of the string is returned. The right of function behaves like the semicolon here, can we do</span> <span data-start="1206.309" data-end="1214.25">that? So we wrap the expressions, the two expressions that we had, that we want to change,</span> <span data-start="1214.25" data-end="1218.639">we wrap them into anonymous functions so we can call them like we want to later on when</span> <span data-start="1218.639" data-end="1224.73">they come into our semicolon function later as arguments. We also need an extra return</span> <span data-start="1224.73" data-end="1229.32">here so that the last value gets out of this extra function that we wrapped around it again.</span> </p>
<p><span data-start="1229.32" data-end="1235.141">So that's like a technical step, and then, to abstract from the two statements we can</span> <span data-start="1235.141" data-end="1240.95">now pass in the first and second expression as arguments into our semicolon function.</span> <span data-start="1240.95" data-end="1244.89">Now it's also clear why we had to wrap them into anonymous function because of the different</span> <span data-start="1244.89" data-end="1251.46">return area which we have here. The expressions depend on each other, but the first result</span> <span data-start="1251.46" data-end="1257.559">gets thrown away. We can now chain the first and second expression in the same way a semi</span> <span data-start="1257.559" data-end="1264.309">colon can, so it's producing the same output. In fact we can chain as many expressions as</span> <span data-start="1264.309" data-end="1274.35">we like. So I can chain here this works. Like a semicolon and then bang, which adds an explanation</span> <span data-start="1274.35" data-end="1279.799">mark and then I get my result of 16. This sounds really boring because we already have</span> <span data-start="1279.799" data-end="1285.35">a semicolon in JavaScript, but if you think about this for a while we just constructed</span> <span data-start="1285.35" data-end="1290.73">a chaining function from purely functional parts. So this is a big deal. We went from</span> <span data-start="1290.73" data-end="1294.941">a world in which the order of functions or statements doesn't make a difference to a</span> <span data-start="1294.941" data-end="1300.48">world in which we can change statements into a sequence, to establish their order. The</span> <span data-start="1300.48" data-end="1307.72">semicolon function works like a function known as monadic bind. What's that? So mow daddic</span> <span data-start="1307.72" data-end="1313.86">bind or mbind resemble composition throws away immediate results and statements can</span> <span data-start="1313.86" data-end="1321.76">be executed just for their side effects. I just replaced the name here mbind. So, we</span> <span data-start="1321.76" data-end="1329.82">said Monads chain things into sequences, what kind of things? Let's imagine a container</span> <span data-start="1329.82" data-end="1337.929">a cooking pot. We start with pot one, so that's my pot one, it has some contents, here is</span> <span data-start="1337.929" data-end="1344.919">pot one and when we have the result from pot one, we can execute pot two, so it would look</span> <span data-start="1344.919" data-end="1351.58">like this and go on like this. So I'm doing some steps here this is a different view under</span> <span data-start="1351.58" data-end="1356.889">semi colon function from above, steps can be chained with mbind after we work through</span> <span data-start="1356.889" data-end="1363.51">the entire sequence of steps we get some kind of result in the pot, the contents. Let's</span> <span data-start="1363.51" data-end="1368.111">express this work flow in steps to reveal the pattern. If you would just write town</span> <span data-start="1368.111" data-end="1374.87">the values of\h‑‑ write down the values of the pewation it would like like this. The</span> <span data-start="1374.87" data-end="1379.83">difference we between the two versions is the first one puts everything in the pot and</span> <span data-start="1379.83" data-end="1386.289">the second one works on a naked values. Let's now imagine we have a really good reason to</span> <span data-start="1386.289" data-end="1392.12">put everything into a pot. So for example we could hide some additional logic in there.</span> </p>
<p><span data-start="1392.12" data-end="1396.36">The pot could keep track of the sum of all numbers that are stored in it or it could</span> <span data-start="1396.36" data-end="1403.59">keep a list of ingredients sorted in a pot. The question is now can we deduce a generic</span> <span data-start="1403.59" data-end="1413.97">monad pattern from this? So we want a function that applies a function to the contents inside</span> <span data-start="1413.97" data-end="1419.94">the pot and gives us a new pot. Containing the result of that function. We can define</span> <span data-start="1419.94" data-end="1426.649">this function which is mbind for the pot monad on the pot prototype, let's do that. We see</span> <span data-start="1426.649" data-end="1431.629">a very clear pattern now. We also see that we need an extra step to get the contents</span> <span data-start="1431.629" data-end="1438.65">out of the pot in the end, So, I'm doing the C contents here to get it out. And step one</span> <span data-start="1438.65" data-end="1444.61">of the computation is A equals new pot of one as an object oriented programmer I say,</span> <span data-start="1444.61" data-end="1452.07">ait's a con instructor, a new type of pot. But in the monad jargon we call it unit or</span> <span data-start="1452.07" data-end="1459.121">return, return is already taken in JavaScript, so I want to be careful. It takes a value</span> <span data-start="1459.121" data-end="1464.69">and transforms the value into a nomadic value. The next steps all have a similar pattern.</span> <span data-start="1464.69" data-end="1471.25">We've seen it before, we know it uses the function mbind and mbind takes a monadic value</span> <span data-start="1471.25" data-end="1477.649">and function which works on the contents we sometimes say the play non‑monadic type</span> <span data-start="1477.649" data-end="1485.23">and returns a new monadic value containing the result, just as we intended. And that's</span> <span data-start="1485.23" data-end="1490.879">all! Why got so many people talking about monads what continue we say patterns that</span> <span data-start="1490.879" data-end="1497.799">wraps and changes computation. First of all it's not a very good name, and also it was</span> <span data-start="1497.799" data-end="1504.691">described by mathematician from the field of Cat theory first. The monad pattern, this</span> <span data-start="1504.691" data-end="1508.679">is completely unimportant we don't need to know about it, but what's really cool about</span> <span data-start="1508.679" data-end="1513.61">the monad pattern in JavaScript is we can hide stuff in it. We get an extra layer of</span> <span data-start="1513.61" data-end="1517.87">abstraction to hide the bookkeeping and all this error handling and let the beauty of</span> <span data-start="1517.87" data-end="1526.97">the algorithm shine. So now that we've con cored the monads do we get desert? I'd rather</span> <span data-start="1526.97" data-end="1532.26">have you take something home because it's late. I hope you enjoyed some of the techniques</span> </p>
<p><span data-start="1532.26" data-end="1538.36">I hope I could make them digestible if you ever find yourself in a mess, maybe some of</span> <span data-start="1538.36" data-end="1541.95">these techniques will help you out of it. And if you never get yourself into one, at</span> <span data-start="1541.95" data-end="1548.049">least it's fun to reason about them (Laughs) so don't forget to take home some of the purely</span> <span data-start="1548.049" data-end="1554.499">functional goodness, abstraction it's more important than we think. Very localized understanding</span> <span data-start="1554.499" data-end="1560.24">of code and very small functions that you can reuse. Explicit said effects that we know</span> <span data-start="1560.24" data-end="1569.26">about error handling, and reusability resulting from this. And as some of you might have seen</span> <span data-start="1569.26" data-end="1575.25">all of this and more can be found in the book called gas cure rebuke, I'm not sure how\h‑‑</span> <span data-start="1575.25" data-end="1583.559">Das Crrurry ‑ Buch. The book is in German the code examples are in English so you can</span> <span data-start="1583.559" data-end="1590.6">ease into a known language again W have seen it's fun and totally possible to explore deeper</span> <span data-start="1590.6" data-end="1595.649">functional concepts in JavaScript, it's all there, even though I still like Haskell, I'm</span> <span data-start="1595.649" data-end="1599.799">amazed how much elegance this programming style reveal from the core of JavaScript,</span> <span data-start="1599.799" data-end="1604.991">I think it's just awesome refactorring in a functional style is really fun, thank you</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
