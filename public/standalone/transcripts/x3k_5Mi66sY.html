<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="web.dev LIVE video transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>x3k_5Mi66sY</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/x3k_5Mi66sY?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="7.46" data-end="13.05">I'm glad you came to hear about the new parser coming to Node.</span> <span data-start="13.05" data-end="18.11">About who I am, I'm Fedor Indutny.</span> <span data-start="18.11" data-end="21.85">Here's my Twitter and GitHub handles which are the same.</span> <span data-start="21.85" data-end="24.32">And I write code at PayPal.</span> <span data-start="24.32" data-end="30.26">You might know me by this dark avatar I use on GitHub and Twitter and practically everywhere</span> <span data-start="30.26" data-end="32.14">else.</span> <span data-start="32.14" data-end="37.1">For today talk, the slides and the presentations are already up online.</span> <span data-start="37.1" data-end="42.59">If you would like, you can scan the QR code and open your browser and follow along as</span> <span data-start="42.59" data-end="44.54">I'm going to present the topic.</span> <span data-start="44.54" data-end="45.9">Which is llhttp.</span> <span data-start="45.9" data-end="51.829">The new HTTP protocol parser for Node.js.</span> <span data-start="51.829" data-end="57.44">This has deep roots into the history of Node.js.</span> <span data-start="57.44" data-end="64.32">And it would be hard if not impossible not to mention the history while describing.</span> </p>
<p><span data-start="64.32" data-end="67.43">Of course, Node.js is used to load for the front-end tooling.</span> <span data-start="67.43" data-end="71.8">But originally historically it started as the backend platform.</span> <span data-start="71.8" data-end="78.56">It was exclusively about building asynchronous HTTP servers.</span> <span data-start="78.56" data-end="83.79">And the creator of Node, HTTP parser is what started as node.</span> <span data-start="83.79" data-end="89.93">There's presentations on the importance and role and structure.</span> <span data-start="89.93" data-end="95.88">It's a power Node.js event loop and it's key ever since they set up the node.</span> <span data-start="95.88" data-end="100.67">And you might remember if there's a dependency, however, it is not.</span> <span data-start="100.67" data-end="106.45">As an HTTP parser, it has all the dependencies that Node ever had.</span> <span data-start="106.45" data-end="109.59">It leads all the dependencies in Node.</span> <span data-start="109.59" data-end="116.759">Initially it was inspired by mongrel, a Ruby web server with its own parser created by</span> <span data-start="116.759" data-end="117.99">web show.</span> </p>
<p><span data-start="117.99" data-end="122.81">And later, parts Nginx code introduced in HTTP parser, the</span> <span data-start="122.81" data-end="123.81">original one.</span> <span data-start="123.81" data-end="127.56">And, of course, the code itself.</span> <span data-start="127.56" data-end="130.619">The parser has been with us since 2009.</span> </p>
<p><span data-start="130.619" data-end="132.969">It's been more than ten years.</span> <span data-start="132.969" data-end="138.73">And in effect, Node itself has been introduced that the very conference ten years ago by</span> <span data-start="138.73" data-end="139.73">Ryan.</span> <span data-start="139.73" data-end="143.139">So, it's kind of a jubilee for both of those projects.</span> <span data-start="143.139" data-end="149.37">And I wrote another HTTP parser to replace the original parser.</span> <span data-start="149.37" data-end="156.239">So, why would anyone want to get rid of such a library?</span> <span data-start="156.239" data-end="157.92">Of course, it's a fantastic library.</span> <span data-start="157.92" data-end="159.389">It has been with us for ten years.</span> </p>
<p><span data-start="159.389" data-end="161.939">It should have been worked fine.</span> <span data-start="161.939" data-end="166.739">And it has many users inside of the Node.js community as well.</span> <span data-start="166.739" data-end="169.059">For example, Android proxy by Google.</span> <span data-start="169.059" data-end="174.93">They use it for parsing HTTP requests and it's quite a popular project as well.</span> <span data-start="174.93" data-end="179.849">What makes this parser great and why did it stay?</span> <span data-start="179.849" data-end="183.359">First, good enough performance.</span> <span data-start="183.359" data-end="189.089">It takes quite a bit of time to invoke a C function, and parser is written in C. It takes</span> <span data-start="189.089" data-end="191.909">way less time to parse the requests.</span> <span data-start="191.909" data-end="195.37">I'm going to elaborate on it a bit later in this presentation.</span> <span data-start="195.37" data-end="200.319">But for NodeJS purposes, it's very good performance.</span> <span data-start="200.319" data-end="202.809">Couldn't be better.</span> <span data-start="202.809" data-end="207.469">It also supports a lot of clients and servers that violate the HTTP specification.</span> </p>
<p><span data-start="207.469" data-end="210.999">There are way too many of them out on the Internet.</span> <span data-start="210.999" data-end="212.569">You would be surprised how many.</span> <span data-start="212.569" data-end="217.139">And, of course, it was very important for early adoption of NodeJS.</span> <span data-start="217.139" data-end="222.859">Because in 2009 there was even more such clients and servers out there.</span> <span data-start="222.859" data-end="225.98">Another point is that original parser has a lot of test suites.</span> <span data-start="225.98" data-end="232.749">So, over ten years Ryan, Ben and other maintainers of the project, including myself, have wrote</span> <span data-start="232.749" data-end="238.349">quite a comprehensive test suite that covers almost every aspect of HTTP specification.</span> <span data-start="238.349" data-end="240.059">So, the parser is welltested.</span> <span data-start="240.059" data-end="243.219">So, that was the good points of the original parser.</span> <span data-start="243.219" data-end="245.709">Now we come to other points.</span> </p>
<p><span data-start="245.709" data-end="250.319">Unfortunately, with the HTTP library the code became quite rigid.</span> <span data-start="250.319" data-end="256.15">It became impossible to move things around, to make significant changes to it.</span> <span data-start="256.15" data-end="263.12">And as a consequence of this, it became impossible to maintain this library efficiently.</span> <span data-start="263.12" data-end="268.919">Furthermore, as one of the maintainers of the project, I have to constantly relearn</span> <span data-start="268.919" data-end="275.12">and get familiar with the parts of the codebase that I was previously familiar with before.</span> <span data-start="275.12" data-end="280.87">And I did it on every pull request and still I wasn't sure if the code is going to run</span> <span data-start="280.87" data-end="283.94">in the way I expected it to run.</span> </p>
<p><span data-start="283.94" data-end="287.449">So, it could introduce some unexpected behavior.</span> <span data-start="287.449" data-end="290.05">Or maybe a security vulnerability as well.</span> <span data-start="290.05" data-end="292.18">Which is obviously bad.</span> <span data-start="292.18" data-end="298.569">It doesn't help either that most NodeJS users and developers are familiar with JavaScript</span> <span data-start="298.569" data-end="303.65">and are more comfortable with it than they are with C. So, there was not too many people</span> <span data-start="303.65" data-end="307.5">interested in working on this HTTP parser.</span> <span data-start="307.5" data-end="312.56">With all this in mind, several years ago I set out on a quest it make the library better</span> <span data-start="312.56" data-end="316.319">and maybe a bit faster in the process.</span> </p>
<p><span data-start="316.319" data-end="318.73">First attempts were quite conservative.</span> <span data-start="318.73" data-end="321.56">So, I tried to stay with existing code as much as possible.</span> <span data-start="321.56" data-end="323.19">And some of them were successful.</span> <span data-start="323.19" data-end="328.389">Like replacing the parser state machine with a cross, and using it consistently not only</span> <span data-start="328.389" data-end="331.55">improved the code, but also made it faster.</span> <span data-start="331.55" data-end="333.129">Which was nice.</span> <span data-start="333.129" data-end="335.19">Other attempts were a complete disaster.</span> <span data-start="335.19" data-end="339.969">I tried to move those states into a separated function and just called them from the loop</span> <span data-start="339.969" data-end="345.02">so each state would return the next state that was supposed to be executed and then</span> <span data-start="345.02" data-end="347.05">the loop would run the function for it.</span> <span data-start="347.05" data-end="352.949">This completely ruins the performance and I never contributed or sent it to the string.</span> <span data-start="352.949" data-end="358.99">From this attempt was success or failure, the conclusion was clear.</span> <span data-start="358.99" data-end="362.65">It was hard to make an improvement while staying with the existing codebase.</span> <span data-start="362.65" data-end="367.81">There was no requirement to use as much code as possible, it was no longer required to</span> <span data-start="367.81" data-end="371.38">make it in the same programming language as before.</span> </p>
<p><span data-start="371.38" data-end="376.039">Why not develop it in JavaScript or maybe TypeScript instead?</span> <span data-start="376.039" data-end="381.31">And, of course, JavaScript performance is quite great.</span> <span data-start="381.31" data-end="386.499">But you wouldn't be surprised that it's slower than C and takes a lot of effort to reach</span> <span data-start="386.499" data-end="390.55">comparable performances in the C libraries when you write programs in JavaScript.</span> <span data-start="390.55" data-end="391.55">Takes a lot of effort.</span> <span data-start="391.55" data-end="392.65">But it's possible.</span> <span data-start="392.65" data-end="398.02">So, I wanted to get this performance optimization out of consideration.</span> <span data-start="398.02" data-end="404.069">And also, I decided to just define the parser in TypeScript and still compile it down to</span> <span data-start="404.069" data-end="405.069">the C library.</span> </p>
<p><span data-start="405.069" data-end="409.009">So, the end result would be C library that was used in Node and other projects.</span> <span data-start="409.009" data-end="415.4">Which was great because existing users of HTTP parser this way would be able to transition</span> <span data-start="415.4" data-end="420.4">their code to the new parser and hopefully the process and the performance would not</span> <span data-start="420.4" data-end="423.919">degrade so much because in the end it's the same programming language.</span> <span data-start="423.919" data-end="429.49">It would have good chances of being the same speed.</span> <span data-start="429.49" data-end="435.87">So, llhttp is the next major version of HTTP parser.</span> <span data-start="435.87" data-end="440.389">It has the same core principles and similar API, which is almost identical.</span> <span data-start="440.389" data-end="447.87">And the way they work, is they scan one character at a time.</span> <span data-start="447.87" data-end="454.28">And during the process they change the internal state and they could add a header fields or</span> <span data-start="454.28" data-end="459.719">maybe header values and later on body.</span> <span data-start="459.719" data-end="462.159">I'm not sure if we're going to wait for this.</span> <span data-start="462.159" data-end="463.159">It's quite slow.</span> <span data-start="463.159" data-end="464.159">Okay.</span> <span data-start="464.159" data-end="465.159">Yeah.</span> <span data-start="465.159" data-end="467.49">I think you probably understand what it means now.</span> </p>
<p><span data-start="467.49" data-end="469.189">At least to some extent.</span> <span data-start="469.189" data-end="477.229">So, this can by the virtue of this one scan the parser can work without buffering anything</span> <span data-start="477.229" data-end="478.229">at all.</span> <span data-start="478.229" data-end="480.889">So, it doesn't allocate memory itself.</span> <span data-start="480.889" data-end="486.879">And it creates especially for request bodies because it could just need the slices of original</span> <span data-start="486.879" data-end="490.99">buffers that came from that work instead of allocating the coping data.</span> <span data-start="490.99" data-end="496.77">So, in the core principle of the HTTP parser, it's not copying.</span> <span data-start="496.77" data-end="498.37">That's important.</span> <span data-start="498.37" data-end="504.33">And as soon as any amount of data arrives via a request or a single byte of request,</span> <span data-start="504.33" data-end="506.529">HTTP parser is ready to process it.</span> <span data-start="506.529" data-end="510.319">And it will be possibly partial because it will be health requests.</span> <span data-start="510.319" data-end="516.229">And the header names, we are just seeing in this animation.</span> <span data-start="516.229" data-end="523.63">In the original version of the parser, this scan was quite naturally implemented foreloop</span> <span data-start="523.63" data-end="525.95">over the input.</span> <span data-start="525.95" data-end="530.61">Just going by the input bytebybyte and doing some syncs.</span> <span data-start="530.61" data-end="537.43">What it did, it was described by a huge which statement or all possible parsing state.</span> </p>
<p><span data-start="537.43" data-end="542.36">Whether it's a header name, header value, whether it's value of content lengths header,</span> <span data-start="542.36" data-end="549.03">it was all described by the switch statement, and they represented different states of the</span> <span data-start="549.03" data-end="550.6">state machine.</span> <span data-start="550.6" data-end="556.709">All of this lived in a single function or 1,000 lines of code which is quite a terrible</span> <span data-start="556.709" data-end="557.709">idea.</span> <span data-start="557.709" data-end="564.49">So, an obvious improvement would be to break this switch into pieces and make it such that</span> <span data-start="564.49" data-end="566.94">each piece has precise action.</span> <span data-start="566.94" data-end="570.25">It's sort of a unique philosophy, I guess.</span> <span data-start="570.25" data-end="575.66">So, it would be just exactly about doing one small thing at a time.</span> <span data-start="575.66" data-end="578.57">Go to statements would be used to jump between states.</span> </p>
<p><span data-start="578.57" data-end="583.97">There would not be as much need for this foreloop, at least not as much.</span> <span data-start="583.97" data-end="589.73">With all this in mind, how do I approach this process?</span> <span data-start="589.73" data-end="599.18">I developed a domainspecific language, DSL, and created a compiler around it, LL parse,</span> <span data-start="599.18" data-end="607.41">so, again, double L. And this compiler is used to describe the parsing states in terms</span> <span data-start="607.41" data-end="609.66">of these actions that they perform.</span> <span data-start="609.66" data-end="614.259">So, each state would have several actions assigned to them and they would perform them</span> <span data-start="614.259" data-end="617.63">and move on to the next state.</span> <span data-start="617.63" data-end="623.09">Because of this llparse is quite a general compiler, it can be used for other protocols</span> <span data-start="623.09" data-end="624.09">as well.</span> <span data-start="624.09" data-end="629.589">It works better for textual protocols, but I think it's useful.</span> <span data-start="629.589" data-end="633.91">Original parser suffered from a surplus of handwritten code.</span> <span data-start="633.91" data-end="639.12">I have selected a few actions that were repeated most in the original library and had DSL around</span> <span data-start="639.12" data-end="640.12">them.</span> <span data-start="640.12" data-end="645.67">The idea here is that I wanted the description of the new parser to be concise.</span> <span data-start="645.67" data-end="650.43">So, I wanted to write code with less lines and less signals than possible.</span> <span data-start="650.43" data-end="656.92">I wanted to move the most common iterations inside of the compiler so that the rest would</span> <span data-start="656.92" data-end="661.05">have to do the work all over again and the original parser.</span> </p>
<p><span data-start="661.05" data-end="666.22">Here were a few that the compiler supports.</span> <span data-start="666.22" data-end="668.66">One is match.</span> <span data-start="668.66" data-end="675.68">It takes a sequence, or a character of bytes and it tries to match them from the input.</span> <span data-start="675.68" data-end="680.98">For example, it could be keep alive, which is the value of the headernamed connection.</span> <span data-start="680.98" data-end="683.47">It's quite a common header and very important.</span> <span data-start="683.47" data-end="685.899">So, it could match this sequence.</span> <span data-start="685.899" data-end="691.16">And when it does, move to the next state by taking the reference to this state.</span> <span data-start="691.16" data-end="696.029">And other times the parser needs to check the next character in the incoming data without</span> <span data-start="696.029" data-end="697.37">actually consuming it.</span> <span data-start="697.37" data-end="701.3">And it could be used for this.</span> </p>
<p><span data-start="701.3" data-end="709.56">Takes a single character and mentions it and moves on without moving the input stream.</span> <span data-start="709.56" data-end="716.569">And speaking of headers, headers like lengths, they have internal values which frankly described</span> <span data-start="716.569" data-end="719.339">by strings, it's a contextual protocol.</span> <span data-start="719.339" data-end="723.269">The new parser has to be able to parse the integer strings.</span> <span data-start="723.269" data-end="731.18">And the way I decided to do it was to implement a select method in DSL which takes a map as</span> <span data-start="731.18" data-end="732.73">an input.</span> </p>
<p><span data-start="732.73" data-end="737.6">And this map has sequences or characters as keys.</span> <span data-start="737.6" data-end="738.839">And the integers as values.</span> <span data-start="738.839" data-end="745.61">So, it tries to map this sequence to the integers and just passes values along to the next state.</span> <span data-start="745.61" data-end="752.94">The next state could be storing integers inside some property of the structure, or maybe walking</span> <span data-start="752.94" data-end="755.85">a user code back with them.</span> </p>
<p><span data-start="755.85" data-end="760.339">Speaking of callbacks, there is one special type of callback.</span> <span data-start="760.339" data-end="767.519">It is very important in the life span of both original and the new HTTP parser.</span> <span data-start="767.519" data-end="770.94">During their executions they need ranges of data.</span> <span data-start="770.94" data-end="775.709">For example, header names, or headers are in this way.</span> </p>
<p><span data-start="775.709" data-end="782.31">And begin that we have a stream of data that comes to the parser, we have to be able to</span> <span data-start="782.31" data-end="787.33">mark some certain place inside of this stream as the beginning of this range.</span> <span data-start="787.33" data-end="792.949">And then at some other point later on we want to set it as an ending of the range.</span> <span data-start="792.949" data-end="797.069">So, between those beginning and ending, or you can see, our beginning and ending.</span> <span data-start="797.069" data-end="800.649">Between them the callback is going to be invoked for every byte.</span> <span data-start="800.649" data-end="806.36">And it's really, really useful for header names, header values and bodies, and other</span> <span data-start="806.36" data-end="811">things that could be needed that spans the ranges of input.</span> <span data-start="811" data-end="815.529">Of course, there are a couple of important actions that I have not needed in previous</span> <span data-start="815.529" data-end="820.009">slides that are actually mandatory to have in this state.</span> </p>
<p><span data-start="820.009" data-end="822.43">They call otherwise and skip to.</span> <span data-start="822.43" data-end="829.6">And those specify which states of the parser should be reached next if nothing else matches</span> <span data-start="829.6" data-end="830.99">inside of the current state.</span> <span data-start="830.99" data-end="837.73">So, in this example, the input would be A. The parser would move to the A state, and</span> <span data-start="837.73" data-end="843.029">for B, move to B and C or D or E or whatever is later.</span> <span data-start="843.029" data-end="846.55">It would move to some other state.</span> <span data-start="846.55" data-end="848.18">Skip to is quite similar.</span> <span data-start="848.18" data-end="851.85">It's the same thing but consumes the character from the input stream.</span> <span data-start="851.85" data-end="854.769">Otherwise, it does not change the input stream at all.</span> <span data-start="854.769" data-end="856.14">It just moves on.</span> <span data-start="856.14" data-end="863.73">So, that was a bit of description maybe too concise to be useful of DSL.</span> <span data-start="863.73" data-end="870.329">And with this DSL in mind, llhttp becomes a type Script program.</span> <span data-start="870.329" data-end="877.31">This program uses it to describe the actions and input as said before.</span> <span data-start="877.31" data-end="881.769">Because it's a TypeScript program, or JavaScript program, really, I could split it into several</span> <span data-start="881.769" data-end="884.52">sub modules and use them efficiently.</span> </p>
<p><span data-start="884.52" data-end="885.87">And each submodule could have the subparser.</span> <span data-start="885.87" data-end="889.74">This is what I use in HTTP.</span> <span data-start="889.74" data-end="896.91">I have a separate parser inside of it and can use it and run it separately and can be</span> <span data-start="896.91" data-end="902.86">used separately as well as a library if anyone wants it.</span> <span data-start="902.86" data-end="912.009">Llparse compile this is TypeScript program down to C. And that's the main action of it.</span> <span data-start="912.009" data-end="919.579">Know that because it uses a stable DSL, oh, sorry, just uses DSL, the parser doesn't need</span> <span data-start="919.579" data-end="921.259">to do any parsing.</span> <span data-start="921.259" data-end="924.81">It's done automatically by the JS engine.</span> <span data-start="924.81" data-end="926.98">So, V8 does it for us.</span> <span data-start="926.98" data-end="930.649">V8 does this itself internally.</span> <span data-start="930.649" data-end="937.009">Llparse builds a graph of state which I will try to show you.</span> <span data-start="937.009" data-end="938.26">It looks kind of terrible.</span> <span data-start="938.26" data-end="939.42">But I probably can zoom in.</span> <span data-start="939.42" data-end="940.42">Yeah.</span> <span data-start="940.42" data-end="945.509">So, yeah, hear, how it looks like in practice.</span> </p>
<p><span data-start="945.509" data-end="949.37">I can probably actually show you something more useful.</span> <span data-start="949.37" data-end="956.449">So, here on the right you see ACL buy check out this.</span> <span data-start="956.449" data-end="958.96">Mobile names supported by parser.</span> <span data-start="958.96" data-end="961.819">And the name is matched in this of the input.</span> <span data-start="961.819" data-end="967.4">It will store the integer and coding as a method inside those internal properties of</span> <span data-start="967.4" data-end="968.4">parsers.</span> </p>
<p><span data-start="968.4" data-end="971.31">It works this way more or less.</span> <span data-start="971.31" data-end="975.139">I guess with a that means is the kind of graph is looking awesome.</span> <span data-start="975.139" data-end="978.529">So, that's one of the reasons to have it.</span> <span data-start="978.529" data-end="983.5">And another reason to have it is that llparse can do static analysis on this graph.</span> <span data-start="983.5" data-end="989.339">Before in original parsers there was no way to reason about the states automatically.</span> <span data-start="989.339" data-end="993.23">So, it was all described manually inside of the parser.</span> <span data-start="993.23" data-end="995.389">There was just a lot of C code.</span> <span data-start="995.389" data-end="999.05">And there was no way to analyze it and to do any optimizations for checks.</span> <span data-start="999.05" data-end="1006.91">What I can to in llparse is check the code for absence of infant loops which is possible</span> <span data-start="1006.91" data-end="1010.259">due to otherwise so, they could be combined together.</span> <span data-start="1010.259" data-end="1014.79">Not just making any progress over the input and just being in indefinitely.</span> <span data-start="1014.79" data-end="1020.579">It's important to check this statically because there might be an array of conditions that</span> <span data-start="1020.579" data-end="1021.579">could trigger it.</span> <span data-start="1021.579" data-end="1026.86">It might not be immediately verifiable with the test suite.</span> <span data-start="1026.86" data-end="1031.81">Speaking of optimizations, the parser could do peephole optimizations.</span> </p>
<p><span data-start="1031.81" data-end="1037.88">That's a fancy name for just combining similar states together into one.</span> <span data-start="1037.88" data-end="1044.48">This way the amount of code is reduced, and also the compiler sorry, programmer has a</span> <span data-start="1044.48" data-end="1049.64">lot more freedom and development with the parser because they don't have to think about</span> <span data-start="1049.64" data-end="1052.56">doing these optimizations manually in their code.</span> <span data-start="1052.56" data-end="1058.08">So, as I said, the DSL is quite stable for llparse.</span> <span data-start="1058.08" data-end="1062.27">So, same program could be compared to different outputs.</span> <span data-start="1062.27" data-end="1066.67">At this moment, C and the code is wellsupported.</span> <span data-start="1066.67" data-end="1074.1">And the code was kind of before, it was supported before the C. So, that's the reason why both</span> <span data-start="1074.1" data-end="1077.06">projects have double L in their names.</span> <span data-start="1077.06" data-end="1078.81">Kind of a historical reason.</span> <span data-start="1078.81" data-end="1087.39">But in the end when I ran benchmarks, this tree C compiler worked better than the code</span> <span data-start="1087.39" data-end="1090.45">which I spent several weeks on.</span> </p>
<p><span data-start="1090.45" data-end="1092.23">It was surprising for me, maybe shocking.</span> <span data-start="1092.23" data-end="1096.8">I had a few months to think about it.</span> <span data-start="1096.8" data-end="1097.8">Yeah.</span> <span data-start="1097.8" data-end="1102.18">And speaking of performance, you might be wondering how fast this new parser is given</span> <span data-start="1102.18" data-end="1104.95">that it is not handwritten at all.</span> <span data-start="1104.95" data-end="1110.03">But, of course, despite the maintenance issues, as I said before, the original parser has</span> <span data-start="1110.03" data-end="1111.22">quite a bit of improvements.</span> <span data-start="1111.22" data-end="1113.75">They're good enough, still very good.</span> <span data-start="1113.75" data-end="1119.45">It would have been very unreasonable to replace it with something that performed significantly</span> <span data-start="1119.45" data-end="1120.45">worse.</span> <span data-start="1120.45" data-end="1125.33">So, ll shipping is not handwritten, it's not hand optimized.</span> <span data-start="1125.33" data-end="1133.49">And when I ran benchmarks, I discovered that it runs twice as fast as the original parser.</span> <span data-start="1133.49" data-end="1141.58">[ Applause ] Thank you.</span> </p>
<p><span data-start="1141.58" data-end="1143.62">And here is the actual benchmark numbers.</span> <span data-start="1143.62" data-end="1149.44">So, as you can see, both those numbers did quite well.</span> <span data-start="1149.44" data-end="1154.89">As it presents a number of requests per second that each parser can take.</span> <span data-start="1154.89" data-end="1159.19">And this way both parsers run in microseconds.</span> <span data-start="1159.19" data-end="1163.47">You wouldn't ever see this on the profile logs.</span> <span data-start="1163.47" data-end="1165.36">Just impossible to see it.</span> <span data-start="1165.36" data-end="1169.77">And, of course, it's important to note as well that llhttp is more than two times faster</span> <span data-start="1169.77" data-end="1171.66">than the original parser.</span> <span data-start="1171.66" data-end="1175.21">But no one hardly cares about it.</span> <span data-start="1175.21" data-end="1179.67">This llhttp parser is a default in Node version 12.</span> <span data-start="1179.67" data-end="1186.96">If you are using the latest Node, I hope you do, you are already running this.</span> <span data-start="1186.96" data-end="1192.59">And even more, you have a reason to blame me for any kinds of HTTP problems that you</span> <span data-start="1192.59" data-end="1193.59">have.</span> </p>
<p><span data-start="1193.59" data-end="1197.57">So, feel free to do so and it would be rightful.</span> <span data-start="1197.57" data-end="1200.01">Please open GitHub.</span> <span data-start="1200.01" data-end="1203.56">Don't just brag on Twitter how bad I am.</span> <span data-start="1203.56" data-end="1204.56">And tag me on GitHub.</span> <span data-start="1204.56" data-end="1209.21">I will be happy to look into it and fix it as soon as possible.</span> <span data-start="1209.21" data-end="1214.57">As I said before, over ten years originally the parser has accumulated a comprehensive</span> <span data-start="1214.57" data-end="1216.05">test suite.</span> <span data-start="1216.05" data-end="1220.46">It would be really unwise to get rid of it and just start it over.</span> <span data-start="1220.46" data-end="1223.79">So, I ported all the original tests to mark down.</span> <span data-start="1223.79" data-end="1225.24">And the new ones.</span> <span data-start="1225.24" data-end="1228.74">And here they are described by the markdown files.</span> <span data-start="1228.74" data-end="1234.4">So, they completed, and I encourage you to take a look at them if you want.</span> <span data-start="1234.4" data-end="1240.29">Because I find them the most I'm using part of the project that worked on.</span> <span data-start="1240.29" data-end="1241.29">Yes.</span> <span data-start="1241.29" data-end="1242.33">They're really, really fun.</span> </p>
<p><span data-start="1242.33" data-end="1251.25">I'm going to give a bit more time because I see that some people scanned</span> <span data-start="1251.25" data-end="1252.25">the codes.</span> <span data-start="1252.25" data-end="1253.25">Okay.</span> <span data-start="1253.25" data-end="1254.25">So, that makes it.</span> <span data-start="1254.25" data-end="1257.82">And each markdown file contains several tests.</span> <span data-start="1257.82" data-end="1260.01">They are separated by the headings.</span> <span data-start="1260.01" data-end="1262.62">So, it's quite easy to read.</span> <span data-start="1262.62" data-end="1264.22">And even easier to contribute.</span> <span data-start="1264.22" data-end="1269.24">In fact, they had one contributor that submitted a test without asking a question how to do</span> <span data-start="1269.24" data-end="1270.24">so.</span> <span data-start="1270.24" data-end="1275.92">And I don't know that many projects that uses a test system that's easy to contribute.</span> <span data-start="1275.92" data-end="1279.92">And furthermore, each test has an actual description inside of them.</span> <span data-start="1279.92" data-end="1286.71">They have code chunks inside of markdown, code chunk for expected output, and between</span> <span data-start="1286.71" data-end="1289.2">those you can put just any text you want.</span> </p>
<p><span data-start="1289.2" data-end="1292.26">You can put hyperlinks, you can put images.</span> <span data-start="1292.26" data-end="1295.19">You can put GIFs of pets doing stuff.</span> <span data-start="1295.19" data-end="1298.99">So, it's quite a nice way of writing tests.</span> <span data-start="1298.99" data-end="1303.58">And it especially works well for HTTP because it's the contextual protocol.</span> <span data-start="1303.58" data-end="1310.34">And you can see in C where it's actually inside the test suite.</span> <span data-start="1310.34" data-end="1311.34">Yeah.</span> <span data-start="1311.34" data-end="1317.03">So, here's been the presence of the parser and the history of it.</span> <span data-start="1317.03" data-end="1322.34">So, naturally I would like to talk about what's coming next.</span> <span data-start="1322.34" data-end="1326.03">And there is room for future improvements with regards to doing more static checks in</span> <span data-start="1326.03" data-end="1330.83">this graph I'm showing to you and doing more performance optimizations.</span> </p>
<p><span data-start="1330.83" data-end="1336.86">There are forks of original parsers that use CPUspecific vector instructions which are</span> <span data-start="1336.86" data-end="1337.86">really, really, fast.</span> <span data-start="1337.86" data-end="1342.2">They perform better than both.</span> <span data-start="1342.2" data-end="1344.62">Not much use for this speed bump for Node.</span> <span data-start="1344.62" data-end="1348.3">But nevertheless, there's no reason to not explore it.</span> <span data-start="1348.3" data-end="1353.99">I probably should do it, or I would love someone do it for me to do some.</span> <span data-start="1353.99" data-end="1357.97">Quite ashamedly, the project is not well documented.</span> <span data-start="1357.97" data-end="1366.29">It has quite a bit of information describing the API of llparse, but it's scattered through</span> <span data-start="1366.29" data-end="1369.9">several dependencies and could be made more accessible.</span> </p>
<p><span data-start="1369.9" data-end="1377.27">I could use help with this and I'm sure some people might find this quite entertaining</span> <span data-start="1377.27" data-end="1381.74">as well because there's a lot of interesting moments in this parser, in this code.</span> <span data-start="1381.74" data-end="1390.02">Finally, it would be fascinating to see different types of parsers implemented on top of llparse.</span> <span data-start="1390.02" data-end="1394.62">Two examples that I have in mind, SMTP and protocols, they are contextual and could be</span> <span data-start="1394.62" data-end="1397.68">implemented in llparse.</span> <span data-start="1397.68" data-end="1404.02">I really look forward to either working on this or helping someone with this.</span> <span data-start="1404.02" data-end="1405.48">And, yeah.</span> <span data-start="1405.48" data-end="1414.34">Here is a link to the ll repos.</span> </p>
<p><span data-start="1414.34" data-end="1417.11">It's quite easy to find on GitHub.</span> <span data-start="1417.11" data-end="1420.37">Just under the Node.js organization.</span> <span data-start="1420.37" data-end="1423.13">GitHub.com/Node.js/ et cetera /llhttp.</span> <span data-start="1423.13" data-end="1425.89">So, I guess that's it.</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
