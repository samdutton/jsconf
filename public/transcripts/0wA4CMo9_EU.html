<section>
<p><span data-start="5.5" data-end="6">Hello, my name is Philip Walton</span> <span data-start="6" data-end="11.53">I'm an engineer on the Chrome and web platform team at footballing, and I'm really excited</span> <span data-start="11.53" data-end="16.33">to talk to you all today about this, because container queries is one of my favourite topics</span> <span data-start="16.33" data-end="21.581">and a feature I've been waiting for for a long, long time, and so I've a lot to say</span> <span data-start="21.581" data-end="22.581">about it.</span> <span data-start="22.581" data-end="26.56">Let's dive right in.</span> <span data-start="26.56" data-end="31.75">Container queries are a contentious topic, and to fully understand why, you have to know</span> <span data-start="31.75" data-end="33.29">their history.</span> <span data-start="33.29" data-end="38.08">Like many things in this area, their history starts with response to design.</span> <span data-start="38.08" data-end="44.07">So, in 2010, Responsive Web Design was published and changed the way we think about web design</span> <span data-start="44.07" data-end="45.87">forever.</span> </p>
<p><span data-start="45.87" data-end="50.32">Web developers can build sites with one set of styles and confidently serve those styles</span> <span data-start="50.32" data-end="51.69">to any device.</span> <span data-start="51.69" data-end="56.73">Over the next year or so, you started to see the same questions popping up over and over</span> <span data-start="56.73" data-end="62.86">again: as the web matured and its modular component-based architecture started to gain</span> <span data-start="62.86" data-end="67.29">popularity, a lot of people were noticing the limitations of using media queries to</span> <span data-start="67.29" data-end="69.579">build responsive designs.</span> </p>
<p><span data-start="69.579" data-end="75.09">In 2013, prominent voices in the community, like Nicholas Gallagher, were starting to</span> <span data-start="75.09" data-end="81.499">suggest that responsive designs should really be component-based rather than viewport based.</span> <span data-start="81.499" data-end="86.899">Folks like Jonathan Neil started proposing new syntax that could support element-based</span> <span data-start="86.899" data-end="90">queries in CSS.</span> <span data-start="90" data-end="96.49">Probably the most influential thing came in April of 2013 a post on the front page of</span> <span data-start="96.49" data-end="98.32">Hacker News for a while.</span> <span data-start="98.32" data-end="107.359">He called — he said the definitions for the design and lay-out of a particular site.</span> <span data-start="107.359" data-end="110.329">He said that what we really need are element queries.</span> <span data-start="110.329" data-end="114.479">And this article is largely responsible for popularising that term.</span> </p>
<p><span data-start="114.479" data-end="121.429">So, a few days after that, after getting slammed with requests for this feature, my colleague</span> <span data-start="121.429" data-end="126.34">and CSS working group member, wrote a reply that summarises the problems with element</span> <span data-start="126.34" data-end="131">queries, and it's kind of become the de facto response from the working group whenever developers</span> <span data-start="131" data-end="133.11">ask for this feature.</span> <span data-start="133.11" data-end="136.75">So I will explain the argument in a second, but for now, the main thing I want you to</span> <span data-start="136.75" data-end="143.44">understand, that in many of the valid points, developers still wanted element queries to</span> <span data-start="143.44" data-end="145.1">be a thing.</span> </p>
<p><span data-start="145.1" data-end="150.43">Blog posts were written.</span> <span data-start="150.43" data-end="155.66">For example, this one includes a great example that I think perfectly illustrates the problem.</span> <span data-start="155.66" data-end="159.86">So, with media queries, you can build a calendar widget like this one and it works great on</span> <span data-start="159.86" data-end="166.23">desktop and mobile, but it only works if the counter widget is rendered in the content</span> <span data-start="166.23" data-end="171.79">area that is the same width of the screen.</span> </p>
<p><span data-start="171.79" data-end="176.86">If you try to put it in a said bar, it will break because the media queries report a wide</span> <span data-start="176.86" data-end="180.2">view port.</span> <span data-start="180.2" data-end="184.47">We need the ability for the calendar to detect that it is in an arrow context and render</span> <span data-start="184.47" data-end="186.51">itself accordingly.</span> <span data-start="186.51" data-end="195.09">To prove that this is isn't a contrived example, this is a an example of the new calendar in</span> <span data-start="195.09" data-end="203.4">Google and the same rendered in Gmail in the side bar.</span> <span data-start="203.4" data-end="209.06">Not only is it being reused in a different view, but being used in an entirely different</span> <span data-start="209.06" data-end="213.9">web application, two different code basis using the same component.</span> </p>
<p><span data-start="213.9" data-end="218.569">This is a real-world example of how responsive design is more than just about page layouts.</span> <span data-start="218.569" data-end="222.35">It is definitely about component layouts.</span> <span data-start="222.35" data-end="226.6">But since browsers weren't implementing element queries natively, developers started to build</span> <span data-start="226.6" data-end="228.27">polyfils.</span> <span data-start="228.27" data-end="233.38">Since there is no official syntax, each made up its own syntax, unofficial syntax.</span> <span data-start="233.38" data-end="238.43">The problem with inventing your own syntax is that it creates a potential future compatible</span> <span data-start="238.43" data-end="239.819">risk.</span> <span data-start="239.819" data-end="241.68">Something we see a lot in the JavaScript community.</span> <span data-start="241.68" data-end="246.68">Recent examples like smush-gate chose to pinned.</span> <span data-start="246.68" data-end="257.229">It started a standardisation effort for element queries.</span> <span data-start="257.229" data-end="262.52">And after their heroic work getting the picture element standardised in browsers, developers</span> <span data-start="262.52" data-end="263.539">had high hopes.</span> <span data-start="263.539" data-end="267.93">Unfortunately, though, the work was met with a lot of resistance from browser surrenders</span> <span data-start="267.93" data-end="271.439">as well as the CSS working group.</span> </p>
<p><span data-start="271.439" data-end="278.86">In 2015, an article was borrow and the challenges and explained that element queries, at least</span> <span data-start="278.86" data-end="283.99">in the current form, were essentially dead.</span> <span data-start="283.99" data-end="287.37">Given the resistance and challenges related to element queries, the group perspective</span> <span data-start="287.37" data-end="291.34">today for something they thought might be easy to get through the standard bodies, so</span> <span data-start="291.34" data-end="294.93">they called it container queries, and thus this new term was born.</span> <span data-start="294.93" data-end="299.879">Instead of having CSS conditionally target an element itself, it targets the element's</span> <span data-start="299.879" data-end="301.889">immediate patient.</span> <span data-start="301.889" data-end="306.52">Unfortunately, while it's true that container queries is less problematic than element queries,</span> <span data-start="306.52" data-end="312.909">they are still problematic and strong resistance from browsers to implement them.</span> <span data-start="312.909" data-end="318.25">But was again, developers kept on asking.</span> <span data-start="318.25" data-end="322.84">It was hypothesised on Twitter, if element queries were real, they would be used more</span> <span data-start="322.84" data-end="332.33">often than media queries.</span> </p>
<p><span data-start="332.33" data-end="337.849">So the question is: if container queries are useful in design, and developers clearly want</span> <span data-start="337.849" data-end="341.4">them, why don't they exist?</span> <span data-start="341.4" data-end="345.689">It almost feels like there's this epic battle between web developers and browser makers</span> <span data-start="345.689" data-end="349.059">where neither side fully understand the other.</span> <span data-start="349.059" data-end="356">Jimmy Keith describes the sentiment well in a post he published a year ago in his blog:</span> <span data-start="356" data-end="360.27">according to him, browser makers always claim they want real-world feedback from actual</span> <span data-start="360.27" data-end="365.699">developers, but when developers tell them they want container queries, browser makers</span> <span data-start="365.699" data-end="368.039">don't know what to say."</span> <span data-start="368.039" data-end="372.479">To be honest, in my experience, this is mostly true.</span> </p>
<p><span data-start="372.479" data-end="377.22">So you have browser-makers — so, I mean, it begs the question: have browser-makers put</span> <span data-start="377.22" data-end="383.08">on their evil goatees, in a dystopian timeline where developers don't get any say in the</span> <span data-start="383.08" data-end="386.419">future of the web?</span> <span data-start="386.419" data-end="391.12">Before we get too cynical, let's look at why browser-makers are concerned about container</span> <span data-start="391.12" data-end="392.12">queries.</span> </p>
<p><span data-start="392.12" data-end="400.59">Due to the way CSS works in browsers today, containers present two primary problems: the</span> <span data-start="400.59" data-end="407.02">first is the infinite loan incursion problem.</span> <span data-start="407.02" data-end="412.389">The second less familiar one is that they actually break the cascade.</span> <span data-start="412.389" data-end="416.009">So consider these two CSS rules.</span> </p>
<p><span data-start="416.009" data-end="420.979">The first one defines an element that defaults to 500 pixels wide; the second conditionally</span> <span data-start="420.979" data-end="428.839">overrides the first rule to say if it gets wider, make it 4 pixels instead.</span> <span data-start="428.839" data-end="434.909">However, if we make it 499 pixels, then the selector will no longer match.</span> <span data-start="434.909" data-end="439.27">But this means we are back to just the first selector matching, and remember, the first</span> <span data-start="439.27" data-end="442.47">selector tells the browser to make the element 500 pixels wide.</span> <span data-start="442.47" data-end="446.83">That means the second selector now matches again and you can see we have a problem where</span> <span data-start="446.83" data-end="450.169">an infinite loop and it's not an obvious way to resolve this.</span> <span data-start="450.169" data-end="453.84">Note that this problem doesn't just apply to element queries.</span> <span data-start="453.84" data-end="457.61">It also applies to container queries.</span> <span data-start="457.61" data-end="462.83">Oftentimes in CSS, an element size is determined by the size of its children.</span> <span data-start="462.83" data-end="467.24">This is known as shrink-to-fit and it can happen with things like inline-block and floats</span> <span data-start="467.24" data-end="469.62">like in this example.</span> </p>
<p><span data-start="469.62" data-end="473.99">So here we have a container floated and a child element with a declared width of 500</span> <span data-start="473.99" data-end="474.99">pixels.</span> <span data-start="474.99" data-end="479.319">Since the container is floated, it will be the same width as its child, so it is also</span> <span data-start="479.319" data-end="481.86">500 pixels wide.</span> <span data-start="481.86" data-end="486.4">But the next rule says in the event that the container's width is 500 pixels or greater,</span> <span data-start="486.4" data-end="490.589">the child's width should be set to 499 pixels.</span> <span data-start="490.589" data-end="495.419">Since the container is floated, changing the child's width will also change the container's</span> <span data-start="495.419" data-end="497.809">width to 499 pixels.</span> <span data-start="497.809" data-end="503.319">Now you can see that we have the same problem that we had before.</span> <span data-start="503.319" data-end="506.27">So that's how container queries can lead to infinite loops.</span> </p>
<p><span data-start="506.27" data-end="512.82">Let's look at how they brake assumptions that the browsers make about the cascade.</span> <span data-start="512.82" data-end="517">In order to understand why this is the case, you have to first have an understanding of</span> <span data-start="517" data-end="522.72">how browsers take CSS and HTML and render content to the screen.</span> <span data-start="522.72" data-end="529.14">They render in three distinct phases: style, layout, and paint.</span> <span data-start="529.14" data-end="535.16">Before I explain them, I wanted to make sure one thing is clear: they are distinct and</span> <span data-start="535.16" data-end="536.53">sequential.</span> <span data-start="536.53" data-end="540.58">Meaning that each one must completely finish before the next one starts.</span> <span data-start="540.58" data-end="545.04">That's very important.</span> <span data-start="545.04" data-end="548.57">Let's look at the style phase.</span> <span data-start="548.57" data-end="556.88">In the style phase, the browser goes through every single element in the DOM, it matches</span> <span data-start="556.88" data-end="560.88">with with selectors in the CSS, and then it determines what value should apply to every</span> <span data-start="560.88" data-end="564.13">single CSS property the browser supports.</span> </p>
<p><span data-start="564.13" data-end="570.06">This is known as the cascade.</span> <span data-start="570.06" data-end="575.13">Most websites have hundreds if not thousands of style rules and DOM elements, so it's critically</span> <span data-start="575.13" data-end="579.69">important that this process can run as efficiently and quickly as possible.</span> <span data-start="579.69" data-end="583.16">So I think most people in this room probably understand how things like specificity and</span> <span data-start="583.16" data-end="587.43">short order work, so I will go through this quick.</span> </p>
<p><span data-start="587.43" data-end="590.87">When doing style calculations, you have to start with the root element in the tree and</span> <span data-start="590.87" data-end="592.25">traverse down.</span> <span data-start="592.25" data-end="598.3">Most of the time, s element is HTML, but in this example, the root element is a section.</span> <span data-start="598.3" data-end="603.58">So the reason you have to start the root element is because some properties are inherited which</span> <span data-start="603.58" data-end="607.91">means that you have to compute the full set of properties for the parent before you can</span> <span data-start="607.91" data-end="614.07">move on to the child.</span> <span data-start="614.07" data-end="622.99">Actually, that's not quite true — technically, you also need to list the default values for</span> <span data-start="622.99" data-end="627.57">every CSS property that's not mentioned by any specific rule.</span> <span data-start="627.57" data-end="631.7">It looks like this which is just a little bit verbose.</span> </p>
<p><span data-start="631.7" data-end="634.39">For the purposes of these examples, I will imply this.</span> <span data-start="634.39" data-end="639.6">I will not list every single property that the browser source in every single case.</span> <span data-start="639.6" data-end="646.67">Also, technically, you don't use the shorthand, you use the longhand for these properties,</span> <span data-start="646.67" data-end="648.87">but this is getting into the details.</span> <span data-start="648.87" data-end="653.82">It's easy to show the individual properties that match to the rules defined if the CSS.</span> </p>
<p><span data-start="653.82" data-end="657.73">So next to come to the UL, and we do the same for it.</span> <span data-start="657.73" data-end="660.74">As you can see, there are four properties and two rules, and the patient element doesn't</span> <span data-start="660.74" data-end="664.16">have any non-default inheritable properties to those that apply, with , so this is the</span> <span data-start="664.16" data-end="665.67">full set of properties.</span> <span data-start="665.67" data-end="669.48">It gets more interesting when we get to the LI.</span> <span data-start="669.48" data-end="674.17">As you can see, two rules match, but due to source order, the second declaration overrides</span> <span data-start="674.17" data-end="675.9">the first one.</span> </p>
<p><span data-start="675.9" data-end="679.11">So this is the computed set of property.</span> <span data-start="679.11" data-end="684.78">We're not quite done yet because the LI is a child of the UL, and that has a colour define,</span> <span data-start="684.78" data-end="689.3">and colour is inheritable, so you have to add that to the list.</span> <span data-start="689.3" data-end="693.93">Anyway, sorry if this is getting too into the weeds, but it is actually really easy</span> <span data-start="693.93" data-end="697.52">to see how this works when you look in were your browser's developer tools.</span> <span data-start="697.52" data-end="701.99">All you have to do is select any DOM element and look at the style paint and see the properties</span> <span data-start="701.99" data-end="708.05">that are calculated.</span> <span data-start="708.05" data-end="718.48">With regard to this pipeline, now we have done style, only now with key do layout.</span> <span data-start="718.48" data-end="723.57">We do what is called kind of at least in Carol, we call this calculating the box tree.</span> <span data-start="723.57" data-end="728.92">What you have — you have to take the full set of cascaded properties for an element</span> <span data-start="728.92" data-end="734.48">and then you calculate all the kind of rectangular co-ordinates of everything in the DOM.</span> <span data-start="734.48" data-end="738.6">In this case, we know that this element is the root elements, so it starts out in the</span> <span data-start="738.6" data-end="744.67">top left at zero zero, and since we know it's auto, we know it's going to fill up the entire</span> <span data-start="744.67" data-end="749.01">space, so let's imagine it's 600 pixels wide.</span> <span data-start="749.01" data-end="752.62">We don't know the height because we have to go through all the tree, but we will get to</span> <span data-start="752.62" data-end="753.78">that next.</span> </p>
<p><span data-start="753.78" data-end="755.21">The UL is very similar.</span> <span data-start="755.21" data-end="759.79">It takes up the same space as the section.</span> <span data-start="759.79" data-end="764.83">But when you get to the LI, now we can start developing this box tree, but the important</span> <span data-start="764.83" data-end="769.74">thing to remember here, and none of these details are important, they're all kind of,</span> <span data-start="769.74" data-end="774.82">faking this example, but the critically important thing to remember is we can't do layout unless</span> <span data-start="774.82" data-end="778.51">we know what all of the styles are, so we have to do all the styles first, and then</span> <span data-start="778.51" data-end="779.51">layout.</span> <span data-start="779.51" data-end="781.57">We can't do them at the same time.</span> <span data-start="781.57" data-end="789.5">So the most ly boring part is over, but the main part from all of that, is you have to</span> <span data-start="789.5" data-end="791.86">do style before layout.</span> <span data-start="791.86" data-end="794.26">Imagine now that we try to implement container queries.</span> <span data-start="794.26" data-end="796.91">Imagine your browser, and you're going to implement container queries in your browser</span> <span data-start="796.91" data-end="799.45">rendering engine.</span> </p>
<p><span data-start="799.45" data-end="801.5">So look at this HTML and CSS again.</span> <span data-start="801.5" data-end="804.45">Now let's add another rule that has a container query.</span> <span data-start="804.45" data-end="809.84">So, as you can see, this rule conditionally targets LI elements if the parent UL is wide</span> <span data-start="809.84" data-end="810.84">enough.</span> <span data-start="810.84" data-end="816.68">Let's try to compute what the cascaded property values would be for the LI.</span> <span data-start="816.68" data-end="821.24">If you look closely, you notice that there are two different values for the flex property.</span> </p>
<p><span data-start="821.24" data-end="825.09">So the question is: which one should be applied?</span> <span data-start="825.09" data-end="831.28">Well, the only way to answer this question is to know how wide the UL is.</span> <span data-start="831.28" data-end="834.76">Is it wider than 500 pixels or not wider than 500 pixels?</span> <span data-start="834.76" data-end="839.79">Since we haven't done layout yet, we don't have that information.</span> <span data-start="839.79" data-end="844.29">If you allow selectors to query based on layout information, then you go from a sequential</span> <span data-start="844.29" data-end="847.42">rendering pipeline to something like this.</span> <span data-start="847.42" data-end="851.84">In this model, we do style again after layout, but since doing style again might completely</span> <span data-start="851.84" data-end="856.16">change the results of the cascade, you also have to do layout again, but doing layout</span> <span data-start="856.16" data-end="860.41">again may completely change what selectors match which means you have to do style again,</span> <span data-start="860.41" data-end="864.7">and you have to repeat this process over and over again until everything kind of settles</span> <span data-start="864.7" data-end="868.59">and there are no more changes and only then can you move on.</span> <span data-start="868.59" data-end="875">This is much, much, much slower than what we have currently today.</span> <span data-start="875" data-end="878.16">Given what I just showed you, I actually think it's a good thing that browsers push back</span> <span data-start="878.16" data-end="881.28">and didn't implement container queries when developers asked.</span> <span data-start="881.28" data-end="886.24">If they had done it how developers want it, the web would be significantly slower today,</span> <span data-start="886.24" data-end="888.4">and nobody wants that.</span> </p>
<p><span data-start="888.4" data-end="892.85">There is good news: the reason I said this isn't the darkest timeline because there are</span> <span data-start="892.85" data-end="897.18">few event in the history of container queries that I skipped over and didn't mention.</span> <span data-start="897.18" data-end="901.16">The truth is that browser-makers have been working hard to come up with performant solutions</span> <span data-start="901.16" data-end="902.99">to this problem.</span> <span data-start="902.99" data-end="911.44">In 2015, Chrome started implementing CSS containment, giving developers the way to tell the browser</span> <span data-start="911.44" data-end="918.99">what parts of the page lay-out are independent of the other parts.</span> <span data-start="918.99" data-end="924.37">It paves the way for potentially avoiding the circularity issue, for example, with CSS</span> <span data-start="924.37" data-end="928.81">containment, you can specify an element size can't be affected by any of its descendents,</span> <span data-start="928.81" data-end="932.34">no matter how big or small they might be.</span> <span data-start="932.34" data-end="936.74">Despite the appearance and belief by some that browser makers and web developers are</span> <span data-start="936.74" data-end="938.61">at war, this is definitely not the case.</span> </p>
<p><span data-start="938.61" data-end="943.09">There are many examples of browser engineers reaching out to developers and engaging with</span> <span data-start="943.09" data-end="947.76">them to see that the features they're specifying will help solve real problems that the developers</span> <span data-start="947.76" data-end="949.08">are facing.</span> <span data-start="949.08" data-end="953.37">I know there are plenty of browser engineers here today who would love to talk to all of</span> <span data-start="953.37" data-end="956.47">you, myself included.</span> <span data-start="956.47" data-end="961.68">So continuing on in 2016, Chrome started working on a feature called ResizeObserver which is</span> <span data-start="961.68" data-end="970.57">one of my new favourite web APIs, letting you monitor size element on a page with a</span> <span data-start="970.57" data-end="972.15">simple callback function.</span> <span data-start="972.15" data-end="977.75">Previously, you could only observe changes to the entire window but obviously we know</span> <span data-start="977.75" data-end="982.15">it's possible for elements to change their size, even if the window doesn't change.</span> </p>
<p><span data-start="982.15" data-end="988.08">Then, finally, in January of this year, Chrome shipped ResizeObserver, which means the feature's</span> <span data-start="988.08" data-end="991.68">now available to over two billion users worldwide.</span> <span data-start="991.68" data-end="996.37">Where does that leave us today?</span> <span data-start="996.37" data-end="998.3">Some of these new features may seem cool.</span> </p>
<p><span data-start="998.3" data-end="1002.94">We still don't have container queries, right?</span> <span data-start="1002.94" data-end="1007.52">If you squint your eyes hard enough, and you're willing to take the definition of "container</span> <span data-start="1007.52" data-end="1013.41">queries" very annoyingly literally, then we actually have had them since the beginning</span> <span data-start="1013.41" data-end="1015.47">of CSS.</span> <span data-start="1015.47" data-end="1021.73">For example, where here we define styles for an input and header element and then override</span> <span data-start="1021.73" data-end="1027.93">the styles on the state classes that can be applied to the state let me's containers.</span> <span data-start="1027.93" data-end="1030.559">A selector is essentially a query, right?</span> <span data-start="1030.559" data-end="1033.829">So these are kind of like container queries.</span> <span data-start="1033.829" data-end="1038.88">We can use the same concept to build something today that I think is as good if not even</span> <span data-start="1038.88" data-end="1042.49">better than the queries that developers have been asking for.</span> <span data-start="1042.49" data-end="1044.43">I call this responsive components.</span> </p>
<p><span data-start="1044.43" data-end="1047.14">Let me show you what I mean.</span> <span data-start="1047.14" data-end="1052.11">This is the CSS for component which uses the hypothetical container query syntax.</span> <span data-start="1052.11" data-end="1056.27">You start by applying base styles to an element.</span> <span data-start="1056.27" data-end="1060.52">These styles apply, they define on the elements, so they apply in all situations.</span> <span data-start="1060.52" data-end="1066.88">Then you additional styles for when the container is 36ms or wider, and you add even more styles</span> <span data-start="1066.88" data-end="1069.22">for when it is 48 or wider.</span> <span data-start="1069.22" data-end="1074.11">This similar to how we do mobile-first design today.</span> <span data-start="1074.11" data-end="1080.17">Now imagine you replace those hypothetical pseudo-class functions with actual classes.</span> <span data-start="1080.17" data-end="1083.81">Of course, this isn't magic.</span> <span data-start="1083.81" data-end="1086.3">It only works if those classes are in the DOM.</span> <span data-start="1086.3" data-end="1088.38">That's the only way that they will apply.</span> <span data-start="1088.38" data-end="1092.58">Then they have to be automatically added and removed if the container changes size.</span> <span data-start="1092.58" data-end="1095.83">It will have to work a little bit like this.</span> <span data-start="1095.83" data-end="1100.22">Note how the classes are added and removed from the container as the box gets bigger</span> <span data-start="1100.22" data-end="1108.72">and then smaller.</span> </p>
<p><span data-start="1108.72" data-end="1111.809">So the question is, can we make this work?</span> <span data-start="1111.809" data-end="1113.17">If so, how?</span> <span data-start="1113.17" data-end="1118.05">This is exactly where ResizeObserver comes into play, and why it's is to so great.</span> <span data-start="1118.05" data-end="1122.62">This is code that implement the exact logic I showed you in a previous slide.</span> <span data-start="1122.62" data-end="1124.24">It is not that much code.</span> <span data-start="1124.24" data-end="1126.69">Let's go through it.</span> <span data-start="1126.69" data-end="1131.51">The first thing you create is a ResizeObserver instance and you pass a callback function.</span> <span data-start="1131.51" data-end="1135.76">This callback function is invoked any time the elements that you're observing change</span> <span data-start="1135.76" data-end="1137.43">their size.</span> <span data-start="1137.43" data-end="1145.059">You get past a list of elements because elements can change at one time and you're given more</span> <span data-start="1145.059" data-end="1147.63">details in those.</span> <span data-start="1147.63" data-end="1154.18">So, in the next function, we define a set of breakpoint names and their respective minimum</span> <span data-start="1154.18" data-end="1155.18">widths.</span> <span data-start="1155.18" data-end="1159.47">This is the mapping between the break point names we're going to use and the width that</span> <span data-start="1159.47" data-end="1160.47">we decide.</span> </p>
<p><span data-start="1160.47" data-end="1166.19">Then we loop through a list of break points for each changed element, and then if the</span> <span data-start="1166.19" data-end="1170.68">element width is larger than the miniwidth for the break point, we add the class element,</span> <span data-start="1170.68" data-end="1176.03">and, if smaller, we remove the class.</span> <span data-start="1176.03" data-end="1181.28">Next we set that the observer is now active and monitoring this element.</span> <span data-start="1181.28" data-end="1185.77">This step is technically optional but useful for styling the element in CSS if you want</span> <span data-start="1185.77" data-end="1189.54">to because it is often the case that you don't want to show an element until its initial</span> <span data-start="1189.54" data-end="1191.78">break point is set.</span> </p>
<p><span data-start="1191.78" data-end="1196.44">Finally, we query for all container elements in the DOM and start observing them.</span> <span data-start="1196.44" data-end="1201.73">I should point out that the callback gets observed elements so you have to explicitly</span> <span data-start="1201.73" data-end="1202.73">observe them.</span> <span data-start="1202.73" data-end="1204.89">It doesn't by default observe all elements.</span> <span data-start="1204.89" data-end="1208.48">That would be too inefficient.</span> <span data-start="1208.48" data-end="1215.61">So some of you might share the opinion expressed in this tweet, and while I understand the</span> <span data-start="1215.61" data-end="1225.231">sentiment, and, even though the technique uses JavaScript, it doesn't depend on it.</span> <span data-start="1225.231" data-end="1229.29">It doesn't break without it, or if there are any errors with the JavaScript.</span> <span data-start="1229.29" data-end="1233.4">So, if you look at the CSS again, you will notice that I defined an initial set of base</span> <span data-start="1233.4" data-end="1237.27">styles that don't have any break point classes attached.</span> </p>
<p><span data-start="1237.27" data-end="1241.141">If the user has JavaScript disabled or there was an error when trying to run it, these</span> <span data-start="1241.141" data-end="1242.7">base styles will still apply.</span> <span data-start="1242.7" data-end="1248.55">It is like if you load a mobile website on your desktop browser, it might look weird,</span> <span data-start="1248.55" data-end="1250.929">but it's still completely usable.</span> <span data-start="1250.929" data-end="1254.059">This is a textbook example of progressive enhancement.</span> </p>
<p><span data-start="1254.059" data-end="1262.3">I don't see — even in cases where JavaScript is disabled, or if there is an error running</span> <span data-start="1262.3" data-end="1268.63">it, we can use CSS to guarantee our components will always be displayed because errors in</span> <span data-start="1268.63" data-end="1270.41">JavaScript will not affect CSS.</span> <span data-start="1270.41" data-end="1273.76">This is a great use case for CSS.</span> </p>
<p><span data-start="1273.76" data-end="1282.19">So, we define an animation with two-second initial delay that fades in for each container</span> <span data-start="1282.19" data-end="1285.78">element, and then if the JavaScript fails for some reason, the cache element will still</span> <span data-start="1285.78" data-end="1291.03">become vis — the container element will become visible at most two seconds after the CSS</span> <span data-start="1291.03" data-end="1293.85">is loaded.</span> <span data-start="1293.85" data-end="1298.59">When you're ResizeObserver code runs, and it runs sooner than that, we remove the animation,</span> <span data-start="1298.59" data-end="1301.28">and so everything works as normal.</span> <span data-start="1301.28" data-end="1306.52">Lastly, we add a no script tag, so if JavaScript is turned off entirely, we show the element</span> <span data-start="1306.52" data-end="1307.52">no matter what.</span> <span data-start="1307.52" data-end="1310.12">We don't have that delay.</span> <span data-start="1310.12" data-end="1314.98">So, if you're building a complex web application that has container queries, there's a good</span> <span data-start="1314.98" data-end="1320.94">chance you're using a component architecture, whether it is something like React, or native</span> <span data-start="1320.94" data-end="1328.08">web components, you can get to dynamic DOM.</span> <span data-start="1328.08" data-end="1332.17">With custom elements, you can hook into the custom callback which gets invoked when the</span> <span data-start="1332.17" data-end="1339.17">element is added to the DOM and observe new container elements as they're created.</span> <span data-start="1339.17" data-end="1343.34">As a point, you don't have to worry about unobserving removed elements because that</span> <span data-start="1343.34" data-end="1347.6">gets handled by garbage collection.</span> </p>
<p><span data-start="1347.6" data-end="1351.09">The other really nice thing about using custom elements is then you can give them more meaningful</span> <span data-start="1351.09" data-end="1352.98">famous like this.</span> <span data-start="1352.98" data-end="1357.929">You can also easily define a base container class that all other responsive components</span> <span data-start="1357.929" data-end="1363.44">can extend or behaviours that they can mix in.</span> <span data-start="1363.44" data-end="1373.05">I know it's not cool to show a slide with minified code, even though this is a — 100</span> <span data-start="1373.05" data-end="1380.55">per cent of the code to make this work, both the CSS and the JavaScript, is on this slide</span> <span data-start="1380.55" data-end="1382.35">right here.</span> <span data-start="1382.35" data-end="1388.56">And this is actually hand transpiled ES5, so it will work in IE11 as well.</span> <span data-start="1388.56" data-end="1394.7">Also, note, this assumes that the browser supports ResizeObserver, so, if you want to</span> <span data-start="1394.7" data-end="1399.52">use this code on a producer that doesn't use ResizeObserver, you can import a polyfill.</span> <span data-start="1399.52" data-end="1404.41">You don't have to load the polyfill, because if the browser doesn't support ResizeObserver</span> <span data-start="1404.41" data-end="1407.62">and you get an error, you get the base styles.</span> </p>
<p><span data-start="1407.62" data-end="1413.11">So, to prove that this technique works, I built the demo side a few days ago showing</span> <span data-start="1413.11" data-end="1419.5">the — you can resize them in a variety of different ways, and the UI is supposed to</span> <span data-start="1419.5" data-end="1422.74">mimic common patterns that I see in the wild.</span> <span data-start="1422.74" data-end="1429.05">So, in this case, the side bars are expandible and collapsable, and this pane is resizable</span> <span data-start="1429.05" data-end="1430.36">by the user.</span> <span data-start="1430.36" data-end="1435.19">There's no way to handle situations like this with media queries, because you have no idea</span> <span data-start="1435.19" data-end="1439.51">what the user's preference will be and what size they will make these errors.</span> <span data-start="1439.51" data-end="1446.7">It is built with regular DOM and as well as custom elements, and the source code is clearly</span> <span data-start="1446.7" data-end="1451.22">linked from the site so you can dive in and see how it's implemented.</span> <span data-start="1451.22" data-end="1452.72">The site works cross-browser.</span> <span data-start="1452.72" data-end="1454.24">It is not a Chrome- onlithing.</span> <span data-start="1454.24" data-end="1459.96">It even works in IE and even works when JavaScript is turned off.</span> <span data-start="1459.96" data-end="1464.67">Even though ResizeObserver is chrome-only, this demo shows that that is not a good enough</span> <span data-start="1464.67" data-end="1466.8">reason not to use the technique.</span> <span data-start="1466.8" data-end="1467.8">It does work everywhere.</span> </p>
<p><span data-start="1467.8" data-end="1472.12">It is progressive enhancement like I said before.</span> <span data-start="1472.12" data-end="1478.31">So summarise, container queries don't exist in the form that developers have been asking</span> <span data-start="1478.31" data-end="1479.31">for.</span> <span data-start="1479.31" data-end="1482.63">There are lots of ways to mimic the behaviours with web technologies.</span> <span data-start="1482.63" data-end="1491.57">The strict I've outlined here is performant, it is easy to implement, it doesn't require</span> <span data-start="1491.57" data-end="1499.08">any specific JavaScript framework or build tool, and even works without JavaScript entirely.</span> <span data-start="1499.08" data-end="1505.37">Now that we've discussed the past and present, let's look at what the future might bring.</span> <span data-start="1505.37" data-end="1510.87">So the good news is that the W3C, through their web community group, has restarted the</span> <span data-start="1510.87" data-end="1513.87">container query efforts.</span> <span data-start="1513.87" data-end="1520.76">This has been led by Mozilla and the new spec is being edited by Tommy Hodgkins, the creator</span> <span data-start="1520.76" data-end="1527.42">of the polyfill before while it's impossible to say for sure what the future will bring,</span> <span data-start="1527.42" data-end="1534">let me give you a couple of my predictions: first, browsers are definitely not going to</span> <span data-start="1534" data-end="1536.14">be making the web slower.</span> </p>
<p><span data-start="1536.14" data-end="1541.299">This means that any future container solution will be built on top of exiting optimisations</span> <span data-start="1541.299" data-end="1544.31">like CSS containment and ResizeObserver.</span> <span data-start="1544.31" data-end="1550.4">Second, I think web opponents and APIs will be a big part of this future.</span> <span data-start="1550.4" data-end="1555.96">I imagine we ship something like a declarative resize element or component that requires</span> <span data-start="1555.96" data-end="1561.37">60 CSS containment, that way, browsers can easily optimise for it.</span> <span data-start="1561.37" data-end="1562.55">If you're not familiar with web APIs.</span> <span data-start="1562.55" data-end="1564.29">Talk to me about it afterwards.</span> <span data-start="1564.29" data-end="1569.49">It is a really exiting new idea.</span> <span data-start="1569.49" data-end="1575.19">I think some of the experimentation that browsers are doing with async layout might lead to</span> <span data-start="1575.19" data-end="1579.93">breakthroughs in the efficiency we can do layout, even if that happens, I don't think</span> <span data-start="1579.93" data-end="1585.29">container queries will be implemented if they require a multi-pass rendering.</span> <span data-start="1585.29" data-end="1589.679">You can imagine if layouts becomes ten times faster this the browsers pip don't think the</span> <span data-start="1589.679" data-end="1594.47">browser will lose the entire 17 gain to introduce a slow feature.</span> <span data-start="1594.47" data-end="1598.57">Normally, they will be shouting from the rooftops how much faster their browser is than the</span> <span data-start="1598.57" data-end="1600.37">competition.</span> </p>
<p><span data-start="1600.37" data-end="1607.66">Final thoughts: first of all, ResizeObserver finally gives you see the ability to build</span> <span data-start="1607.66" data-end="1611.611">ultra performant truly responsive components, so please build out the ATI.</span> <span data-start="1611.611" data-end="1615.91">If you find anything cool, share it.</span> <span data-start="1615.91" data-end="1622.82">CSS containment will likely shape the future of container queries.</span> <span data-start="1622.82" data-end="1625.01">If you haven't used it, you should try that out as well.</span> <span data-start="1625.01" data-end="1632.26">It can make your site feel faster.third, browser makers and weapon environments should not</span> <span data-start="1632.26" data-end="1633.79">feel like they're at war with each other.</span> </p>
<p><span data-start="1633.79" data-end="1635.4">They should be working together.</span> <span data-start="1635.4" data-end="1640.929">But don't forget, that, while browser makers want the to please web developers, their ultimate</span> <span data-start="1640.929" data-end="1645.179">responsibility it to the users, and that's what we as web developers should care most</span> <span data-start="1645.179" data-end="1647.25">about as well.</span> <span data-start="1647.25" data-end="1649.19">Let's make the web faster for everybody.</span> </p>
<p><span data-start="1649.19" data-end="1650.19">Thank you.</span> <span data-start="1650.19" data-end="1651.19">[Applause].</span> <span data-start="1651.19" data-end="1652.19">Here are the links I talked about.</span> <span data-start="1652.19" data-end="1653.19">I will be at JS CSSconf as well if you want to talk about these things.</span> </p>
</section>