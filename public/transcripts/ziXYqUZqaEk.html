<section>
<p><span data-start="2.5" data-end="3.99">Just to get started.</span> <span data-start="3.99" data-end="7.71">Anyone who hasn't heard of WebAssembly?</span> <span data-start="7.71" data-end="9.79">Great.</span> </p>
<p><span data-start="9.79" data-end="15.53">Anyone here who has had a reason to use WebAssembly in a production app?</span> <span data-start="15.53" data-end="17.14">All right.</span> <span data-start="17.14" data-end="19.52">So we are all about on the same page.</span> <span data-start="19.52" data-end="24.279">I would like to invite you back into journey of time to the year 2017.</span> <span data-start="24.279" data-end="30.51">Like most of you, I heard about WebAssembly but beyond surface level stuff I didn't know</span> <span data-start="30.51" data-end="31.67">much about it.</span> </p>
<p><span data-start="31.67" data-end="39.14">I read this headline and thought huh, I guess if WebAssembly really does kill JavaScript</span> <span data-start="39.14" data-end="43.17">I will figure that stuff out but it seems like people have wanted JavaScript to die</span> <span data-start="43.17" data-end="48.559">for a while and we are still here.</span> <span data-start="48.559" data-end="52.47">What does a typical web dev need Wasm for?</span> <span data-start="52.47" data-end="61.02">I work for a consulting firm based in Seattle called GEN/UI.</span> <span data-start="61.02" data-end="71.07">I think our dev manager described it best when he said our web expertise is in doing</span> <span data-start="71.07" data-end="74.79">something weird.</span> <span data-start="74.79" data-end="87.02">We built a screen recording and editing app for Chrome OS that runs entirely client-side.</span> <span data-start="87.02" data-end="91.7">Our requirements were as follows: The app was meant to look and feel like it was native</span> <span data-start="91.7" data-end="97.57">to Chrome OS and act as a competitor to others out there.</span> </p>
<p><span data-start="97.57" data-end="103.85">The client requested the video provided video editing capability and needed to run locally</span> <span data-start="103.85" data-end="106.18">offline.</span> <span data-start="106.18" data-end="116.36">There are a couple ways to develop for Chrome OS and we decided to use Chrome package OS</span> <span data-start="116.36" data-end="124.899">and they are essentially web apps given additional hardware APIs.</span> <span data-start="124.899" data-end="129.39">As we started to investigate how we wanted to implement the project, it was a surprise</span> <span data-start="129.39" data-end="133.599">to discover how much it is possible to do with media in native JavaScript.</span> <span data-start="133.599" data-end="139.95">For instance, if the user consents, you can capture their whole screen or Webcam and use</span> <span data-start="139.95" data-end="145.88">the native recorder API to record the screen, create a video and allow the user to download</span> <span data-start="145.88" data-end="147.92">it to their machine.</span> <span data-start="147.92" data-end="151.02">That is possible in any modern web browser.</span> <span data-start="151.02" data-end="155.76">There is nothing special about Chromebook that lets you do it.</span> <span data-start="155.76" data-end="160.48">If all we needed was a screen recording app we would be set with those tools but the client</span> <span data-start="160.48" data-end="164.349">had requested some video editing capabilities.</span> <span data-start="164.349" data-end="169.349">As a result, we started to get into a realm of things that are technically possible in</span> </p>
<p><span data-start="169.349" data-end="173.48">JavaScript that is just not a great idea for a variety of reasons.</span> <span data-start="173.48" data-end="180.18">For instance, if you wanted to create a water mark you can create a media stream that collects</span> <span data-start="180.18" data-end="182.519">data from a canvas element.</span> <span data-start="182.519" data-end="187.92">You can then draw your watermark on to every frame of that canvas element and merge it</span> <span data-start="187.92" data-end="194.3">into the stream from your screen recording but unsurprisingly it is too memory intensive.</span> <span data-start="194.3" data-end="198.54">The resulting videos were kind of like watching a very badly dubbed foreign film.</span> <span data-start="198.54" data-end="204.18">You have got all the pieces there but they don't line up.</span> <span data-start="204.18" data-end="209.129">Another video editing feature we wanted to implement was trimming or shortening the video.</span> <span data-start="209.129" data-end="214.379">It turns out you can actually do that in plain JavaScript so long as you only want to trim</span> <span data-start="214.379" data-end="215.72">the end of the video.</span> </p>
<p><span data-start="215.72" data-end="220.98">If you want to trim the beginning, you are out of luck, at least in Chrome.</span> <span data-start="220.98" data-end="226.69">That brings us to functionality that simply isn't possible in native JavaScript.</span> <span data-start="226.69" data-end="231.239">Once you create that WebM file you are done.</span> <span data-start="231.239" data-end="237.52">There is no way to add a watermark or filter after the fact and it isn't possible to re-encode</span> <span data-start="237.52" data-end="238.52">the video.</span> <span data-start="238.52" data-end="246.72">The media recorder API gives you a WebM so if you want a gif or MP4 you can't do that</span> <span data-start="246.72" data-end="247.91">with native functionality.</span> <span data-start="247.91" data-end="254.379">At this point, we went back to the client and recommended a server-side only solution.</span> <span data-start="254.379" data-end="259.22">There are two big reasons for this.</span> <span data-start="259.22" data-end="266.04">Video editing is a memory intensive process and Chromebooks are meant to do most work</span> <span data-start="266.04" data-end="268.81">from the Cloud by design.</span> <span data-start="268.81" data-end="273.27">And client side video editing pushes the limits on what is possible today.</span> <span data-start="273.27" data-end="282.27">We had two people working on this without an infinite budget.</span> </p>
<p><span data-start="282.27" data-end="291.25">The client asked us to move ahead with a client-side only implementation eventually.</span> <span data-start="291.25" data-end="296.75">This set us off on the journey of determining what is possibly limiting.</span> <span data-start="296.75" data-end="302.53">We determined video editing isn't possible in native JavaScript we needed to find a way</span> <span data-start="302.53" data-end="311.25">to run a code that is not native JavaScript.</span> <span data-start="311.25" data-end="314.55">Running non-JS code in a browser has a long history.</span> <span data-start="314.55" data-end="320.53">Anyone remember this thing called Flash?</span> <span data-start="320.53" data-end="321.53">Anyone?</span> <span data-start="321.53" data-end="323.37">It is kind of obscure.</span> <span data-start="323.37" data-end="325.07">Any ActionScript devs out there?</span> <span data-start="325.07" data-end="329.19">Any OUBT about Silver Light?</span> <span data-start="329.19" data-end="338.4">You may have heard WebAssembly isn't just another way to write plugins and that is true</span> <span data-start="338.4" data-end="344.13">but without understanding more about plugins in general it is hard to know why the comparison</span> <span data-start="344.13" data-end="345.13">is made.</span> </p>
<p><span data-start="345.13" data-end="348.12">The '90s are in again.</span> <span data-start="348.12" data-end="349.86">Let's go back to 1995.</span> <span data-start="349.86" data-end="360.069">We are all wearing JNCOs and the Slater guy is this guy.</span> <span data-start="360.069" data-end="366.639">Your browser of choice is Netscape and they just released the Netscape plugin API or NP</span> <span data-start="366.639" data-end="373.34">API which was the first way to develop plugins or browser extension and handle media from</span> <span data-start="373.34" data-end="375.06">within the browser.</span> <span data-start="375.06" data-end="379.76">What happened was the browser would come across content it couldn't handle and detect the</span> <span data-start="379.76" data-end="387.03">file type and load the appropriate plugins that will run in place on your web page.</span> <span data-start="387.03" data-end="391.75">As of today, NP API is deprecated in every browser.</span> <span data-start="391.75" data-end="403.41">That is because the Advent of HTML5 means the browser can handle a lot of things natively</span> <span data-start="403.41" data-end="407.509">that would otherwise have been handled by plugins.</span> <span data-start="407.509" data-end="411.419">Plugins didn't actually fully die with NP API.</span> </p>
<p><span data-start="411.419" data-end="419.349">Google released the pepper API which is a build chain that produces binary file types</span> <span data-start="419.349" data-end="427.74">native client or pepper native.</span> <span data-start="427.74" data-end="434.2">It was meant to provide a more secure, less complex alternative to NP API.</span> <span data-start="434.2" data-end="442.74">You can recompile libraries written in C or C++ and that could be run within the browser</span> <span data-start="442.74" data-end="444.08">and accessed in JavaScript.</span> <span data-start="444.08" data-end="448.81">For the WebAssembly fans in the crowd this may sound familiar.</span> <span data-start="448.81" data-end="454.74">Why aren't we talking about pepper and how it harkens the death of the most widely used</span> <span data-start="454.74" data-end="457.889">program language?</span> <span data-start="457.889" data-end="465.47">An open standard for pepper was not created and they were only supported on Chrome, Chromium</span> <span data-start="465.47" data-end="468.54">and blink-base browsers.</span> </p>
<p><span data-start="468.54" data-end="474.199">Portable native client is deprecated for every platform except Chromebook but we were building</span> <span data-start="474.199" data-end="478.819">for Chromebooks so let's put a pen in that.</span> <span data-start="478.819" data-end="484.77">WebAssembly, like portable native client, takes advantage of common hardware capabilities</span> <span data-start="484.77" data-end="493.919">to deliver native or near native performance and allows libraries written in C, C++ and</span> <span data-start="493.919" data-end="498.24">rest into a Wasm format.</span> </p>
<p><span data-start="498.24" data-end="505.669">Developers can write directly in WebAssembly for the super nerds out there.</span> <span data-start="505.669" data-end="511.02">Unlike pepper WebAssembly is an open standard and has been adopted by every modern browser.</span> <span data-start="511.02" data-end="515.97">It is really something that you can use and deliver to the vast majority of the web.</span> <span data-start="515.97" data-end="521.24">That doesn't actually say so much about what is great about WebAssembly in the first place,</span> <span data-start="521.24" data-end="523.33">or why we would want to use C or C++.</span> <span data-start="523.33" data-end="529.98">There are a couple reasons why you might use WebAssembly in your application.</span> <span data-start="529.98" data-end="532.31">The first of these is performance.</span> <span data-start="532.31" data-end="537.02">Performance on WebAssembly is faster than native JavaScript and that is mostly due to</span> <span data-start="537.02" data-end="553.44">a lack of dynamic typing in WebAssembly.</span> </p>
<p><span data-start="553.44" data-end="557.88">You might look into WebAssembly if you have a particularly heavy operation you could perform</span> <span data-start="557.88" data-end="561.99">in JavaScript but prefer not to.</span> <span data-start="561.99" data-end="568.91">Every single page web application framework has a DOM diffing operation.</span> <span data-start="568.91" data-end="574.87">It is a heavy thing to do and it can have negative performance implications for updating</span> <span data-start="574.87" data-end="578.16">your page particularly in component-heavy scenario.</span> <span data-start="578.16" data-end="583.06">Glimmer, which is the DOM rendering engine by the Ember team has an existing build that</span> <span data-start="583.06" data-end="588.941">leverages WebAssembly for this purpose and that is a methodology that should result in</span> <span data-start="588.941" data-end="590.95">a much faster rendering engine.</span> <span data-start="590.95" data-end="596.01">I am definitely not saying that because of the primary architecture of Glimmer is speaking</span> <span data-start="596.01" data-end="597.87">later today.</span> </p>
<p><span data-start="597.87" data-end="602.45">There are folks looking into this as well for React.</span> <span data-start="602.45" data-end="609.6">Performance aside, the second reason you may want to use Wasm speaks to video editing.</span> <span data-start="609.6" data-end="615.99">You cannot edit video in JavaScript but you can edit video in C++.</span> <span data-start="615.99" data-end="627.54">You can do several things in C++ or Rest like video editing, platform immolation and games.</span> <span data-start="627.54" data-end="635.94">Wasm was built for our use case and we needed to choose a video editing library we can use.</span> <span data-start="635.94" data-end="641.45">It was important to find a library because there were only two of us and we had neither</span> <span data-start="641.45" data-end="647.019">the budget or expertise to build something from scratch.</span> <span data-start="647.019" data-end="653.39">It turns out there are not tons of video editing options in C++ or Rust and that may be due</span> <span data-start="653.39" data-end="664.709">to FFmpeg which is a command line tool that supports adding watermark or tripping or cropping</span> <span data-start="664.709" data-end="670.61">video or anything you might want to do with it.</span> <span data-start="670.61" data-end="676.16">FFmpeg could be used through portable native client or WebAssembly and we were unable to</span> <span data-start="676.16" data-end="680.93">find another good candidate.</span> <span data-start="680.93" data-end="692.54">The first thing we did was go to the mpm registry and there is an FFmpeg.</span> <span data-start="692.54" data-end="699.49">I am grateful to the author of this package and the person who forked it and added extra</span> <span data-start="699.49" data-end="700.49">documentation.</span> </p>
<p><span data-start="700.49" data-end="704.899">Without these folks, we would have been lost but these were enough bread crumbs for us</span> <span data-start="704.899" data-end="708.519">to figure out how to do this.</span> <span data-start="708.519" data-end="709.8">Getting back to my MPM install.</span> <span data-start="709.8" data-end="713.66">I saw a couple concerning things off the bat.</span> <span data-start="713.66" data-end="714.85">First is the size.</span> </p>
<p><span data-start="714.85" data-end="724.28">The entirety of FFmpeg is about 15 bytes and that is a lot to load and a lot to ask of</span> <span data-start="724.28" data-end="727.06">users to download.</span> <span data-start="727.06" data-end="731.88">The default build includes tons of functionality we didn't plan on using.</span> <span data-start="731.88" data-end="742.19">It also includes the H2-64 kodak which was still pat patented.</span> <span data-start="742.19" data-end="746.1">This is an old version, also.</span> </p>
<p><span data-start="746.1" data-end="751.88">We came to the conclusion there is an existing MPM install for this library, but we needed</span> <span data-start="751.88" data-end="755.389">to compile our own Wasm file.</span> <span data-start="755.389" data-end="759.389">This is the point at which we started to get into technologies that JS devs don't tend</span> <span data-start="759.389" data-end="767.779">to use on a day to day basis and the first is called Emscripten.</span> <span data-start="767.779" data-end="772.26">For those that haven't done a lot of this thing it is vaguely analogous to a tool like</span> <span data-start="772.26" data-end="773.89">Babel.</span> <span data-start="773.89" data-end="780.51">It takes uncompiled C++ library and builds it in a way that a Wasm is produced.</span> <span data-start="780.51" data-end="782.51">You can pass in various build options.</span> <span data-start="782.51" data-end="789.04">If you want to build your Wasm binary in a way it is compatible with web workers you</span> <span data-start="789.04" data-end="793.92">will do that as part of the overall Emscripten and build command.</span> <span data-start="793.92" data-end="795.81">That is a lot of high level information.</span> <span data-start="795.81" data-end="798.9">Let's bring it down.</span> </p>
<p><span data-start="798.9" data-end="804.92">The following example is a little hello, world written in C. Like most of you I don't program</span> <span data-start="804.92" data-end="814.75">in C# but the main method is what runs when the app loads.</span> <span data-start="814.75" data-end="820.48">We imported the standard input and output library.</span> <span data-start="820.48" data-end="826.11">In a C# application this prints to the console and in our app prints to the JavaScript console</span> <span data-start="826.11" data-end="829.47">but we will display it in the DOM also.</span> <span data-start="829.47" data-end="834.09">Now we need to compile our hello world to a Wasm file.</span> <span data-start="834.09" data-end="837.81">You can do that in Emscripten with the following command.</span> <span data-start="837.81" data-end="842.88">You can see we do need to specify Wasm and that is because Emscripten can compile to</span> <span data-start="842.88" data-end="844.67">other formats too.</span> <span data-start="844.67" data-end="854.62">And dash 0 output to HTML lets us know I want Emscripten to build the page rather than just</span> <span data-start="854.62" data-end="857.01">compile a binary.</span> </p>
<p><span data-start="857.01" data-end="859.61">Let's look at the web page.</span> <span data-start="859.61" data-end="863.75">There is a lot more going on than just LEL hello world.</span> <span data-start="863.75" data-end="871.43">The default gives you a page with a console you can use to see the Wasm output and it</span> <span data-start="871.43" data-end="875.13">has JavaScript glue code.</span> <span data-start="875.13" data-end="886.69">If this was a Thanksgiving turkey drawing tutorial we are at this strep drawing an outline</span> <span data-start="886.69" data-end="887.69">of the hand.</span> <span data-start="887.69" data-end="893.62">You know what comes next?</span> <span data-start="893.62" data-end="895.269">We don't need hello, world.</span> <span data-start="895.269" data-end="899.76">We need FFmpeg and there are a few steps in between.</span> <span data-start="899.76" data-end="913.95">It is worth just trying here to convert FFmpeg and see what happens next.</span> <span data-start="913.95" data-end="918.329">Make is a Unix tool.</span> <span data-start="918.329" data-end="931.33">And clang is a front end compilation for interface and gcc is the GNU/Unix.</span> <span data-start="931.33" data-end="942.13">This is the root folder of the FFmpeg library.</span> <span data-start="942.13" data-end="951.62">We need to use the project's make file and substitute cling and gcc with the own Emscripten</span> <span data-start="951.62" data-end="952.81">build tool.</span> </p>
<p><span data-start="952.81" data-end="954.98">Piece of cake.</span> <span data-start="954.98" data-end="960.87">In case you thought it was cake, let me assure you it isn't.</span> <span data-start="960.87" data-end="969.13">Emscripten built their own tool to help you substitute for clang and gcc.</span> <span data-start="969.13" data-end="972.529">It is called M con emconfigure.</span> <span data-start="972.529" data-end="988.23">We will run emmake make and that should build the library into the format and bit code.</span> <span data-start="988.23" data-end="994.04">Assuming everything is well, we can run a command similar to the hello, world command</span> <span data-start="994.04" data-end="997.56">from earlier but of course, everything hasn't gone well.</span> </p>
<p><span data-start="997.56" data-end="1003.92">After about 20 minutes of compilation, emmake make has an error generating deep from within</span> <span data-start="1003.92" data-end="1006.3">the heart of this massive library.</span> <span data-start="1006.3" data-end="1013.829">Anyone who has struggled to get builds to translate knows the pain that can accompany</span> <span data-start="1013.829" data-end="1018.029">production builds particularly as they become more complex.</span> <span data-start="1018.029" data-end="1023.49">Building a project in C# isn't different and compiling tat project into a format it was</span> <span data-start="1023.49" data-end="1026.22">never intended for adds a greater degree of complexity.</span> <span data-start="1026.22" data-end="1030.3">Looking at the hello, world.</span> <span data-start="1030.3" data-end="1037.449">C from earlier it seems reasonable to debug the process even though we are not C# developers.</span> <span data-start="1037.449" data-end="1042.9">It didn't see reasonable to debug this giant make file and dive in the heart of this legacy</span> <span data-start="1042.9" data-end="1047.01">framework.</span> <span data-start="1047.01" data-end="1053.79">Emconfigure makes assumptions about your C# base build environment that may not be true.</span> <span data-start="1053.79" data-end="1057.88">It was necessary to go in and replace every reference to the existing build change.</span> <span data-start="1057.88" data-end="1068.69">Emscripten can't use anything using ASM and that is used in any C# libraries to provide</span> <span data-start="1068.69" data-end="1071.26">compiler instructions to gcc.</span> </p>
<p><span data-start="1071.26" data-end="1078.96">Since we are not building with gcc we need to pass the option to build without this.</span> <span data-start="1078.96" data-end="1083.669">And finally, Emscripten will not convert every possible application.</span> <span data-start="1083.669" data-end="1090.38">In the end we prevailed.</span> <span data-start="1090.38" data-end="1100.53">Here we are looking at a video that has been created in native JavaScript through a screen</span> <span data-start="1100.53" data-end="1102.23">recording of a YouTube clip.</span> <span data-start="1102.23" data-end="1107.31">Our media recorder returned a blob we can convert to a file and save to the user's local</span> <span data-start="1107.31" data-end="1108.31">machine.</span> <span data-start="1108.31" data-end="1115.039">You will notice we cannot seek through the video and this is due to a Chrome-specific</span> <span data-start="1115.039" data-end="1119.94">bug where their mediator recorder doesn't create key frames as it reports therefore</span> <span data-start="1119.94" data-end="1126.38">the find of file created doesn't know important things.</span> </p>
<p><span data-start="1126.38" data-end="1131.36">The client wanted to add trim functionality to the app and that makes total sense.</span> <span data-start="1131.36" data-end="1137.32">We have started screen recordings for getting to set-up our screen and needing to trim out</span> <span data-start="1137.32" data-end="1139.71">the first bit.</span> <span data-start="1139.71" data-end="1141.669">This is where FFmpeg comes in handy.</span> <span data-start="1141.669" data-end="1154.97">If we run our FFmpeg we will ask it to trim to the desired length.</span> <span data-start="1154.97" data-end="1163">I compiled my FFmpeg build, create a new web worker and listen to make sure that worker</span> <span data-start="1163" data-end="1168.76">is ready, once everything is loaded I will post a message containing all the information</span> <span data-start="1168.76" data-end="1172.76">that FFmpeg needs to kick off a trim operation.</span> </p>
<p><span data-start="1172.76" data-end="1179.559">We can see the type of thing I want to run is called run and that is the default or main</span> <span data-start="1179.559" data-end="1189.039">method in FFmpeg and I have passed in data which is actually an array buffer.</span> <span data-start="1189.039" data-end="1195.2">Finally, I pass in the same arguments I would pass in if I were using FFmpeg from the command</span> <span data-start="1195.2" data-end="1196.2">line.</span> <span data-start="1196.2" data-end="1200.03">We have got a dash-SS where you start the video.</span> <span data-start="1200.03" data-end="1203.53">Dash T is how long the video is.</span> <span data-start="1203.53" data-end="1206.96">Dash c copy means to use the existing kodak.</span> <span data-start="1206.96" data-end="1213.21">Let's see what that looks like.</span> <span data-start="1213.21" data-end="1219.2">I kicked off the FFmpeg by default in the background and we can see before too long</span> <span data-start="1219.2" data-end="1220.49">we get a little video.</span> <span data-start="1220.49" data-end="1222.169">It is different than it was before.</span> <span data-start="1222.169" data-end="1226.16">It is only two seconds long.</span> <span data-start="1226.16" data-end="1230.48">That being said, there are some important caveats for using this technology.</span> </p>
<p><span data-start="1230.48" data-end="1236.78">The last video editing feature was to provide crop and that is in case the user wants to</span> <span data-start="1236.78" data-end="1240.52">only display a portion of what they have created in their video.</span> <span data-start="1240.52" data-end="1244.93">You can see we have kicked off our operation, we are getting lots of logging output from</span> <span data-start="1244.93" data-end="1246.58">FFmpeg and that is great.</span> <span data-start="1246.58" data-end="1255.58">We know something is happening but that video is only a minute long and we are still watching</span> <span data-start="1255.58" data-end="1261.28">it convert so we can't put that in front of the user, obviously.</span> </p>
<p><span data-start="1261.28" data-end="1262.95">The other options were really fast?</span> <span data-start="1262.95" data-end="1263.95">What is up?</span> <span data-start="1263.95" data-end="1268.909">I told you performance in WebAssembly is supposed to be much better, right?</span> <span data-start="1268.909" data-end="1273.36">There are two things happening here that cause performance issues.</span> </p>
<p><span data-start="1273.36" data-end="1278.71">One is just that re-encoding takes a little more time than copying the exist code act.</span> <span data-start="1278.71" data-end="1283.1">This operation would be a little slower from the command line but not by a factor of about</span> <span data-start="1283.1" data-end="1285.679">a 1,000 which is what we have here.</span> <span data-start="1285.679" data-end="1290.76">It turns out when Emscripten provides the conversion there are a few patterns in C++</span> <span data-start="1290.76" data-end="1295.87">that convert but have implications.</span> <span data-start="1295.87" data-end="1300.04">Code that relies on X86 behavior.</span> <span data-start="1300.04" data-end="1305.92">And yes, I had to look at stuff up there.</span> <span data-start="1305.92" data-end="1310">In theory, could we address these performance issues and patch them in the same way we watch</span> <span data-start="1310" data-end="1312.42">the code causing conversion problems?</span> <span data-start="1312.42" data-end="1318.86">Or add in WebAssembly specific composition applications to compensate?</span> <span data-start="1318.86" data-end="1322.84">The truth is I don't know.</span> <span data-start="1322.84" data-end="1329.6">We did haven't the budget to become all-knowing video Wasm encoding masters and who does,</span> <span data-start="1329.6" data-end="1330.73">really?</span> <span data-start="1330.73" data-end="1336.27">It is worth mentioning when WebAssembly shipped to all browsers it shipped as an MVP.</span> <span data-start="1336.27" data-end="1340.56">A ton of functionality is coming down the pipeline that might help support the issues</span> <span data-start="1340.56" data-end="1347.42">we had with FFmpeg and one is multi-threaded support.</span> </p>
<p><span data-start="1347.42" data-end="1356.54">Wasm is looking to support garbage collection will opens the doors beyond C++ and Rust.</span> <span data-start="1356.54" data-end="1360.6">Since we were on the Chromebook platform we looked at using the pepper build change and</span> <span data-start="1360.6" data-end="1367.69">an FFmpeg process is defined there and the result is quite a bit faster than our WebAssembly</span> <span data-start="1367.69" data-end="1368.69">binary.</span> <span data-start="1368.69" data-end="1375.26">Perhaps, unsurprisingly, the performance heavy conversions take time and produce an unacceptable</span> <span data-start="1375.26" data-end="1380.55">user experience on the Chromebooks due to their lightweight processor.</span> <span data-start="1380.55" data-end="1382.72">Is this a story on why you should not use WebAssembly?</span> <span data-start="1382.72" data-end="1384.28">Not at all.</span> <span data-start="1384.28" data-end="1387.11">We learned a lot and I want to share those takeaways.</span> <span data-start="1387.11" data-end="1398.22">First, FFmpeg was the wrong library to learn about WebAssembly and C++ in the first place.</span> </p>
<p><span data-start="1398.22" data-end="1409.2">If you are evaluating a new C++ library you think you mind like to use there are well-known</span> <span data-start="1409.2" data-end="1414.429">patterns you can check for to give you a good idea about whether you should proceed.</span> <span data-start="1414.429" data-end="1419.02">Portability guidelines can be found on the Emscripten website.</span> <span data-start="1419.02" data-end="1425.99">This is where it is good idea to have someone with C++ expertise to determine if your library</span> <span data-start="1425.99" data-end="1430.66">contains these and how difficult it is to patch them.</span> <span data-start="1430.66" data-end="1435.669">The Rust language was designed with the web in mind and looks to support Wasm.</span> <span data-start="1435.669" data-end="1443.53">If the functionality you are looking in exists in C++ and Rust it is probably a good idea</span> <span data-start="1443.53" data-end="1445.15">to use Rust.</span> <span data-start="1445.15" data-end="1454.22">WebAssembly is helping pave the way to use the browser as a true application platform.</span> </p>
<p><span data-start="1454.22" data-end="1467.71">For the average JavaScript converting into Wasm is still a problem.</span> <span data-start="1467.71" data-end="1472.01">As Wasm becomes more mainstream, I expect to see better tooling, more libraries and</span> <span data-start="1472.01" data-end="1474.529">simpler processes become more prevalent.</span> <span data-start="1474.529" data-end="1479.1">In the mean time we may all be consuming WebAssembly in frameworks long before we ever have a reason</span> <span data-start="1479.1" data-end="1481.24">to create things ourselves.</span> </p>
</section>