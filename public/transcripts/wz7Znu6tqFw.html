<section>
<p><span data-start="13.65" data-end="14.65">And welcome to my session.</span> <span data-start="14.65" data-end="20.64">I'm going to be talking about V8 in the real world, or more specifically in the native</span> <span data-start="20.64" data-end="21.86">script framework.</span> </p>
<p><span data-start="21.86" data-end="29.15">I'm Stanimira Vlaeva, I'm a software engineer and work on this cool open source project,</span> <span data-start="29.15" data-end="30.279">NativeScript.</span> <span data-start="30.279" data-end="36.86">And I'm with web technologies, and find me on Twitter, the best place.</span> <span data-start="36.86" data-end="40.61">Or in the karaoke after.</span> <span data-start="40.61" data-end="42.82">So, NativeScript.</span> <span data-start="42.82" data-end="47.81">Our main topic today after V8, of course.</span> <span data-start="47.81" data-end="48.81">What is it?</span> <span data-start="49.81" data-end="52.98">How many people here have heard about NativeScript?</span> <span data-start="52.98" data-end="54.77">Awesome.</span> <span data-start="54.77" data-end="56.56">Okay.</span> <span data-start="56.56" data-end="62.3">NativeScript is a framework for building native mobile applications for Android and iOS using</span> <span data-start="62.3" data-end="63.73">web technologies.</span> <span data-start="63.73" data-end="66.68">Like Angular, Vue, or just plain JavaScript.</span> <span data-start="66.68" data-end="72.1">In short, it is a way to execute JavaScript in the mobile world.</span> </p>
<p><span data-start="72.1" data-end="75.02">And build mobile applications with it.</span> <span data-start="75.02" data-end="79.02">We will take a short overview of the architecture of the framework.</span> <span data-start="79.02" data-end="84.54">At the bottom, of course, we have Android and iOS.</span> <span data-start="84.54" data-end="86.76">Operating systems.</span> <span data-start="86.76" data-end="92.07">On top of that we have the NativeScript run times for Android and for iOS which provide</span> <span data-start="92.07" data-end="96.13">the 100% native API access.</span> <span data-start="96.13" data-end="101.3">But if you have had to build a native application for Android or iOS, you may have noticed the</span> <span data-start="101.3" data-end="103.82">way to do that is quite different.</span> <span data-start="103.82" data-end="108.55">The APIs are different and the way to build your user interface is different.</span> <span data-start="108.55" data-end="113.06">Everything is completely different because they are two different worlds.</span> <span data-start="113.06" data-end="117.89">That's why NativeScript provides a common abstraction for these APIs.</span> <span data-start="117.89" data-end="123.87">It is part of the framework and the NativeScript developer cans use that in order to build</span> <span data-start="123.87" data-end="130.25">layouts or build user interface or even style their applications with CSS and this layer</span> <span data-start="130.25" data-end="135.95">is written in JavaScript and you can use that so that you can have a single codebase and</span> <span data-start="135.95" data-end="140.91">have different applications for Android and iOS.</span> </p>
<p><span data-start="140.91" data-end="146.42">NativeScript also has a very light application framework which provides us with native bindings,</span> <span data-start="146.42" data-end="149.37">navigations and some other cool things.</span> <span data-start="149.37" data-end="154.2">And if you need something a bit more sophisticated while building your applications, NativeScript</span> <span data-start="154.2" data-end="158.95">also supports Angular and Vue JS.</span> </p>
<p><span data-start="158.95" data-end="162.39">Today we're gonna talk about the bottom most levels.</span> <span data-start="162.39" data-end="164.37">The deep stuff.</span> <span data-start="164.37" data-end="168.15">And more specifically, we're gonna talk about the Android runtime.</span> <span data-start="168.15" data-end="170.319">The two runtimes are quite similar.</span> <span data-start="170.319" data-end="175.319">And the biggest difference between them is that the Android runtime uses V8 under the</span> <span data-start="175.319" data-end="179.959">hood whereas the iOS run time uses another JavaScript engine.</span> <span data-start="179.959" data-end="182.14">JavaScript Core.</span> <span data-start="182.14" data-end="187.56">But the principle of how they work is quite similar.</span> <span data-start="187.56" data-end="191.55">We're gonna start by explaining how the native API access works.</span> <span data-start="191.55" data-end="196.18">As you make have guessed from the name ""NativeScript,"" this is kind of what we mostly brag about</span> <span data-start="196.18" data-end="200.34">because we have 100% API access.</span> </p>
<p><span data-start="200.34" data-end="209.81">And this is why you should be using NativeScript instead of whatever\h anything else you choose.</span> <span data-start="209.81" data-end="212.2">The main advantage.</span> <span data-start="212.2" data-end="214.8">How it works.</span> <span data-start="214.8" data-end="218.67">We'll start with the look at the application package of our NativeScript application.</span> <span data-start="218.67" data-end="225.84">So, we have Android, some phone or some device that is running the Android operating system.</span> <span data-start="225.84" data-end="230.099">And the NativeScript application is just a regular Android application and which has</span> <span data-start="230.099" data-end="233.37">some NativeScript magic inside it.</span> <span data-start="233.37" data-end="237.239">And the first part of the magic is, of course, the JavaScript code that the NativeScript</span> <span data-start="237.239" data-end="240.59">developer wrote and shipped inside that application.</span> <span data-start="240.59" data-end="247.099">The JavaScript code is not cross compiled or converted or anything like that, it stays</span> <span data-start="247.099" data-end="253.78">JavaScript during the whole life cycle while the application is running.</span> <span data-start="253.78" data-end="257.489">We also have the NativeScript run time, both in the Java part.</span> <span data-start="257.489" data-end="262.639">We're going to talk about them shipped together inside the application.</span> </p>
<p><span data-start="262.639" data-end="267.47">And the last part, almost, is V8.</span> <span data-start="267.47" data-end="271.11">Why do we need to ship V8 inside an Android application?</span> <span data-start="271.11" data-end="274.4">Well, to execute JavaScript.</span> <span data-start="274.4" data-end="277.229">V8 is a JavaScript engine.</span> <span data-start="277.229" data-end="279.33">It executes JavaScript.</span> <span data-start="279.33" data-end="285.839">It is embedded in Chrome, Note, even Microsoft nowadays and of course in NativeScript.</span> <span data-start="285.839" data-end="287.809">It was developed by Google.</span> <span data-start="287.809" data-end="292.199">It was created from the Chrome browser and it's one of the fastest JavaScript engines</span> <span data-start="292.199" data-end="293.199">out there.</span> <span data-start="293.199" data-end="298.8">Another reason why we chose V8 is because it has a cool API that we can use and plug</span> <span data-start="298.8" data-end="303.539">into the runtime.</span> <span data-start="303.539" data-end="308.02">If you want to read a bit more about V8 and how it works, I highly recommend these two</span> <span data-start="308.02" data-end="310.139">resources.</span> <span data-start="310.139" data-end="318.389">The first one is a really amazing popup series which is a crash course just in time compilers.</span> </p>
<p><span data-start="318.389" data-end="322.139">And the other one is a video which is very recent.</span> <span data-start="322.139" data-end="323.409">It's called why the script?</span> <span data-start="323.409" data-end="330.199">And describes the optimizations under the hood while it executes your JavaScript code.</span> <span data-start="330.199" data-end="332.35">It's from the V8 team.</span> <span data-start="332.35" data-end="337.619">If you want to learn about modern JavaScript engines, these are two great resources to</span> <span data-start="337.619" data-end="341.169">get started.</span> <span data-start="341.169" data-end="342.919">The next part of the NativeScript magic.</span> <span data-start="342.919" data-end="345.699">The metadata generator.</span> <span data-start="345.699" data-end="351.009">This is one of the very, very valid JavaScript code inside of NativeScript.</span> </p>
<p><span data-start="351.009" data-end="356.659">But we have something that is not usually in the JavaScript language, right?</span> <span data-start="356.659" data-end="357.659">Android.</span> <span data-start="357.659" data-end="359.879">Where does this come from?</span> <span data-start="359.879" data-end="365.15">Well, let's imagine that when your computer, you have some native library.</span> <span data-start="365.15" data-end="367.659">For example, Android SDK.</span> <span data-start="367.659" data-end="371.309">And you use that inside your NativeScript application.</span> </p>
<p><span data-start="371.309" data-end="378.02">While your application is being built, NativeScript runs a special tool called the metadata generator</span> <span data-start="378.02" data-end="383.15">which traverses that native library and gets information about the APIs.</span> <span data-start="383.15" data-end="388.71">It gets information about all the global packages, about every single class, about how these</span> <span data-start="388.71" data-end="394.889">classes can be instantiated, about every method in these classes and what are the meta signatures.</span> <span data-start="394.889" data-end="404.419">Basically, it gets information how every single method and API can be used.</span> <span data-start="404.419" data-end="410.25">That is saved inside a compact runtime binary which is, again, shipped inside the application.</span> <span data-start="410.25" data-end="419.249">So, we have information about how we can create stuff in Java inside the metadata.</span> <span data-start="419.249" data-end="425.229">And the metadata of course is shipped together with the whole application as well?</span> </p>
<p><span data-start="425.229" data-end="426.879">And what happens at launch time?</span> <span data-start="426.879" data-end="430.529">We initialize V8 which can execute the JavaScript code.</span> <span data-start="430.529" data-end="435.659">We load the metadata from the files saved inside the application and we attach source</span> <span data-start="435.659" data-end="438.449">and callbacks.</span> <span data-start="438.449" data-end="443.839">And the callbacks are the most important part about embedding V8.</span> </p>
<p><span data-start="443.839" data-end="451.25">They are our way to plug into the JavaScript code and do all sorts of stuff.</span> <span data-start="451.25" data-end="455.729">Let's start by explaining some stuff about these callbacks and how they actually work</span> <span data-start="455.729" data-end="462.289">together with the metadata to provide access with the native APIs.</span> <span data-start="462.289" data-end="466.27">Okay, we have this expression, Android media recorder.</span> <span data-start="466.27" data-end="470.669">We are trying to execute that JavaScript code.</span> <span data-start="470.669" data-end="476.439">The NativeScript runtime has read the metadata and found out that there is an Android global</span> <span data-start="476.439" data-end="478.129">package.</span> <span data-start="478.129" data-end="485.8">That's why it has created a global object inside the running V8 instance for Android.</span> <span data-start="485.8" data-end="489.509">It also has attached some callbacks to that object.</span> <span data-start="489.509" data-end="496.129">Like the package getter callback so that when we query for Android.media, the NativeScript</span> <span data-start="496.129" data-end="498.43">runtime plugs in with that callback.</span> <span data-start="498.43" data-end="500.369">The callback will be executed.</span> <span data-start="500.369" data-end="505.409">And inside the callback the NativeScript runtime will try to find Android.media inside the</span> <span data-start="505.409" data-end="507.339">metadata.</span> </p>
<p><span data-start="507.339" data-end="512.96">It returns something, some information, for example, some information that Android.media</span> <span data-start="512.96" data-end="515.19">has some media recorder.</span> <span data-start="515.19" data-end="518.08">And it also has a package getter callback attached.</span> <span data-start="518.08" data-end="523.83">So, when that callback is called, we find the media recorder inside the Android media</span> <span data-start="523.83" data-end="526.53">package in the metadata.</span> <span data-start="526.53" data-end="532.85">And this time we return a constructer function because this is actually a class.</span> <span data-start="532.85" data-end="534.98">And why is this constructer function so important?</span> <span data-start="534.98" data-end="540.88">Well, because when it's invoked with new, it actually contains a constructer callback.</span> </p>
<p><span data-start="540.88" data-end="544.95">Again, attached by the NativeScript runtime.</span> <span data-start="544.95" data-end="547.1">And this is where the actual magic happens.</span> <span data-start="547.1" data-end="552.86">Because the NativeScript runtime creates a native Java object.</span> <span data-start="552.86" data-end="554.92">But how does that happen?</span> <span data-start="554.92" data-end="563.45">Well, we use JNA, Java native interface, and this is a bridge between V8 and the running</span> <span data-start="563.45" data-end="564.93">Android runtime.</span> <span data-start="564.93" data-end="569.94">So, we can save functions back and forth between the two.</span> <span data-start="569.94" data-end="574.4">So, we create a native object.</span> <span data-start="574.4" data-end="578.59">Then we create the JavaScript proxy object that we're going to discuss a bit later and</span> <span data-start="578.59" data-end="583.59">we return the proxy object to the JavaScript world.</span> </p>
<p><span data-start="583.59" data-end="589.58">If it's right to access something inside that proxy, well, actually this proxy object is</span> <span data-start="589.58" data-end="591.25">not very simple.</span> <span data-start="591.25" data-end="594.14">It's not a plain object.</span> <span data-start="594.14" data-end="596.2">It creates some callbacks.</span> <span data-start="596.2" data-end="597.69">Contains some callbacks as well.</span> <span data-start="597.69" data-end="603.181">So, when we try to access this random field, we know that this field exists in the Java</span> <span data-start="603.181" data-end="607.81">world so that we have attached a field getter callback.</span> </p>
<p><span data-start="607.81" data-end="612.99">And the field getter callback actually queries the original Java object.</span> <span data-start="612.99" data-end="614.61">But there is a slight complication here.</span> <span data-start="614.61" data-end="617.89">Okay, we can get the result from the Java world.</span> <span data-start="617.89" data-end="622.26">But the data type is different from the JavaScript data type, right?</span> <span data-start="622.26" data-end="627.89">So, Java run string is not something we can assign to a JavaScript variable.</span> <span data-start="627.89" data-end="631.84">And that is why there is a marshaling service.</span> <span data-start="631.84" data-end="636.14">To convert it from Java so to JavaScript and vice versa.</span> <span data-start="636.14" data-end="642.82">At this point, you would say, wouldn't that be terribly slow to convert everything?</span> <span data-start="642.82" data-end="648.8">Obviously, it will be, if it's to convert object, it's not a good idea.</span> <span data-start="648.8" data-end="652.2">This is another reason why proxies are quite useful.</span> <span data-start="652.2" data-end="658.84">So, for objects, we just create a plain JavaScript object which has the same methods with the</span> <span data-start="658.84" data-end="661.49">same signatures.</span> <span data-start="661.49" data-end="666.01">And the same members as well.</span> </p>
<p><span data-start="666.01" data-end="668.2">And inside that we have callbacks.</span> <span data-start="668.2" data-end="673.18">So, that when you call some method with the same name on the JavaScript object, the callback</span> <span data-start="673.18" data-end="681.35">will be called and the NativeScript runtime will call the original Java method for JNA.</span> <span data-start="681.35" data-end="683.87">And this is a very cheap operation.</span> <span data-start="683.87" data-end="685.75">Creating new JavaScript objects.</span> <span data-start="685.75" data-end="689.46">Instead of converting data.</span> <span data-start="689.46" data-end="691.85">If you call a method, same story.</span> <span data-start="691.85" data-end="694.81">A method callback is triggered.</span> <span data-start="694.81" data-end="697.47">We call the original Java method.</span> <span data-start="697.47" data-end="702.09">The result is marshallized again and returned back to the JavaScript world.</span> <span data-start="702.09" data-end="708.24">If we have arguments in that method, the arguments will be converted to Java data format.</span> <span data-start="708.24" data-end="713.75">And then they will be\h the Java method will be called with deconverted arguments.</span> <span data-start="713.75" data-end="715.29">Okay.</span> <span data-start="715.29" data-end="723.02">Let's see just a quick overview of all these callbacks, if they are confused you so far.</span> <span data-start="723.02" data-end="728.45">We try to instantiate new object and assign that to a JavaScript variable.</span> </p>
<p><span data-start="728.45" data-end="729.95">We call the constructer callback.</span> <span data-start="729.95" data-end="737.2">If you want to create a new instance of the class through JNA.</span> <span data-start="737.2" data-end="739.19">The instance is returned.</span> <span data-start="739.19" data-end="745.54">And because it's an object, the NativeScript runtime creates a JavaScript proxy object.</span> <span data-start="745.54" data-end="749.35">Then we try to call some methods on that proxy.</span> <span data-start="749.35" data-end="753.15">We call actually the method callback without knowing that we are calling it.</span> <span data-start="753.15" data-end="754.15">Everything is hidden.</span> <span data-start="754.15" data-end="755.51">It happens behind the scenes.</span> <span data-start="755.51" data-end="760.43">But the method callback then calls the original Java method.</span> <span data-start="760.43" data-end="766.06">The result that we can get is returned through JNA and marshallized and returned back to</span> <span data-start="766.06" data-end="768.68">the JavaScript world.</span> <span data-start="768.68" data-end="773.07">That's all the communication magic that happens.</span> <span data-start="773.07" data-end="777.77">What you may be wondering at this point what happens with these objects.</span> <span data-start="777.77" data-end="779.69">Like we create JavaScript objects.</span> <span data-start="779.69" data-end="781.46">We also create Java objects.</span> <span data-start="781.46" data-end="783.02">They are collected in some way.</span> </p>
<p><span data-start="783.02" data-end="788.02">So, we actually have to take care of their life cycle.</span> <span data-start="788.02" data-end="792.71">And in JavaScript we don't have to manually manage the memory.</span> <span data-start="792.71" data-end="795.11">There is a garbage collector that runs.</span> <span data-start="795.11" data-end="800.82">And it's always to retrieve the memory of the unused objects.</span> <span data-start="800.82" data-end="803.48">It also has a nondeterministic nature.</span> <span data-start="803.48" data-end="807.75">We can't be sure when the garbage collector will run.</span> <span data-start="807.75" data-end="812.28">And the other kind of complication is that, well, the Android runtime also has a garbage</span> <span data-start="812.28" data-end="814.7">collector.</span> <span data-start="814.7" data-end="815.7">It's pretty funny.</span> <span data-start="815.7" data-end="816.7">So, we have two garbage collectors running.</span> <span data-start="816.7" data-end="818.97">We have objects in both worlds.</span> </p>
<p><span data-start="818.97" data-end="822.64">And that's one of the biggest challenges of the NativeScript runtime.</span> <span data-start="822.64" data-end="827.47">We have to kind of try to synchronize that.</span> <span data-start="827.47" data-end="834.29">We have to ensure that no object is collected if there is a living counterpart.</span> <span data-start="834.29" data-end="840.37">For example, if you create some Java object through JavaScript, and then try to access</span> <span data-start="840.37" data-end="845.94">it, if the Android garbage collector collected the native Java object, that sounds really</span> <span data-start="845.94" data-end="850.48">cool because you will try to access something is that doesn't exist, and the application</span> <span data-start="850.48" data-end="852.23">will crash.</span> </p>
<p><span data-start="852.23" data-end="855.15">Like, it will crash.</span> <span data-start="855.15" data-end="856.15">Yeah.</span> <span data-start="856.15" data-end="862.31">You're running a mobile application and it's not really cool user experience.</span> <span data-start="862.31" data-end="863.72">Okay.</span> <span data-start="863.72" data-end="871.39">In order to plugin into the life cycle, we use finalizer callbacks so that when the garbage</span> <span data-start="871.39" data-end="876.98">collector of V8 marks something that\h for collecting, says that some object doesn't</span> <span data-start="876.98" data-end="883.11">have living instances anywhere and it should be collected, the finalize of the callback</span> <span data-start="883.11" data-end="884.24">will be called.</span> <span data-start="884.24" data-end="890.5">And this is the place where the script runtime is plugged into.</span> <span data-start="890.5" data-end="892.42">We have strong and weak references.</span> <span data-start="892.42" data-end="894.88">Let's see how these actually look like.</span> <span data-start="894.88" data-end="898.06">We have the same example as before.</span> </p>
<p><span data-start="898.06" data-end="902.11">First, we create the native object.</span> <span data-start="902.11" data-end="905.37">Then we create the JavaScript proxy.</span> <span data-start="905.37" data-end="907.96">And then the NativeScript runtime has two collections.</span> <span data-start="907.96" data-end="912.89">One for strong references and one for weak references.</span> <span data-start="912.89" data-end="918.73">When the objects are first created, we create a strong reference or a link, if you would</span> <span data-start="918.73" data-end="922.84">like to call that, between the two objects.</span> <span data-start="922.84" data-end="927.75">And if that's confusing, okay, the proxy lives inside V8.</span> <span data-start="927.75" data-end="933.61">The original object lives inside the Android runtime and the references live inside the</span> <span data-start="933.61" data-end="934.79">NativeScript runtime.</span> </p>
<p><span data-start="934.79" data-end="936.43">All right.</span> <span data-start="936.43" data-end="938.46">Time to collect stuff.</span> <span data-start="938.46" data-end="940.07">Some garbage collector runs.</span> <span data-start="940.07" data-end="945.17">We can't really say for sure if it's gonna be the V8 garbage collector or the Android</span> <span data-start="945.17" data-end="946.17">runtime garbage collector.</span> <span data-start="946.17" data-end="951.93">But say in this example that V8 will decide to collect the memory first.</span> <span data-start="951.93" data-end="958.77">So, there is no one in the JavaScript world using the JavaScript proxy recorder.</span> <span data-start="958.77" data-end="960.62">And that's why it's marked for collection.</span> <span data-start="960.62" data-end="964.61">But at this point the finalizer callback is called.</span> </p>
<p><span data-start="964.61" data-end="969.529">And the NativeScript runtime sees that there is a living strong reference.</span> <span data-start="969.529" data-end="973.3">That's why the strong reference is turned into a weak reference.</span> <span data-start="973.3" data-end="978.92">And we instruct V8 not to collect that object.</span> <span data-start="978.92" data-end="984.59">The next time when the Android garbage collector runs, it decides to mark the recorder object</span> <span data-start="984.59" data-end="988.05">for collection because no one in the Java world is using it.</span> <span data-start="988.05" data-end="990.91">And sees there's a weak reference.</span> <span data-start="990.91" data-end="995.63">And because it's a weak reference, this object will be collected.</span> <span data-start="995.63" data-end="1002.73">So, let's say that at some time the V8 garbage collector runs again.</span> <span data-start="1002.73" data-end="1005.67">Well, now there is a weak reference.</span> <span data-start="1005.67" data-end="1008.62">And the weak reference doesn't point to anything.</span> <span data-start="1008.62" data-end="1013.87">And because we don't have anything out there in the Java world, this object can also be</span> <span data-start="1013.87" data-end="1014.87">collected.</span> </p>
<p><span data-start="1014.87" data-end="1018.13">It's marked for collection and now we can collect it.</span> <span data-start="1018.13" data-end="1025.399">But if we had two consecutive garbage collector collection runs inside V8 and we still had</span> <span data-start="1025.399" data-end="1031.159">a weak reference to a living object that wasn't created by the Java garbage collector, the</span> <span data-start="1031.159" data-end="1035.539">V8 object wouldn't have been collected as well.</span> <span data-start="1035.539" data-end="1039.97">So, this is a normal cycle.</span> <span data-start="1039.97" data-end="1047.369">And as you could imagine, there are some challenges that happen because we have two running garbage</span> <span data-start="1047.369" data-end="1048.529">collectors.</span> <span data-start="1048.529" data-end="1052.419">Well, we could get out of memory exceptions.</span> <span data-start="1052.419" data-end="1056.7">Usually the objects that were created in the Android application are not really big.</span> <span data-start="1056.7" data-end="1063.23">So, we wouldn't have that happening for a hello world application, right?</span> <span data-start="1063.23" data-end="1069.149">But the problem is that, of course, yeah, we have a few garbage collection cycles that</span> <span data-start="1069.149" data-end="1073.77">should be run in order for some memory to be retrieved back.</span> <span data-start="1073.77" data-end="1078.28">And if we create some big objects, this can cause problems.</span> <span data-start="1078.28" data-end="1082.679">Because the memory is not retrieved on time.</span> <span data-start="1082.679" data-end="1086.98">For example, we can have images.</span> </p>
<p><span data-start="1086.98" data-end="1092.669">And an image\h let's say that this Java array in the Java world.</span> <span data-start="1092.669" data-end="1094.789">The Java array is quite big.</span> <span data-start="1094.789" data-end="1096.94">Whereas the JavaScript proxy is not so big.</span> <span data-start="1096.94" data-end="1100.69">It's actually just a plain object with some callbacks attached.</span> <span data-start="1100.69" data-end="1104.69">So, it actually looks like that, memorywise.</span> <span data-start="1104.69" data-end="1107.419">We have a lot of memory in the Java world.</span> <span data-start="1107.419" data-end="1110.83">We have a really plain JavaScript proxy.</span> <span data-start="1110.83" data-end="1116.669">And the Java\h the Android garbage collector is actually dependent on the V8 garbage collector</span> <span data-start="1116.669" data-end="1121.95">in order to retrieve this huge chunk of memory.</span> <span data-start="1121.95" data-end="1129.309">So, at this point the V8 garbage collector, even if you have tens of thousands of these</span> <span data-start="1129.309" data-end="1133.82">small, plain proxies, it doesn't have pressure to be run.</span> <span data-start="1133.82" data-end="1140.509">Because we don't really take a lot of memory in the running JavaScript virtual machine.</span> <span data-start="1140.509" data-end="1144.49">So, V8 doesn't really have a reason to trigger garbage collection.</span> <span data-start="1144.49" data-end="1152.13">If that doesn't happen on time, well, we may cause out of memory exceptions.</span> </p>
<p><span data-start="1152.13" data-end="1158.049">Because we're taking too much space in the Java virtual machine.</span> <span data-start="1158.049" data-end="1162.2">Some solutions or more like strategies to overcome this.</span> <span data-start="1162.2" data-end="1165.96">Because there is no straightforward deterministic solution.</span> <span data-start="1165.96" data-end="1167.62">Because of the nature of the problem.</span> <span data-start="1167.62" data-end="1178.799">The first one, there is an API provided by V8 that lets us instruct V8 about the memory</span> <span data-start="1178.799" data-end="1181.32">that is allocated inside of it.</span> <span data-start="1181.32" data-end="1187.21">So, in our case we can say to V8, okay, the Android application that is running actually</span> <span data-start="1187.21" data-end="1189.1">uses this amount of memory.</span> <span data-start="1189.1" data-end="1193.039">And this memory is used because you have created some JavaScript objects.</span> <span data-start="1193.039" data-end="1198.07">And the JavaScript objects are still pointing to living instances in the Java world.</span> </p>
<p><span data-start="1198.07" data-end="1203.97">So, this should hint V8 to garbage collection more often because it's aware that there is</span> <span data-start="1203.97" data-end="1205.309">more memory freed.</span> <span data-start="1205.309" data-end="1214.499">I mean, it works in practice, but we can still get out of memory exceptions.</span> <span data-start="1214.499" data-end="1218.47">Another important thing, we are doing this internally inside of a NativeScript runtime</span> <span data-start="1218.47" data-end="1222.429">so the NativeScript developers don't have to use that.</span> <span data-start="1222.429" data-end="1226.299">And it is a technique used internally.</span> <span data-start="1226.299" data-end="1228.47">Another solution.</span> <span data-start="1228.47" data-end="1230.369">We can force garbage collection, of course.</span> <span data-start="1230.369" data-end="1234.429">We can say, V8, come on, run garbage collection.</span> <span data-start="1234.429" data-end="1237.809">Mark these objects as free to be retrieved.</span> <span data-start="1237.809" data-end="1240.09">Make these strong references weak.</span> </p>
<p><span data-start="1240.09" data-end="1243.149">Then we can run the Android garbage collector.</span> <span data-start="1243.149" data-end="1246.169">And then run the V8 garbage collector again.</span> <span data-start="1246.169" data-end="1250.429">This is not the best thing ever because it doesn't guarantee that the garbage collection</span> <span data-start="1250.429" data-end="1251.429">will be run.</span> <span data-start="1251.429" data-end="1254.809">It kind of schedules it or hints it that it will be run.</span> </p>
<p><span data-start="1254.809" data-end="1257.36">But we don't have a guarantee that it will be run.</span> <span data-start="1257.36" data-end="1261.21">And you don't have a guarantee that it will be run in that order as well.</span> <span data-start="1261.21" data-end="1265.08">And it's not the cheapest option out there.</span> <span data-start="1265.08" data-end="1269.9">You are checking the objects and seeing if they have living references.</span> <span data-start="1269.9" data-end="1272.58">It may have the opposite effect.</span> <span data-start="1272.58" data-end="1277.419">So, this is not the best solution ever.</span> </p>
<p><span data-start="1277.419" data-end="1278.419">You can do it.</span> <span data-start="1278.419" data-end="1284.08">It is some strategy, but we don't really recommend using that.</span> <span data-start="1284.08" data-end="1286.11">Okay.</span> <span data-start="1286.11" data-end="1287.86">Let's take a look at this again.</span> <span data-start="1287.86" data-end="1289.14">We have a strong reference.</span> <span data-start="1289.14" data-end="1291.899">What didn't have references?</span> <span data-start="1291.899" data-end="1299.07">And what if we had the control over things like this Java object can't be collected because</span> <span data-start="1299.07" data-end="1300.259">I'm not using it anymore, it can be collected.</span> <span data-start="1300.259" data-end="1303.129">I'm not using it in the JavaScript world.</span> <span data-start="1303.129" data-end="1310.47">Well, the NativeScript runtime releases a function, release native counterpart and we</span> <span data-start="1310.47" data-end="1316.84">need to run the object, and it basically destroys all these references.</span> </p>
<p><span data-start="1316.84" data-end="1319.169">So, we invoke that.</span> <span data-start="1319.169" data-end="1325.29">We basically instruct that we're no longer using this native object and it can be retrieved.</span> <span data-start="1325.29" data-end="1332.529">So, whenever the next Android garbage collector runs, it is no longer dependent on V8's garbage</span> <span data-start="1332.529" data-end="1333.539">collector.</span> <span data-start="1333.539" data-end="1339.809">It can mark this object and say retrieve it.</span> <span data-start="1339.809" data-end="1345.61">And as the last part of the presentation, something like a bit simpler.</span> <span data-start="1345.61" data-end="1348.289">What is the point?</span> <span data-start="1348.289" data-end="1353.429">Well, the JavaScript code in NativeScript is run and executed from a single thread.</span> </p>
<p><span data-start="1353.429" data-end="1357.33">Which actually happens to be the main user interface thread.</span> <span data-start="1357.33" data-end="1362.84">And if you see where I'm going, this can cause some problems with log and junk.</span> <span data-start="1362.84" data-end="1369.769">So, you can see some glitches while your mobile application is being used.</span> <span data-start="1369.769" data-end="1373.71">And this is not the best experience for a native mobile application as well.</span> <span data-start="1373.71" data-end="1378.049">So, first you know what is junk, probably.</span> <span data-start="1378.049" data-end="1384.77">It is the percentage of frames that are dropped while you are doing some calculations.</span> <span data-start="1384.77" data-end="1387.429">We're not gonna focus on that.</span> <span data-start="1387.429" data-end="1390.649">It's important to know that in the NativeScript application, if you are just building user</span> <span data-start="1390.649" data-end="1395.309">interface, you are creating native Android and iOS widgets.</span> </p>
<p><span data-start="1395.309" data-end="1400.869">So, you shouldn't experience junk in a native list view when scrolling, for example.</span> <span data-start="1400.869" data-end="1404.769">If you are creating animations, same thing.</span> <span data-start="1404.769" data-end="1409.85">You have many ways of creating in NativeScript, with Angular, CSS, with JavaScript.</span> <span data-start="1409.85" data-end="1414.76">But internally it's actually creating native applications.</span> <span data-start="1414.76" data-end="1419.039">So, you shouldn't have any problem while running animations.</span> <span data-start="1419.039" data-end="1424.639">The other thing that is commonly\h we're commonly asked for.</span> <span data-start="1424.639" data-end="1430.359">If you're creating an HTTP request, the plugin that you're gonna use creates a background</span> <span data-start="1430.359" data-end="1436.009">thread in the Java world which wouldn't freeze the main UI thread.</span> <span data-start="1436.009" data-end="1441.16">But you may see some junk when you're executing CPUintensive operations.</span> <span data-start="1441.16" data-end="1445.179">And the same thing would happen if you are executing CPUintensive Java code in an Android</span> <span data-start="1445.179" data-end="1447.36">application.</span> <span data-start="1447.36" data-end="1448.36">What is the solution?</span> </p>
<p><span data-start="1448.36" data-end="1449.409">Well, worker threads.</span> <span data-start="1449.409" data-end="1458.679">Essentially background threads to unlock the main thread.</span> <span data-start="1458.679" data-end="1462.909">We don't have JavaScript memory sharing, but we have a way to communicate between the worker</span> <span data-start="1462.909" data-end="1465.789">thread and the main UI thread.</span> <span data-start="1465.789" data-end="1467.879">And the final thing, I'm going to ask you a question.</span> </p>
<p><span data-start="1467.879" data-end="1470.309">You have to be patient for 30 more seconds.</span> <span data-start="1470.309" data-end="1474.45">What is a worker thread in NativeScript?</span> <span data-start="1474.45" data-end="1477.409">Two hints.</span> <span data-start="1477.409" data-end="1479.179">Is it an isolate?</span> <span data-start="1479.179" data-end="1484.659">Isolate is V8's way to isolate and executes some memory\h sorry\h to isolate some memory</span> <span data-start="1484.659" data-end="1487.359">for a code that's being executed.</span> </p>
<p><span data-start="1487.359" data-end="1492.32">They can run in parallel and we don't have memory sharing.</span> <span data-start="1492.32" data-end="1493.529">Context.</span> <span data-start="1493.529" data-end="1498.139">One isolate can have multiple contexts.</span> <span data-start="1498.139" data-end="1502.139">We don't have member isolation and we can't run contexts in parallel.</span> <span data-start="1502.139" data-end="1508.489">Also, you have to explicitly specify the context that some code is being executed on.</span> <span data-start="1508.489" data-end="1510.25">Isolates or context?</span> <span data-start="1510.25" data-end="1511.299">Isolates.</span> <span data-start="1511.299" data-end="1512.35">Contexts.</span> <span data-start="1512.35" data-end="1513.4">Okay.</span> <span data-start="1513.4" data-end="1515.5">That's okay.</span> <span data-start="1515.5" data-end="1516.559">Isolates.</span> </p>
<p><span data-start="1516.559" data-end="1517.61">Okay.</span> <span data-start="1517.61" data-end="1519.71">So, isolate.</span> <span data-start="1519.71" data-end="1521.809">All right.</span> <span data-start="1521.809" data-end="1525.19">So, this was about NativeScript and V8.</span> </p>
<p><span data-start="1525.19" data-end="1531.83">If you want to meet me afterwards, you can find me in Twitter, and I'll be coming to</span> <span data-start="1531.83" data-end="1532.83">you.</span> <span data-start="1532.83" data-end="1537.25">And I also want to thank my colleague who helped me with this presentation.</span> <span data-start="1537.25" data-end="1540.45">And this is his handle on Twitter as well.</span> <span data-start="1540.45" data-end="1547.409">So, thanks a lot.</span> </p>
</section>