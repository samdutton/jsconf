<section>
<p><span data-start="3.11" data-end="11.44">Jason Miller — Preact — Into the void 0 >> I was really hoping for the music to keep</span> </p>
</section>

<section>
<p><span data-start="46.12" data-end="47.12"><span class="speaker">Jason</span>: Hi, everybody.</span> <span data-start="47.12" data-end="48.12">I'm Jason, as was advertised before when the slides came up.</span> <span data-start="48.12" data-end="49.12">I'm a developer.</span> <span data-start="49.12" data-end="53.44">I'm a serial library author, as some of you may know — that's self-diagnosed.</span> <span data-start="53.44" data-end="57.98">I like donuts and poutine and axes which means I'm Canadian.</span> <span data-start="57.98" data-end="60.92">I like constraints.</span> <span data-start="60.92" data-end="65.13">I've been developing for the mobile web before the mobile web was something anybody would</span> <span data-start="65.13" data-end="67.93">wilfully use.</span> <span data-start="67.93" data-end="71.56">I've written a bunch of UI frameworks.</span> </p>
<p><span data-start="71.56" data-end="76.56">It is a serious problem I've developed that I'm trying to work around, and the reason</span> <span data-start="76.56" data-end="80.39">why is I find constraints to be interesting challenges.</span> <span data-start="80.39" data-end="86.15">I have something called ADHD — you're probably familiar with that — it basically means that,</span> <span data-start="86.15" data-end="91.12">in order to do something effectively, it is best if I can hyperfocus on it and the interesting</span> <span data-start="91.12" data-end="96.689">constraint challenges provide me a situation where it is true.</span> <span data-start="96.689" data-end="103.33">I wrote Preact and called into the void zero.</span> <span data-start="103.33" data-end="109.36">That's the only semicolon you will see in these slides!</span> <span data-start="109.36" data-end="111.09">You might be wondering what is Preact.</span> <span data-start="111.09" data-end="113.78">This is it in its entirety.</span> <span data-start="113.78" data-end="116.57">I did remove the source map comment.</span> <span data-start="116.57" data-end="122.799">Today we're going to be to touch that on and that.</span> <span data-start="122.799" data-end="123.84">Mostly the second one.</span> </p>
<p><span data-start="123.84" data-end="129.19">We can't even talk about them before we even talk about this stuff up here, and this is</span> <span data-start="129.19" data-end="134.91">a Preact presentation, so naturally, we need something in purple, so, whatever that is,</span> <span data-start="134.91" data-end="137.54">that will be the last thing we touch on.</span> <span data-start="137.54" data-end="141.64">Before we did get to any of this, we need to talk about jsx.</span> <span data-start="141.64" data-end="146.84">If you're not familiar with it, I don't know what ruck you've been living under.</span> <span data-start="146.84" data-end="149.95">Don't worry, it is really, really easy to understand.</span> <span data-start="149.95" data-end="153.33">Jsx is simple at its core.</span> <span data-start="153.33" data-end="158.66">By the end of my talk, you will be starting to rewrite your webpack configuration in jsx</span> <span data-start="158.66" data-end="164.15">which makes is it longer and complex which is a good thing.</span> </p>
<p><span data-start="164.15" data-end="171.86">If you don't believe me, go and look at the webpack 2docs and that is in them.</span> <span data-start="171.86" data-end="172.86">What is JSX?</span> <span data-start="172.86" data-end="178.81">It's an XML-like expression compiled to a function call.</span> <span data-start="178.81" data-end="185.379">We write the thing that you see on the left — we write in these HTML-looking angle-bracket</span> <span data-start="185.379" data-end="190.93">syntaxes and on the right is what we get out of the transpiler like Babel or Bubl� — there</span> <span data-start="190.93" data-end="193.22">are ten transpilers now.</span> <span data-start="193.22" data-end="201.15">The whole point to me of JSX is I would be happy writing the thing on the right.</span> <span data-start="201.15" data-end="206.38">This is verified by the fact that I'm constantly Tweeted at by people who much prefer the thing</span> <span data-start="206.38" data-end="207.38">on the right.</span> <span data-start="207.38" data-end="208.769">I think telling.</span> </p>
<p><span data-start="208.769" data-end="212.91">I like JSX because I like parity with the DOM.</span> <span data-start="212.91" data-end="215.83">The thing on the right is something people are happy to write.</span> <span data-start="215.83" data-end="222.55">It is important this is a transparent thing sitting in front of an understandable thing.</span> <span data-start="222.55" data-end="227.65">There is one little complexity on top of this from JSX and it is you can get back into JavaScript</span> <span data-start="227.65" data-end="230.05">from these angle-bracket syntaxes.</span> <span data-start="230.05" data-end="238.33">You can see on the left one and the variable "world" are on the right.</span> <span data-start="238.33" data-end="245.769">If you use the capital letter as the first letter of a tag name, resulted in a generating</span> <span data-start="245.769" data-end="247.29">code.</span> <span data-start="247.29" data-end="252.31">So, the essence of JSX is this factory function we saw.</span> </p>
<p><span data-start="252.31" data-end="253.73">It is really simple.</span> <span data-start="253.73" data-end="261.459">It just has a signature that accepts the things that you .. tag name, the same thing, which</span> <span data-start="261.459" data-end="262.699">will be a string or function.</span> <span data-start="262.699" data-end="263.699">Really, it could be anything.</span> <span data-start="263.699" data-end="264.839">It's going to be one of these two.</span> <span data-start="264.839" data-end="268.379">You have attributes which could be optional, an object, and the rest of the arguments are</span> <span data-start="268.379" data-end="271.96">children, and this is how we do composition.</span> <span data-start="271.96" data-end="276.159">You might be thinking to yourself, aren't you just writing hyperscript, right?</span> </p>
<p><span data-start="276.159" data-end="278.8">Isn't really what this is under the hood?</span> <span data-start="278.8" data-end="281.05">You wouldn't be wrong.</span> <span data-start="281.05" data-end="288.089">Hyperscript is very similar in, in some cases, it is a slight super set of JSX because of</span> <span data-start="288.089" data-end="290.819">this.</span> <span data-start="290.819" data-end="293.55">This!</span> <span data-start="293.55" data-end="298.639">So hyperscript supports this additional tag syntax where you can use essentially CSS selectors</span> <span data-start="298.639" data-end="304.43">to predefined attributes on the element and JSX does not have that.</span> <span data-start="304.43" data-end="313.4">So, what JSX does have is the ability to use these sort of extended tag names, so, it is</span> <span data-start="313.4" data-end="318.84">important that we have a solid understanding of JSX because the concept is simple and direct,</span> <span data-start="318.84" data-end="323.849">but it is the interface through which we access all of these virtual DOM libraries.</span> </p>
<p><span data-start="323.849" data-end="330.27">Please remember that JSX is not DOM, not related to DOM, it is just a syntax.</span> <span data-start="330.27" data-end="333.379">It doesn't know anything about your code or how it is intended to work.</span> <span data-start="333.379" data-end="335.379">You can use this to write your webpack configuration.</span> <span data-start="335.379" data-end="336.889">Please don't.</span> <span data-start="336.889" data-end="341.499">You could use it to write XML, so if you want to write a soap client and you want to use</span> <span data-start="341.499" data-end="344.389">parsing and serialisation, you could use JSX for that.</span> <span data-start="344.389" data-end="348.28">I would recommend that as an interesting solution to a problem.</span> <span data-start="348.28" data-end="349.879">That's JSX on the way.</span> <span data-start="349.879" data-end="353.649">The next step in our adventure is virtual DOM.</span> <span data-start="353.649" data-end="358.629">Virtual DOM are objects that represent a tree structure.</span> <span data-start="358.629" data-end="359.629">That's it.</span> <span data-start="359.629" data-end="360.629">There's nothing else going on.</span> <span data-start="360.629" data-end="365.939">I like to think of it as configuration that you're passing to a DOM builder of some kind</span> <span data-start="365.939" data-end="370.8">and we are going to walk through in making the DOM builder not so theoretical.</span> </p>
<p><span data-start="370.8" data-end="375.939">The first thing we need to understand how do we get from JSX to V-DOM.</span> <span data-start="375.939" data-end="382.919">It is fairly straightforward.</span> <span data-start="382.919" data-end="386.879">We know that we wrote our JSX, we got our H function calls.</span> <span data-start="386.879" data-end="392.58">We need to have an H define such that it produces these objects.</span> <span data-start="392.58" data-end="393.729">This is Virtual Dom.</span> <span data-start="393.729" data-end="396.979">Sometimes, it gets trumped up beyond this.</span> <span data-start="396.979" data-end="398.8">This is what is it looks like.</span> <span data-start="398.8" data-end="401.729">It's just nested objects.</span> <span data-start="401.729" data-end="404.099">This is surprisingly easy to do.</span> <span data-start="404.099" data-end="406.059">This is how you do it.</span> <span data-start="406.059" data-end="409.449">It is a one-line function.</span> <span data-start="409.449" data-end="414.83">You could normalise children, remove empty values, coalesce adjacent string nodes — lots</span> <span data-start="414.83" data-end="419.86">of stuff — but at its volunteer, you could write a virtual DOM renderer using this function.</span> </p>
<p><span data-start="419.86" data-end="424.569">Let's do that and write a virtual DOM renderer.</span> <span data-start="424.569" data-end="427.58">We will pass ourselves a V node.</span> <span data-start="427.58" data-end="433.059">This is the object we saw up there on the right of the scroll bar.</span> <span data-start="433.059" data-end="438.189">So the first thing is, we need to create a DOM element that matches the type of the V</span> <span data-start="438.189" data-end="444.899">DOM element so we can use that using "create element" pretty straightforward.</span> <span data-start="444.899" data-end="454.009">One ID equals foo and then set up recursion so we're going to loop over children, pass</span> <span data-start="454.009" data-end="458.469">them back to render and take the resulting DOM element and append it to our current DOM</span> <span data-start="458.469" data-end="459.469">element.</span> <span data-start="459.469" data-end="464.789">There is one slight complexity here you might have noticed: one of the children is a string.</span> <span data-start="464.789" data-end="467.089">One of these things is not like the other.</span> <span data-start="467.089" data-end="468.789">We need to deal with that hello text.</span> <span data-start="468.789" data-end="476.919">The way we do that, if it is a string, we bail out with a text note.</span> <span data-start="476.919" data-end="478.739">That's our virtual DOM renderer.</span> <span data-start="478.739" data-end="484.49">There is one slight complexity here in attributes — notice I've called them attributes.</span> <span data-start="484.49" data-end="490.509">If anyone has used React, you're probably getting hot under the collar about that.</span> <span data-start="490.509" data-end="491.509">They're not attributes.</span> </p>
<p><span data-start="491.509" data-end="493.8">Don't let anyone tell you that except me.</span> <span data-start="493.8" data-end="497.839">I don't know why I've chosen why I can get away with it — forth duration of the talk</span> <span data-start="497.839" data-end="499.129">I can!</span> <span data-start="499.129" data-end="507.59">They're props — they're an abstraction between these two things.</span> <span data-start="507.59" data-end="514.18">Most HTML elements can accept data as attributes, and they can also accept similar, often typed</span> <span data-start="514.18" data-end="518.539">data, as properties through something called DOM property reflection.</span> <span data-start="518.539" data-end="520.05">But both of these are technically wrong.</span> <span data-start="520.05" data-end="523.539">There are things we can do with attributes that we can't do with properties and things</span> <span data-start="523.539" data-end="526.17">we can't do with properties that we can do with attributes.</span> </p>
<p><span data-start="526.17" data-end="529.62">What we need is a way to have both.</span> <span data-start="529.62" data-end="536.48">Thinking about Preact, with you can't use whitelists.</span> <span data-start="536.48" data-end="542.99">Self-closing tag names, that's not a thing that Preact could never do.</span> <span data-start="542.99" data-end="548.691">Instead, we have a reference to a DOM node and we ask the DOM node, "Do you have a support</span> <span data-start="548.691" data-end="550.44">for a property foo"?</span> <span data-start="550.44" data-end="554.94">If it does, we use the property, if not, we fall back on the attribute.</span> <span data-start="554.94" data-end="564.509">It is good for custom elements, and we use those and move forward.</span> <span data-start="564.509" data-end="568.38">So the question you may be asking yourself is, "Does it work?"</span> <span data-start="568.38" data-end="572.079">Sorry, I have a really bad Sean Connery impression.</span> <span data-start="572.079" data-end="576.54">I promised someone I wouldn't do that and I had to do it in order to break the promise!</span> <span data-start="576.54" data-end="578.07">Here's the virtual DOM we wrote.</span> <span data-start="578.07" data-end="585.2">We will pass the through the render function we note.</span> <span data-start="585.2" data-end="592.199">Here is the output in JSFiddle and it works.</span> <span data-start="592.199" data-end="593.199">Deploy to production.</span> </p>
<p><span data-start="593.199" data-end="597.649">Be thankful you don't work with me!</span> <span data-start="597.649" data-end="599.85">We build a simple virtual DOM renderer.</span> <span data-start="599.85" data-end="608.67">It is a terrible virtual DOM renderer, it's a version 0, but it is terrible because it</span> <span data-start="608.67" data-end="610.1">doesn't diff.</span> <span data-start="610.1" data-end="615.199">It doesn't look at the current state of the DOM and update the DOM to reflect anything.</span> </p>
<p><span data-start="615.199" data-end="623.379">It just blows away the whole DOM and replaces it with something.</span> <span data-start="623.379" data-end="627.94">The debate is warranted because there are trade-offs here that you can't treat as black</span> <span data-start="627.94" data-end="635.959">and white things.</span> <span data-start="635.959" data-end="641.87">Diffing is basically this idea of instead of rendering top down and creating a new as</span> <span data-start="641.87" data-end="645.62">we rendered top down, we're going to pass ourselves a reference to what the DOM looks</span> <span data-start="645.62" data-end="653.94">like now and then mutate it to look like what this JSX-derived looks like, our virtual DOM,</span> <span data-start="653.94" data-end="655.46">just apply the differences.</span> <span data-start="655.46" data-end="662">On the left, you can see what the virtual DOM looks like.</span> <span data-start="662" data-end="664.399">On the right, you can see what the actual DOM looks like.</span> <span data-start="664.399" data-end="668.089">You can see that the nails are the name or similar.</span> </p>
<p><span data-start="668.089" data-end="671.81">There is actually a DOM children property, it just include text nodes so we don't use</span> <span data-start="671.81" data-end="672.92">that.</span> <span data-start="672.92" data-end="677.5">You can see how you can run through this and perform a comparison left to right and apply</span> <span data-start="677.5" data-end="679.519">the changes on the right.</span> </p>
<p><span data-start="679.519" data-end="684.49">So, it's basically a three-step process to run through the diff.</span> <span data-start="684.49" data-end="686.97">First step is type.</span> <span data-start="686.97" data-end="692.47">Before we can do anything, we need to create an element with the correct node name.</span> <span data-start="692.47" data-end="695.49">This is pretty straightforward, but that's kind of step one here.</span> <span data-start="695.49" data-end="699.69">The second step is we are going to loop over the children, perform a by-directional comparison</span> <span data-start="699.69" data-end="703.589">and figure out whether we need to add, remove children, rearrange them, et cetera.</span> <span data-start="703.589" data-end="711.899">The last step is to update the attribute/props with the new values from our virtual DOM tree.</span> <span data-start="711.899" data-end="714.16">We set up incursion by looping over the children.</span> <span data-start="714.16" data-end="716.12">Let's start with type.</span> <span data-start="716.12" data-end="719.31">We enter your our diff.</span> </p>
<p><span data-start="719.31" data-end="721.519">Is this node owned by a component?</span> <span data-start="721.519" data-end="724.62">If it is not owned by a component, things are really easy.</span> <span data-start="724.62" data-end="729.87">We look at the node type — in this case, node name — if it is the same, we will update it</span> <span data-start="729.87" data-end="733.509">in place and render it.</span> <span data-start="733.509" data-end="739.709">If it is different, we're going to throw out the node and create a new one and then continue</span> <span data-start="739.709" data-end="742.769">diffing down the tree, setting attributes and trees and so on.</span> <span data-start="742.769" data-end="748.17">If a node was owned by a component and things are a little bit more complex, basically we</span> <span data-start="748.17" data-end="750.86">needed to create a backing instance.</span> </p>
<p><span data-start="750.86" data-end="753.5">Create it if it doesn't exist and update it if it does.</span> <span data-start="753.5" data-end="761">Then things get easy, we call rending on that backing instance which we pass back into the</span> <span data-start="761" data-end="765.3">same diff function so it's not that complex.</span> <span data-start="765.3" data-end="770.949">There are intricacies here with life cycle, but as far as a chart on a slide goes, it</span> <span data-start="770.949" data-end="772.459">is pretty simple.</span> <span data-start="772.459" data-end="775.509">So, children is even easier than that.</span> <span data-start="775.509" data-end="777.49">It is basically three steps.</span> <span data-start="777.49" data-end="781.699">The first step is we loop all over the existing children in the DOM and put them in the lists.</span> <span data-start="781.699" data-end="786.16">There is an unkeyed list which is ordered and a keyed list which is named.</span> <span data-start="786.16" data-end="791.16">The second step is we move over the new virtual children which are these lightweight objects</span> <span data-start="791.16" data-end="798.509">or strings and we find the first match in our list of unkeyed or our map of keyed, and</span> <span data-start="798.509" data-end="809.379">we find that or null, an element, and diff that against our virtual DOM child objection.</span> </p>
<p><span data-start="809.379" data-end="818.2">We have a specification for that and we insert that in the current index we're at in the</span> <span data-start="818.2" data-end="820.22">virtual loop.</span> <span data-start="820.22" data-end="825.17">The last stuff is the easiest: if there are any kids left, we delete them because they're</span> <span data-start="825.17" data-end="829.05">not used in the updated definition of what the DOM should look like.</span> <span data-start="829.05" data-end="833.74">You might be wondering about the keyed versus unkeyed lists.</span> <span data-start="833.74" data-end="838.059">This is probably the worst understood of virtual DOMs.</span> </p>
<p><span data-start="838.059" data-end="846.199">I tried to explain this on Stack Overflow and butchered it.</span> <span data-start="846.199" data-end="853.68">Keys attribute meaningful order to virtual DOM elements when they have uniform type.</span> <span data-start="853.68" data-end="858.44">So we can see in in example, we have three list its — one, two, and three.</span> <span data-start="858.44" data-end="863.48">In the second render here, we only have two list items, and it is clear to you and I as</span> <span data-start="863.48" data-end="871.23">humans that we've deleted item 2, that the text 2 is gone so we know logically, we deleted</span> <span data-start="871.23" data-end="874.07">the second item and the third one has moved up.</span> </p>
<p><span data-start="874.07" data-end="877.41">A virtual DOM renderer does not know that.</span> <span data-start="877.41" data-end="881.699">There is nothing saying that item 2 is item 2 in the second render.</span> <span data-start="881.699" data-end="883.35">It receives a new tree each time.</span> <span data-start="883.35" data-end="886.26">There's no way for it to correlate these things.</span> <span data-start="886.26" data-end="889.949">So what it is going to do is going to look at one — one is unchanged.</span> <span data-start="889.949" data-end="890.949">That's easy.</span> </p>
<p><span data-start="890.949" data-end="891.949">Nothing happens.</span> <span data-start="891.949" data-end="896.559">It is going to look at 2 and it says, "Oh, no, they changed the context of 2 to 3.</span> <span data-start="896.559" data-end="899.05">That's fine, I will update that."</span> <span data-start="899.05" data-end="901.88">It gets to three and it's gone in the second render.</span> <span data-start="901.88" data-end="903.17">It will kill that node.</span> <span data-start="903.17" data-end="907.029">The thing to understand here is by default for a list of uniform elements in virtual</span> <span data-start="907.029" data-end="911.08">DOM it will always push off and pop at the end.</span> <span data-start="911.08" data-end="917.19">It has no concept of removing and adding to the middle of the child list.</span> <span data-start="917.19" data-end="920.819">Contrast this with a keyed approach.</span> <span data-start="920.819" data-end="926.509">In a keyed approach, we give each element a unique key — they do have to be unique.</span> <span data-start="926.509" data-end="928.13">In the first render, we've got one, two, and three.</span> <span data-start="928.13" data-end="930.04">In the second render, one and three.</span> </p>
<p><span data-start="930.04" data-end="933.76">It's obvious the element with key 2 has been removed.</span> <span data-start="933.76" data-end="941.85">Now we tell the DOM renderer what to do, so it knows when it loops over the list, it will</span> <span data-start="941.85" data-end="945.5">delete it and move to item 3 which will move up in its place.</span> <span data-start="945.5" data-end="948.069">It makes things really, really simple for the renderer.</span> <span data-start="948.069" data-end="949.069">It is kind of cheating.</span> <span data-start="949.069" data-end="952.66">You're essentially telling the diff to do its own job, but in the where you would like</span> <span data-start="952.66" data-end="956.329">to control the diff, it is nice to have the escape hatch.</span> <span data-start="956.329" data-end="961.339">The last step for the diff process is attributes.</span> <span data-start="961.339" data-end="963.259">This is really easy.</span> <span data-start="963.259" data-end="966.199">We give ourselves the old properties in the new properties.</span> <span data-start="966.199" data-end="970.509">We loop over the old ones, find the ones that are not in the new property bag and set them</span> <span data-start="970.509" data-end="973.85">to undefine in the DOM and then we do the exact opposite.</span> <span data-start="973.85" data-end="979.09">For each new attribute, we check if it is new values, check if it was defined and now</span> <span data-start="979.09" data-end="985.05">, it is going undefined to some value and then we set its value in the DOM to the</span> <span data-start="985.05" data-end="988.82">corresponding property.</span> </p>
<p><span data-start="988.82" data-end="995.161">So we solved all of life's problems and now our app is as fast as it could possibly, except</span> <span data-start="995.161" data-end="996.85">this is not the case.</span> <span data-start="996.85" data-end="1004.319">All we've done is move our problems into a library, in Preact, React, Inferno — the list</span> <span data-start="1004.319" data-end="1006.129">goes on.</span> <span data-start="1006.129" data-end="1009.639">I want to tell you guys a little bit about the performance journey I've been on in writing</span> <span data-start="1009.639" data-end="1015.45">Preact, trying to benchmark it and take it further than it currently is.</span> <span data-start="1015.45" data-end="1021.85">This is something you will often see people say, especially if you hang out on Twitter</span> <span data-start="1021.85" data-end="1023.439">for various reasons.</span> <span data-start="1023.439" data-end="1026.89">We often hear complaints the DOM is slow, the DOM is a source of slowness.</span> <span data-start="1026.89" data-end="1031.199">It is true that the DOM is not as fast an immediate-mode drawing API.</span> <span data-start="1031.199" data-end="1033.02">It is not designed to be.</span> </p>
<p><span data-start="1033.02" data-end="1035.48">They're different things.</span> <span data-start="1035.48" data-end="1040.27">But the DOM has all these different things that if we compare it an immediate-drawing</span> <span data-start="1040.27" data-end="1044.089">API we're not taking into account.</span> <span data-start="1044.089" data-end="1048.12">The first one is that the DOM offers accessibility bit in.</span> <span data-start="1048.12" data-end="1053.9">You can an know date the DOM and you're going to get screenreader support for basically</span> <span data-start="1053.9" data-end="1055.21">free.</span> </p>
<p><span data-start="1055.21" data-end="1058.57">Other platforms have ways of doing this, but the DOM's way of doing this is incredibly</span> <span data-start="1058.57" data-end="1059.57">easy.</span> <span data-start="1059.57" data-end="1066.71">You almost don't need to know how it works if you're writing semantic mark-up.</span> <span data-start="1066.71" data-end="1070.99">If I'm using Twitter on windows and I want to add emoji support to Twitter, I install</span> <span data-start="1070.99" data-end="1078.32">a browser extension and I can type in an emijo.</span> </p>
<p><span data-start="1078.32" data-end="1079.84">Twitter don't know about this.</span> <span data-start="1079.84" data-end="1081.18">They don't care about this.</span> <span data-start="1081.18" data-end="1089.77">This is one of the values of the DOM, this substrate that is extensible without our knowledge.</span> <span data-start="1089.77" data-end="1094.13">That's the same thing saying the DOM is framework agnostic.</span> <span data-start="1094.13" data-end="1098.6">You can write two widgets in two different frameworks, and as long as they're rendering</span> <span data-start="1098.6" data-end="1101.87">elements, you can append them to a common parent and they don't have to know or care</span> <span data-start="1101.87" data-end="1103.94">about each other.</span> <span data-start="1103.94" data-end="1113.809">Preact at its core is essentially a DOM renderer.</span> </p>
<p><span data-start="1113.809" data-end="1119.049">On him going to share a couple of lessons I've learned since writing a DOM library.</span> <span data-start="1119.049" data-end="1124.029">The first is use text nodes for text.</span> <span data-start="1124.029" data-end="1128.36">This sounds stupid, I'm aware of that!</span> <span data-start="1128.36" data-end="1133.4">It's surprising how often you will see this either miss construed or misinterpreted.</span> <span data-start="1133.4" data-end="1139.26">The DOM has an API for working with text that we often ignore.</span> <span data-start="1139.26" data-end="1144.89">You concede an initial value, insert these, move them around like any other elements.</span> <span data-start="1144.89" data-end="1148.23">They don't inherit from element, they inherit from node but and so that you can set its</span> <span data-start="1148.23" data-end="1150.669">text.</span> <span data-start="1150.669" data-end="1156.14">I don't remember.</span> <span data-start="1156.14" data-end="1161.169">So, this is a perch mark showing that that is the case.</span> <span data-start="1161.169" data-end="1166.44">We've got text content, and then text.node value just for an a-topic update.</span> </p>
<p><span data-start="1166.44" data-end="1168.7">No value is clearly faster here.</span> <span data-start="1168.7" data-end="1174.78">If you do a library that does text update, you would be crazy to use the first one.</span> <span data-start="1174.78" data-end="1183.17">It is not unjustified in its slowness, it is removing elements that don't belong there.</span> <span data-start="1183.17" data-end="1189.24">It does a lot of work but in a lot of cases, we're using text content in a situation where</span> <span data-start="1189.24" data-end="1191.53">we don't need any of that work.</span> <span data-start="1191.53" data-end="1199.14">So the next DOM lesson — I think that's an ArrowSmith joke — is just avoid getters entirely.</span> </p>
<p><span data-start="1199.14" data-end="1200.19">Don't use them.</span> <span data-start="1200.19" data-end="1205.14">Don't rely on them, or, when you are using them, be incredibly cognizant of the fact</span> <span data-start="1205.14" data-end="1208">that they are.</span> <span data-start="1208" data-end="1213.32">Here is a snippet from Chrome dev tools sake if we look at the node-type property of a</span> <span data-start="1213.32" data-end="1219.86">next node, it should be the integer three which is the corresponding type.</span> </p>
<p><span data-start="1219.86" data-end="1228.23">It's  on the text prototype which is counterintuitive.</span> <span data-start="1228.23" data-end="1233.13">This is a huge red flag that I have highlighted as a red flag.</span> <span data-start="1233.13" data-end="1236.63">The idea is everything is going to have this inheritance from node.</span> <span data-start="1236.63" data-end="1237.679">They implemented it in one place.</span> <span data-start="1237.679" data-end="1239.69">I'm sure there's some reason for this.</span> <span data-start="1239.69" data-end="1242.99">This is a red flag for anybody writing a DOM library.</span> <span data-start="1242.99" data-end="1249.149">This means that, when we write code that relies on node type, by drought, this is not going</span> <span data-start="1249.149" data-end="1250.86">to run as fast as it could.</span> <span data-start="1250.86" data-end="1255.28">Instead, we can use duck-typing to improve the performance of this.</span> <span data-start="1255.28" data-end="1259.17">They have split text.</span> </p>
<p><span data-start="1259.17" data-end="1261.529">Split text is much faster because it is not a getter.</span> <span data-start="1261.529" data-end="1264.08">All we're doing is checking the property exists.</span> <span data-start="1264.08" data-end="1267.2">I know Benedict would tell you this if I didn't.</span> <span data-start="1267.2" data-end="1270.899">You can check to see the if the property exists.</span> <span data-start="1270.899" data-end="1276.58">The problem with the second check is that it will check if it is existing and truthy,</span> <span data-start="1276.58" data-end="1280.09">which is two operations where the second one we don't care about.</span> <span data-start="1280.09" data-end="1283.779">This is a performance test showing that that is true.</span> <span data-start="1283.779" data-end="1287.799">You can see here we've got instance of a couple of different variants there, instance of is</span> <span data-start="1287.799" data-end="1293.529">not great because if you have after text node from a different document, it is a different</span> <span data-start="1293.529" data-end="1295.77">parent class so it is kind of useless.</span> <span data-start="1295.77" data-end="1300.22">The getters are relatively slow but the property accesses are surprisingly fast.</span> <span data-start="1300.22" data-end="1303.51">This is how to Preact reacts to text node.</span> </p>
<p><span data-start="1303.51" data-end="1305.38">Live load lists.</span> <span data-start="1305.38" data-end="1307.789">Please try not to use these.</span> <span data-start="1307.789" data-end="1311.25">They were a good-intentioned thing but they end up hurt performance.</span> <span data-start="1311.25" data-end="1315.71">Here is an example of trying to clear out children of a parent element.</span> <span data-start="1315.71" data-end="1321.88">You do a backwards loop over what appears to be an array because the indexes are going</span> <span data-start="1321.88" data-end="1326.86">to be all screwy if you loop forwards because it is a live node list, they change as you</span> <span data-start="1326.86" data-end="1327.929">mutate.</span> <span data-start="1327.929" data-end="1329.779">But we're removing the children as we go through the list.</span> <span data-start="1329.779" data-end="1332.11">Eventually, we will get back to none and we're good.</span> </p>
<p><span data-start="1332.11" data-end="1337.36">The second one is much faster though because we are accessing one property at each point</span> <span data-start="1337.36" data-end="1338.36">in the loop.</span> <span data-start="1338.36" data-end="1342.279">We never have to go back and ask for child nodes again.</span> <span data-start="1342.279" data-end="1346.61">We never have to access an offset in essentially an array.</span> <span data-start="1346.61" data-end="1348.399">We're just using references.</span> <span data-start="1348.399" data-end="1349.5">So here's a performance benchmark.</span> </p>
<p><span data-start="1349.5" data-end="1353.85">One thing to remember with the benchmark is that a lot is set up overhead, I can benchmark</span> <span data-start="1353.85" data-end="1360.71">the elements, and in the last case, the last child is always faster.</span> <span data-start="1360.71" data-end="1368.029">I've been doing performance optimisation for quite a while.</span> <span data-start="1368.029" data-end="1374.99">Benchmarks were run a loop five million times, check the date before and after, and cross</span> <span data-start="1374.99" data-end="1375.99">your fingers.</span> <span data-start="1375.99" data-end="1379.31">It is still the way stuff works.</span> <span data-start="1379.31" data-end="1382.07">Chrome dev tools has advanced this.</span> </p>
<p><span data-start="1382.07" data-end="1389.49">It is having a tiny copy of Sam in your browser and you can ask him to run performance tests.</span> <span data-start="1389.49" data-end="1398">It is far and away the best tab in chrome dev tools to use in a slide!</span> <span data-start="1398" data-end="1404.07">One metric is the total time to render a tree of components.</span> <span data-start="1404.07" data-end="1406.24">The value here is that you can see it visually.</span> <span data-start="1406.24" data-end="1414.059">It is 3.18 milliseconds to render this but I can see it is consistently around that same</span> <span data-start="1414.059" data-end="1415.059">value.</span> <span data-start="1415.059" data-end="1417.73">It's good to be able to visualise that.</span> </p>
<p><span data-start="1417.73" data-end="1426.19">The next tool is from a V8 engineer, and this actually touches on what Lin was talking about</span> <span data-start="1426.19" data-end="1427.4">DOps and compilers.</span> <span data-start="1427.4" data-end="1432.62">I can slip over this slide.</span> <span data-start="1432.62" data-end="1441.48">It will show you visually when your code is going to de-opt.</span> <span data-start="1441.48" data-end="1445.67">You run this with flags, and, if you want to know the flags and figure out how to run</span> <span data-start="1445.67" data-end="1452.84">Chrome to get the flags with the tracing output, and go to the — that only works on Mac iOS</span> <span data-start="1452.84" data-end="1458.76">for now.</span> <span data-start="1458.76" data-end="1465.289">This is unsurprisingly the first app built Preact in September of 2015 and it hasn't</span> <span data-start="1465.289" data-end="1466.5">been updated since then.</span> </p>
<p><span data-start="1466.5" data-end="1469.38">There are a whole bunch of UX flaws.</span> <span data-start="1469.38" data-end="1480.37">The goals of the bench is to give you a simple user interface on top of Babble and benchmark.js.</span> <span data-start="1480.37" data-end="1485.66">You can do comparisons of various different implementations of a given function and literally</span> <span data-start="1485.66" data-end="1487.299">just figure out which runs fastest.</span> <span data-start="1487.299" data-end="1493.169">You can do it in a bunch of different browsers, check it as new Chrome diseases come out,</span> <span data-start="1493.169" data-end="1495.77">and suddenly the benchmarks have inverted.</span> <span data-start="1495.77" data-end="1500.09">It is useful to know, that way we're not doing performance optimisations and a year down</span> <span data-start="1500.09" data-end="1504.88">the line, suffering because of them.</span> <span data-start="1504.88" data-end="1508.52">The first lesson is be explicit.</span> </p>
<p><span data-start="1508.52" data-end="1514.24">Don't task something to a Boolean if you have no reason to do that.</span> <span data-start="1514.24" data-end="1519.529">So, in this case, we're checking what looks like the existence of props on an object,</span> <span data-start="1519.529" data-end="1522.85">but really what we are doing is checking that it exists and that it isn't zero, an empty</span> <span data-start="1522.85" data-end="1523.85">string, null, false.</span> <span data-start="1523.85" data-end="1529.85">The next one is explicit checking to see if props are defined.</span> <span data-start="1529.85" data-end="1536.25">Reading this as a programmer, it makes more sense and faster for V8 to be able to run.</span> <span data-start="1536.25" data-end="1539.919">The next lesson is inline helper.</span> <span data-start="1539.919" data-end="1544.09">Functions can be way too develop and JavaScript developers because this is a language that</span> <span data-start="1544.09" data-end="1547.98">will let you do anything you want, this is really, really common.</span> </p>
<p><span data-start="1547.98" data-end="1550.76">So this is a hook function that was in Preact.</span> <span data-start="1550.76" data-end="1551.909">It does way too much stuff.</span> <span data-start="1551.909" data-end="1559.909">It gets deopted immediately and the solution is to rewrite it as an inline functions call.</span> <span data-start="1559.909" data-end="1565.5">Here is a quote by me!</span> <span data-start="1565.5" data-end="1569.5">But basically the idea is if you can avoid making a function call, avoid it.</span> <span data-start="1569.5" data-end="1571.98">Sometimes, there's just no reason to do certain things.</span> <span data-start="1571.98" data-end="1577.25">In the case of Preact, it would be like if you're dipping a virtual DOM tree and there</span> <span data-start="1577.25" data-end="1587.07">is one contextual child, it will update the diff and then bail.</span> <span data-start="1587.07" data-end="1593.26">Probably the most significant performance that has ever gone into Preact is that particular</span> <span data-start="1593.26" data-end="1595.909">early return.</span> <span data-start="1595.909" data-end="1600.98">So the point of all this is to say please make decisions based on actual data.</span> <span data-start="1600.98" data-end="1607.779">Find a way to get data, whether it is a benchmarking tool, dev tools or any of these solutions.</span> <span data-start="1607.779" data-end="1611.4">Collect better data through benchmarks and performance tests and then act on that by</span> <span data-start="1611.4" data-end="1612.4">setting better goals.</span> <span data-start="1612.4" data-end="1617.85">If I can leave you with a message, it is remember we have a shared goal making the web faster</span> <span data-start="1617.85" data-end="1620.21">and more accessible.</span> </p>
<p><span data-start="1620.21" data-end="1624.76">That's how we provide better experiences to frustrated users of the mobile web.</span> <span data-start="1624.76" data-end="1628.81">It is how we're going to make the mobile web the platform of choice in the next three and</span> <span data-start="1628.81" data-end="1633.59">a half years — I suspect that number — and then finally, it is how we get the next billion</span> <span data-start="1633.59" data-end="1637.96">people online so they can benefit from the access to the same resources that we have</span> <span data-start="1637.96" data-end="1640.09">had opportunities from.</span> </p>
<p><span data-start="1640.09" data-end="1641.09">So that's my talk.</span> </p>
</section>