<section>
<p><span data-start="9.8" data-end="10.72">Hello, Berlin?</span> <span data-start="10.72" data-end="11.82">How is everyone?</span> <span data-start="11.82" data-end="15.34">It's a pleasure to be here on the stage.</span> <span data-start="15.34" data-end="19.18">I've been coming to JSConf for years and so privileged, and it's a pleasure to be back</span> <span data-start="19.18" data-end="22.34">on the stage and give back to the community.</span> <span data-start="22.34" data-end="27.769">Sad that I'm not here with my family because coming back to JSConf every time feels like</span> <span data-start="27.769" data-end="32.66">coming back to see my family, and I think that's because of the amazing community we</span> <span data-start="32.66" data-end="34.35">have built here, and the organisers built.</span> <span data-start="34.35" data-end="40.43">A massive round of applause for the organisers for allows us all to be here to do this.</span> <span data-start="40.43" data-end="41.43">[Applause].</span> </p>
<p><span data-start="41.43" data-end="42.48">My name is Patrick Hamann.</span> <span data-start="42.48" data-end="51.79">I work for the Edge Cloud provider Fastly where we specialise in real time content delivery</span> <span data-start="51.79" data-end="53.07">for the world's leading brands.</span> <span data-start="53.07" data-end="58.74">I there get a lot of time to sit, think about, and research how we can make our customers'</span> <span data-start="58.74" data-end="64.33">websites load as fast as possible, and that's what I'm here to talk to you about today.</span> </p>
<p><span data-start="64.33" data-end="70.369">Why am I actually here and what does the clickbait-y Buzzfeed headline of to push or not to push</span> <span data-start="70.369" data-end="71.45">mean?</span> <span data-start="71.45" data-end="76.35">I'm not going to quote Hamlet to you now.</span> <span data-start="76.35" data-end="79.13">The reason I'm here is because of this.</span> <span data-start="79.13" data-end="80.93">I hear this all the tile.</span> <span data-start="80.93" data-end="86.759">I've sat on stages and said exactly this that HTTP/2 is going to solve this problem, literally</span> <span data-start="86.759" data-end="87.759">everyone.</span> <span data-start="87.759" data-end="90.34">The problem is that it's not.</span> </p>
<p><span data-start="90.34" data-end="95.77">Resource diabetic loading in the browser is very, very hard.</span> <span data-start="95.77" data-end="99.369">After this talk, hopefully, you will have a better understanding of why it's hard and</span> <span data-start="99.369" data-end="105.149">the techniques we have today to overcome the problems it produces.</span> <span data-start="105.149" data-end="106.99">Why is it hard?</span> <span data-start="106.99" data-end="112.34">Performance is coupled to latency.</span> <span data-start="112.34" data-end="114.9">Connection s costs are high.</span> <span data-start="114.9" data-end="121.539">TCP's congestion control algorithm is there for very good reasons but penalises us at</span> <span data-start="121.539" data-end="124.189">the beginning after connection when it's most important.</span> <span data-start="124.189" data-end="127.409">Our critical resources can be hidden to the browsers.</span> <span data-start="127.409" data-end="131.599">Browsers are extremely powerful things and have speculative parses but they simply are</span> <span data-start="131.599" data-end="137.43">not magic enough to know the resources that you as an application developer want to load.</span> <span data-start="137.43" data-end="142.069">Because of that, bandwidth is often under utilised, leaving idle connections open where</span> <span data-start="142.069" data-end="147.099">we could be sending resources but we can't do that yet because of the way that browsers</span> <span data-start="147.099" data-end="149.15">and servers interact with each other.</span> <span data-start="149.15" data-end="156.9">Finally, once we do get it down script, it is extremely to expensive to parse and execute</span> <span data-start="156.9" data-end="160.79">and we waste idle time on the network again because of that.</span> </p>
<p><span data-start="160.79" data-end="164.18">How can we load our resources mostly?</span> <span data-start="164.18" data-end="168.599">What patterns and techniques can we use today and what is coming up in the future to enable</span> <span data-start="168.599" data-end="174.459">us to do in the most efficient and speedy way?</span> <span data-start="174.459" data-end="178">Think about the product or website that you're designing today.</span> <span data-start="178" data-end="182.84">If you are only allowed to send three resources down the wire, would what they be?</span> <span data-start="182.84" data-end="184.299">Is it your fonts?</span> <span data-start="184.299" data-end="190.019">The lazy-loaded related comments on the bottom of this ft.com home page or adverts?</span> </p>
<p><span data-start="190.019" data-end="191.739">I don't think so.</span> <span data-start="191.739" data-end="196.019">What did the user come here for?</span> <span data-start="196.019" data-end="202.909">Bench wars from Calibre, who is sitting with us here today, when we talk about loading,</span> <span data-start="202.909" data-end="208.049">we talk about a critical request path, and he defines a critical request as one that</span> <span data-start="208.049" data-end="213.04">contains an asset that is essential to the content to the user's view port.</span> <span data-start="213.04" data-end="216.79">What are your critical resources.</span> </p>
<p><span data-start="216.79" data-end="221.049">I want you really to take this away from my talk as I want you to think about what are</span> <span data-start="221.049" data-end="225.47">the two or three things you need to send down as soon as possible so that browser can get</span> <span data-start="225.47" data-end="229.09">on with rendering and creating a good user experience for your users.</span> <span data-start="229.09" data-end="232.25">A critical CSS for your initial route?</span> <span data-start="232.25" data-end="234.609">Font or hero images.</span> <span data-start="234.609" data-end="237.599">One we don't discuss enough is the application bootstrap data.</span> <span data-start="237.599" data-end="243.859">A lot of client-side rendered applications probably make a JSON request that is hidden</span> <span data-start="243.859" data-end="244.859">to the browser.</span> <span data-start="244.859" data-end="248.879">It is known as a hidden sub resource and the browser doesn't know about it upfront.</span> </p>
<p><span data-start="248.879" data-end="253.319">We need to be able to tell the browser what the resource is specifically to our need,</span> <span data-start="253.319" data-end="257.259">and to create the delightful user experiences.</span> <span data-start="257.259" data-end="261.989">Once you've determined what your critical requests are, you need to think about how</span> <span data-start="261.989" data-end="264.15">they contribute to the user's experience.</span> </p>
<p><span data-start="264.15" data-end="267.18">After all, performance is a user experience problem.</span> <span data-start="267.18" data-end="270.26">What resources do you need to get a first meaningful paint?</span> <span data-start="270.26" data-end="274.71">What resources do you have to deliver so that users can start interacting with your website</span> <span data-start="274.71" data-end="276.54">as fast as possible.</span> </p>
<p><span data-start="276.54" data-end="281.28">It's this section here we will focus on today, this initial loading experience, and how we</span> <span data-start="281.28" data-end="286.97">can tell the browser, make, allow the browser to make informed decisions about what it load</span> <span data-start="286.97" data-end="289.99">so we can have delightful users' experience.</span> <span data-start="289.99" data-end="294.54">So I summarise a good loading strategy as one that prioritises above the file rendering,</span> <span data-start="294.54" data-end="295.88">prioritising interactivity.</span> <span data-start="295.88" data-end="301.41">It is easy to use because some we look at today aren't necessarily, and innovate importantly,</span> <span data-start="301.41" data-end="302.41">measurable.</span> <span data-start="302.41" data-end="308.13">The first solution to overcoming a performance problem is to measure your current performance,</span> <span data-start="308.13" data-end="311.34">if then optimise for it.</span> <span data-start="311.34" data-end="314.15">So the first technique that we are doing, now that we've identified what we should be</span> <span data-start="314.15" data-end="316.919">loading, let's see how we can do this efficiently.</span> <span data-start="316.919" data-end="319.8">The first I'm going to discuss is the preload API.</span> </p>
<p><span data-start="319.8" data-end="324.03">What if we could tell the browser ahead of time what the critical resources are required</span> <span data-start="324.03" data-end="325.069">for this?</span> <span data-start="325.069" data-end="331.94">The problem is earlier on we identified fonts, and application bootstrap data, as being critical</span> <span data-start="331.94" data-end="332.94">resources.</span> <span data-start="332.94" data-end="334.27">However, they're hidden from the browser.</span> <span data-start="334.27" data-end="335.27">Why is this?</span> <span data-start="335.27" data-end="340.69">First, you make a get request for the home page been we wait for the response of that.</span> <span data-start="340.69" data-end="345.46">HTML can be parsed I can be mentally so, as the bytes come down the wire, the browser</span> <span data-start="345.46" data-end="350.18">can start constructing the DOM without waiting for the HTML file to be delivered.</span> </p>
<p><span data-start="350.18" data-end="357.57">They have speculative parses that goes ahead while it's constructing the DOM, finds the</span> <span data-start="357.57" data-end="362.83">file sheets and script tags references in the page and initiates fetches for them ahead</span> <span data-start="362.83" data-end="364.18">of time.</span> <span data-start="364.18" data-end="368.639">But with CSS, unfortunately, it is render-blocking and can't be parsed incrementally.</span> <span data-start="368.639" data-end="372.669">We have to wait for all the bytes to come down first because if we didn't, there would</span> <span data-start="372.669" data-end="376.52">be lots of painting flashing on the screen because of the way the cascade works.</span> <span data-start="376.52" data-end="381.229">Eventually, it is only until this point that the CSS object it model and the document object</span> <span data-start="381.229" data-end="383.77">model combine to form the render tree.</span> </p>
<p><span data-start="383.77" data-end="388.24">It is only at this point when we have the render tree and we've done the networking</span> <span data-start="388.24" data-end="392.639">first which is when the browser will dispatch the font request.</span> <span data-start="392.639" data-end="397.919">Your CSS may reference five or six font files but only two are being used for the initial</span> <span data-start="397.919" data-end="398.919">load.</span> <span data-start="398.919" data-end="402.61">This is why fonts are known as criticals hidden sub resources.</span> <span data-start="402.61" data-end="405.069">The browser can't know about them up front.</span> <span data-start="405.069" data-end="410.47">The idea of preload is what if we could provide a declarative fetch primitive that initiates</span> <span data-start="410.47" data-end="418.229">an early fetch, decoupling that logic, saying to the browser, "I know you're going to find</span> <span data-start="418.229" data-end="422.09">the font later on, and I know you need it, or for your JavaScript application, I know</span> <span data-start="422.09" data-end="427.43">you're going to make a request about a JSON file to the user, you won't find it later</span> <span data-start="427.43" data-end="431.57">in the process," I know about it, perform the networking for it now.</span> <span data-start="431.57" data-end="434.11">That's why it is extremely powerful.</span> <span data-start="434.11" data-end="443.15">Here, we have three new primitives, one via HTML, and one by JavaScript, by our HTTP link</span> <span data-start="443.15" data-end="444.15">headers.</span> </p>
<p><span data-start="444.15" data-end="452.06">We also have had module preload specification for those shipping the native browsers already.</span> <span data-start="452.06" data-end="457.96">Fonts have to be requested as non-origin, so this is really powerful.</span> <span data-start="457.96" data-end="464.58">By adding three HTTP headers, we can tell the browser upfront about our critical resources.</span> <span data-start="464.58" data-end="468.3">So if we were to look at the network waterfall for featherweight dominate, for instance,</span> <span data-start="468.3" data-end="473.25">before applying this, you will see that the font files are really low priority here, and</span> <span data-start="473.25" data-end="478.31">because they haven't been discovered until the CSS file has been parsed, but just by</span> <span data-start="478.31" data-end="484.16">adding the preload headers, we can instantly prioritise and initiate those fetches early,</span> <span data-start="484.16" data-end="487.729">and so the browser can get on with it.</span> <span data-start="487.729" data-end="497.03">Customers saw they had 50 per cent, 1.2 seconds, improvement by adding preload headers for</span> <span data-start="497.03" data-end="499.66">their font files and hidden sub roars.</span> <span data-start="499.66" data-end="506.53">I've never known a single technique that's one line of code that can have a two-second</span> <span data-start="506.53" data-end="511.979">average improvement on the user experience of loading up a page.</span> <span data-start="511.979" data-end="517.18">The question that I want to ask, and propose to you, is: is indicating resource hints via</span> <span data-start="517.18" data-end="523.36">the HTML like this, in fact, too late in the connection flow, too late in the loading experience</span> <span data-start="523.36" data-end="524.36">of the page?</span> </p>
<p><span data-start="524.36" data-end="530.88">And that is what HTTP/2 server push comes in, or was specifically designed to solve.</span> <span data-start="530.88" data-end="533.17">Let's look at how it can help us.</span> <span data-start="533.17" data-end="539.49">First, let's look at the traditional request flow that you to make when you're loading</span> <span data-start="539.49" data-end="540.49">a page.</span> <span data-start="540.49" data-end="542.13">You perform a get request to your server.</span> <span data-start="542.13" data-end="548.06">The server has server think time and perform a database action, or render some template.</span> <span data-start="548.06" data-end="555.56">All of the time this is thinking, and, then eventually, it will respond with your index.html.</span> <span data-start="555.56" data-end="558.94">Then the browser stars parsing it.</span> <span data-start="558.94" data-end="564.821">This makes me sad because we've left the connection open for so long whilst the browser, the server</span> <span data-start="564.821" data-end="565.94">was doing that think time.</span> <span data-start="565.94" data-end="571.35">At Fastly, we see an average server think time of 200 to 400 milliseconds wasted on</span> <span data-start="571.35" data-end="578.029">the wire here, and round-trip can be 800 to 1,000 milliseconds on a good 3G connection.</span> <span data-start="578.029" data-end="584.7">What if the server could predict the next thing the client is going to request is that</span> <span data-start="584.7" data-end="591.94">main CSS file and flush the bytes for it down as soon as it receives that get request.</span> <span data-start="591.94" data-end="593.42">How soon can I use push?</span> </p>
<p><span data-start="593.42" data-end="603.05">If you have an HTTP/2 server enabled today, Node natively supports it, we've converged</span> <span data-start="603.05" data-end="609.62">using our link preload header to use as the semantic of "I want to push this resource,"</span> <span data-start="609.62" data-end="616.49">so if your server is HTTP/2 enabled, it will read these and initiate pushes for you.</span> <span data-start="616.49" data-end="618.2">Really super quick win.</span> </p>
<p><span data-start="618.2" data-end="623.29">If you don't want to push and you still want the semantics of preload, you can add the</span> <span data-start="623.29" data-end="628.63">no-push attribute there, and at Fastly, we realise that you might only want to push and</span> <span data-start="628.63" data-end="633.48">not have a race between push and preload, and we allow you to say that and will strip</span> <span data-start="633.48" data-end="635.38">the header on the way out.</span> <span data-start="635.38" data-end="638.57">What benefit does this actually give us?</span> <span data-start="638.57" data-end="643.5">If we look to our common waterfall for loading a page, we've got the index file, then we</span> <span data-start="643.5" data-end="648.18">look for the CSS, we find that, and then perform the networking for the JavaScript, and the</span> <span data-start="648.18" data-end="649.18">CSS.</span> <span data-start="649.18" data-end="653.66">By pushing the resource, we are saving one round trip here, the light-shaded bit.</span> <span data-start="653.66" data-end="659.38">The round-trip time is the time it takes for the client to send the request to hit the</span> <span data-start="659.38" data-end="662.19">server and back again until we start receiving the first bytes.</span> <span data-start="662.19" data-end="668.76">Again, on a 3G connection in Europe, that could be as about 800 milliseconds, in some</span> <span data-start="668.76" data-end="670.639">other developing areas, that could be seconds.</span> </p>
<p><span data-start="670.639" data-end="672.13">So it's great.</span> <span data-start="672.13" data-end="677.93">It gives us a one round-trip time saving to improve our loading experience.</span> <span data-start="677.93" data-end="682.66">But in the here it's idle time still left on the connection.</span> <span data-start="682.66" data-end="686.889">This makes me really, really sad.</span> <span data-start="686.889" data-end="687.889">Why is this?</span> <span data-start="687.889" data-end="689.94">Let's look again at this request flow.</span> <span data-start="689.94" data-end="694.81">As a server push is indicated via the link header, we have to wait for the server to</span> <span data-start="694.81" data-end="700.1">do its think time in responding before we as a server, or your proxy layer, your CDN,</span> <span data-start="700.1" data-end="708.41">if you use Apache is only until we've received all of the HTML bytes that we initiate that</span> <span data-start="708.41" data-end="709.41">push.</span> </p>
<p><span data-start="709.41" data-end="712.891">That is far too late in the connection flow because we've still got this idle connection</span> <span data-start="712.891" data-end="714.6">time.</span> <span data-start="714.6" data-end="715.769">This makes me really sad.</span> <span data-start="715.769" data-end="719.68">Wasn't this what push was designed to solve?</span> <span data-start="719.68" data-end="725.579">To summarise, push gives us a round trip saving, I would argue the fact that, if you need,</span> <span data-start="725.579" data-end="729.029">with , you have got no that long server think time, you should be optimising your servers</span> <span data-start="729.029" data-end="730.47">instead.</span> <span data-start="730.47" data-end="734.089">Is link header far too late in the connection flow?</span> <span data-start="734.089" data-end="739.31">And this is where asynch push comes in.</span> <span data-start="739.31" data-end="744.029">To be able to truly utilise push, we need to decouple the pushing behaviour from our</span> <span data-start="744.029" data-end="749.339">applications HTML response, and do it right at the beginning of the connection flow.</span> <span data-start="749.339" data-end="755.77">So a more common architecture as I discussed you may have a CDN or a proxy as it receives</span> <span data-start="755.77" data-end="760.96">that request it is only there and then whilst we have that server think time, we can push</span> <span data-start="760.96" data-end="762.25">the bytes down the wire.</span> </p>
<p><span data-start="762.25" data-end="767.44">I forgot to mention earlier on that the way that push works is HTTP/2 has a binary data</span> <span data-start="767.44" data-end="768.71">framing layer.</span> <span data-start="768.71" data-end="773.88">This is a magical thing that allows us no longer just plain text on the wire, on our</span> <span data-start="773.88" data-end="779.019">TCP connection, now we have binary frames allowing us to interleave separate data frames</span> <span data-start="779.019" data-end="783.07">for subsequent requests or multiple questions at the same time, called multiplexing.</span> <span data-start="783.07" data-end="788.85">This is why we can have a single HTTP/2 open and deliver hundreds of resources at the same</span> <span data-start="788.85" data-end="789.85">time.</span> <span data-start="789.85" data-end="795.029">Push works by sending a push promise frame, as you can see here, a data frame sent to</span> <span data-start="795.029" data-end="803.04">the client saying I'm going to send you these bytes, and here they are, go and have them.</span> <span data-start="803.04" data-end="806.66">Utilising idle connection time like this makes me extremely happy.</span> <span data-start="806.66" data-end="808.8">Again you're wondering how you can do this.</span> </p>
<p><span data-start="808.8" data-end="812.67">This is using Node standard HTTP/2 standard library.</span> <span data-start="812.67" data-end="814.19">I've got a request handler here.</span> <span data-start="814.19" data-end="816.889">I checked to see if the URL matches.</span> <span data-start="816.889" data-end="822.449">If it does, I want to initiate a push, here is where you can flush down your critical</span> <span data-start="822.449" data-end="826.529">resources that you've identified, piping they think them down a extreme, and then you can,</span> <span data-start="826.529" data-end="834.85">down a stream, and then you can — so let's see the benefits that this has on our waterfall.</span> <span data-start="834.85" data-end="839.37">As you can see here, when our push example, we had the one round-trip saving when using</span> <span data-start="839.37" data-end="840.519">the link header.</span> <span data-start="840.519" data-end="846.529">By using asynch push, we've hit the Holy Grail that we are pushing the styles that JavaScript</span> <span data-start="846.529" data-end="850.399">required to render the screen before the HTML is even consumed.</span> <span data-start="850.399" data-end="855.31">Now the browser has all of the information it needs instantly to render as soon as the</span> </p>
<p><span data-start="855.31" data-end="856.56">HTML is finished.</span> <span data-start="856.56" data-end="859.45">That makes Patrick extremely happy!</span> <span data-start="859.45" data-end="862.66">But what about the repeat view I hear you asking?</span> <span data-start="862.66" data-end="864.839">I definitely ask this a lot.</span> <span data-start="864.839" data-end="870.709">We have already sent the assets to the clients.</span> <span data-start="870.709" data-end="874.82">The client should have that asset in its patch.</span> <span data-start="874.82" data-end="878.8">The problem is that we've got no way of indicating that the serve questioner and what is in its</span> <span data-start="878.8" data-end="879.86">cache.</span> <span data-start="879.86" data-end="888.16">What will happen is on the repeat view and will be detrimental here and create tension</span> <span data-start="888.16" data-end="894.23">on the underlying network link and end up worse than when you [sound feed distorted].</span> <span data-start="894.23" data-end="923.389">The request</span> <span data-start="923.389" data-end="928.94">never even goes out to the network, and so we don't have to push, so we benefit from</span> <span data-start="928.94" data-end="935.1">not having to worry about the cache state.</span> </p>
<p><span data-start="935.1" data-end="938.56">But that's only if you have a service worker, and a lot of us may not have.</span> <span data-start="938.56" data-end="942.17">So the server has got no knowledge of the class state, and this is a really, really</span> <span data-start="942.17" data-end="945.09">big problem.</span> <span data-start="945.09" data-end="946.09">What is the problem?</span> <span data-start="946.09" data-end="949.43">The theory there is great: push should be amazing.</span> <span data-start="949.43" data-end="954.31">We should be able to give the client all of the information it needs before I've even</span> <span data-start="954.31" data-end="957.97">received the HTML but the adoption is extremely low.</span> <span data-start="957.97" data-end="958.97">Why is that?</span> <span data-start="958.97" data-end="959.97">What is the problem?</span> <span data-start="959.97" data-end="964.27">I also want to make a poll here: who is using H2 in production right now?</span> </p>
<p><span data-start="964.27" data-end="969.18">Leave your hands up if you're also using push.</span> <span data-start="969.18" data-end="974.149">So only about ten per cent of the people that were using push, and there was only probably</span> <span data-start="974.149" data-end="977.079">only about 20 per cent of the room using H2 at all.</span> <span data-start="977.079" data-end="978.079">What is the problem?</span> <span data-start="978.079" data-end="981.13">Why is no-one adopting it?</span> <span data-start="981.13" data-end="983.47">To do that, let's take a look at the request flow again.</span> <span data-start="983.47" data-end="987.92">Once we've sent the get requests, and we start pushing the bytes down the wire, I lied to</span> <span data-start="987.92" data-end="989.01">you earlier on.</span> </p>
<p><span data-start="989.01" data-end="994.389">Even though the browser doesn't have a mechanism for telling its cache state, it has a mechanism</span> <span data-start="994.389" data-end="999.49">to reset that stream, so you can send a reset stream saying I don't want those bytes any</span> <span data-start="999.49" data-end="1002.449">more, I've got it in my cache.</span> <span data-start="1002.449" data-end="1007.91">Unfortunately, we've got a race condition here that, by the time the client has initiated</span> <span data-start="1007.91" data-end="1012.66">the reset stream but by the time that gets to the server, because our critical resources</span> <span data-start="1012.66" data-end="1018.149">are normally small, we have flushed the bytes down the wire already, or, if more importantly,</span> <span data-start="1018.149" data-end="1024.63">they left the user space, it's inside their TCP buffer, and once something is in the kernel's</span> <span data-start="1024.63" data-end="1030.66">TCP space, there's no way for an application to prevent those being flushed down the physical</span> <span data-start="1030.66" data-end="1031.66">listening.</span> <span data-start="1031.66" data-end="1037.36">We've got a race conditions here which isn't a good thing.</span> <span data-start="1037.36" data-end="1044.1">The new quick protocol that was — QUIC protocol is going to hopefully solve a lot of those</span> <span data-start="1044.1" data-end="1050.63">problems by moving a lot of the application layer out of the kernel into user space and</span> <span data-start="1050.63" data-end="1054.3">allow us to do amazing things here.</span> </p>
<p><span data-start="1054.3" data-end="1060.88">Another common area of misconception of HTTP/2 server push is how the servers cache that</span> <span data-start="1060.88" data-end="1062.21">resource.</span> <span data-start="1062.21" data-end="1067.53">Once I pushed all the bytes down, still a request that is initiated from your page needs</span> <span data-start="1067.53" data-end="1072.79">to claim that resource from the HTTP/2's push cache.</span> <span data-start="1072.79" data-end="1077.61">A push cache is not connected to the HTTP cache, it is connected to the lifetime of</span> <span data-start="1077.61" data-end="1081.89">that single HTTP/2 connection, so, for every H2 connection you have to an origin, you're</span> <span data-start="1081.89" data-end="1084.44">going to have a dedicated push cache for that.</span> <span data-start="1084.44" data-end="1088.04">One of the problems is that the push cache is the last to be requested.</span> <span data-start="1088.04" data-end="1092.72">As the request leaves the page, first it will go to the memory cache attached to that document,</span> <span data-start="1092.72" data-end="1096.78">it's all of the resources that document has already requested.</span> </p>
<p><span data-start="1096.78" data-end="1101.14">Then it will be looked up in the service worker cache, then the HTTP cache, the service worker</span> <span data-start="1101.14" data-end="1106.55">caches are shared globally where the memory caches are pushed, and finally, it will try</span> <span data-start="1106.55" data-end="1108.55">and look inside the push cache.</span> <span data-start="1108.55" data-end="1112.62">It's highly likely a lot of the time the push cache will never be claimed, and therefore</span> <span data-start="1112.62" data-end="1117.29">therefore you've wasted sending bytes down the wire.</span> <span data-start="1117.29" data-end="1122.82">The other tricky thing here to note is that HTTP/2 connections are credentialed or non-credentialed</span> <span data-start="1122.82" data-end="1128.47">which is why a font file has to be served as a non-credentialed resource.</span> <span data-start="1128.47" data-end="1135.3">If a CSS file was to push a font file, the CSS file is credentialed and so actually won't</span> <span data-start="1135.3" data-end="1138.89">be able to claim the font file request.</span> <span data-start="1138.89" data-end="1144.28">So to summarise, the problem here is the push cache is hats to be authoritative for it,</span> <span data-start="1144.28" data-end="1146.63">a single cache per connection.</span> <span data-start="1146.63" data-end="1150.7">The items can only be claimed once, so, if you have multiple tabs open for the single</span> <span data-start="1150.7" data-end="1154.7">one, the push can only be sent once, and you have to repeat that push.</span> </p>
<p><span data-start="1154.7" data-end="1165.6">The thing that I find is that the cache behaviour is not specced as part of the implementation.</span> <span data-start="1165.6" data-end="1170.51">If you do consider using HTTP/2 push, I urge you to read this blog post by Jake Archbold,</span> <span data-start="1170.51" data-end="1175.09">where he goes into great detail and the browser inconsistencies, and it's tougher than we</span> <span data-start="1175.09" data-end="1176.09">thought it was.</span> <span data-start="1176.09" data-end="1189.72">A tl;dr summarisation of that, we can only ably use it in Chrome and Firefox.</span> <span data-start="1189.72" data-end="1194.8">The networking stack is — Edge have done great work.</span> <span data-start="1194.8" data-end="1200.56">One of the great things that Jake did in this post was to document all the problems and</span> <span data-start="1200.56" data-end="1204.96">create tickets on all of the browsers bug trackers, so my hat's off to Jake for doing</span> <span data-start="1204.96" data-end="1205.96">that.</span> </p>
<p><span data-start="1205.96" data-end="1209.13">Edge are improving but not yet.</span> <span data-start="1209.13" data-end="1212.27">Still one connection per tag.</span> <span data-start="1212.27" data-end="1215.09">This leaves us to UA sniff for push.</span> <span data-start="1215.09" data-end="1219.1">That's really, really bad, and we know what happens when we start going down that route</span> <span data-start="1219.1" data-end="1220.96">of UA sniffing.</span> <span data-start="1220.96" data-end="1224.22">The race of adoption.</span> <span data-start="1224.22" data-end="1230.41">For instance as at Fastly, we only see 0.008 requests — that's 800 questions out of a</span> <span data-start="1230.41" data-end="1235.5">million, we do around 6 million requests a second, that we see a push initiated.</span> </p>
<p><span data-start="1235.5" data-end="1239.68">If it was so good, everybody should be using it, but they're not.</span> <span data-start="1239.68" data-end="1244.88">This lack of adoption has got so bad that certain vendors have considered ripping push</span> <span data-start="1244.88" data-end="1248.63">out of the HTTP/2 specification entirely.</span> <span data-start="1248.63" data-end="1249.74">When should you push?</span> <span data-start="1249.74" data-end="1254.7">Only if you have long round-trip times or an app shell architecture and you could use</span> <span data-start="1254.7" data-end="1260.46">the purple appear or if you could manage your own cache state natively, or if you've got</span> <span data-start="1260.46" data-end="1264.26">a native application or an electron app.</span> </p>
<p><span data-start="1264.26" data-end="1270.65">Is that round-trip worth the complexity of the benefits it gives us, and are there simple</span> <span data-start="1270.65" data-end="1272.77">solutions out there that we can use?</span> <span data-start="1272.77" data-end="1280.06">This is why I want to talk about what is ahead for us in the future.</span> <span data-start="1280.06" data-end="1286.48">Can we just fix the HTTP push problems?</span> <span data-start="1286.48" data-end="1287.95">They're quite simple.</span> <span data-start="1287.95" data-end="1289.39">What can we do to fix that?</span> <span data-start="1289.39" data-end="1292.9">That is where the cached digest specification comes in.</span> <span data-start="1292.9" data-end="1296.95">What if the browser, whenever it created a new connection could send a frame called a</span> <span data-start="1296.95" data-end="1303">cache digest that contained a cuckoo filter which is a probabilistic data structure representing</span> <span data-start="1303" data-end="1306.63">all the items the browser has for the clash of that host name?</span> <span data-start="1306.63" data-end="1310.42">Then the server can be much more intelligent about what it wants to push.</span> <span data-start="1310.42" data-end="1316.84">It's I'm not going to push main.css but I will send you the new version of my JavaScript</span> <span data-start="1316.84" data-end="1320.99">application because you don't have the latest version of that.</span> <span data-start="1320.99" data-end="1326.05">I'm excited by not just for solving push, this opens up a lot of great opportunity for</span> <span data-start="1326.05" data-end="1330.6">us for instance in the JavaScript bundling and modules world that we could choose and</span> <span data-start="1330.6" data-end="1335.14">be more intelligence of what we bundle and what we send down and we have a bit more knowledge</span> <span data-start="1335.14" data-end="1337.97">about the client cache state.</span> </p>
<p><span data-start="1337.97" data-end="1342.56">Going back to the repeat view, if we had cache digests for our first view we could push and</span> <span data-start="1342.56" data-end="1347.28">on the subsequent view, the client says I've got that in my resource and we wouldn't have</span> <span data-start="1347.28" data-end="1350.13">to push it.</span> <span data-start="1350.13" data-end="1354.08">Cache digest specification is an experimental in ITF at the moment.</span> <span data-start="1354.08" data-end="1359.85">It was proposed by my colleague, and it's been worked on, but I think we're going to</span> <span data-start="1359.85" data-end="1362.28">see implementations land in browsers soon.</span> <span data-start="1362.28" data-end="1366.26">Fastly have got the first implementation of the server side as that of that in that you</span> <span data-start="1366.26" data-end="1371.97">are open source server, but this seems too complicated.</span> <span data-start="1371.97" data-end="1376.55">Like we are still having to maintain a lot of logic to manage state between the client</span> <span data-start="1376.55" data-end="1377.89">and the server.</span> <span data-start="1377.89" data-end="1381.78">Http after all is a stateless protocol, why it's so beautiful.</span> <span data-start="1381.78" data-end="1383.46">It is complicated.</span> <span data-start="1383.46" data-end="1386.98">This is where the 103 early-hint specification comes in.</span> </p>
<p><span data-start="1386.98" data-end="1389.16">This is again pursued by my colleague.</span> <span data-start="1389.16" data-end="1393.09">Who has heard of 100 informational ranges at all?</span> <span data-start="1393.09" data-end="1395.61">I hadn't at all until this came out.</span> <span data-start="1395.61" data-end="1400.89">New HTTP response code that allows the server to indicate to the client the resource that</span> <span data-start="1400.89" data-end="1405.55">is are going to be required for the 200 response that is coming.</span> <span data-start="1405.55" data-end="1410.92">It looks like this, when we perform a Get request, we then send down an initial response</span> <span data-start="1410.92" data-end="1417.37">just containing headers using our friend link preload and the browser gets to decide I've</span> <span data-start="1417.37" data-end="1421.94">got this and don't have that, and initiates the fetches early during the think time.</span> <span data-start="1421.94" data-end="1424.17">This is what it would look like on the wire.</span> <span data-start="1424.17" data-end="1427.18">It is as simple as that.</span> <span data-start="1427.18" data-end="1431.65">This is why it's more powerful than push because we are moving that logic and decision process</span> <span data-start="1431.65" data-end="1436.67">back to the browser where it belongs, so the server can send down a 103 response saying</span> <span data-start="1436.67" data-end="1441.79">here are the critical resources for this page, you decide what you want to do with it and</span> <span data-start="1441.79" data-end="1443.44">follow up with a 200.</span> <span data-start="1443.44" data-end="1446.95">Again, this has been accepted by ITF in experimental mode.</span> </p>
<p><span data-start="1446.95" data-end="1451.38">We've got a working implementation on the server side but the problem is at the moment,</span> <span data-start="1451.38" data-end="1455.58">many browser are worried about the complexity this adds to the networking stack and worried</span> <span data-start="1455.58" data-end="1460.67">we will break the internet because middle proxies don't understand the 100 range but</span> <span data-start="1460.67" data-end="1464.08">only served over TLS to overcome the problems.</span> <span data-start="1464.08" data-end="1468.051">Early hints gives us all the same benefits as push but possession simpler and we can</span> <span data-start="1468.051" data-end="1474.26">leverage the browser cache now not have the complexities of the H2 server push cache and</span> <span data-start="1474.26" data-end="1480.16">it's great because it allows the client to do the decision-making.</span> <span data-start="1480.16" data-end="1487.79">We've got preload to do the headers, and new specification coming out that allows us to</span> <span data-start="1487.79" data-end="1493.86">decorate our HTML with resources saying I know this hero image is high priority but</span> <span data-start="1493.86" data-end="1495.03">this fetch request is low.</span> <span data-start="1495.03" data-end="1500.02">I urge you to go and check out the specification and add to the GitHub page here.</span> </p>
<p><span data-start="1500.02" data-end="1504.41">So, in closing, I've run out of time, so I've got to wrap up.</span> <span data-start="1504.41" data-end="1508.66">Eve only scratched the surface here of methodologies but I hope I've given you techniques to use</span> <span data-start="1508.66" data-end="1509.68">today.</span> <span data-start="1509.68" data-end="1514.43">HTTP/2 doesn't solve everything but there are a lot of things to solve this.</span> <span data-start="1514.43" data-end="1519.31">Resource-loading in the browser is hard but I'm excited by the future.</span> <span data-start="1519.31" data-end="1522.16">Most importantly, performance is for humans.</span> <span data-start="1522.16" data-end="1526.2">Optimise for a good user experience, not for the networking stack.</span> <span data-start="1526.2" data-end="1529.35">Measure your experience and optimise for that.</span> <span data-start="1529.35" data-end="1534.97">So, the checklist, if I was going to do today, identify your critical resources, preload</span> <span data-start="1534.97" data-end="1540.05">any hidden sub resources, avoid push for possible and the future is looking great.</span> <span data-start="1540.05" data-end="1544.47">We can use early hints when they become available.</span> <span data-start="1544.47" data-end="1545.47">Thank you very much.</span> </p>
</section>