<section>
<p></p>
</section>

<section>
<p><span data-start="26.01" data-end="30.98"><span class="speaker">Mathias Bynens</span>: All right so in ES6 every regular expression has a Unicode getter that</span> <span data-start="30.98" data-end="36.16">returns true or false depending on whether a new flag, the u flag, which stands for Unicode</span> <span data-start="36.16" data-end="40.86">has been enabled for this regular expression or\hnot. That’s pretty much what this presentation</span> <span data-start="40.86" data-end="54.26">will be about. Fun fact about the title of this talk, you shouldn't ever run Unicode.</span> <span data-start="54.26" data-end="59.83">You shouldn't use this code because technically it should throw an error, Unicode is a getter</span> <span data-start="59.83" data-end="65.05">that defined in the prototype, but the getter checks if it's being called on a regular expression</span> <span data-start="65.05" data-end="71.22">instance, and RegExp type itself is not a regular expression instance. Just a quick</span> <span data-start="71.22" data-end="75.19">fun fact. Anyway, before we get started let's just make</span> <span data-start="75.19" data-end="79.47">sure we're all on\hthe same page when it comes to Unicode I am just going to throw some terminology</span> <span data-start="79.47" data-end="86.69">at you a couple of terms I will be using throughout the rest of the presentation. Let's get started.</span> </p>
<p><span data-start="86.69" data-end="91.83">So the easiest way of to think of Unicode is kind of like a database that maps any symbol</span> <span data-start="91.83" data-end="97.98">you can think of to a unique name for that symbol and a unique canonical, which is a</span> <span data-start="97.98" data-end="107.01">unique number for that. You have the letter A which you have the code point U+0041 and</span> <span data-start="107.01" data-end="112.73">the small letter a which is a completely different symbol, it gets it own unique name and code</span> <span data-start="112.73" data-end="118.71">point. This is very useful because it allows you to refer to a specific symbol without</span> <span data-start="118.71" data-end="123.07">having to use the symbol itself, you can just refer to code point or to name, and everyone</span> <span data-start="123.07" data-end="127.03">can look it up and the Unicode standard and know exactly which symbol you are talking</span> <span data-start="127.03" data-end="130.75">about. Now, code points are usually formatted the</span> <span data-start="130.75" data-end="136.94">way you see here you get the u+ prefix then following by a number of hexadecimal digits,</span> <span data-start="136.94" data-end="144.01">up\hto at least 4 hexadecimal digits as well. There's a bunch of code points in Unicode</span> <span data-start="144.01" data-end="150.14">for\hexample there's also the pile of poo and many other emoji, and really the code</span> <span data-start="150.14" data-end="154.45">points in Unicode span a\hvery wide range, there’s a lot of them. It goes all the way</span> <span data-start="154.45" data-end="162.53">from 0 to 10 FFF so that's a little over 1.1 million different code points. Now to keep</span> <span data-start="162.53" data-end="168.239">thing a little bit organised Unicode divides these code points up into 17 so called planes</span> </p>
<p><span data-start="168.239" data-end="172.54">I am not going to bore you with the details for each of these individual planes. the first</span> <span data-start="172.54" data-end="177.329">one is pretty interesting it's called the basic the multilingual plane or the BMP, it</span> <span data-start="177.329" data-end="183.659">goes from 0FFFF, I\hthink it's the most important one it contains all the most commonly used</span> <span data-start="183.659" data-end="189.779">symbols, whenever you are writing a text document in English or Spanish or German you probably</span> <span data-start="189.779" data-end="194.129">won't need any symbols outside of this BMP range.</span> </p>
<p><span data-start="194.129" data-end="198.889">Now all the other planes combined they\hare calling the astral planes so they range from</span> <span data-start="198.889" data-end="208.2">1000 to 10FFFF so the vast majority of\hthe Unicode point space lies in this astral range,</span> <span data-start="208.2" data-end="214.29">over 95% of all code points are there, but because the BMP contains all the most important</span> <span data-start="214.29" data-end="219.269">ones, a\hlot of developers tend to forget about all\hthe other code points.</span> <span data-start="219.269" data-end="222.81">I actually gave a presentation about that last year, it\hwas titled ‘JavaScript has</span> <span data-start="222.81" data-end="230.109">a Unicode problem.’ I explained some of the problems in JavaScript strings I will</span> <span data-start="230.109" data-end="235.29">not be able to repeat all\hthe examples and explain how you fix them if you are interested</span> <span data-start="235.29" data-end="239.239">in that just check out the presentation I gave last year, the link is right there and</span> <span data-start="239.239" data-end="243.739">just\hto give you one small example for\hexample if you take a string containing only an astral</span> <span data-start="243.739" data-end="249.309">symbol like the pile of poo emoji for\hinstance, it has a length of 2 instead of 1 which may</span> <span data-start="249.309" data-end="256.09">not be what you expect. This happens because JavaScript expresses astral symbols as 2 separate</span> <span data-start="256.09" data-end="266.11">units called surrogate half. That combined together in\ha surrogate pair, this represents</span> <span data-start="266.11" data-end="274.13">a single astral symbol. It's a little bit confusing. Let's talk about RegExp so there's</span> <span data-start="274.13" data-end="279.99">a bunch of effects that this new u flag for regular expressions has, but first that will</span> <span data-start="279.99" data-end="286.61">discuss is\hthe impact on syntax. It also kind of changes the meaning of the .operator,</span> <span data-start="286.61" data-end="291.89">quantifiers are affected as character classes have new behaviour, character class escape</span> <span data-start="291.89" data-end="297.86">have changed the iflag for case in sensitivity gets a new behaviour when it's combined with</span> <span data-start="297.86" data-end="303.38">the u flag, even HTML documents are kind of impacted by the existence of the u flag believe</span> <span data-start="303.38" data-end="309.28">it or\hnot, and finally we will take a look at browser support. Let's get started with</span> <span data-start="309.28" data-end="315.87">the impact the u flag has on syntax. Adding the u flag to a regular expression automatically</span> <span data-start="315.87" data-end="321.85">unlocks a new syntax called Unicode code point escapes. These things start with a\ followed</span> <span data-start="321.85" data-end="327.04">by u followed by braces. Between those braces you can us\hany number of hexadecimal digits</span> <span data-start="327.04" data-end="330.87">you want to use a of\hcourse you only need sticks to be able\hto rep sensibility any</span> </p>
<p><span data-start="330.87" data-end="337.69">Unicode point that's plenty. Now this again makes it really easy to refer to any symbol</span> <span data-start="337.69" data-end="342.23">with having to use the symbol itself you can just refer to code point it instead, specially</span> <span data-start="342.23" data-end="346.48">if you\hare creating a huge regular expression that tries to match a\hlot of different code</span> <span data-start="346.48" data-end="350.78">points or symbols it can make a regular expression actually more readable if you want to deal</span> <span data-start="350.78" data-end="355.69">with you probably don't want to look at all these weird characters in your code you just</span> <span data-start="355.69" data-end="361.02">want to see the code points instead this makes that's really ease. In fact this Unicode code</span> <span data-start="361.02" data-end="366.53">point escapes syntax is automatically available in string and template strings as well in</span> </p>
<p><span data-start="366.53" data-end="372.56">ES6 if you want to use it in regular expression you need to use the u flag first.</span> <span data-start="372.56" data-end="376.9">In fact if may look like you are already able to use these code points escapes even without</span> <span data-start="376.9" data-end="382.77">a u flag but that not really what's going on. For\hexample the code at the bottom doesn't</span> <span data-start="382.77" data-end="388.31">throw an error which might lead you\hto believe it actually already works but it also does</span> <span data-start="388.31" data-end="393.28">not quite do what you would expect to\hit. So in this case the\followed by the u is actually</span> <span data-start="393.28" data-end="398.87">an unnecessary escape sequence for the u character, then the braces and numbers rapped in the</span> <span data-start="398.87" data-end="406.05">braces that the quantifier, instead of matching the code point U+234 you\hare basically saying</span> <span data-start="406.05" data-end="413.86">match the letter U repeat it 1, 2, 3, 4 times. That’s why you explicitly opt in by using</span> <span data-start="413.86" data-end="420.08">the u flag if you want to use this feature it's also a good reason to not blindly go</span> <span data-start="420.08" data-end="425.49">through your existing source code and blindly add the u flag to your existing RegExp because</span> <span data-start="425.49" data-end="429.4">you might end up accidentally changing their meaning this way.</span> </p>
<p><span data-start="429.4" data-end="433.81">Now to avoid this kind of ambiguity in\hthe future the u flag prevents you from using</span> <span data-start="433.81" data-end="439">unneeded escapes for example the A character doesn't have any special meaning at regular</span> <span data-start="439" data-end="444">expression, so there no reason why you would want to escape using a \U if you enabled the</span> <span data-start="444" data-end="448.15">U flag for a regular expression. This will actually throw an error this is JavaScript's</span> <span data-start="448.15" data-end="451.31">way of warning you, you are doing something weird here.</span> </p>
<p><span data-start="451.31" data-end="456.47">So really you can think of\hthe u flag as kind of like a strict mode for RegExp specifically</span> <span data-start="456.47" data-end="462.4">I\hthink you should use is for any new RegExp you create from now on, but at the same time</span> <span data-start="462.4" data-end="466.78">you should not blindly go back to your old source code and just add the u flag to all</span> <span data-start="466.78" data-end="471.4">your own regular expression without thinking what you are doing because once again you</span> <span data-start="471.4" data-end="476.72">accidentally change their meaning in\ha very subtle way and possibly break your code.</span> <span data-start="476.72" data-end="483.81">Now let's talk about the impact on the dot pop operator. Now without the u flag, dot</span> <span data-start="483.81" data-end="492.22">matches any BMP symbol without line terminator. If you use a.bin\ha regular expression, it</span> <span data-start="492.22" data-end="497.84">won't match the tetragram for sender symbol, because that's an astral symbol as\hfar\has</span> <span data-start="497.84" data-end="502.65">JavaScript is concerned, that astral symbol consists of\hthe 2 surrogate halves, it treats</span> <span data-start="502.65" data-end="509.1">each of them as an individual character. This is a bit surprising, but all you need to do</span> <span data-start="509.1" data-end="514.18">is work around this behaviour is just enable the u flag ES6 that automatically makes the</span> <span data-start="514.18" data-end="520.01">dot operator work the way we would expect to\hit work in the first place.</span> </p>
<p><span data-start="520.01" data-end="526.17">Another thing that is effective is quantifiers, they are things like the plus sign the question</span> <span data-start="526.17" data-end="532.13">mark, numbers wrapped in braces indicate how\hmany times you want to repeat the previous part</span> <span data-start="532.13" data-end="538.21">of the regular expression, in this example we're matching 2 consecutive A symbols. This</span> <span data-start="538.21" data-end="543.64">works as expected, if you are trying to do the same thing using an astral symbol instead</span> <span data-start="543.64" data-end="548.3">it won't actually work, the result is now false instead of true.</span> <span data-start="548.3" data-end="553.43">That is because without the new flag if a quantifier follows an astral symbol, it only</span> <span data-start="553.43" data-end="558.14">applies to\hthe low surrogate of that symbol. As\hfar\has JavaScript is concerned, this</span> <span data-start="558.14" data-end="562.25">is what that regular expression looks like. You have the astral symbol represented by</span> <span data-start="562.25" data-end="568.05">a surrogate pair then there\his way easy to see that quantifier simply applies to only</span> <span data-start="568.05" data-end="571.8">the last part of the surrogate pair not to surrogate pair as a whole.</span> </p>
<p><span data-start="571.8" data-end="577.26">This again probably not what you want, or what you would expect, but it's really easy</span> <span data-start="577.26" data-end="582.87">to fix this, all you need\hto\hdo is just apply the u flag. This way quantifiers apply</span> <span data-start="582.87" data-end="589.01">to whole symbols even for astral symbols. So it's the only way to make sure that JavaScript</span> <span data-start="589.01" data-end="594.66">treats all code points equally. I believe that's part of the code of conduct at JSConfEU,</span> <span data-start="594.66" data-end="601.31">you are basically legally obliged to use the u flag from now on. Other way that’s different</span> <span data-start="601.31" data-end="606.8">is character classes. Without the u flag any given character class can only match a BMP</span> <span data-start="606.8" data-end="614.9">symbol, things like BCD work as expected they match either B or C or D if you try to add</span> <span data-start="614.9" data-end="621.69">an astral symbol to that class the JavaScript treats it again as two separate characters,</span> <span data-start="621.69" data-end="630.65">one for each half of the surrogate pair because of that tetragram for symbol is not matched</span> <span data-start="630.65" data-end="637.75">this again is a little bit confusing I\hthink. So as\hfar\has JavaScript is concerned this</span> <span data-start="637.75" data-end="644.17">is what regular expression looks like, the character class contains not 3 but 4 characters,</span> <span data-start="644.17" data-end="648.15">and that is why the result is false instead of true.</span> </p>
<p><span data-start="648.15" data-end="651.9">Now all you need\hto\hdo to fix it, well you guessed it all you need\hto\hdo\his add the</span> <span data-start="651.9" data-end="656.48">u flag to regular expression and that magically makes it work the way you expect to\hit, you</span> <span data-start="656.48" data-end="662.72">can now use a whole astral symbols in character classes. Now this also means that the whole</span> <span data-start="662.72" data-end="667.96">astral symbols can be used in character class ranges, and everything will still work the</span> <span data-start="667.96" data-end="671.279">way you would expect to\hit as long as the u flag is set.</span> <span data-start="671.279" data-end="675.42">in this case I'm trying to create a range from the pile of poo character to the busy</span> <span data-start="675.42" data-end="684.62">symbol, pile of poo and the busy symbol, it works the way I would expect it to.\h However,</span> <span data-start="684.62" data-end="692">if you omit the a flag if you tried this in ES 5 you would get an error.\h The regular</span> <span data-start="692" data-end="696.6">expression would throw and it would say the range is out of order in the character class,</span> <span data-start="696.6" data-end="701.92">that happens again, because of the same behaviour basically, so far as JavaScript is concerned</span> <span data-start="701.92" data-end="705.68">this is what that regular expression looks like you are creating a range between two</span> <span data-start="705.68" data-end="711.86">astral symbols each represented by a surrogate pair and JavaScript tries to create a range</span> <span data-start="711.86" data-end="717.5">between the first character and first surrogate for the second one it's not the range you</span> <span data-start="717.5" data-end="722.54">wanted to create in the first place, the first code point is a greater number than the second</span> <span data-start="722.54" data-end="728.72">one it also throws an error.\h Once again just use the u flag and all the problems go</span> <span data-start="728.72" data-end="731.86">away automatically. Now the u flag</span> <span data-start="731.86" data-end="738.93">also effects negated character classes, so for example, carat a character class matches</span> <span data-start="738.93" data-end="750.27">any BMP accept a, but not astral symbols JavaScript considers those to be too separate characters.</span> </p>
<p><span data-start="750.27" data-end="755.26">With the u flag enabled the very same regular expression now matches the best bigger set</span> <span data-start="755.26" data-end="763.07">of all Unicode symbols except\hfor a. \h\h\h\h\h\h\h\h\h\h\h \h\h\h\h\h Now, character</span> <span data-start="763.07" data-end="769.35">class escapes are impacted as well, backslash, lower case d, which matches any digit from</span> <span data-start="769.35" data-end="777.86">zero to 9, also backslash upper case D, matches the set nothing that's not a digit 0 — 9,</span> <span data-start="777.86" data-end="788.01">white space characters, you can match, or non-white space, backslash S for,/W, a word</span> <span data-start="788.01" data-end="794.25">charge defined as any character from A to Z in lower case or upper case, underscore</span> <span data-start="794.25" data-end="798.339">or digit from 0 — 9. Now the</span> <span data-start="798.339" data-end="807.67">U flag affects the meaning of these character class escapes with an upper case, so/d, /w,</span> <span data-start="807.67" data-end="814.57">without U+ flag these match any BMP symbol not matched by the lower case counterparts,</span> <span data-start="814.57" data-end="822.05">so for example,/S, matches any non-white space symbol, so it would match the character A</span> <span data-start="822.05" data-end="829.24">for example, but it wouldn't match an astral symbol like tetragram for centre and that</span> <span data-start="829.24" data-end="834.67">is because once again those are considered to be two separate characters in JavaScript,</span> <span data-start="834.67" data-end="842.37">this is probably not what you want.\h Now, with the u flag enabled,/D, S and W, they</span> <span data-start="842.37" data-end="848.19">match astral symbols too which makes a lot more sense.\h Now it's important to know that</span> <span data-start="848.19" data-end="853.68">in the verse counter points so the lower case d, sand w, they're not affected at all by</span> <span data-start="853.68" data-end="858.85">the a flag, there was in fact a proposal on ES discussed to change their meaning and make</span> <span data-start="858.85" data-end="866.279">them more Unicode aware,/d could match many more digits in many scripts not just o- nine</span> <span data-start="866.279" data-end="873.55">in Arabic, but other scripts, but it was rejected in favour of a bigger proposal I'll talk about</span> <span data-start="873.55" data-end="875.99">in a second. \h\h\h\h\h\h\h\h\h\h\h \h\h\h\h\h Now there</span> <span data-start="875.99" data-end="883.51">is another gotcha with this, essentially the act of converting upper case Unicode symbols</span> <span data-start="883.51" data-end="890.02">into lower case form, that's not just letters A to Z, that's pretty simple, but actually</span> <span data-start="890.02" data-end="895.31">you need to be aware of different scripts, different languages and Unicode standard defines</span> <span data-start="895.31" data-end="899.089">all these mappings for all the different code points.</span> </p>
<p><span data-start="899.089" data-end="902.83">Now when both the i flag for case insensitivity and</span> <span data-start="902.83" data-end="907.7">the a flag for Unicode are enabled, on the same regular expression all the symbols are</span> <span data-start="907.7" data-end="914.43">implicitly case folded before being compared, this might lead to surprising results every</span> <span data-start="914.43" data-end="917.529">now and then. \h\h\h\h\h\h\h\h\h\h\h \h\h\h\h\h So for example,</span> <span data-start="917.529" data-end="923.38">the regular expression where you match the range A to Z in lower case, you can enable</span> <span data-start="923.38" data-end="928.75">case insensitivity using the i flag, if you now enable the u flag as well, suddenly you</span> <span data-start="928.75" data-end="936.74">will also match the code point oh 17 F, it goes to the S, according to Unicode case folder,</span> <span data-start="936.74" data-end="944.69">same for A and 212 A, so this another one of the things you need to watch out for and</span> <span data-start="944.69" data-end="949.89">it's another reason not just to blindly add the a flag to your existing regular expressions</span> <span data-start="949.89" data-end="954.36">you might change their meaning this way. \h\h\h\h\h\h\h\h\h\h\h \h\h\h\h\h The case</span> <span data-start="954.36" data-end="958.72">folding logic I mentioned applies to the symbols in the regular expression pattern as well</span> <span data-start="958.72" data-end="964.31">as the symbols in the string to be matched, so it goes both ways.\h In general that's</span> <span data-start="964.31" data-end="970.14">petty useful behaviour, but in some cases it can be really, really confusing, for example,</span> <span data-start="970.14" data-end="979.93">by default /W, matches anything that is not matched by/w, it matches any non-word character,</span> <span data-start="979.93" data-end="990.12">but when both the I and the u flag the case folding logic kicks in, essentially, well,</span> <span data-start="990.12" data-end="997.85">/W which is supposed to match no word characters, now matches the capital letter K and S, it's</span> <span data-start="997.85" data-end="1001.29">probably weird, it's not what you would expect, it's another thing to watch out for when you</span> <span data-start="1001.29" data-end="1006.6">are using the u flag and another reason not to just blindly add to all your existing regular</span> <span data-start="1006.6" data-end="1012.43">expressions, make sure you are not using /W first.</span> </p>
<p><span data-start="1012.43" data-end="1015.85">Now believe it or not the existence of the a flag also</span> <span data-start="1015.85" data-end="1021.64">has its effect on HTML documents, the pattern attribute for input or exterior elements,</span> <span data-start="1021.64" data-end="1028.87">allows you to — the browser then provides with styling and scribing hooks to make stuff</span> <span data-start="1028.87" data-end="1032.929">happen on the validity of that input. \h\h\h\h\h\h\h\h\h\h\h \h\h\h\h\h Now the</span> <span data-start="1032.929" data-end="1038.86">u flag is always enabled for regular expressions compiled through HTML pattern, according to</span> <span data-start="1038.86" data-end="1046.919">the specification, la.w, use that as a pattern, the dot operator well match astral symbols</span> <span data-start="1046.919" data-end="1051.89">as well, just like we discussed before. \h\h\h\h\h\h\h\h\h\h\h \h\h\h\h\h Now what</span> <span data-start="1051.89" data-end="1059">about browser and engine support for new Unicode features.\h Microsoft edge is the only stable</span> <span data-start="1059" data-end="1065.76">browser with implementation of it, they support it in they Chakra engine, but not the HTML</span> <span data-start="1065.76" data-end="1072.03">pattern flag yet, however I filed a book on that, I can assume that they are working on</span> <span data-start="1072.03" data-end="1077.17">it, also an experimental version available, it's hidden behind the flag, you can play</span> <span data-start="1077.17" data-end="1084.82">around with it if you want to, there are a few minor bugs, but we're working on it, what</span> <span data-start="1084.82" data-end="1090.45">about all the other browsers, it would be a shame if we couldn't use u flag today, wouldn't</span> <span data-start="1090.45" data-end="1102.309">it, that's why I created RegExp, the ES 6 expressions using the u flag into ES 5 codes</span> <span data-start="1102.309" data-end="1109.67">that work day-to-day so you can start using the u flag today, you may actually have noticed</span> <span data-start="1109.67" data-end="1115.92">that the Babel transpilers both support the a flag as well, if you use a regular expression</span> <span data-start="1115.92" data-end="1128.57">with the u flag they will translate it into ES 5 regular.\h The good news is if you are</span> <span data-start="1128.57" data-end="1133.4">using a transpiler as part of the build process you don't have to do anything, you can start</span> <span data-start="1133.4" data-end="1137.73">using the u flag today. \h\h\h\h\h\h\h\h\h\h\h \h\h\h\h\h Now, just</span> <span data-start="1137.73" data-end="1145.99">to give quickly give you an idea of how RegExPu works internally, we need to borrow JavaScript</span> <span data-start="1145.99" data-end="1155.11">code, we need source code to put that into abstract syntax tree, I used the esprima</span> <span data-start="1155.11" data-end="1167.03">parser for this.\h Then I look for regular expressions, literals in that EST that have</span> <span data-start="1167.03" data-end="1175.679">the u flag enabled, once I found such a regular expression, I parsed it, it self, using another</span> <span data-start="1175.679" data-end="1188.299">parser, — it was originally a regular expression parser of course for this progress I needed</span> <span data-start="1188.299" data-end="1202.61">to support ECMA 6 as well, like the u flag — 
finally we rewrite each regular expression</span> <span data-start="1202.61" data-end="1210.75">without u flag so it's equivalent, but compatible with ES5, I use regenerate for that and no</span> </p>
<p><span data-start="1210.75" data-end="1217.94">Unicode data, some data packages I will give you an example of this later.</span> <span data-start="1217.94" data-end="1223.5">Then we update the regular expression abstract syntax tree then we transform the regular</span> <span data-start="1223.5" data-end="1228.95">expression syntax tree back into regular expression literal. You could use the GN project for</span> <span data-start="1228.95" data-end="1236.169">that. Then finally we update our original JavaScript abstract tree so\hit contains the</span> <span data-start="1236.169" data-end="1244.51">new regular expression. I do this, it makes it really easy, transforming the JavaScript</span> <span data-start="1244.51" data-end="1250.86">abstract syntax tree back into JavaScript code. That's it at the end. We started out</span> <span data-start="1250.86" data-end="1256.15">with ES6 code that uses lots of ES6 features and u flag for regular expression, at the</span> <span data-start="1256.15" data-end="1263.11">end ECMAScript 5 compatible code comes out. Now for something that still no built in syntax</span> <span data-start="1263.11" data-end="1269.6">in ECMAScript 6 even with the u flag, for\hexample, Unicode provides a\hlot of data files for</span> <span data-start="1269.6" data-end="1274.95">categories, scripts, blocks and properties, but there’s no way to access that data directly</span> <span data-start="1274.95" data-end="1279.4">in regular expressions. So for\hexample let's say you want\hto match all\hthe Unicode symptoms</span> <span data-start="1279.4" data-end="1286.14">in\hthe Greek script. One way to do this is to use the third party library like exRegExp</span> <span data-start="1286.14" data-end="1292.82">that would look like this so you just use the \p syntax, then between the braces you</span> <span data-start="1292.82" data-end="1299.14">can use the name of a property or a category or a block, and exRegExp will care of that</span> <span data-start="1299.14" data-end="1305.89">for you. know the I am also parsing the character a there, a flag that stands for astral symbol</span> <span data-start="1305.89" data-end="1314.57">support, a custom flag that it makes it really easy to match all Greek symbols. There’s</span> <span data-start="1314.57" data-end="1322.03">only one down side to this, it's that exRegExp is a 35kb runtime, it may not be the best</span> <span data-start="1322.03" data-end="1328.01">solution in performance critical situations. There's another way of coming up with a similar</span> <span data-start="1328.01" data-end="1334.59">result, you could just build a script use the regenerate library I talked about earlier.</span> </p>
<p><span data-start="1334.59" data-end="1339.91">That would look something like this, so you write a script like that you require, regenerate,</span> <span data-start="1339.91" data-end="1347.12">then you use the node Unicode data modules that basically contain arrays of Unicode symbols</span> <span data-start="1347.12" data-end="1352.09">and points. I am getting\han array containing all\hthe symbols and the Greek scripts according</span> <span data-start="1352.09" data-end="1358.15">to Unicode version 6.30, I am parsing that array into regenerate. That gives me a set</span> <span data-start="1358.15" data-end="1363.78">of characters or code points and then I turn that into a regular expression or, well actually</span> <span data-start="1363.78" data-end="1369.74">a string I can use as part of a regular expression literal. It gives me this result. Again this</span> <span data-start="1369.74" data-end="1374.1">not a regular expression that I would enjoy writing out by hand let alone testing it or</span> <span data-start="1374.1" data-end="1379.01">maintaining it. You may have noticed I am actually using an outdated Unicode version</span> <span data-start="1379.01" data-end="1385.5">here, this is version 6.3.0, but the latest version is version 8. Imagine having to update</span> <span data-start="1385.5" data-end="1389.83">this regular expression manually without having this build script of 4 lines it would be a\hlot</span> <span data-start="1389.83" data-end="1394.79">of work. Now I have the small scripts, all\hI need\hto\hdo is change the version number,</span> <span data-start="1394.79" data-end="1400.53">run the script again, just like that an up-to-date regular expression comes out.</span> </p>
<p><span data-start="1400.53" data-end="1407.37">Now, hopefully in\ha future version of ECMAScript there will\hbe built in support for the \p</span> <span data-start="1407.37" data-end="1415.91">syntax that Pearl already supports, that way you could already use \p to match all\hthe</span> <span data-start="1415.91" data-end="1422.52">symbols in\hthe Greek script, then it would just work as long as you use the u flag. The</span> <span data-start="1422.52" data-end="1427.7">thing is everyone agrees it's a very big proposal, everyone wants to do this but the problem</span> <span data-start="1427.7" data-end="1432.24">is that someone needs to do the work and write the specification for it so if you are interested</span> <span data-start="1432.24" data-end="1435.309">in that come talk to me afterwards, we'll make it happen.</span> <span data-start="1435.309" data-end="1442.76">Anyway, the main takeaways here are you should use the u flag when you can for all the regular</span> <span data-start="1442.76" data-end="1447.75">expressions you write from now on. I\hthink remember the u flag is to regular expression</span> <span data-start="1447.75" data-end="1454.299">as strict mode is to all of JavaScript. Now, you also should\hnot blindly add the</span> <span data-start="1454.299" data-end="1458.63">u flag to your existing regular expression, you might accidentally change their meaning</span> <span data-start="1458.63" data-end="1465.86">in very subtle ways that might actually break your code. Finally, we should use a transpiler,</span> <span data-start="1465.86" data-end="1470.559">because this way your ES6 code runs everywhere. You shouldn't just use a transpiler for these</span> <span data-start="1470.559" data-end="1476.09">particular features but for many other features as well, of\hcourse Babel and Tracer, they</span> <span data-start="1476.09" data-end="1483.46">both already support transpilation of the u flag thanks\hto RegExpu. Whenever you need</span> <span data-start="1483.46" data-end="1491.049">a regular expression based on some unicode category or a property or a script, you should just write a simple build script that use regenerate</span> <span data-start="1491.049" data-end="1509.22">and build it and use xRegExp\hat runtime. Thank you. \{applause\}</span> </p>
<p><span data-start="1509.22" data-end="1514.38">There is a blogpost at that URL which basically details the same thing I talked about in this presentation,</span> </p>
</section>