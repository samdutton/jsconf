<section>
<p><span data-start="9.46" data-end="14.96">Thank you very much, Rachel, and welcome to my talk, JavaScript engines, the good parts.</span> <span data-start="14.96" data-end="21.56">Initially, I was going to give this talk together with Bryan Tilson from Microsoft — you know,</span> <span data-start="21.56" data-end="27.01">nice guy, blond hair, working on a JavaScript VM.</span> <span data-start="27.01" data-end="33.6">Then life happened, and now I'm standing here alone.</span> <span data-start="33.6" data-end="39.25"Audience member: What are you talking about?</span> <span data-start="39.25" data-end="44.739">I'm right here, man!</span> <span data-start="44.739" data-end="46.109">[Applause].</span> <span data-start="46.109" data-end="47.489">[Laughter].</span> <span data-start="47.489" data-end="48.489"Audience member: This is weird.</span> </p>
</section>

<section>
<p><span data-start="48.489" data-end="50.399"><span class="speaker">Benedikt</span>: Now we have two Bryan lookalikes.</span> <span data-start="50.399" data-end="54.59">I can't do a talk with both of you.</span> <span data-start="54.59" data-end="58.469"Audience member: Thank you for the cameo.</span> <span data-start="58.469" data-end="60.95"Audience member: Thank you.</span> <span data-start="60.95" data-end="62.199">[Laughter].</span> <span data-start="62.199" data-end="65.93"Audience member: Applause for Peter!</span> <span data-start="65.93" data-end="67.18">[Applause].</span> </p>
<p><span data-start="67.18" data-end="69.99">With that out of the way, let's get started with the actual presentation.</span> <span data-start="69.99" data-end="72.59">JavaScript engines, the good parts.</span> <span data-start="72.59" data-end="77.829">Nowadays, JavaScript runs not only in web browsers but also in Node.js, in react Native,</span> <span data-start="77.829" data-end="85.579">in Electron, and on IoT devices, and I've even been told it runs in space.</span> <span data-start="85.579" data-end="88.34">It is everywhere nowadays.</span> <span data-start="88.34" data-end="93.6">As a developer, learning JavaScript, or improving your JavaScript skills, is an excellent time</span> <span data-start="93.6" data-end="99.83">investment, so, let's take a look today behind the scenes of how JavaScript engines work.</span> <span data-start="99.83" data-end="100.83">This is V8.</span> <span data-start="100.83" data-end="105.36">It is the JavaScript engine used in Google Carol, Node.js, and Electron, for example.</span> <span data-start="105.36" data-end="111.01">Recently, we've been speaking about how V8 works behind the scenes.</span> <span data-start="111.01" data-end="115.04">However, it's not just V8 out there, there are more out there.</span> <span data-start="115.04" data-end="117.799">We are going to do a little bit different today.</span> <span data-start="117.799" data-end="122.2"Audience member: Yes, actually, we are going to look at some of the fundamentals that are common to</span> <span data-start="122.2" data-end="124.7">all the JavaScript engines out there.</span> </p>
<p><span data-start="124.7" data-end="130.08">These fundamentals make it possible to write these amazing applications we see today and</span> <span data-start="130.08" data-end="132.76">of which we've heard a lot at this conference already.</span> <span data-start="132.76" data-end="139.87">Starring with that, it's not just V8, there is an engine called SpiderMonkey which powers</span> <span data-start="139.87" data-end="149.75">Firefox, and fun fact: there is even a node fork using SpiderMonkey called SpiderNode.</span> <span data-start="149.75" data-end="157.91"Audience member: Then there is Microsoft's in Edge called Chakra and the main part is open source.</span> </p>
<p><span data-start="157.91" data-end="164.74">There is a node chakra core project powered by that rather than V8.</span> <span data-start="164.74" data-end="171.88"Audience member: There is also JSC, or JavaScript core, which is the engine that was originally built</span> <span data-start="171.88" data-end="178.84">for webkit, and is nowadays powering Safari but React Native applications.</span> <span data-start="178.84" data-end="181.25">These are the major JavaScript applications out there.</span> <span data-start="181.25" data-end="185.44">If you want to play around with any of these engines directly, which is without going through</span> <span data-start="185.44" data-end="193.49">an embedder or Node.js, then you can use — you install it globally, you follow the readme</span> <span data-start="193.49" data-end="200.75">instructions before after that, you can run V8 SpiderMonkey, Chakra, straight from the</span> <span data-start="200.75" data-end="201.75">command line.</span> </p>
<p><span data-start="201.75" data-end="206.33">The JavaScript you run in there will run directly in the engine itself.</span> <span data-start="206.33" data-end="209.97">Now that you have these JavaScript engines installed on your system, let's look what</span> <span data-start="209.97" data-end="211.57">they have in common.</span> <span data-start="211.57" data-end="215.73">It starts with the JavaScript code that you write.</span> <span data-start="215.73" data-end="227.26">The engine parses it into a source, the AST, into the interpreter which can do its thing.</span> <span data-start="227.26" data-end="229.86">At this point, the engine is running your JavaScript code.</span> <span data-start="229.86" data-end="234.76">However, to make it run more smoothly and efficiently, there is also an optimiser compiler</span> <span data-start="234.76" data-end="240.7">pipeline, so the byte code gets fed into the optimiser compiler, alongside profiling data</span> <span data-start="240.7" data-end="245.26">that we collect while the code is running, and that way, the optimiser compiler can make</span> <span data-start="245.26" data-end="249.68">some assumptions based on the profiling data and generate highly optimised machine code</span> <span data-start="249.68" data-end="251.7">that runs more efficiently.</span> </p>
<p><span data-start="251.7" data-end="255.04">If one of those assumptions turns out to be incorrect later, it's no big deal because</span> <span data-start="255.04" data-end="260.479">we can de-optimise and fall back through the byte code through the interpreter.</span> <span data-start="260.479" data-end="264.65">So let's focus on the important part here, which is the part where the code actually</span> <span data-start="264.65" data-end="266.84">gets run.</span> <span data-start="266.84" data-end="273.03">Each JavaScript engine has some kind of pipeline with an interpreter and an optimiser compiler</span> <span data-start="273.03" data-end="274.04">pipeline.</span> <span data-start="274.04" data-end="277.74">The interpreter generates byte code and the optimising compiler generates highly optimised</span> <span data-start="277.74" data-end="278.779">machine code.</span> <span data-start="278.779" data-end="280.83"Audience member: You just stole my punch line.</span> <span data-start="280.83" data-end="282.8">This was the V8 slide.</span> </p>
<p><span data-start="282.8" data-end="285.18">So, actually, that's exactly how V8 works.</span> <span data-start="285.18" data-end="290.169">Our interpreter is named Ignition, and the interpreter is responsible for generating</span> <span data-start="290.169" data-end="291.75">and executing the byte code.</span> <span data-start="291.75" data-end="297.569">And, as it is executing the byte code, it collects profiling data, and, when a function</span> <span data-start="297.569" data-end="302.889">gets hot — so let's say you call it a couple of times, then we feed it to our optimising</span> <span data-start="302.889" data-end="307.83">compiler, and that using the profiling data to generate highly optimising machine code.</span> <span data-start="307.83" data-end="310.43"Audience member: I love hot functions.</span> </p>
<p><span data-start="310.43" data-end="312.189">SpiderMonkey does it differently.</span> <span data-start="312.189" data-end="317.49">They have two optimising compilers, so the interpreter optimises into the baseline compiler</span> <span data-start="317.49" data-end="320.47">which produced at a somewhat optimised code.</span> <span data-start="320.47" data-end="327.479">While that is running it gets run through the iron monkey optimising compiler which</span> <span data-start="327.479" data-end="329.729">produces even more highly optimised machine code.</span> <span data-start="329.729" data-end="331.84"Audience member: You did it again.</span> <span data-start="331.84" data-end="334.819">This is exactly Chakra core, except they have different names.</span> </p>
<p><span data-start="334.819" data-end="343.71">In Chakra core, the first optimising compiler is a just-in-time compiler and generates somewhat</span> <span data-start="343.71" data-end="344.84">optimised code.</span> <span data-start="344.84" data-end="354.759">When a function gets really hot, then it feeds it to fulgit and this generates awesome code.</span> <span data-start="354.759" data-end="359.509"Audience member: Then JSC uses three optimising compilers.</span> <span data-start="359.509" data-end="364.699">It starts with LLint, the low-level interpreter which produces the byte code, and, from there,</span> <span data-start="364.699" data-end="369.539">they can optimise into the baseline compiler which produces somewhat optimised code.</span> <span data-start="369.539" data-end="373.87">From this baseline compiler, based on some heuristics they can optimise into the DFG</span> <span data-start="373.87" data-end="377.169">compiler or the FDL compiler.</span> </p>
<p><span data-start="377.169" data-end="382.319">So, based, let's look at all what else all these JavaScript engines have in common by</span> <span data-start="382.319" data-end="387.569">zooming in on some aspects and how they implement in common, because, besides these difference</span> <span data-start="387.569" data-end="391.46">that is we just discussed at a very high level, all engines follow the same architecture,</span> <span data-start="391.46" data-end="398.729">they have some kind of parser, and an interpreter compiler pipeline.</span> <span data-start="398.729" data-end="402.43">For example, how do JavaScript engines implement the JavaScript object model?</span> <span data-start="402.43" data-end="406.569">And which tricks do they use to speed up accessing properties and objects?</span> <span data-start="406.569" data-end="409.699">As it turns out, all major engines implement this more or less similarly.</span> <span data-start="409.699" data-end="415.379"Audience member: But, wait, isn't it the case that all objects in JavaScript are just dictionaries?</span> <span data-start="415.379" data-end="416.63"Audience member: That is true.</span> <span data-start="416.63" data-end="422.9">If you look at the JavaScript pack, objects are dictionaries with string keys, and the</span> <span data-start="422.9" data-end="427.879">string keys map to not just the value but to something the spec calls property attributes.</span> <span data-start="427.879" data-end="434.469">In this example, the X and the Y are string keys in a dictionary, according to the spec.</span> <span data-start="434.469" data-end="439.55">The five and six values are just values within the property attributes for.property.</span> </p>
<p><span data-start="439.55" data-end="445.34">Other than the value, attributes can store whether the property is writable, numerable,</span> <span data-start="445.34" data-end="446.719">or configurable.</span> <span data-start="446.719" data-end="451.41">This is not something that JavaScript make up but part of the spec.</span> <span data-start="451.41" data-end="455.46">Writable determines whether the property can be reassigned to, innumerable, means that</span> <span data-start="455.46" data-end="461.37">the property can show up in loops, and configurable means it is a deletable property.</span> <span data-start="461.37" data-end="465.55">You can get to this property attribute in JavaScript for any object and any property</span> <span data-start="465.55" data-end="469.36">by using the object.getonlyproperty descriptor API.</span> <span data-start="469.36" data-end="470.36">Interesting.</span> <span data-start="470.36" data-end="473.08"Audience member: That's how JavaScript sees objects.</span> <span data-start="473.08" data-end="474.869">What if we take arrays?</span> <span data-start="474.869" data-end="481.819"Audience member: You can think of them as special objects with one difference: they have special handling</span> <span data-start="481.819" data-end="483.369">for array indices.</span> <span data-start="483.369" data-end="485.689"Audience member: What is an array index?</span> <span data-start="485.689" data-end="487.729"Audience member: It's a spec architectural.</span> </p>
<p><span data-start="487.729" data-end="493.069">They are limited to the two to the power of 32 minus one item, so that is the maximum</span> <span data-start="493.069" data-end="494.43">array length you can have.</span> <span data-start="494.43" data-end="501.74">An array ending is any valid integer within that range to the power of two to the 32,</span> <span data-start="501.74" data-end="502.74">minus two.</span> <span data-start="502.74" data-end="506.259"Audience member: Not every integer is a valid area index?</span> <span data-start="506.259" data-end="507.259"Audience member: Exactly.</span> <span data-start="507.259" data-end="508.819"Audience member: You mentioned more differences?</span> <span data-start="508.819" data-end="512.659"Audience member: Another difference is the imaginal length property that arrays have.</span> <span data-start="512.659" data-end="513.659"Audience member: Magic?</span> <span data-start="513.659" data-end="515.039"Audience member: It is pure magic.</span> <span data-start="515.039" data-end="518.06">If you look at this example, the array has a length of two in the beginning.</span> <span data-start="518.06" data-end="522.39">Then we add another item to the array, and automatically, the line property is updated.</span> </p>
<p><span data-start="522.39" data-end="527.04">JavaScript's spec defines how this engines have to do this automatically in the background.</span> <span data-start="527.04" data-end="531.35">As a JavaScript developer, you have to manually update it.</span> <span data-start="531.35" data-end="533.85">So let's take a look at how JavaScript defines arrays.</span> <span data-start="533.85" data-end="536.13">This is stored similarly to objects.</span> <span data-start="536.13" data-end="551.83">For example, all the keys, including the array indexes are strings, so the first [sound feed</span> <span data-start="551.83" data-end="556.73">distorted].</span> <span data-start="556.73" data-end="565.75"Audience member: Okay, that looks really spectacular to the object.</span> <span data-start="565.75" data-end="571.75">[Sound feed distorted].</span> <span data-start="571.75" data-end="579.67">Most common operation in these problems is the property .. I guess we had better make</span> <span data-start="579.67" data-end="580.85">that fast.</span> <span data-start="580.85" data-end="587.62">And, in fact, what we see in the wild is that most objects in the same programme tend to</span> <span data-start="587.62" data-end="592.571">have the same property keys, at least there is a set of objects that have the same, so</span> <span data-start="592.571" data-end="595.53">you could say that all of them have the same shape.</span> <span data-start="595.53" data-end="596.53"Audience member: Right.</span> <span data-start="596.53" data-end="597.53">That makes sense.</span> </p>
<p><span data-start="597.53" data-end="601.45">It is also very common to access the same property on different objects that have the</span> <span data-start="601.45" data-end="602.45">same shape.</span> <span data-start="602.45" data-end="606.74">So, with that in mind, JavaScript engines can optimise object property access based</span> <span data-start="606.74" data-end="607.96">on these shapes.</span> <span data-start="607.96" data-end="610.4">So let's take a look at how that works.</span> <span data-start="610.4" data-end="616.91"Audience member: Okay, let's assume we have this one object here which has properties X and Y.</span> <span data-start="616.91" data-end="620.56">It's represented using this dictionary data structure that we saw before.</span> <span data-start="620.56" data-end="626.19">So be the X and Y are stored as strings in the dictionary, and point to the property</span> <span data-start="626.19" data-end="629.34">attributes for these individual properties.</span> <span data-start="629.34" data-end="633.53">If you then write something like object.y in your programme, the engine has to reach</span> <span data-start="633.53" data-end="640.39">out to the JS object, find the key inside of it, reach out to the property attributes,</span> <span data-start="640.39" data-end="642.2">and eventually, load the value from it.</span> <span data-start="642.2" data-end="645.011"Audience member: Okay, so where are these property attributes stored?</span> </p>
<p><span data-start="645.011" data-end="648.84">Stored them as part of the JS object data structure itself?</span> <span data-start="648.84" data-end="651.1">That seems wasteful.</span> <span data-start="651.1" data-end="657.24">If we expect more objects to have the same shape, you would end up duplicating that information</span> <span data-start="657.24" data-end="658.66">for every single object.</span> <span data-start="658.66" data-end="659.69">That seems wasteful memory-wise.</span> <span data-start="659.69" data-end="662.18"Audience member: That's a good observation.</span> <span data-start="662.18" data-end="665.97">I think some people made this observation already.</span> <span data-start="665.97" data-end="670.87">At least this is kind of how we represent it in JavaScript engines nowadays.</span> <span data-start="670.87" data-end="677.24">What we do is that the engine stores the shape separately from the value of the attributes.</span> <span data-start="677.24" data-end="684.97">In this case, the shape describes which properties you have, and which property attributes you</span> <span data-start="684.97" data-end="687.39">have on this, except for the value.</span> <span data-start="687.39" data-end="693.52">So, instead, the property information contains the offset where you find the value inside</span> <span data-start="693.52" data-end="697.48">of the JS object, the offset where you find the value.</span> </p>
<p><span data-start="697.48" data-end="702.68">It totally makes sense when you start to look at multiple objects that have the same shape.</span> <span data-start="702.68" data-end="708.22">Now you only need one instance of this shape, and the object only contained the information</span> <span data-start="708.22" data-end="714.06">that is unique to this object, so you don't repeat this information that is common anyway.</span> <span data-start="714.06" data-end="717.841"Audience member: So even if we have a million objects, there will only be one shape as they all have the</span> <span data-start="717.841" data-end="720.55">same shame and point to the same one?</span> <span data-start="720.55" data-end="721.55"Audience member: That's true.</span> <span data-start="721.55" data-end="722.98"Audience member: It seems like it would save a lot of memorial.</span> <span data-start="722.98" data-end="726.09"Audience member: I hope so, yes.</span> <span data-start="726.09" data-end="729.66">This is not even something that JavaScript engines made up, this happened before.</span> <span data-start="729.66" data-end="732.73">So, like, there's been a lot of research on this.</span> <span data-start="732.73" data-end="738.2">If you look at academic papers, they're not called shapes but hidden classes.</span> <span data-start="738.2" data-end="743.42"Audience member: That would be a confusing name in a JavaScript engine because they're already a name in JavaScript.</span> <span data-start="743.42" data-end="745.81"Audience member: V8 calls them maps.</span> <span data-start="745.81" data-end="747.16"Audience member: It is the same problem.</span> <span data-start="747.16" data-end="748.52">It is a terrible name!</span> <span data-start="748.52" data-end="751.12"Audience member: How about times for Chakra core.</span> <span data-start="751.12" data-end="752.42"Audience member: That's not confusing at all.</span> <span data-start="752.42" data-end="754.86"Audience member: I can offer structure for JSC.</span> <span data-start="754.86" data-end="757.42"Audience member: I like the name "structure", with , that is what makes sense.</span> </p>
<p><span data-start="757.42" data-end="760.3">I will keep calling them shapes because that is what SpiderMonkey.</span> <span data-start="760.3" data-end="763.2">I like the nail.</span> <span data-start="763.2" data-end="768.67">It seems like a common thing if you have an object to add a property to it.</span> <span data-start="768.67" data-end="772.79">So what if you have an object with a certain shape, you add a property to it, how does</span> <span data-start="772.79" data-end="775.02">the JavaScript engine find the new shape?</span> <span data-start="775.02" data-end="779.76"Audience member: So, what JavaScript engines do is that that the shapes inside of the engine form</span> <span data-start="779.76" data-end="782.54">so-called transition chains.</span> <span data-start="782.54" data-end="785.22">Let me run you through the example quickly.</span> <span data-start="785.22" data-end="787.87">Let's assume we start with the empty object.</span> <span data-start="787.87" data-end="793.1">This object initially points to the empty shape that doesn't have any property on this.</span> <span data-start="793.1" data-end="797.25">Now you start adding a property to it, like in our case, we add X.</span> <span data-start="797.25" data-end="803.27">It means we transition to a new shape that has the property X on it, with the property</span> <span data-start="803.27" data-end="808.88">information, and away append the value for this property to the object, and then we record</span> <span data-start="808.88" data-end="813.11">inside of the shape, inside of the property information that this value can be found at</span> <span data-start="813.11" data-end="814.93">offset zero now.</span> <span data-start="814.93" data-end="819.23">So let's say we add yet another property to it, like this case, Y.</span> </p>
<p><span data-start="819.23" data-end="823.3">Then we do the same as before, we introduce a new shape that contains this new property,</span> <span data-start="823.3" data-end="829.54">in addition to the X property, and we append the value to the object, and we record to</span> <span data-start="829.54" data-end="832.11">the value can be found at offset 1.</span> <span data-start="832.11" data-end="837.84">However, if we do this, then we might waste a lot of space, because we repeat the fall</span> <span data-start="837.84" data-end="841.6">table all the tile.</span> <span data-start="841.6" data-end="844.63"Audience member: Repeating X like all the information for X is duplicated.</span> <span data-start="844.63" data-end="847.63"Audience member: All the information for X is duplicated.</span> <span data-start="847.63" data-end="849.63">That's not really what engines do.</span> </p>
<p><span data-start="849.63" data-end="855.43">Instead, what you do is you just remember the information about the new property that</span> <span data-start="855.43" data-end="856.55">was added.</span> <span data-start="856.55" data-end="857.55"Audience member: Right.</span> <span data-start="857.55" data-end="860.4"Audience member: We don't have to repeat the information for X because we can just find it earlier</span> <span data-start="860.4" data-end="861.449">in the chain.</span> <span data-start="861.449" data-end="866.33"Audience member: That's the trick, so, we introduce a back link to the previous shape so you can walk</span> <span data-start="866.33" data-end="870.83">the transition chain backwards until you find the shape that changes the property and then</span> <span data-start="870.83" data-end="876.38">you know where to look into the object.</span> <span data-start="876.38" data-end="880.82">Just looking at this example, if you now need to find X on it, you would start at the last</span> <span data-start="880.82" data-end="884.88">shape, and you see okay, this is not the one I'm looking for because it introduces Y.</span> <span data-start="884.88" data-end="887.86">You walk back once, and there is X. Awesome.</span> <span data-start="887.86" data-end="889.62">I know where to find it.</span> <span data-start="889.62" data-end="895.09"Audience member: That's what happened when you type o.x in JavaScript.</span> <span data-start="895.09" data-end="897.56">What if you have two objects with the same shape.</span> <span data-start="897.56" data-end="900.11">You have two properties to each of them.</span> </p>
<p><span data-start="900.11" data-end="905.17">There is no way to chain the shapes?</span> <span data-start="905.17" data-end="913.73"Audience member: We have instead transition trees, and we branch off in various ways from shapes.</span> <span data-start="913.73" data-end="915.57">Let's look at this example.</span> <span data-start="915.57" data-end="917.35">This is what we learned before already.</span> <span data-start="917.35" data-end="918.61">We have the MP object.</span> <span data-start="918.61" data-end="924.98">We introduce X on it which means we introduce two shapes from a single chain to the shape</span> <span data-start="924.98" data-end="926.91">that contains X.</span> </p>
<p><span data-start="926.91" data-end="932.73">If we ran the second line of code, if we start again with an empty object, and we add a property</span> <span data-start="932.73" data-end="938.49">Y to it, we branch off the empty shape with the property Y, and we end up with a tree</span> <span data-start="938.49" data-end="942.5">that ends up with a total of three shapes in two chains.</span> <span data-start="942.5" data-end="943.5"Audience member: Right.</span> <span data-start="943.5" data-end="948.69">So does that mean if we walk up the shape tree, we always end up at the empty shape?</span> <span data-start="948.69" data-end="950.01"Audience member: No.</span> </p>
<p><span data-start="950.01" data-end="951.01">Not necessarily.</span> <span data-start="951.01" data-end="953.7">There is always an exception to the rule.</span> <span data-start="953.7" data-end="959.36">And the reason is that JavaScript engines have special treatment for object literals</span> <span data-start="959.36" data-end="962.94">that already introduce properties from the get-go.</span> <span data-start="962.94" data-end="967.74">Like in this case, the first thing is what we saw before, we start with the empty object</span> <span data-start="967.74" data-end="973.48">and then add X to it, and the second line is we start with an object that contains an</span> <span data-start="973.48" data-end="974.48">X.</span> <span data-start="974.48" data-end="979.59">And you can imagine that it might be a bit faster just to construct objects with the</span> <span data-start="979.59" data-end="981.31">property on it already.</span> </p>
<p><span data-start="981.31" data-end="988.05">So, what we end up, for example, in V8, and in SpiderMonkey, is this is the first case</span> <span data-start="988.05" data-end="994.31">that we know, so, here we start from the empty object, and we add X to it later.</span> <span data-start="994.31" data-end="997.47">That is exactly what we had before.</span> <span data-start="997.47" data-end="1002.38">But now, the second example we start with an object that already contains X from the</span> <span data-start="1002.38" data-end="1007.37">beginning, so we introduce a new root shape that already contains this X.</span> <span data-start="1007.37" data-end="1010.04">And we don't branch it off the empty shape.</span> <span data-start="1010.04" data-end="1012.85"Audience member: We can skip over that empty shape altogether in this case.</span> <span data-start="1012.85" data-end="1014.13"Audience member: That's true.</span> <span data-start="1014.13" data-end="1019.29">The reason why we do this is to keep the transition chains short, because otherwise, it is a lot</span> <span data-start="1019.29" data-end="1023.96">of metadata that we waste, and also because it is more efficient to construct objects</span> <span data-start="1023.96" data-end="1024.989">this way.</span> <span data-start="1024.989" data-end="1026.37"Audience member: It sounds super familiar.</span> </p>
<p><span data-start="1026.37" data-end="1029.169">Didn't you write a blog post about this?</span> <span data-start="1029.169" data-end="1032.169"Audience member: Shameless plug — yes, I did!</span> <span data-start="1032.169" data-end="1036.88">I actually published a blog post last year about this where I tried to highlight how</span> <span data-start="1036.88" data-end="1041.459">these subtleties with the shapes can have effects on real-world performance, especially</span> <span data-start="1041.459" data-end="1044.11">to be — for common applications.</span> <span data-start="1044.11" data-end="1046.559"Audience member: I read that blog post.</span> <span data-start="1046.559" data-end="1049.259">It talks about these things called ICs.</span> <span data-start="1049.259" data-end="1050.259">What are those?</span> <span data-start="1050.259" data-end="1052.879"Audience member: That is actually the magic inside of the engine.</span> <span data-start="1052.879" data-end="1054.22">No, it's the not!</span> <span data-start="1054.22" data-end="1055.57">It is more magic.</span> <span data-start="1055.57" data-end="1061.559">It stands for "inline cache" which are the key ingredients which is necessary to make</span> <span data-start="1061.559" data-end="1066.029">JavaScript run fast, and also the main motivation for actually having shapes.</span> <span data-start="1066.029" data-end="1069.33"Audience member: So how do these ICs work exactly?</span> <span data-start="1069.33" data-end="1075.46"Audience member: So JavaScript engines use ICs to memorise information where to find properties on objects,</span> <span data-start="1075.46" data-end="1080.21">so that we don't need to repeat expensive property look-up on each property access.</span> <span data-start="1080.21" data-end="1082.419"Audience member: Okay, so how does that work?</span> <span data-start="1082.419" data-end="1088.32"Audience member: Okay, let me run you through this example we have a function get.x which takes an object</span> <span data-start="1088.32" data-end="1092.07">o and logs the property x from it.</span> <span data-start="1092.07" data-end="1094.7"Audience member: That seems a common thing to do, get a property somewhere?</span> <span data-start="1094.7" data-end="1097.759"Audience member: Yes, I think I've seen it in the wild.</span> </p>
<p><span data-start="1097.759" data-end="1102.809">If we feed this to a JavaScript core, then it generates the following byte code which</span> <span data-start="1102.809" data-end="1110.12">contains two instructions: the get by ID instruction which has the property ID look-up, loads X</span> <span data-start="1110.12" data-end="1115.83">from arc one, first argument, which is 0, and stores the result into lock zero, and</span> <span data-start="1115.83" data-end="1119.959">the next instruction just returns whatever is in lock zero.</span> <span data-start="1119.959" data-end="1124.6"Audience member: This makes sense but how do ICs come into play here?</span> <span data-start="1124.6" data-end="1126.02"Audience member: It's not just that.</span> <span data-start="1126.02" data-end="1131.919">JC introduces an inline cache into the byte code, so, in this case by the get by ID instructions.</span> <span data-start="1131.919" data-end="1137.93">This IC contains two un initialised slots initially.</span> <span data-start="1137.93" data-end="1146.679">When we call this function, let's say we call it with an object, X:a.</span> <span data-start="1146.679" data-end="1154.179">In this case, the property value for X is founded opposite zero.</span> <span data-start="1154.179" data-end="1156.499">Now we invoke the function with this.</span> </p>
<p><span data-start="1156.499" data-end="1161.9">We need to reach out to the shape of this object, search for X inside, load the property</span> <span data-start="1161.9" data-end="1166.159">information from it, determine the offset, then go back to the object, and load whatever</span> <span data-start="1166.159" data-end="1167.859">is set at offset zero.</span> <span data-start="1167.859" data-end="1169.7"Audience member: That sounds like a lot of work.</span> <span data-start="1169.7" data-end="1170.7"Audience member: It is.</span> </p>
<p><span data-start="1170.7" data-end="1174.73">Since the engine already did this work, it makes a lot of sense to memorise the information</span> <span data-start="1174.73" data-end="1177.169">we can reuse on the next call for this function.</span> <span data-start="1177.169" data-end="1182.139">Let's say we call it — it makes a lot of sense to recall the information for the next</span> <span data-start="1182.139" data-end="1183.139">call.</span> <span data-start="1183.139" data-end="1187.49">What we do is we memorise the shape that we have seen, and also the offset at which we</span> <span data-start="1187.49" data-end="1190.74">found X inside of this shape.</span> <span data-start="1190.74" data-end="1196.21">When we then call this function again with an object that has the same shape, we only</span> <span data-start="1196.21" data-end="1198.039">need to check, "Oh, it's the same shape.</span> <span data-start="1198.039" data-end="1200.73">No, it is already offset zero."</span> </p>
<p><span data-start="1200.73" data-end="1203.58">I don't need to reach out to the property information at all.</span> <span data-start="1203.58" data-end="1204.58"Audience member: Wow.</span> <span data-start="1204.58" data-end="1206.47">We can get rid of that expensive loop altogether.</span> <span data-start="1206.47" data-end="1207.7">It sound great.</span> <span data-start="1207.7" data-end="1210.289"Audience member: Yes, and it's significantly faster now.</span> <span data-start="1210.289" data-end="1215.73"Audience member: How would this work for arrays where you can expect most elements to be array indices,</span> <span data-start="1215.73" data-end="1217.23">most properties.</span> <span data-start="1217.23" data-end="1224.1">You wouldn't want to store property attributes for each and every array index in your codebase.</span> <span data-start="1224.1" data-end="1226.82">You know they're going to be rewritable, configurable.</span> <span data-start="1226.82" data-end="1232.54"Audience member: Totally, that would be a total waste of space.</span> <span data-start="1232.54" data-end="1233.94"Audience member: What happens instead?</span> <span data-start="1233.94" data-end="1240.429"Audience member: All engines make use of the fact that all array properties are writable, configurable,</span> <span data-start="1240.429" data-end="1243.12">innumerable data properties.</span> <span data-start="1243.12" data-end="1244.79">Let's look at this array.</span> <span data-start="1244.79" data-end="1249.74">The array has a property lang, which this — length.</span> <span data-start="1249.74" data-end="1253.65">Let's say the length is stored stored inside the array.</span> </p>
<p><span data-start="1253.65" data-end="1260.61">For all the elements that in the array indexed by array, we store them in a separate elements</span> <span data-start="1260.61" data-end="1266.779">packing store, and it only stores the values, and it has this implicit tag attached to it</span> <span data-start="1266.779" data-end="1270.829">which says whatever you find in here is rewritable, innumerable, and configureable.</span> <span data-start="1270.829" data-end="1275.9"Audience member: Away don't have to store property attributes for array elements because they match the</span> <span data-start="1275.9" data-end="1276.9">default.</span> <span data-start="1276.9" data-end="1279.1"Audience member: They're default values anyway.</span> <span data-start="1279.1" data-end="1282.059"Audience member: What if someone overrides the attributes?</span> <span data-start="1282.059" data-end="1283.059">This is JavaScript.</span> <span data-start="1283.059" data-end="1284.059">JavaScript is wild.</span> <span data-start="1284.059" data-end="1285.859"Audience member: I know you're wild.</span> <span data-start="1285.859" data-end="1287.659"Audience member: You can totally do this, though.</span> </p>
<p><span data-start="1287.659" data-end="1293.879">What if I use object or define property on an array element, and I set one of its attributes</span> <span data-start="1293.879" data-end="1298.029">to the non-default value of false?</span> <span data-start="1298.029" data-end="1302.21"Audience member: You know, Mathias, whenever you do something like this, you kill a kitten!</span> <span data-start="1302.21" data-end="1304.589">So, like, just look at this one.</span> <span data-start="1304.589" data-end="1305.589"Audience member: Awp.</span> <span data-start="1305.589" data-end="1307.38"Audience member: You cannot kill it.</span> <span data-start="1307.38" data-end="1309.19">You want to kill this one?</span> <span data-start="1309.19" data-end="1311.599"Audience member: So cute!</span> <span data-start="1311.599" data-end="1314.009"Audience member: Come on.</span> <span data-start="1314.009" data-end="1315.309"Audience member: My heart melts!</span> <span data-start="1315.309" data-end="1317.709">A whole bunch of them.</span> <span data-start="1317.709" data-end="1319.039"Audience member: It's a family of kittens.</span> </p>
<p><span data-start="1319.039" data-end="1321.119">Remember, don't do this!</span> <span data-start="1321.119" data-end="1327.74">Kittens aside, for these edge cases, the engine represents the entire backing store for the</span> <span data-start="1327.74" data-end="1334.45">elements as a dictionary which map from indices to full-fledged property attributes like in</span> <span data-start="1334.45" data-end="1336.44">the JavaScript specification.</span> <span data-start="1336.44" data-end="1342.539"Audience member: If I use this define property on one array index, the whole array gets stored like this?</span> <span data-start="1342.539" data-end="1347.59"Audience member: Yes, because the basic assumption of the engine is that you don't do this.</span> <span data-start="1347.59" data-end="1349.259">Also, remember the kittens.</span> <span data-start="1349.259" data-end="1350.259">Come on!</span> <span data-start="1350.259" data-end="1351.259"Audience member: Got it.</span> <span data-start="1351.259" data-end="1354.35">I think you're saying I should avoid using object define property and array indexes which</span> <span data-start="1354.35" data-end="1356.539">is a weird thing to do anyway?</span> <span data-start="1356.539" data-end="1357.539"Audience member: Yes.</span> <span data-start="1357.539" data-end="1358.539"Audience member: Okay.</span> <span data-start="1358.539" data-end="1360.379">I won't do that again.</span> </p>
<p><span data-start="1360.379" data-end="1364.309">We've learned a lot about JavaScript engine internals today and we got coding advice out</span> <span data-start="1364.309" data-end="1365.559">of it as well.</span> <span data-start="1365.559" data-end="1368.259">Let's recap the main takeaways.</span> <span data-start="1368.259" data-end="1372.99">Always initialise your object in exactly the same way so they don't end up having different</span> <span data-start="1372.99" data-end="1374.22">shapes.</span> <span data-start="1374.22" data-end="1378.679">And second don't mess with property attributes of array elements so that they can be stored</span> <span data-start="1378.679" data-end="1380.539">and operated on efficiently.</span> </p>
<p><span data-start="1380.539" data-end="1382.94">Think of the kittens!</span> <span data-start="1382.94" data-end="1383.94">That's it.</span> <span data-start="1383.94" data-end="1384.94">Thanks for listening.</span> </p>
</section>