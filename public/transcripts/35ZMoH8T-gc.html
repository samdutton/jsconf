<section>
<p><span data-start="9.48" data-end="10.48">Hey.</span> <span data-start="10.76" data-end="11.88">How are ya'll doing today?</span> <span data-start="11.88" data-end="13.44">It's hot, right?</span> <span data-start="13.45" data-end="18.26">So, thank you all for coming to this room and bearing the heat.</span> <span data-start="18.26" data-end="19.37">Hello.</span> </p>
<p><span data-start="19.37" data-end="22.12">So, this is a fun one.</span> <span data-start="22.12" data-end="23.12">I do this a lot.</span> <span data-start="23.12" data-end="24.41">If you have seen me talk before, I'm sorry.</span> <span data-start="24.41" data-end="25.75">I'm going to do it again.</span> <span data-start="25.75" data-end="27.81">But I kind of walk into the audience.</span> <span data-start="27.81" data-end="29.5">That's not good.</span> <span data-start="29.5" data-end="30.5">No.</span> </p>
<p><span data-start="31.5" data-end="32.5">No.</span> <span data-start="33.5" data-end="34.62">Okay I'll do the short version.</span> <span data-start="34.62" data-end="37.96">I go like this and do this with the cat and it will calm me down.</span> <span data-start="37.96" data-end="39.23">This backfired.</span> <span data-start="39.23" data-end="40.949">I'm not calm.</span> <span data-start="40.949" data-end="44.27">That didn't work.</span> </p>
<p><span data-start="44.27" data-end="46.27">Improvisation is a fun thing.</span> <span data-start="46.27" data-end="47.82">I'm Myles.</span> <span data-start="47.82" data-end="53.84">I work for Google as a developer advocate on Cloud Platform.</span> <span data-start="53.84" data-end="54.84">This little line at the bottom.</span> <span data-start="54.84" data-end="57.149">This is all your talks.</span> <span data-start="57.149" data-end="59.81">This is my opinion, this is not my company's.</span> <span data-start="59.81" data-end="61.809">So, we're going to start with a quick glossary.</span> <span data-start="61.809" data-end="64.839">I use lots of terms.</span> <span data-start="64.839" data-end="71.95">ESN, ECMAScript module, CJS, common JS module.</span> <span data-start="71.95" data-end="74.78">Interoperability.</span> <span data-start="74.78" data-end="80.64">This is the ability to access ESN from CJS and vice versa.</span> <span data-start="80.64" data-end="87.49">This is an important core concept of getting Node on the web to play nicely and move forward</span> <span data-start="87.49" data-end="91.97">in a way that doesn't fracture the ecosystem.</span> </p>
<p><span data-start="91.97" data-end="94.33">Transparent interoperability.</span> <span data-start="94.33" data-end="104.24">This is a way to require ESN in CJS and import in without knowing the type of the module.</span> <span data-start="104.24" data-end="111.14">The ability to use a module and then just use ESN or CJS and not have to worry about</span> <span data-start="111.14" data-end="112.14">it.</span> <span data-start="112.14" data-end="117.81">This is how a lot of the transpilers work, Babel or transpiler or Webpack.</span> <span data-start="117.81" data-end="121.24">You don't need to know the type of module.</span> <span data-start="121.24" data-end="127.2">A goal is a pairing of a top-level grammar and a top-level execution model.</span> <span data-start="127.2" data-end="129.64">I'll get back to that later.</span> <span data-start="129.64" data-end="134.05">Bare inputs is the ability to require a module by its name.</span> <span data-start="134.05" data-end="142.27">If you do require or import_, or vice versa, to reference by the name of the module and</span> <span data-start="142.27" data-end="149.74">not give the full path is referred to as a bare import.</span> <span data-start="149.74" data-end="152.97">Existential dread.</span> <span data-start="152.97" data-end="156.87">This is a feeling I get trying to get all this to work and thinking about this problem</span> <span data-start="156.87" data-end="157.87">space.</span> <span data-start="157.87" data-end="163.08">And, you know, there are a handful of existential problems we have in JavaScript, the language</span> <span data-start="163.08" data-end="164.92">right now.</span> </p>
<p><span data-start="164.92" data-end="165.92">Find me later.</span> <span data-start="165.92" data-end="168.13">We can have a beer and talk about it.</span> <span data-start="168.13" data-end="171.96">But how did we get to where we are today?</span> <span data-start="171.96" data-end="175.87">So, who remembers ES4?</span> <span data-start="175.87" data-end="177">It never happened.</span> <span data-start="177" data-end="181.61">The ES4 is introduced the concept of packages.</span> <span data-start="181.61" data-end="184.75">These were primarily based on C++ name spaces.</span> <span data-start="184.75" data-end="190.39">And the intent was to create something similar to the Java jar system.</span> <span data-start="190.39" data-end="192.31">For those who don't know the joke, ES4 never shipped.</span> <span data-start="192.31" data-end="196.89">We went straight to ES5 from ES3.</span> <span data-start="196.89" data-end="200.07">It was ripped out of the standards track and never seen again.</span> <span data-start="200.07" data-end="204.06">All of these ES4 features just kind of vanished.</span> <span data-start="204.06" data-end="206.3">Common JS was introduced.</span> </p>
<p><span data-start="206.3" data-end="209.95">Members of TC39 worked on it, but it was never standardized.</span> <span data-start="209.95" data-end="213.65">It was intended primarily for service.JS.</span> <span data-start="213.65" data-end="218.81">And we'll get into it in a minute and why this is for servers and doesn't scale to the</span> <span data-start="218.81" data-end="219.81">web.</span> <span data-start="219.81" data-end="225.43">And NodeJS implemented a variant of the common JS spec.</span> <span data-start="225.43" data-end="229.73">Who remembers AMD?</span> </p>
<p><span data-start="229.73" data-end="231.79">Keep your hands up if you liked writing the files.</span> <span data-start="231.79" data-end="232.79">It's okay.</span> <span data-start="232.79" data-end="234.98">You all right put them down.</span> <span data-start="234.98" data-end="237.18">But AMD wasn't specified.</span> <span data-start="237.18" data-end="244.89">It was mostly implemented in require JS and it was more of a convention than a standard.</span> <span data-start="244.89" data-end="250.45">And because of these things, we had a thing, UMD to package them up to not think about</span> <span data-start="250.45" data-end="251.45">the modules.</span> </p>
<p><span data-start="251.45" data-end="256.13">UMD was the transparent interop of five years ago.</span> <span data-start="256.13" data-end="260.95">But ES modules landed at ECMA 2.62.</span> <span data-start="260.95" data-end="263.59">We had modules and they were standardized, but they weren't anywhere.</span> <span data-start="263.59" data-end="266.11">So, back to the glossary again.</span> <span data-start="266.11" data-end="268.32">What's a loader?</span> <span data-start="268.32" data-end="276.96">A loader is a generic term for a workflow, fetch, transform and the evaluation hook.</span> <span data-start="276.96" data-end="280.48">These are the phases that happen when you try to load a module.</span> <span data-start="280.48" data-end="286.6">When I reference a loader, it is an implementation that does all of these things.</span> <span data-start="286.6" data-end="292.12">And this is where we get into like the first really weird thing that makes things hard.</span> <span data-start="292.12" data-end="295.68">CommonJS technically doesn't have a separate loader phase.</span> <span data-start="295.68" data-end="298.98">It has synchronous load and inline execution.</span> <span data-start="298.98" data-end="302.66">When you run Node and start a file, it starts executing.</span> <span data-start="302.66" data-end="308.1">When you hit a require, it starts executing that file and it does this synchronously.</span> <span data-start="308.1" data-end="311.29">When you try to load that file off of the disk, it starts executing.</span> <span data-start="311.29" data-end="314.88">And it does that through essentially the whole graph of your modules.</span> <span data-start="314.88" data-end="317.41">And this is why it's not really good for the web.</span> </p>
<p><span data-start="317.41" data-end="322.19">If you have to wait for something to go over the network, every single time you hit require,</span> <span data-start="322.19" data-end="327.35">and this isn't able to be done asynchronously, you'll have a long time to wait until your</span> <span data-start="327.35" data-end="328.35">first paint.</span> <span data-start="328.35" data-end="329.43">Which is no good.</span> <span data-start="329.43" data-end="334.56">And I said there's no step, everything just kind of happens.</span> <span data-start="334.56" data-end="338.61">And this is how Babel originally implemented ESN.</span> <span data-start="338.61" data-end="343.5">People from Babel, you can find them afterwards, and maybe I'm overstretching the implementation,</span> <span data-start="343.5" data-end="349.75">but they took the input statements, converted them into require and then converted that</span> <span data-start="349.75" data-end="352.12">into files being linked together.</span> </p>
<p><span data-start="352.12" data-end="356.5">The original Babel loader was this in line execution.</span> <span data-start="356.5" data-end="364.06">They changed to Babel when they implemented the asynchronous model that was specified.</span> <span data-start="364.06" data-end="370.76">because they specify asynchronous load, and these are different phases.</span> <span data-start="370.76" data-end="374.64">The module tree is figured first.</span> <span data-start="374.64" data-end="379.78">They may change the guarantees.</span> <span data-start="379.78" data-end="383.58">It is possible that the actual execution of your graph could become asynchronous.</span> <span data-start="383.58" data-end="388.17">That's not what this talk is about.</span> <span data-start="388.17" data-end="392.4">Grab me at the party, I'll tell you about this.</span> <span data-start="392.4" data-end="393.4">This is the fun part.</span> <span data-start="393.4" data-end="395.83">The loader is not specified.</span> <span data-start="395.83" data-end="397.65">It's implemented by the embedder.</span> <span data-start="397.65" data-end="401.51">The way in which it executes is specified.</span> <span data-start="401.51" data-end="405.8">The way in which the graph is crawled, and everything is specified.</span> <span data-start="405.8" data-end="409.6">But how you actually load all those resources is left up to the embedder.</span> <span data-start="409.6" data-end="416.54">There's been attempts to specify this both at the W3C as well as the what working group.</span> <span data-start="416.54" data-end="419.26">But most of the processes at this point have stalled.</span> </p>
<p><span data-start="419.26" data-end="424.93">And it's primarily being implemented and maybe specified in the future.</span> <span data-start="424.93" data-end="426.47">I mentioned that load phase.</span> <span data-start="426.47" data-end="431.5">The load phase first goes and fetches all of the texts for all of the module graphs.</span> <span data-start="431.5" data-end="435.26">So, it can go, it finds all the symbols and all the things it needs to load over the network</span> <span data-start="435.26" data-end="438.06">and asynchronously grabs these.</span> <span data-start="438.06" data-end="442.52">And that goes with a concept like H2 push.</span> <span data-start="442.52" data-end="445.51">You can grab everything quickly.</span> <span data-start="445.51" data-end="451.61">It resolved the specifiers within the source text and goes to the linking phase.</span> <span data-start="451.61" data-end="454.93">For the linking phase, the module graph, all the files need to be in memory.</span> <span data-start="454.93" data-end="460.28">After they're in memory, they executed in pre traversal order.</span> </p>
<p><span data-start="460.28" data-end="463.96">From the top down, it's linking the entire graph.</span> <span data-start="463.96" data-end="466.06">This is important when you have things like cycles.</span> <span data-start="466.06" data-end="472.12">If you have modules that are referencing modules that are referencing modules it gets complicated.</span> <span data-start="472.12" data-end="476.1">You don't need multiple instances.</span> <span data-start="476.1" data-end="481.02">Everything in the graph is returning a singleton when you're grabbing a keyword.</span> <span data-start="481.02" data-end="487.47">You import React in one file and another file, you want that same version of React because</span> <span data-start="487.47" data-end="493.16">you want to register the components in the same area or things get weird.</span> <span data-start="493.16" data-end="498.49">And that moves into the execution phase which requires your link to be completed and is</span> <span data-start="498.49" data-end="500.25">actually done in post traversal order.</span> <span data-start="500.25" data-end="504.84">It starts at the roof nodes and goes to the root node.</span> <span data-start="504.84" data-end="508.33">This is an instantiation phase.</span> <span data-start="508.33" data-end="513.529">You are going through the modules in the graph, loading everything up into memory, creating</span> <span data-start="513.529" data-end="519.69">you will of the singletons so when you call React later, it's ready to be used.</span> </p>
<p><span data-start="519.69" data-end="522.65">This is not something CommonJS needed to worry about.</span> <span data-start="522.65" data-end="524.93">Everything is executing in line.</span> <span data-start="524.93" data-end="526.98">This is where things get weird.</span> <span data-start="526.98" data-end="532.25">They are not interchangeable, and it can result in different execution order.</span> <span data-start="532.25" data-end="537.93">The exact same graph, defined by require and then defined by input can actually cause things</span> <span data-start="537.93" data-end="539.83">to execute in a different order.</span> </p>
<p><span data-start="539.83" data-end="546.57">And if you're relying on the order that your modules are going to execute, that can bite</span> <span data-start="546.57" data-end="547.63">you.</span> <span data-start="547.63" data-end="549.93">More behavior differences.</span> <span data-start="549.93" data-end="553.42">The specifier resolution algorithm is also different.</span> <span data-start="553.42" data-end="559.04">so, TC3 leaves it up to the hosting environment how to do specifier resolution.</span> <span data-start="559.04" data-end="561.68">That's the name of the module you're loading.</span> <span data-start="561.68" data-end="566.76">The specifier in the browser is a relative path to things on the disk.</span> <span data-start="566.76" data-end="572.48">And in Node, this could be a combination of relative paths or a bare import as we mentioned</span> <span data-start="572.48" data-end="573.48">before.</span> </p>
<p><span data-start="573.48" data-end="578.79">So, NodeJS has a specific resolution algorithm for dealing with specifiers.</span> <span data-start="578.79" data-end="582.29">We support their imports, so you can import low dash.</span> <span data-start="582.29" data-end="585.21">We allow you to impart JSON.</span> <span data-start="585.21" data-end="587.3">You can drop the file extension.</span> <span data-start="587.3" data-end="591.56">You can import a file with no extension and import a directory.</span> <span data-start="591.56" data-end="593">Those are nice.</span> <span data-start="593" data-end="599.17">You can name a fail capability and then that can turn into a directory with all sorts of</span> <span data-start="599.17" data-end="603.779">things in it later without you ever having to refactor your code.</span> </p>
<p><span data-start="603.779" data-end="607.19">But this isn't exactly how things work on the web.</span> <span data-start="607.19" data-end="609.46">The web doesn't support bare imports.</span> <span data-start="609.46" data-end="613.97">Currently the web only supports those paths.</span> <span data-start="613.97" data-end="617.589">You can only specify either absolute or indirect paths.</span> <span data-start="617.589" data-end="624.12">If you had a module for Node, it's going to blow up not browser.</span> <span data-start="624.12" data-end="631.22">There's a proposal, package name maps, to allow a lookup process to find the bare imports</span> <span data-start="631.22" data-end="632.56">in the tree.</span> <span data-start="632.56" data-end="636.69">But it has a slightly different feature set than Nodes model.</span> <span data-start="636.69" data-end="642.69">Specifically, you can do bare imports bub you can also do deep module traversal by file</span> <span data-start="642.69" data-end="643.69">name.</span> <span data-start="643.69" data-end="648.13">The name of the file, slash, and a name of the file deep in the tree.</span> </p>
<p><span data-start="648.13" data-end="653.8">But you can't import directories and you have to give the file extension.</span> <span data-start="653.8" data-end="659.38">The reason is you don't want to be doing multiple network calls for all modules.</span> <span data-start="659.38" data-end="661.33">In Node, this is fine, arguably.</span> <span data-start="661.33" data-end="663.23">It can be a problem.</span> <span data-start="663.23" data-end="667.36">If you import a thing without a file extension, check, is it JS?</span> <span data-start="667.36" data-end="668.69">A native module?</span> <span data-start="668.69" data-end="669.69">JSON?</span> <span data-start="669.69" data-end="670.69">This thing?</span> <span data-start="670.69" data-end="674.63">Maybe checking four or five different file extensions.</span> </p>
<p><span data-start="674.63" data-end="676.48">Those hits are cheap.</span> <span data-start="676.48" data-end="678.31">But not in the browser.</span> <span data-start="678.31" data-end="685.47">You don't want every module making seven or eight network requests and going to the server</span> <span data-start="685.47" data-end="689.49">to respond and handling it 404s.</span> <span data-start="689.49" data-end="695.81">So, this kind of explicitness is necessary.</span> <span data-start="695.81" data-end="697.75">More behavior differences.</span> <span data-start="697.75" data-end="700.98">The code actually executes differently too.</span> <span data-start="700.98" data-end="703.66">So, we were talking about this before.</span> <span data-start="703.66" data-end="708.19">And ESN CommonJS run in different goals.</span> <span data-start="708.19" data-end="712.02">It was a mix of two different things and kind of confusing.</span> <span data-start="712.02" data-end="713.02">Let's dig into it.</span> <span data-start="713.02" data-end="714.05">There's four types of goals.</span> <span data-start="714.05" data-end="720.22">You have script slip, script sloppy, ES module and NodeJS.</span> <span data-start="720.22" data-end="725.48">You can see the goal, the combination of a grammar and an execution mode.</span> <span data-start="725.48" data-end="733.93">Talking about a top level mode, it's strict mode versus sloppy mode.</span> </p>
<p><span data-start="733.93" data-end="737.96">What symbol organize APIs, what is exposed by the language?</span> <span data-start="737.96" data-end="742.441">Strict versus sloppy is denoted by a pragma, strict.</span> <span data-start="742.441" data-end="749.529">Best practice five years ago and it still is and removes capabilities from the language.</span> <span data-start="749.529" data-end="751.16">We don't want to break the language.</span> <span data-start="751.16" data-end="756.87">We don't to want change the way things work.</span> <span data-start="756.87" data-end="758.94">You can do it explicitly and it was often.</span> <span data-start="758.94" data-end="763.69">So, the chance of breaking things on the web before was really low.</span> <span data-start="763.69" data-end="770.79">Now, the module goal, which was different from both the strict and sloppy goal has different</span> <span data-start="770.79" data-end="772.5">changes.</span> <span data-start="772.5" data-end="774.76">You can't use HTML comments.</span> <span data-start="774.76" data-end="778.94">Who can actually use HTML comments in JavaScript?</span> <span data-start="778.94" data-end="780.79">So, you should change that.</span> <span data-start="780.79" data-end="782.67">Or it's going to break when you make modules.</span> <span data-start="782.67" data-end="785.24">A rate is a reserved keyword.</span> <span data-start="785.24" data-end="789.6">This was done by the committee to make sure that the top level was something that could</span> <span data-start="789.6" data-end="791.57">happen.</span> </p>
<p><span data-start="791.57" data-end="795.57">And it may change over time.</span> <span data-start="795.57" data-end="802.37">That await keyword thing makes it hard to use, you know, the any variable that's names</span> <span data-start="802.37" data-end="803.37">await.</span> <span data-start="803.37" data-end="804.899">It's not allowed anymore.</span> <span data-start="804.899" data-end="808.1">So, this is one of the really hard parts, though.</span> </p>
<p><span data-start="808.1" data-end="811.93">ES modules don't have an in source way of determining the goal.</span> <span data-start="811.93" data-end="813.19">Strict mode did.</span> <span data-start="813.19" data-end="815.21">You had a pragma.</span> <span data-start="815.21" data-end="818.06">These are just code, there is no pragma.</span> <span data-start="818.06" data-end="819.83">The committee decided not to use a pragma.</span> <span data-start="819.83" data-end="821.22">It's a new goal.</span> <span data-start="821.22" data-end="822.62">It's a new thing.</span> <span data-start="822.62" data-end="826.35">It's not progressive enhancement or de enhancement.</span> <span data-start="826.35" data-end="829.29">It's its own thing.</span> <span data-start="829.29" data-end="832.48">And you're using the browser and using the type equals module.</span> <span data-start="832.48" data-end="834.87">There's no need to have the pragma.</span> <span data-start="834.87" data-end="839.029">In Node, we have no way of really knowing.</span> <span data-start="839.029" data-end="843.49">And there's also more goals that may be coming in the future that are in the standards track.</span> <span data-start="843.49" data-end="850.99">This includes binary AST, Clarke in the audience who is driving it that you can import Rosen.</span> </p>
<p><span data-start="850.99" data-end="853.83">That's ridiculously cool.</span> <span data-start="853.83" data-end="855.5">Web packages.</span> <span data-start="855.5" data-end="859.1">If you haven't heard, that's cool.</span> <span data-start="859.1" data-end="862.12">Bundlers work because you make a giant script.</span> <span data-start="862.12" data-end="864.43">But not for modules.</span> <span data-start="864.43" data-end="868.19">Because you can't just make a script with multiple modules in it.</span> <span data-start="868.19" data-end="872.589">So, web package is one approach that would allow you to bundle modules all together in</span> <span data-start="872.589" data-end="874.65">a way that could be understood by the browser.</span> <span data-start="874.65" data-end="881.42">And modules, another one that's nice to have if you're, you know, doing modern web Dev.</span> <span data-start="881.42" data-end="885.35">JSX has a lot of this kind of inline ability to make modules.</span> <span data-start="885.35" data-end="888.399">So, we have to pave the cow path.</span> <span data-start="888.399" data-end="894.67">We have to think, not just how do we make ESN and CJN work together, we have to think</span> <span data-start="894.67" data-end="900.94">about a solution that works for any number of infinite possible future goals.</span> </p>
<p><span data-start="900.94" data-end="901.94">And this is hard.</span> <span data-start="901.94" data-end="904.85">Especially thinking about interoperability.</span> <span data-start="904.85" data-end="912.21">If we're loading in Node, it's not the best way of doing it.</span> <span data-start="912.21" data-end="915.19">You can't export the things on that symbol.</span> <span data-start="915.19" data-end="916.52">But you can require ESN.</span> <span data-start="916.52" data-end="920.709">It is because it has an asynchronous loader.</span> <span data-start="920.709" data-end="923.19">Grab me later and we can talk about the inconsistencies there.</span> <span data-start="923.19" data-end="926.64">You can Google it's called zebra striping.</span> <span data-start="926.64" data-end="932.03">But moving from async to sync and back to async, things get weird.</span> <span data-start="932.03" data-end="935.529">There's a lot of different ways to do this.</span> <span data-start="935.529" data-end="939.87">For Node's core modules, you can impart from FS.</span> <span data-start="939.87" data-end="942.72">And as of 10.2, it's released about two weeks ago.</span> <span data-start="942.72" data-end="945.89">You can do named exports from core modules.</span> <span data-start="945.89" data-end="948.73">But core modules in Node have an advantage.</span> </p>
<p><span data-start="948.73" data-end="953.18">Because Node is compiled, and we can do all sorts of things in advance for it.</span> <span data-start="953.18" data-end="958.95">And if we allow it to import from CJS in the ESN implementation, but not with named imports,</span> <span data-start="958.95" data-end="960.769">you only get the defaults.</span> <span data-start="960.769" data-end="963.6">And this capability makes it a little bit more difficult.</span> <span data-start="963.6" data-end="969.019">The idea is not having to know the difference between the type was modules.</span> <span data-start="969.019" data-end="971.24">But you kind of do because you only have a default.</span> <span data-start="971.24" data-end="975.41">And this is one of the things that we're still trying to work out.</span> <span data-start="975.41" data-end="978.1">Import meta require, something we're talking about doing.</span> <span data-start="978.1" data-end="982.48">Import meta is the ability to put I'll talk about it in a second.</span> <span data-start="982.48" data-end="988.25">But import meta require would allow you to require C JS into ESN without having to worry</span> <span data-start="988.25" data-end="990.44">about transparent interop.</span> </p>
<p><span data-start="990.44" data-end="997.529">ESN does not have a way to include lexically scoped variables.</span> <span data-start="997.529" data-end="1001.37">It has lexically scoped variables.</span> <span data-start="1001.37" data-end="1006.589">And I start listing them and all of a sudden it makes sense what a lexically scoped variable</span> <span data-start="1006.589" data-end="1007.589">is.</span> </p>
<p><span data-start="1007.589" data-end="1013.22">In Node, they're on Lamdba, and you inject into the scope of the model.</span> <span data-start="1013.22" data-end="1016.22">These are not globals, they're specific to the module.</span> <span data-start="1016.22" data-end="1022.18">The specific file name, a shared instance of require and the module that's exposed.</span> <span data-start="1022.18" data-end="1026.789">All of these things are things that we inject from, but ESN doesn't have that.</span> <span data-start="1026.789" data-end="1028.149">This is where import meta came in.</span> <span data-start="1028.149" data-end="1029.85">It's stage 3 at TC39.</span> <span data-start="1029.85" data-end="1031.789">A proposal by Dominik.</span> <span data-start="1031.789" data-end="1037.889">And allows run time to inject variables into the module.</span> <span data-start="1037.889" data-end="1043.909">Inside of your module, you can say import meta URL and that's a place for the file name.</span> <span data-start="1043.909" data-end="1047.669">And that's somewhere you can hang your file, for example, to have essentially have a back</span> <span data-start="1047.669" data-end="1067.1">door to allow you to get the CJS modules in without</span> <span data-start="1067.1" data-end="1069.909">a transparent interop.</span> <span data-start="1069.909" data-end="1078.119">[skype breaking up] ESN file, file extension.</span> <span data-start="1078.119" data-end="1079.72">We're going to need that no matter what.</span> </p>
<p><span data-start="1079.72" data-end="1087.999">Even if we allow JS the ability to do a solution to say, hey, this says that the ES module</span> <span data-start="1087.999" data-end="1088.999">is necessary.</span> <span data-start="1088.999" data-end="1094.049">Even if you just say Node, thing.JS.</span> <span data-start="1094.049" data-end="1100.009">That's the way you are able to boot into an ES module.</span> <span data-start="1100.009" data-end="1108.009">We have support for and support for transparent interop and ESN, but no support for transparent</span> <span data-start="1108.009" data-end="1109.23">interop in JS.</span> <span data-start="1109.23" data-end="1112.59">With the async loader, it's currently not possible.</span> <span data-start="1112.59" data-end="1118.499">But we're exploring options in a way this would actually work.</span> <span data-start="1118.499" data-end="1123.279">And we have support for dynamic import in both ESM and CJS.</span> <span data-start="1123.279" data-end="1127.07">You name a module, it returns to a promise to resolve that.</span> </p>
<p><span data-start="1127.07" data-end="1130.809">Top level will make this really great in ESN.</span> <span data-start="1130.809" data-end="1134.019">But currently the top level await spec is not targeting the script goal.</span> <span data-start="1134.019" data-end="1137.019">It's not an enhancement that is available?</span> <span data-start="1137.019" data-end="1138.019">CJS.</span> <span data-start="1138.019" data-end="1139.82">We have support for import meta.</span> <span data-start="1139.82" data-end="1143.99">But currently only exposing import meta URL.</span> <span data-start="1143.99" data-end="1147.59">And some of the decisions have made some people grumpy.</span> <span data-start="1147.59" data-end="1153.139">And in response, we spun up a NodeJS modules team.</span> </p>
<p><span data-start="1153.139" data-end="1157.309">We made it open and 42 members signed up in the first week.</span> <span data-start="1157.309" data-end="1163.07">This included representation from at least ten countries including Canada, China, Germany,</span> <span data-start="1163.07" data-end="1167.649">Israel, Italy, Japan, Nigeria, the United Kingdom and South Africa.</span> <span data-start="1167.649" data-end="1170.2">And the U.S.</span> <span data-start="1170.2" data-end="1174.779">We have representation from ten corporate organizations including Airbnb, Bloomberg,</span> <span data-start="1174.779" data-end="1181.169">GoDaddy, Google, Groupon, IBM, Microsoft, Mozilla and nearform.</span> <span data-start="1181.169" data-end="1183.929">And Node source.</span> <span data-start="1183.929" data-end="1185.419">I'm off by one in all of these.</span> </p>
<p><span data-start="1185.419" data-end="1190.179">It's a big problem in technology.</span> <span data-start="1190.179" data-end="1196.619">14 programming platforms you know, Angular, Babel, Bloomberg, jQuery, JSPM.</span> <span data-start="1196.619" data-end="1210.22">Lo Dash, tap JS, V8 and Webpack.</span> <span data-start="1210.22" data-end="1213.529">But as you can see, we've got a lot of people who are working on all the tools that we're</span> <span data-start="1213.529" data-end="1216.279">using trying to work towards consensus.</span> <span data-start="1216.279" data-end="1218.269">Trying to make sure that this is happening.</span> <span data-start="1218.269" data-end="1221.499">And we have representation from three of the standards bodies.</span> <span data-start="1221.499" data-end="1227.1">We have people at TC39, the working group and people at W3C.</span> <span data-start="1227.1" data-end="1228.239">This one was really easy.</span> <span data-start="1228.239" data-end="1230.83">There's only three of them.</span> <span data-start="1230.83" data-end="1232.669">But we're all really hard at work on this problem.</span> <span data-start="1232.669" data-end="1235">This is a really, really hard problem.</span> <span data-start="1235" data-end="1238.86">And doing it right is this kind of existential thing.</span> <span data-start="1238.86" data-end="1246.34">If we do it wrong, we could create this like irreconcilable like schism in the community.</span> <span data-start="1246.34" data-end="1250.169">And we all take this really, really, really seriously.</span> </p>
<p><span data-start="1250.169" data-end="1255.799">And I know that probably every single person in this room is worried about this being done</span> <span data-start="1255.799" data-end="1256.799">right.</span> <span data-start="1256.799" data-end="1260.679">And the whole purpose of this talk, I was hoping to kind of just show under the hood</span> <span data-start="1260.679" data-end="1265.1">a little bit of like all the things that make this really hard and really weird and really</span> <span data-start="1265.1" data-end="1266.1">tough.</span> <span data-start="1266.1" data-end="1271.341">But I wanted to reinforce to all of you that like all those people, all those 42 people</span> <span data-start="1271.341" data-end="1276.44">from all those companies, all those fronts, and all those standards bodies, we are pull</span> <span data-start="1276.44" data-end="1277.44">our hair out.</span> <span data-start="1277.44" data-end="1278.679">We are working really hard.</span> <span data-start="1278.679" data-end="1281.769">Biweekly meetings, giant threads.</span> <span data-start="1281.769" data-end="1283.7">You can't even keep up.</span> <span data-start="1283.7" data-end="1289.39">Trying to bash out a solution so that you can just keep writing code and not have to</span> <span data-start="1289.39" data-end="1291.179">worry about this.</span> <span data-start="1291.179" data-end="1296.73">And I really, you know, in the next year, year and a half we'll be able to ship something.</span> <span data-start="1296.73" data-end="1303.539">My dream is that you can npm install something and run in the browser or Node without the</span> <span data-start="1303.539" data-end="1304.559">build step.</span> </p>
<p><span data-start="1304.559" data-end="1308.149">Which would be in my opinion absolutely amazing.</span> <span data-start="1308.149" data-end="1310.33">And with that, here's a surf dog.</span> <span data-start="1310.33" data-end="1311.33">Thank you very much.</span> </p>
</section>