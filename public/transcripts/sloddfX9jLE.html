<section>
<p><span data-start="24.64" data-end="29.23">Hello, so we'll be doing something a little different because I am going to take you on</span> <span data-start="29.23" data-end="37.37">a trip to the zoo. It's a zoo with Monkeys, with rhinos and an aquarium, more specifically</span> <span data-start="37.37" data-end="50.48">there will be Spider Monkey, Rhino, and SquirrelFish, I'll be talking about JavaScript engines.</span> <span data-start="50.48" data-end="57.01">JavaScript has got incredibly fast we look at how JavaScript engines work and optimisation</span> <span data-start="57.01" data-end="62.01">techniques, I'll show you a few examples of how you can write code that takes advantage</span> <span data-start="62.01" data-end="68.41">of those optimisations rather than working again them, I won't focus on the differences</span> <span data-start="68.41" data-end="73.35">between the engines, instead we will look at what they have in common, the optimisation</span> <span data-start="73.35" data-end="76.72">examples work independently of the browser choice.</span> <span data-start="76.72" data-end="85.32">So, a little bit of history, SpiderMonkey is the JavaScript engine that was first, the</span> <span data-start="85.32" data-end="92.39">very first JavaScript engine, written in 1995 back then used in Netscape communicator and</span> <span data-start="92.39" data-end="98.36">after several rewrites that's the engine we have in Firefox today.</span> <span data-start="98.36" data-end="106">Of course SpiderMonkey comes with Monkey friends, trace money JagerMonkey, TraceMonkey and IonMonkey,</span> <span data-start="106" data-end="116.1">they help SpiderMonkey took be even faster. Then in 2002 the squirrel fish was written,</span> <span data-start="116.1" data-end="130.97">for safari and webkit, we also have rhinos, it's a word play, it's a Java script written</span> <span data-start="130.97" data-end="143.65">in oracle, so the next animal, I'm sorry, engine, it's V 8, it's the JavaScript engine</span> <span data-start="143.65" data-end="153.68">in Chrome and it came out in 2009, Microsoft jscript or Chakra was also one of the older</span> <span data-start="153.68" data-end="164.04">ones that came in 1986, that's what we have in Internet Explorer and Edge. With V 8 and</span> <span data-start="164.04" data-end="172.29">jscript I ran out of animals, that's the end of our trip to the zoo, sadly for the rest</span> <span data-start="172.29" data-end="178.9">of the talk there won't be any more animals, let's look at the technical side.</span> </p>
<p><span data-start="178.9" data-end="183.54">As I already mentioned the engines have all been rewritten several times and that was</span> <span data-start="183.54" data-end="190.68">mainly ton for performance, we want fast JavaScript, we want the websites to be fast and responsive,</span> <span data-start="190.68" data-end="197.58">we need good performance. How fast are we? here are some benchmarks over the last ten</span> <span data-start="197.58" data-end="205.099">years, the SunSpider benchmark, as you can see the score gets higher, fee got faster</span> <span data-start="205.099" data-end="213.019">and faster. Ok, are we fast yet, we got faster, there is a website, 'Are we faster.com', you</span> <span data-start="213.019" data-end="219.891">see similar pictures, another benchmark, different versions of Chrome and Firefox, as you can</span> <span data-start="219.891" data-end="224.45">see they got faster, massive performance improvements.</span> <span data-start="224.45" data-end="232.42">All right. So, yes we are faster, but we are faster compared to an older version of ourselves,</span> <span data-start="232.42" data-end="239.409">does it actually mean we are fast? We are faster than 20 years ago, ok, but are we fast?</span> <span data-start="239.409" data-end="245.19">Let's compare to something where we know that it really is fast.</span> <span data-start="245.19" data-end="253.59">Let's have a race between C++ and JavaScript, we know C++ is fast. So, the contenders are</span> <span data-start="253.59" data-end="261.34">C++ and JavaScript and the race track are prime numbers. A basic example I want to compute</span> <span data-start="261.34" data-end="268.69">the first 25,000 prime numbers and see how fast the JavaScript compared to C++.</span> <span data-start="268.69" data-end="275.64">So, on the left you have C++ and on the right you have JavaScript, don't worry, you don't</span> <span data-start="275.64" data-end="280.21">need to read thorough the algorithm I just want to give you a quick idea, it's fairly</span> <span data-start="280.21" data-end="286.51">short, it easily fits on the page and the C++ and JavaScript code, they do the same</span> <span data-start="286.51" data-end="288.11">things, same algorithm.</span> </p>
<p><span data-start="288.11" data-end="300.47">Ok, so when I run this, with C++, I first printout the 25,000 prime number, which is</span> <span data-start="300.47" data-end="305.11">that one, to make sure my algorithm is correct, it took me a little bit over 6 seconds, 6.2,</span> <span data-start="305.11" data-end="314.73">seconds, so how did JavaScript do? So I ran this running D 8 the debugging shell for d8</span> <span data-start="314.73" data-end="323">makes it really easy to time it, I ran the prime number example in JavaScript, I get</span> <span data-start="323" data-end="332.03">the correct answer so that's good. It's barely slower than C++, 6.7 seconds. So if you do</span> <span data-start="332.03" data-end="340.969">the maths, JavaScript is less than 14% slower than C++. I think this is really amazing,</span> <span data-start="340.969" data-end="347.08">those are amazing numbers, because what's so special about this, why is it surprising</span> <span data-start="347.08" data-end="353.36">that JavaScript can calculate prime numbers almost as fast as C++. Well C++</span> <span data-start="353.36" data-end="359.7">is statically typed, before you run your code you have to specify for every variable what</span> <span data-start="359.7" data-end="367.08">type it is, so even at compile time the compiler knows exactly what it will get, knows it will</span> <span data-start="367.08" data-end="374.45">get an integer, string or what class it gets. Before run time you can optimise the machine</span> <span data-start="374.45" data-end="380.37">code that you get and then you get really fast code once you actually execute it.</span> <span data-start="380.37" data-end="384.5">JavaScript is dynamically typed, you don't have this information, only at run time do</span> <span data-start="384.5" data-end="390.83">we know what we get, we can't generate optimised code ahead of time.</span> </p>
<p><span data-start="390.83" data-end="400.21">Just to make sure here, did compile C++ with -03 optimisation flag, if you don't optimise</span> <span data-start="400.21" data-end="406.63">your code when compiling, JavaScript would be way faster than C++ version of this, it's</span> <span data-start="406.63" data-end="415.13">ahead of time optimised code in C++ and it's just a little bit faster than JavaScript.</span> <span data-start="415.13" data-end="421.05">Ok, so in the next 20 minutes we will look at what JavaScript engines are doing to get</span> <span data-start="421.05" data-end="426.56">to this massive performance.</span> <span data-start="426.56" data-end="435.3">So a little bit of background, your classic compiler has four components, lLexer, the</span> <span data-start="435.3" data-end="444.6">parser, it takes tokens and generates the — the translator translates that tree into</span> <span data-start="444.6" data-end="453.57">byte code and then the account code is interpreted. There is basically two main types of compilers,</span> <span data-start="453.57" data-end="464.471">ahead of time compilation and ‘just in time’ compilation. When it's ahead of time, before</span> <span data-start="464.471" data-end="471.029">you run it, you compile everything if possible, you optimise the machine code that you get</span> <span data-start="471.029" data-end="477.16">and then you run it. Obviously C++ is ahead of time. Why do I say obviously, you have</span> <span data-start="477.16" data-end="483.479">to do two separate steps, you call the compiler that gives you an executable, then in the</span> <span data-start="483.479" data-end="492.959">second step you call the compiler, so clear separation. So the benefit of a ahead of time</span> <span data-start="492.959" data-end="499.88">compilation you can take your time to optimise this code, to get really could machine code</span> <span data-start="499.88" data-end="503.8">so when you run it it's very fast.</span> </p>
<p><span data-start="503.8" data-end="509.28">JavaScript on the other hand uses a 'Just in time' compiler, so we're not compiling</span> <span data-start="509.28" data-end="514.82">everything up front ahead of time, for once it would not be great if you opened a website</span> <span data-start="514.82" data-end="519.3">and you have to wait for all the JavaScript code to compile before anything starts and</span> <span data-start="519.3" data-end="526.06">also since it's dynamically typed we could not generate ahead of time good machine code.</span> <span data-start="526.06" data-end="532.26">So we do it, just in time. This is sometimes also called 'Lazy compilation' we only compile</span> <span data-start="532.26" data-end="535">what we need as we want to execute it.</span> </p>
<p><span data-start="535" data-end="543.45">Ok this is good, we don't have a lot of information ahead of time so we do just in time compilation,</span> <span data-start="543.45" data-end="548.08">but usually just in time compilation is very slow, you don't have the big picture, you</span> <span data-start="548.08" data-end="553.14">can't optimise, so the machine code you get does not run very fast.</span> <span data-start="553.14" data-end="559.89">So how do we get the almost C++ performance if we are using just in time compilation?</span> <span data-start="559.89" data-end="568.19">Well, the basic concept that all modern JavaScript engines use are hidden classes. So we don't</span> <span data-start="568.19" data-end="579.46">have hidden classes, at least until ECMA script, but behind the scenes the JavaScript engines</span> <span data-start="579.46" data-end="587.06">assign a type or hidden class to any object. So, integers and strings obviously have different</span> <span data-start="587.06" data-end="594.751">types of different classes, also objects have hidden classes. Going</span> <span data-start="594.751" data-end="599.8">to use this example to show you how the engine in the background assigns the hidden classes.</span> <span data-start="599.8" data-end="605.17">I've constructed a function for a point that takes two arguments and assigns them to x</span> <span data-start="605.17" data-end="618.37">and y , when I instantiate a new point a, my engine creates a point object, it's a pointer</span> <span data-start="618.37" data-end="624.77">and now when I look at the constructor, the engine says, "Ok, so this point object has</span> <span data-start="624.77" data-end="636.82">a hidden class, let's call it z0", so my object has class z0, I go through and assign x , the</span> <span data-start="636.82" data-end="644.45">engine is saying ok, we’ll take Z 0 and add an x to it, as the first member, I'm getting</span> <span data-start="644.45" data-end="652.18">a new hidden class, C 1, it's the hidden class that comes out of Z 0 if you had member x</span> <span data-start="652.18" data-end="657.74">to it, Z 1, opposite zero you have the value for x .</span> </p>
<p><span data-start="657.74" data-end="668.47">Ok, if you go on in the constructor we do the same things for y , we have C 1 and we</span> <span data-start="668.47" data-end="680.79">add y to it, from the 1 we get another hidden class and C 2, where x and y in. Point object</span> <span data-start="680.79" data-end="688.03">now has hidden class C 2 which we get by adding an x and then a y . If we instantiate another</span> <span data-start="688.03" data-end="697.67">point the compiler goes through the same steps but can reuse C 1 and C 2, in the end both</span> <span data-start="697.67" data-end="703.39">A and B will have hidden class C 2, which makes sense, they are very similar objects</span> <span data-start="703.39" data-end="710.93">generated the same way and we probably want them treated the same way later at run time.</span> <span data-start="710.93" data-end="716.73">If we change the order of assigning x and y for example, or if we assign another variable,</span> <span data-start="716.73" data-end="723.6">then the two objects would not have the same hidden class, the order is important and then</span> <span data-start="723.6" data-end="732.85">also the same variables. If you are not sure if two objects have the same hidden class</span> <span data-start="732.85" data-end="741.19">you can easily check. If you pass in the flag, allow native syntax, then you can call a map</span> <span data-start="741.19" data-end="746.55">to check if two objects really have the same hidden class. If that was confusing with the</span> <span data-start="746.55" data-end="750.29">order or if you are not sure that two things there are same, this is how you can check.</span> </p>
<p><span data-start="750.29" data-end="757.94">I instantiate A and B, they have an x and a y and have the same hidden class. Now if</span> <span data-start="757.94" data-end="763.34">I had another variable to A, they don't have the same hidden class any more.</span> <span data-start="763.34" data-end="769.82">So, in practice that means we want the same objects to have the same hidden class so it's</span> <span data-start="769.82" data-end="775.78">good practice to always instantiate all your members in the constructor function. So rather</span> <span data-start="775.78" data-end="780.96">do this, we're in the constructor function you said x and y , then this.</span> <span data-start="780.96" data-end="789.47">So, initial all objects and functions.</span> <span data-start="789.47" data-end="795.36">The compiler is always keeping track of stuff and adding hidden classes how does that make</span> <span data-start="795.36" data-end="804.59">it faster. The hidden classes there are basis for in line caching. So in line caching is</span> <span data-start="804.59" data-end="817.1">what gives us a big performance boost, what it does is we're caching function, so if we</span> <span data-start="817.1" data-end="823.73">have a function do something of A, when we want to execute it we compile it into a machine</span> <span data-start="823.73" data-end="830.05">code and into machine code for anything that looks like an A, anything that has the hidden</span> <span data-start="830.05" data-end="835.88">class of A, now we cache the machine code, the next time we come across, do something,</span> <span data-start="835.88" data-end="842.01">rather than compile it again for anyone that looks like a B, we just check if A and B are</span> <span data-start="842.01" data-end="847.55">similar, if they have the same hidden class we can use the code we already generated.</span> </p>
<p><span data-start="847.55" data-end="852.66">If A and B have the same hidden class we don't have to do all the same work, only if A and</span> <span data-start="852.66" data-end="858.29">B are different in the sense they don't have the same hidden class, we have to recompile</span> <span data-start="858.29" data-end="859.29">and</span> <span data-start="859.29" data-end="866.02">generate the machine instructions and then probably cache that version for later use.</span> <span data-start="866.02" data-end="871.42">What does this mean in practice? I have a silly function twice here, takes an argument</span> <span data-start="871.42" data-end="885.24">A and runs A+ A, if I call twice on the string I expect the string with concat — a million</span> <span data-start="885.24" data-end="896.38">times in the loop, I'm called in randomly on a integer or string.</span> </p>
<p><span data-start="896.38" data-end="902.28">Now for a million times it takes about six seconds, I'm changing this a little bit, instead</span> <span data-start="902.28" data-end="908.19">of twice I'm making two functions, twice string and twice int, they are exactly the same functions</span> <span data-start="908.19" data-end="914.69">they get an argument and return A+ A, the intention with the name, I call twice string</span> <span data-start="914.69" data-end="922.13">only on strings and twice only on integers. Then again in the loop a million times I randomly</span> <span data-start="922.13" data-end="929.35">call twice string on A or twice on 4. So the output module, the randomness is exactly the</span> <span data-start="929.35" data-end="939.06">same of my programme before, just calling A+ A, I call two separate functions.</span> </p>
<p><span data-start="939.06" data-end="947.45">Let's look at how long this takes, the first example took five seconds, sorry, six seconds,</span> <span data-start="947.45" data-end="953.07">but this one with the two functions it only takes five seconds. So we have about 20% speed</span> <span data-start="953.07" data-end="959.61">up, it's not great, but it's a speed up so that's good.</span> <span data-start="959.61" data-end="964.779">In the first example where we only had one function, that function is called a polymorphic</span> <span data-start="964.779" data-end="970.37">function, because the parameter it gets come in different shapes, polymorphic, they come</span> <span data-start="970.37" data-end="978.399">as int or string. In the second example the faster one both functions are considered monomorphic</span> <span data-start="978.399" data-end="984.91">because they always get the same input the twice string always only got strings so the</span> <span data-start="984.91" data-end="990.19">takeaway, monomorphic functions are better than polymorphic function don't switch up</span> <span data-start="990.19" data-end="991.899">the type of your parameters.</span> <span data-start="991.899" data-end="1005.56">Here's a disclaimer though I am talking about optimisation, premature optimisation is the</span> <span data-start="1005.56" data-end="1015.66">root of all evil. Don't go home and change all your polymorphic functions. In the example</span> </p>
<p><span data-start="1015.66" data-end="1022.52">I just had I ran it a million times, I got about a second faster, so probably your application</span> <span data-start="1022.52" data-end="1028.38">is not calling anything a million times, and if you go and change your polymorphic function</span> <span data-start="1028.38" data-end="1034.26">you probably won't see any speed up overall. The only thing you might happen you introduce</span> <span data-start="1034.26" data-end="1045.959">bugs by typos or other mistakes. It's always when you talk about optimisation, don't blindly</span> <span data-start="1045.959" data-end="1058.54">optimise. Our JavaScript engine the compiler is already a just-in-time compiler already,</span> <span data-start="1058.54" data-end="1066.91">that's not quite the speed we saw in the C++ example. So, the trick that all modern JavaScript</span> <span data-start="1066.91" data-end="1073.3">engines use is that they have at least 2 compilers, they have us regular just-in-time compiler</span> <span data-start="1073.3" data-end="1080.36">and an optimised just-in-time compiler so what happens just before we go through our</span> <span data-start="1080.36" data-end="1086.6">tokens, abstract syntax, bytecode then pass it on to just-in-time compiler, which does</span> <span data-start="1086.6" data-end="1092.23">it’s work but now it's profiling and when it realises that it's running a function a</span> <span data-start="1092.23" data-end="1097.92">lot of times it says ooh this is a hot function because we're running it a lot, and the optimised</span> <span data-start="1097.92" data-end="1102.58">just-in-time compiler should take over. So for any function that’s been run a lot the</span> <span data-start="1102.58" data-end="1109.09">optimising just-in-time compiler generates faster machine code for that.</span> </p>
<p><span data-start="1109.09" data-end="1114.559">So anything that's run a lot can be executed faster. But you see there’s a back arrow</span> <span data-start="1114.559" data-end="1118">going back from the optimised to regular just-in-time</span> <span data-start="1118" data-end="1126.79">compiler, well this happens if the optimised compiler has read the machine code for a function,</span> <span data-start="1126.79" data-end="1131.54">all of a sudden we call this function with a different hidden class then we can't use</span> <span data-start="1131.54" data-end="1139.52">the machine code and instead we fall back to the old slower just-in-time compiler.</span> <span data-start="1139.52" data-end="1148.12">So in V8 the optimised compiler is called Crankshaft added in 2010 in Microsoft Chakra.</span> <span data-start="1148.12" data-end="1154.73">They call it a full just-in-time compiler, SquirrelFish has not one but 2 just-in-time</span> <span data-start="1154.73" data-end="1165.49">compilers: DFG and FTL. It's faster than light and SpiderMonkey has IronMonkey which helps</span> <span data-start="1165.49" data-end="1171.33">for better performance. Another thing that a lot of compilers, do they leave out that</span> <span data-start="1171.33" data-end="1178.84">step of translating into bytecode. That gives you a little bit of performance.</span> <span data-start="1178.84" data-end="1184.28">Let's look at this twice example again this time with the optimised compiler turned on</span> <span data-start="1184.28" data-end="1189.87">so minus minus crankshaft, that's the default option. Earlier on I had it explicitly turned</span> <span data-start="1189.87" data-end="1196.03">off. Let's have the optimisation on, the same examples as before, the polymorphic and monomorphic</span> <span data-start="1196.03" data-end="1204.46">functions, let's see how fast that is. We went from 6 and 5 seconds down to 1 second,</span> <span data-start="1204.46" data-end="1209.48">that's already good that's a 5, 6 times speedup but for the monomorphic function we see an</span> <span data-start="1209.48" data-end="1219.059">even better speedup, we're down to 90 milliseconds now. So with modern engines if you by default</span> <span data-start="1219.059" data-end="1225.05">use the optimised just-in-time compiler this really makes it faster.</span> </p>
<p><span data-start="1225.05" data-end="1231.24">We can nicely see what's going on here, when we call the monomorphic example the faster</span> <span data-start="1231.24" data-end="1239.34">one with minus minus trace optimisation, then you see we're optimising twice string because</span> <span data-start="1239.34" data-end="1244.54">twice string is always called with a string, and the optimising compiler can now handle</span> <span data-start="1244.54" data-end="1251.45">this and the same for twice int. The other example was the polymorphic function we don't</span> <span data-start="1251.45" data-end="1261.78">see optimisation. They are for random and the polymorphic example crankshaft never really</span> <span data-start="1261.78" data-end="1271.14">kicks in so we don't have massive speedup. There's another neat thing, if you ran twice</span> <span data-start="1271.14" data-end="1277.47">always on an integer we always call it on 4 and any after 10,000 loop iterations we</span> <span data-start="1277.47" data-end="1285.15">call it on a string. Then we see the following. So, since we're always calling it on an integer</span> <span data-start="1285.15" data-end="1290.58">we can optimise it so optimising twice but then we get to 10,000 once we're running it</span> <span data-start="1290.58" data-end="1296.03">just once with a string but that forces the compiler to throw out this optimised version</span> <span data-start="1296.03" data-end="1300.25">of twice when it's called with an integer because all of a sudden you cannot use that</span> <span data-start="1300.25" data-end="1304.04">machine code you generated.</span> <span data-start="1304.04" data-end="1312.75">So take away, monomorphic functions are better than polymorphic functions. A few more things</span> <span data-start="1312.75" data-end="1320.13">to avoid are try/catch statements, anything with eval, so V8 says I am not optimising</span> <span data-start="1320.13" data-end="1327.68">that at all. SquirrelMonkey can do it a little bit but only the simple examples, avoid "with",</span> <span data-start="1327.68" data-end="1335.91">don't do switch statements with more than 128 cases they can't be optimised or maintained.</span> <span data-start="1335.91" data-end="1342.74">\{laughter\} If you have 4 in loops keep your keys local so don't forget var in front of</span> <span data-start="1342.74" data-end="1350.64">it. If you use any of that that will really slow down your code because you can't use</span> <span data-start="1350.64" data-end="1357.57">the optimising compiler. So here's an example of the Fibonacci series, Jennifer already</span> <span data-start="1357.57" data-end="1363.89">mentioned the series earlier, it's a sequence of number that starts off with 11, you get</span> <span data-start="1363.89" data-end="1370.68">the next number always by adding the last 2 numbers. So the algorithm is for the Fibonacci</span> <span data-start="1370.68" data-end="1377.08">number of n, you just have to add the Fibonacci number of n-1 plus the Fibonacci number of</span> <span data-start="1377.08" data-end="1384.96">n-2. We have this nice recursive algorithm, and I stop the recursion when n is smaller</span> <span data-start="1384.96" data-end="1385.96">than 2</span> <span data-start="1385.96" data-end="1391.55">because the first 2 entries are 1 and 1. So we wrote the algorithm but for some reason</span> <span data-start="1391.55" data-end="1398.17">we left an eval 2+2 in there but it's after the statement, it really shouldn't change</span> <span data-start="1398.17" data-end="1409.63">anything, but now when I run this code n=35 I can see that the compiler says optimisation.</span> </p>
<p><span data-start="1409.63" data-end="1414.44">Reason function calls eval. Just because I had the online in there that didn't change</span> <span data-start="1414.44" data-end="1419.48">anything about the algorithm, we can't optimise it, it takes about 4 seconds.</span> <span data-start="1419.48" data-end="1426.299">Ok let's go ahead and fix that remove that line, it's after the return so it really doesn't</span> <span data-start="1426.299" data-end="1437.27">change the code, let's run it again. So we went from 4 seconds to 200 milliseconds, and</span> <span data-start="1437.27" data-end="1443.35">if you put the flag trace optimisation you see the Fibonacci function a nice recursive</span> <span data-start="1443.35" data-end="1449.059">function always called on integers works perfectly fine with the optimising compiler so from</span> <span data-start="1449.059" data-end="1461.12">4 seconds to 200 milliseconds that's a big speedup, but remember this year, don't prematurely</span> <span data-start="1461.12" data-end="1466.19">optimise. Let's look at this example again.</span> <span data-start="1466.19" data-end="1475.8">So for every n we have to add the Fibonacci number of n-1 and n-2. That means if we increase</span> <span data-start="1475.8" data-end="1485.429">n by 1 we're doubling the effort so we have exponential complexity. No, that's not what</span> <span data-start="1485.429" data-end="1492.33">we want. This example is good because we can really easily change the algorithm, so a simple</span> <span data-start="1492.33" data-end="1496.86">trick is just remember the Fibonacci numbers you have already calculated by saving them</span> <span data-start="1496.86" data-end="1506.1">in array a, when you have calculated one use that instead of recalculating it all the time.</span> </p>
<p><span data-start="1506.1" data-end="1515.88">So we have linear complexity instead of exponential complexity, let's look at how fast this is.</span> <span data-start="1515.88" data-end="1522.49">So the exponential example when we delete eval was down to 200 milliseconds or 180,</span> <span data-start="1522.49" data-end="1535.74">the linear example I didn't even bother to take eval out, that only took 67 milliseconds.</span> <span data-start="1535.74" data-end="1540.631">So remember when you want to do optimisation, don't blindly optimise for the compiler, make</span> <span data-start="1540.631" data-end="1549.72">sure you know your bottle neck and fix your algorithms or whatever else is wrong.</span> <span data-start="1549.72" data-end="1556.03">As you saw on this example, JavaScript is almost as fast as native C++ code which is</span> <span data-start="1556.03" data-end="1562.85">amazing considering that JavaScript is a dynamically type language where you can do ahead-of-time</span> <span data-start="1562.85" data-end="1570.49">complication, and since the compilers rely heavily on hidden classes, and inline caching</span> <span data-start="1570.49" data-end="1579.04">your application works best if it's statically typed in nature. Try to avoid polymorphic</span> <span data-start="1579.04" data-end="1585.23">function, make several functions that are monomorphic instead. Use structure initialisation</span> <span data-start="1585.23" data-end="1590.25">that you make sure all your objects do have the same hidden class, if they are the same</span> <span data-start="1590.25" data-end="1596.53">kind of object, also avoid things like eval so you don't stop the optimising compiler.</span> <span data-start="1596.53" data-end="1602.07">Thank you, if you have any questions please come find me I look forward to talking to</span> </p>
</section>