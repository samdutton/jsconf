<section>
<p><span data-start="11.812" data-end="12.526">Hello.</span> <span data-start="13.119" data-end="18.473">I'm Kang Jaeseok and I'm here to talk about 'Javascript Async for effortless UX'.</span> <span data-start="22.999" data-end="27.202">Sharing this content with all of you here,</span> <span data-start="27.281" data-end="30.882">and at a grand stage like the JS Conf Korea- it's a true honor.</span> <span data-start="31.758" data-end="34.104">There's even small commonalities like this.</span> <span data-start="36.181" data-end="37.64">What I'm going to talk about today is..</span> <span data-start="38.988" data-end="41.334">this is the general flow of my story.</span> <span data-start="42.604" data-end="44.796">First, we are going to talk about a problem.</span> <span data-start="45.13" data-end="51.599">Then, we are going to analyze the cause, and based on the cause, we are going to seek for some solutions.</span> <span data-start="55.645" data-end="57.991">First, I'd like to handle this type of problem.</span> <span data-start="59.651" data-end="63.003">We encounter this problem from time to time when using web applications.</span> <span data-start="63.838" data-end="68.799">The scroll stops, or what I typed doesn't show on the screen right away</span> <span data-start="69.659" data-end="72.724">or the animation isn't smooth.</span> </p>
<p><span data-start="74.594" data-end="80.481">As you can see, these are the main examples that can distract users.</span> <span data-start="81.959" data-end="86.648">There are various causes to these problems.</span> <span data-start="87.168" data-end="89.7">First, the animation itself could've been wrong.</span> <span data-start="90.528" data-end="93.486">There could be a problem in the environment.</span> <span data-start="94.939" data-end="99.987">But in this session, we are going to analyze the cause focused on these factors.</span> <span data-start="102.14" data-end="105.66">One of the features of Javascript language: the run-to-completion,</span> <span data-start="105.66" data-end="112.38">Javascript engine, and the Call stack event loop are the three factors.</span> <span data-start="113.64" data-end="120.06">And based on the analyzed causes, I'm going to suggest some solutions.</span> <span data-start="122.085" data-end="125.086">One thing I want you to keep in mind before we start,</span> <span data-start="125.269" data-end="130.276">is that the things I'm going to explain aren't the exact solutions</span> <span data-start="130.759" data-end="135.946">but are part of the progress in finding a better solution to a problem.</span> <span data-start="138.312" data-end="141.074">Before we start, what is a user experience?</span> <span data-start="141.304" data-end="145.51">I'm not a UX designer or an expert in that field.</span> <span data-start="145.851" data-end="148.189">So I'm being careful here but,</span> <span data-start="149.204" data-end="152.514">when you think about what a user experience is,</span> <span data-start="152.567" data-end="161.655">after all, it's about the user's feeling towards the product, system and service.</span> </p>
<p><span data-start="163.511" data-end="166.016">Then what are the common features of these problems?</span> <span data-start="166.54" data-end="174.615">The interaction that the user intended, like page loading, typing and animation, didn't work in time.</span> <span data-start="175.782" data-end="177.614">If the interaction doesn't work in time</span> <span data-start="177.875" data-end="182.77">Like I said, in the user experience's point of view, it's a negative factor.</span> <span data-start="184.786" data-end="189.352">Then what caused these problems?</span> <span data-start="189.841" data-end="192.596">If the intended action doesn't act in time,</span> <span data-start="193.039" data-end="198.307">we can suspect that something is blocking the act and making it slow.</span> <span data-start="198.905" data-end="206.263">To unravel this suspicion, let's take a look at how the Javascript code works internally.</span> <span data-start="207.661" data-end="211.812">First, I want to mention the traits of Run-to-completion.</span> <span data-start="213.491" data-end="219.637">Run-to-completion is, when a process of one message starts,</span> <span data-start="219.638" data-end="224.332">no other process can get in the way until this message process is finished.</span> </p>
<p><span data-start="225.08" data-end="228.581">We'll look at some example code.</span> <span data-start="228.634" data-end="230.278">What would happen if we run this code?</span> <span data-start="233.658" data-end="237.304">Set running to true first,</span> <span data-start="238.299" data-end="240.655">and the setTimeout function can run.</span> <span data-start="241.821" data-end="243.925">Then, start the while loop</span> <span data-start="245.382" data-end="248.188">and check if the running has changed; but it would still be true.</span> <span data-start="249.228" data-end="253.064">Then the running message would be on the console.</span> <span data-start="254.703" data-end="259.957">After about 500 ms, running still would be true.</span> <span data-start="260.928" data-end="264.131">Then we would never be out of the while loop.</span> <span data-start="265.668" data-end="268.993">You could also encounter this familiar icon.</span> <span data-start="269.894" data-end="273.06">As you all know, this is an icon shown when the Chrome tab process is dead.</span> </p>
<p><span data-start="274.774" data-end="279.921">As a developer, we should understand the run-to-completion process well and work hard not to meet this icon.</span> <span data-start="281.154" data-end="286.417">So, I've shown you the process with example code to explain the run-to-completion process.</span> <span data-start="287.484" data-end="293.776">In the Javascript engine, there's a place that acts as a curser to mark where the code is being processed.</span> <span data-start="293.907" data-end="294.973">That is the call stack.</span> <span data-start="296.408" data-end="302.325">Every time there's a request in Javascript, the requests are kept in call stack in order and are processed.</span> <span data-start="303.298" data-end="307.102">For example, they show what function is called and acted,</span> <span data-start="307.512" data-end="310.558">and they manage the function that should be called next.</span> <span data-start="313.759" data-end="317.676">This is code that calls up the hello function, that has code which writes 'Hello',</span> <span data-start="318.294" data-end="327.062">and also defines the helloJsConf function that has code that writes 'JsConfKorea',</span> <span data-start="327.815" data-end="331.825">and ultimately calls up the helloJsConf function.</span> </p>
<p><span data-start="333.228" data-end="335.37">While this code is processed, let's see</span> <span data-start="337.862" data-end="340.82">what happens in the Call stack.</span> <span data-start="341.803" data-end="344.077">First, the main code block is stacked</span> <span data-start="346.154" data-end="349.133">and by calling the helloJsConf function, it joins the stack.</span> <span data-start="349.876" data-end="352.892">Then it calls the hello function</span> <span data-start="354.584" data-end="357.146">and it would request to write the hello message on the console.</span> <span data-start="359.402" data-end="362.152">By writing the hello message, it's eliminated from the stack.</span> <span data-start="363.238" data-end="374.903">JsConfKorea, which was next to the Hello function call, requests to write 'Js Conf Korea' message and gets eliminated from the stack.</span> <span data-start="375.942" data-end="381.156">So helloJsConf function has done its work, so it's eliminated form the stack.</span> <span data-start="381.768" data-end="384.422">After all the work is done, the main block is eliminated.</span> <span data-start="385.432" data-end="391.599">As you can see, Javascript acts with the Call stack structure and run-to-completion method.</span> <span data-start="392.822" data-end="398.392">When these methods are acted out, what kind of situations would cause a problem?</span> <span data-start="401.282" data-end="403.582">Let's give an example situation</span> <span data-start="405.047" data-end="411.406">If you were processing each request at the call stack, and you come up with a task with some delays, what happens?</span> </p>
<p><span data-start="414.243" data-end="416.413">It operates in the order of requests, like in the exercise before</span> <span data-start="420.476" data-end="425.64">And it encounters a request that takes a lot of processing time, like the function 'someExpensive',</span> <span data-start="426.109" data-end="432.862">then there will be delays in things like displaying 'hello' or 'JSConfKorea', which was performed instantly before.</span> <span data-start="435.677" data-end="438.315">Then we have a question here.</span> <span data-start="438.498" data-end="444.236">Javascript is supposed to process multiple tasks at a single call stack structure,</span> <span data-start="444.913" data-end="447.785">but when we think of using web services</span> <span data-start="448.516" data-end="449.36">we click on something,</span> <span data-start="450.297" data-end="454.599">we scroll, and we type, and the data is added and displayed on screen,</span> <span data-start="455.673" data-end="461.775">and it doesn't look like the tasks are being waited upon and processed in order.</span> <span data-start="462.66" data-end="466.314">Then, how are they managing these complex sync issues?</span> <span data-start="468.89" data-end="472.154">The following could be the answers to this question.</span> <span data-start="473.117" data-end="475.469">Web APIs that help the solution of synchronistic issues,</span> <span data-start="475.711" data-end="481.89">DOM events or XMLHttpRequest; the api's used to call Ajax.</span> <span data-start="482.468" data-end="487.11">There are also setTimeout, which manages the timer, Promise, or RequestAnimationFrame.</span> <span data-start="488.073" data-end="490.165">It's hard to not use these in contemporary web development.</span> <span data-start="490.426" data-end="494.21">And the event loop, which I will discuss further in the next chapter.</span> </p>
<p><span data-start="495.563" data-end="502.057">These two enables asynchronous programming with Javascript.</span> <span data-start="503.67" data-end="507.168">Then we will examine the event loop in depth.</span> <span data-start="508.99" data-end="513.008">MDN describes the event loop with codes, like shown.</span> <span data-start="513.321" data-end="519.215">To interpret: assuming that waitForMessage function operates synchronously</span> <span data-start="519.683" data-end="525.579">the code runs the infinite loop waiting for messages, and if there are any, the code would process the next message.</span> <span data-start="527.14" data-end="531.029">The event loop is not a component of the Javascript engine.</span> <span data-start="531.29" data-end="534.423">Which means, supporting asynchronicity</span> <span data-start="534.97" data-end="540.212">would not be the Javascript engine, but the environment that the engine is driven on, like the browser or node.js.</span> <span data-start="540.551" data-end="542.175">This is where the event loop is grounded.</span> <span data-start="542.593" data-end="549.137">In such an environment, the loop controls which task to shove into the call stack.</span> <span data-start="550.569" data-end="554.613">This is a simple explanation of how the event loop works.</span> <span data-start="555.862" data-end="558.97">If there are tasks, execute the oldest one,</span> </p>
<p><span data-start="559.439" data-end="564.965">And there aren't any tasks, wait for one, and if there's any, go back to number 1 and repeat.</span> <span data-start="568.321" data-end="576.402">Now I will discuss the event loop further with the aforementioned code, using web APIs that manages asynchronicity.</span> <span data-start="577.157" data-end="580.426">Look at the code here: setTimeout is, as you know,</span> <span data-start="580.427" data-end="585.564">a function that creates timer events, wait for a time, and executes them.</span> <span data-start="586.695" data-end="591.337">Like you see in the example code, if there is no factor it will be the default value, 0.</span> <span data-start="592.404" data-end="597.203">The 0 in the timer gives the feeling it should be executed right away, but that's not true.</span> <span data-start="597.438" data-end="601.17">The reason for that, we will find out the steps of how the code works.</span> <span data-start="605.309" data-end="612.869">The Promise is an API dealing with future situations in which asynchronous operations have succeeded or failed at processing.</span> <span data-start="613.364" data-end="619.803">This code restores the Promise's transitioning to empty values with the resolve method,</span> <span data-start="620.012" data-end="624.786">and hands the callback over, when the transition is completed with the then method.</span> </p>
<p><span data-start="624.865" data-end="626.047">Let's take a look.</span> <span data-start="628.26" data-end="631.368">You see, first the setTimeout is called.</span> <span data-start="631.759" data-end="635.047">And the callback goes to the task waiting line.</span> <span data-start="637.388" data-end="638.934">Promise is called over,</span> <span data-start="640.677" data-end="643.159">and the part that was handed over to the then method through callback</span> <span data-start="644.33" data-end="646.188">It should be in the task waiting line</span> <span data-start="647.905" data-end="652.106">but as you can see, its in a slightly different waiting line.</span> <span data-start="653.954" data-end="659.565">In ES6, to deal with the synchronicity, APIs like Promise are added</span> <span data-start="659.93" data-end="665.25">but these deal with tasks slightly differently from regular tasks, which are called microtasks.</span> </p>
<p><span data-start="666.135" data-end="670.049">The difference between tasks and microtasks is this.</span> <span data-start="671.376" data-end="677.867">Tasks are the things that need to be executed in order, in the browser or other places.</span> <span data-start="678.883" data-end="685.973">Their sources can be regular script execution, setTimeout, or callbacks from UI events.</span> <span data-start="687.25" data-end="693.352">Microtasks are asynchronous tasks that come right after the task that's being executed now.</span> <span data-start="693.847" data-end="698.359">Which means that microtasks have higher priorities than regular tasks.</span> <span data-start="698.828" data-end="705.685">Like I mentioned, its sources could be the Promise, Observer API, and the process.nextTick of Node.js.</span> <span data-start="708.002" data-end="714.828">And so coming back to my earlier definition of event loops, we'll need a little modification.</span> </p>
<p><span data-start="717.796" data-end="719.367">If you look at it, before waiting for the task,</span> <span data-start="720.279" data-end="723.307">it needs to check if there are any microtasks</span> <span data-start="723.776" data-end="727.064">and if the microtasks are empty, then it will run the tasks.</span> <span data-start="729.12" data-end="733.711">Then, when we come back to the example code, now we can see what the event loop does.</span> <span data-start="734.674" data-end="737.104">The callback is handed over to the Promise,</span> <span data-start="737.859" data-end="742.319">it is pushed into the call stack through the event loop as a microtask,</span> <span data-start="742.919" data-end="743.633">and it is executed.</span> <span data-start="744.414" data-end="747.547">And the task that displays "hello" would be executed.</span> <span data-start="750.306" data-end="753.755">Then, based on the understanding of event loops,</span> <span data-start="753.756" data-end="758.84">can we solve all the problems if we use web api's dealing with asynchronisity?</span> <span data-start="762.577" data-end="765.267">Unfortunately, no.</span> <span data-start="765.476" data-end="771.006">Still, because of the tasks in front of that, there is still possibility that the next tasks may be blocked.</span> <span data-start="771.371" data-end="772.007">Shall we take a look?</span> <span data-start="773.881" data-end="775.245">Like the example before,</span> <span data-start="776.415" data-end="777.78">call setTimeout,</span> <span data-start="778.535" data-end="780.991">put the callback in the task queue,</span> <span data-start="785.706" data-end="788.032">then call the Promise,</span> </p>
<p><span data-start="789.021" data-end="790.021">The callbacks..</span> <span data-start="791.663" data-end="792.377">One second,</span> <span data-start="795.138" data-end="799.417">The callbacks to execute the expensive tasks of then go into the microtask queue.</span> <span data-start="802.824" data-end="806.869">As I have mentioned, because microtasks have higher priority,</span> <span data-start="806.87" data-end="811.728">the event loop has pushed higher-cost operations into the call stacks first.</span> </p>
<p><span data-start="813.205" data-end="816.237">Therefore, the task of hitting 'Hello'</span> <span data-start="817.079" data-end="819.143">will be blocked by the event loop.</span> <span data-start="821.638" data-end="824.884">Obviously, if the task is completed, then it could be executed.</span> <span data-start="826.458" data-end="830.284">So, though it took a while to get here,</span> <span data-start="830.462" data-end="836.006">to summarize, the causes and process of inconvenient UIs and UXs are as follows.</span> <span data-start="838.054" data-end="841.96">Because tasks are always executed sequentially by the event loop,</span> <span data-start="841.961" data-end="845.619">other tasks cannot be performed until a given task at hand is finished.</span> <span data-start="846.863" data-end="852.587">And since microtask queue has higher priority than other task queues,</span> <span data-start="852.588" data-end="857.578">tasks like UI events cannot be executed until all micro-tasks in queue are cleared.</span> </p>
<p><span data-start="858.521" data-end="860.145">Thus, tasks which take long time to execute,</span> <span data-start="860.328" data-end="866.829">for example, if tasks and microtasks involving multiplication calculation of CPU bounds are being executed,</span> <span data-start="867.516" data-end="872.839">then events directly related to UI, such as click, text, rendering etc, can be blocked.</span> <span data-start="872.97" data-end="877.316">This means that this may be 'an element harmful for user experience'.</span> <span data-start="880.519" data-end="885.099">Then, how can this blocking be resolved?</span> </p>
<p><span data-start="887.022" data-end="891.126">I will illustrate through the demo I've prepared.</span> <span data-start="891.381" data-end="897.964">This material is already public, so please feel free to look it up if you are interested.</span> <span data-start="898.891" data-end="899.809">Prior to the demo,</span> <span data-start="901.86" data-end="905.578">let's take a look at how the demo works, through the code.</span> <span data-start="907.606" data-end="908.835">It's simple code.</span> <span data-start="908.836" data-end="911.762">It's code that whenever a text input event occurs,</span> <span data-start="912.295" data-end="919.777">it creates HTML of a rectangular element of random color, proportional to the number of input characters,</span> <span data-start="920.142" data-end="921.468">and displays it on the screen.</span> <span data-start="921.932" data-end="924.445">There are two main points here.</span> <span data-start="925.376" data-end="927.163">There are many iterations,</span> <span data-start="928.044" data-end="931.864">and that the cost of DOM renewals are high.</span> <span data-start="933.16" data-end="939.223">I think this scenario of CPU bound high-cost operations would be sufficient to recreate the same blocking.</span> </p>
<p><span data-start="940.208" data-end="942.98">Let's take a quick look at the demo.</span> <span data-start="956.736" data-end="958.605">It's a simple UI.</span> <span data-start="959.07" data-end="966.598">There's a text input box in the middle, and the animation surrounds the box.</span> <span data-start="966.764" data-end="974.312">When I type a message, DOM whose number corresponds to the length of the message I typed, would be renewed on the screen.</span> <span data-start="975.527" data-end="979.737">And I'm in the perspective of user interaction this time.</span> <span data-start="979.738" data-end="982.928">I'd like the audience to focus on whether my text inputs are being well-reflected,</span> <span data-start="982.981" data-end="987.691">and if the animation is functioning properly.</span> <span data-start="988.121" data-end="989.919">I will try typing a message here.</span> <span data-start="997.52" data-end="1004.943">You can see that the text freezes at about J, and the animation freezes as well.</span> <span data-start="1005.435" data-end="1009.335">And the rendering is reflected after a few whole seconds.</span> <span data-start="1014.408" data-end="1015.276">Coming back,</span> <span data-start="1021.003" data-end="1025.05">this is the result I got from profiling the demo using Chrome developer tool.</span> <span data-start="1025.8" data-end="1029.775">It looks a bit complex, but there are only two main points to focus on.</span> <span data-start="1030.816" data-end="1032.976">First, the top frame section.</span> <span data-start="1033.492" data-end="1036.258">I don't know if you can see here.</span> </p>
<p><span data-start="1036.592" data-end="1040.175">But, almost three seconds were consumed for just 1 frame.</span> <span data-start="1041.472" data-end="1046.848">Next, regarding the user interaction in this interaction section below,</span> <span data-start="1047.863" data-end="1050.059">you can see the analyzed results.</span> <span data-start="1050.186" data-end="1057.379">The red underlines within the orange blocks refer to the time consumed waiting for the main thread of user interaction.</span> <span data-start="1057.836" data-end="1061.151">So, the very long red underlines mean that</span> <span data-start="1061.152" data-end="1065.782">considerable time has been spent for each interaction.</span> <span data-start="1066.314" data-end="1074.173">So, now I should introduce resolutions for minimizing these problems.</span> <span data-start="1075.275" data-end="1078.275">I have two main solutions.</span> <span data-start="1078.692" data-end="1079.356">First,</span> <span data-start="1080.834" data-end="1084.786">the method of delegating the task to another thread,</span> <span data-start="1084.915" data-end="1087.221">since the block happens because of the structure of a single call stack and event loop.</span> <span data-start="1087.712" data-end="1092.551">Meaning that we could try multi-threading, if it's possible on Javascript as well.</span> <span data-start="1094.003" data-end="1097.22">Or another solution, if the task causing the block is too heavy,</span> <span data-start="1097.221" data-end="1100.089">then we can split the task into smaller tasks.</span> <span data-start="1103.131" data-end="1107.095">Multithreading on javascript can be done through web workers.</span> </p>
<p><span data-start="1107.12" data-end="1112.692">Web workers enable script operation in the background thread, which is separate from the main thread.</span> <span data-start="1114.556" data-end="1118.218">Worker thread is created off the main thread,</span> <span data-start="1119.26" data-end="1121.346">so that message-based communication with the worker thread is possible.</span> <span data-start="1122.252" data-end="1127.624">Through postMessage, execution of long running tasks can be requested to the worker thread.</span> </p>
<p><span data-start="1128.338" data-end="1130.196">The worker thread will execute this,</span> <span data-start="1130.842" data-end="1133.875">and there will be no blocks in the main thread due to this execution.</span> <span data-start="1135.202" data-end="1138.55">When the task is complete, results will be delivered through postMessage again.</span> <span data-start="1139.219" data-end="1142.249">And the main thread can then do something else with it.</span> <span data-start="1143.9" data-end="1145.876">Similarly, looking at this from the code,</span> <span data-start="1147.354" data-end="1149.111">the explanation is pretty much the same.</span> <span data-start="1149.112" data-end="1153.941">Worker object will be created, and through the postMessage method of the worker object,</span> <span data-start="1154.375" data-end="1157.424">the long running task can be requested to the worker thread when necessary,</span> <span data-start="1158.462" data-end="1163.159">and when the worker thread has completed it, the code will handle the results.</span> <span data-start="1164.29" data-end="1168.701">Then, we will take a look at a demo which utilizes this method.</span> <span data-start="1175.092" data-end="1177.411">I'll type the same message.</span> </p>
<p><span data-start="1182.037" data-end="1184.977">Okay, doesn't it seem better than before?</span> <span data-start="1185.134" data-end="1189.904">But, it still seems a bit slow.</span> <span data-start="1195.572" data-end="1200.098">Then, let's take a look at the demo profiling results which have been calculated with the explained methods.</span> <span data-start="1200.119" data-end="1200.901">Let's see.</span> <span data-start="1202.601" data-end="1205.933">You can see that the duration of frame and the duration of interaction</span> <span data-start="1207.645" data-end="1210.157">have very much decreased.</span> <span data-start="1211.709" data-end="1219.902">However, as seen in the demo, this method too fails to provide lag-free usage.</span> </p>
<p><span data-start="1221.518" data-end="1226.091">Most of the display devices these days are 60fps, I believe?</span> <span data-start="1226.349" data-end="1230.784">Considering the display at the standard of 1 frame per 16ms,</span> <span data-start="1231.438" data-end="1236.04">if you look up here, it is taking around 200ms, 600ms and if longer it takes up to around 900 ms.</span> <span data-start="1237.155" data-end="1241.971">My suggested reason, the operation that is CPU bound has been delegated to the worker thread</span> <span data-start="1242.305" data-end="1246.919">but operations like DOM renewals are still happening in the main thread.</span> <span data-start="1247.781" data-end="1253.443">The limitations of web workers are that the main thread and the worker thread can only communicate via a system of messages.</span> <span data-start="1253.935" data-end="1259.375">Meaning, the worker cannot access the DOM or the context of the main thread directly.</span> <span data-start="1261.959" data-end="1266.971">Next, there should be a way to run tasks asynchronously by splitting the heavy tasks into smaller ones.</span> <span data-start="1269.474" data-end="1272.71">It should look something like this when visualized.</span> <span data-start="1274.243" data-end="1277.691">If tasks in the back are getting blocked due to long-running tasks in the front,</span> <span data-start="1278.04" data-end="1284.391">this is a way of scheduling the tasks by splitting the large task into pieces, and placing them between other tasks.</span> <span data-start="1285.736" data-end="1289.91">Did you enjoy the previous session on generators?</span> <span data-start="1289.911" data-end="1292.049">I used the generator as well</span> <span data-start="1293.194" data-end="1296.321">to create an environment of scheduling,</span> <span data-start="1297.591" data-end="1298.721">where you can easily manage your schedule.</span> </p>
<p><span data-start="1298.951" data-end="1303.627">This is also open so feel free to take a look if you'd like.</span> <span data-start="1305.027" data-end="1306.399">I don't know if you can see the code.</span> <span data-start="1306.655" data-end="1311.349">Unlike executing the work once input event is triggered from the existing code,</span> <span data-start="1311.658" data-end="1319.983">here it is calling chunkGenerator on an interface called runChunks, and is passing it on.</span> <span data-start="1320.703" data-end="1325.219">chunkGenerators slice the existing iteration into appropriate chunk units</span> <span data-start="1325.454" data-end="1327.936">and have a pattern of yielding them at the corresponding units.</span> <span data-start="1328.723" data-end="1330.851">runChunks take the works yielded</span> <span data-start="1331.684" data-end="1338.018">and take the role of loading them into the task queue via asynchronous APIs, like the aforementioned setTimeout.</span> </p>
<p><span data-start="1338.861" data-end="1340.891">Then let's take a look at</span> <span data-start="1342.525" data-end="1343.383">the demo with this method applied.</span> <span data-start="1349.857" data-end="1351.053">I will write the same message.</span> <span data-start="1354.409" data-end="1355.339">Yes, in comparison,</span> <span data-start="1356.736" data-end="1360.077">you can see that text input is blocked a lot less</span> <span data-start="1362.289" data-end="1363.003">but still.</span> <span data-start="1364.912" data-end="1369.964">rendering is getting delayed and happening all at once.</span> <span data-start="1373.129" data-end="1375.879">At least text input is not blocked,</span> <span data-start="1377.237" data-end="1378.867">at least we've took care of that.</span> <span data-start="1381.048" data-end="1383.396">Likewise, let's look at the results from profiling.</span> <span data-start="1384.377" data-end="1388.911">Here too, we can see that there has been a big improvement in the numerical aspect as well.</span> </p>
<p><span data-start="1391.097" data-end="1393.519">Since we are already here, let's try to optimize it even more.</span> <span data-start="1394.479" data-end="1397.713">It seems that the cost of updating DOM is quite high.</span> <span data-start="1398.905" data-end="1401.981">We will approach it in the direction of minimizing the DOM update.</span> <span data-start="1402.524" data-end="1406.244">The demo updates DOM depending on the text input,</span> <span data-start="1407.182" data-end="1411.248">so I think it should be fine to only renew it at the last moment like before,</span> <span data-start="1412.057" data-end="1415.223">and not renew it for every typed input, like in the last scenario.</span> <span data-start="1417.247" data-end="1424.501">When the task is in a big chunk, the next task gets blocked so it cannot decide whether to update and continue the execution</span> <span data-start="1424.753" data-end="1427.057">but since it has been sliced into smaller chunks</span> <span data-start="1427.73" data-end="1430.172">applying this method would be possible.</span> <span data-start="1431.391" data-end="1435.324">For example, you can check if it is in the middle of executing the task,</span> <span data-start="1435.325" data-end="1440.046">and it if is, then you can cancel the corresponding task and execute a new task.</span> </p>
<p><span data-start="1441.047" data-end="1441.737">Shall we take a look?</span> <span data-start="1457.187" data-end="1462.697">As you can see, DOM is updated only once, when the final work is processed</span> <span data-start="1462.75" data-end="1465.321">and the animation does not seem to stop.</span> <span data-start="1465.322" data-end="1468.726">Text input is not blocked either.</span> <span data-start="1478.305" data-end="1480.211">The profiling graph seems very tidy as well.</span> <span data-start="1480.987" data-end="1485.297">Maximum duration of frame lasted a little longer at the moment of updating DOM</span> <span data-start="1485.298" data-end="1486.91">and the rest of frames are quite good.</span> <span data-start="1487.11" data-end="1489.71">Duration of interaction is really short too</span> </p>
<p><span data-start="1495.083" data-end="1495.997">Oh, time flies.</span> <span data-start="1496.311" data-end="1498.55">This is it, let me recap.</span> <span data-start="1500.678" data-end="1508.362">When long-running tasks or microtasks block events like rendering, click, and text input,</span> <span data-start="1508.363" data-end="1512.203">it is possible that a UI can harm user experience.</span> <span data-start="1512.204" data-end="1512.939">This is</span> <span data-start="1515.335" data-end="1522.346">due to the structure of the JavaScript engine, event loop and etc</span> <span data-start="1522.347" data-end="1526.264">and one must understand it and handle it properly.</span> <span data-start="1529.014" data-end="1535.518">And in order to handle this, one must delegate long running tasks to background thread like a Web Worker.</span> <span data-start="1535.519" data-end="1541.643">Or, one can split the long-running task so that other important UI events are not blocked.</span> <span data-start="1543" data-end="1543.71">That is the appropriate method;</span> <span data-start="1544.562" data-end="1546.13">This is the summary.</span> </p>
<p><span data-start="1547.556" data-end="1554.164">Actually, the demo I showed you and the assumed situations are rather extreme.</span> <span data-start="1554.424" data-end="1557.992">It's hard for that to happen in common app codes as well,</span> <span data-start="1557.993" data-end="1562.719">and it's a situation that you must try to avoid.</span> <span data-start="1563.989" data-end="1567.021">We say the best way to optimize is to just avoid it</span> <span data-start="1568.057" data-end="1572.207">and it is true that we should avoid expensive operation or excessive DOM updates.</span> <span data-start="1572.857" data-end="1575.987">Nevertheless, the reason for me to come up here and share this topic,</span> <span data-start="1576.685" data-end="1583.59">is that even if codes run smoothly, them being written with or without proper knowledge on their operation</span> <span data-start="1583.591" data-end="1587.042">has a significant impact in the long run.</span> <span data-start="1587.043" data-end="1591.345">I hope my intentions have been conveyed well. I will end it here.</span> </p>
</section>