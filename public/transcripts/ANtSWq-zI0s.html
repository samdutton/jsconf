<section>
<p><span data-start="16.59" data-end="17.28">Hi, everyone.</span> <span data-start="18.18" data-end="19.32">It's really nice to be here.</span> <span data-start="20.4" data-end="21.84">How's it — How's your day been goin'?</span> <span data-start="22.71" data-end="23.82">Great. Okay.</span> </p>
<p><span data-start="24.03" data-end="29.7">So hopefully this one is not too boring to be, you know, a talk at this time of the day</span> <span data-start="29.7" data-end="32.97">because I'm pretty sure you have seen a lot of talks already.</span> <span data-start="33" data-end="38.37">But just briefly introducing myself for those who don't know me.</span> <span data-start="38.52" data-end="39.63">My name is Evan You.</span> <span data-start="40.29" data-end="44.07">My Twitter handle is @youyuxi, which is my Chinese name.</span> <span data-start="44.58" data-end="49.68">I am an independent open source developer since 2016, so</span> <span data-start="51.72" data-end="56.7">that is to say, I've been working just on open source independently for three years now.</span> </p>
<p><span data-start="57.33" data-end="59.82">And I work primarily on Vue.js.</span> <span data-start="60.69" data-end="62.43">How many of you actually use it?</span> <span data-start="65.04" data-end="65.79">Alright, great.</span> <span data-start="66.24" data-end="72.93">So it started as a side project in 2013 and I've been working on it full time since 2016.</span> <span data-start="73.41" data-end="79.26">And over the years of working on frameworks, right, I've learned a lot of stuff.</span> <span data-start="80.31" data-end="91.59">And that kind of also gives me a lot of perspective on the internal design, some of the trade-offs, decisions that people make when it comes to building frameworks, right?</span> <span data-start="92.71" data-end="95.77">How many of you remember the days back in like 2013,</span> <span data-start="95.77" data-end="99.82">when there's probably a new JavaScript framework coming out every single day?</span> <span data-start="100.75" data-end="106.81">ToDoMVC has a list of like 40-50 frameworks, all building the same thing?</span> <span data-start="107.23" data-end="114.22">And Vue kind of started around that time where I was just looking at some of these existing solutions and trying to figure out,</span> <span data-start="114.91" data-end="119.32">what would I do if I were to build something like this?</span> </p>
<p><span data-start="119.77" data-end="125.35">Okay, but obviously, my ideas around what should be done has evolved over time and changed a lot.</span> <span data-start="125.35" data-end="132.88">But today, I'm going to be talking about some of these findings, specifically, front end framework design.</span> <span data-start="135.46" data-end="142">I bet a lot of you have been using a framework, even if you're not using Vue, you probably use React, Angular or some other framework.</span> <span data-start="142.54" data-end="148.96">It's hard to imagine building a complex front end application without something of that sort today, right?</span> <span data-start="149.59" data-end="155.35">You can probably still build things with vanilla JavaScript, but we know it's going to take a bit more time.</span> <span data-start="156.37" data-end="159.31">However, at the same time, like because of all these frameworks,</span> </p>
<p><span data-start="159.31" data-end="164.8">I guess most of you are also kind of tired of all these framework comparisons, right?</span> <span data-start="165.16" data-end="170.65">This is how I look like whenever I see yet another framework comparison article pop up on Medium,</span> <span data-start="170.95" data-end="175.15">like "The best seven new frameworks to using 2019".</span> <span data-start="175.6" data-end="176.68">I just like "ew".</span> <span data-start="178.87" data-end="182.98">Not because, you know, not because I built Vue, and I want people to use it,</span> <span data-start="183.01" data-end="185.53">or I don't want to see people hating on it, right?</span> <span data-start="185.68" data-end="191.82">But because most of the time, these articles just focus on things like GitHub stars,</span> <span data-start="191.82" data-end="193.06">or NPM download counts,</span> <span data-start="193.06" data-end="194.38">or Stack Overflow questions,</span> <span data-start="194.74" data-end="199.39">these stats that you can just easily find anywhere, anybody can just google them up, right.</span> </p>
<p><span data-start="199.39" data-end="207.16">But these stats, while still kind of useful to a certain extent, maybe for marketers, right.</span> <span data-start="207.67" data-end="209.8">But if you're trying to make a technical decision,</span> <span data-start="210.01" data-end="213.64">and you're trying to compete some of these relatively mature technologies,</span> <span data-start="213.87" data-end="217.86">these numbers are less and less relevant above a certain threshold, right?</span> <span data-start="218.74" data-end="225.55">Like most of these, you know, what we use in production today probably have over 10,000 stars on GitHub, right.</span> <span data-start="225.58" data-end="232.09">Above that threshold, like, really? Does it really matter how many stars, like, several thousand stars this library has got?</span> <span data-start="232.99" data-end="234.4">It doesn't really matter that much.</span> <span data-start="234.4" data-end="242.59">What you should probably care more about is some of the internal technical decisions, like what actually differs these frameworks.</span> <span data-start="243.7" data-end="251.05">So before we dig into that, take a step back and think about all the common goals of these frameworks.</span> <span data-start="251.08" data-end="253.66">We all are working towards the same goal -</span> <span data-start="253.69" data-end="260.02">all these framework authors are trying to provide you with something that helps you to build web apps as efficiently as possible,</span> <span data-start="260.17" data-end="263.23">then why do we have all these different competing ideas?</span> </p>
<p><span data-start="263.83" data-end="266.29">And is it a good thing or is it a bad thing? Right?</span> <span data-start="266.32" data-end="272.08">So why do we have so many different frameworks, each with a decent sizable following, right?</span> <span data-start="272.29" data-end="278.92">Because I believe, like, React Angular Vue, each have more than half a million users.</span> <span data-start="279.28" data-end="281.38">So why is that?</span> </p>
<p><span data-start="281.95" data-end="289.75">I think the source, the reason is that there isn't a single good versus bad spectrum for frameworks, right?</span> <span data-start="289.75" data-end="294.91">People tend to ask questions like, which framework is better?</span> <span data-start="295.35" data-end="302.37">Just stop asking that. Because it's not that simple to say framework A is better than framework B.</span> <span data-start="303.42" data-end="308.28">We know that software design is about trade offs. So are front end framework design.</span> <span data-start="308.49" data-end="313.38">There's so many trade offs, in fact, especially in the web world, right,</span> <span data-start="313.41" data-end="318.03">because the web is the platform with probably the most diverse set of use cases.</span> <span data-start="318.39" data-end="325.83">We build all kinds of crazy stuff on the web, from the simplest page possible to the most complex application you use every day.</span> <span data-start="326.94" data-end="334.38">So to accommodate all these use cases, frameworks have to make trade offs not just on a single spectrum.</span> <span data-start="334.86" data-end="340.2">We have to make trade offs on multiple spectrums, a lot of different areas. So -</span> <span data-start="341.52" data-end="351.15">And today, I'm going to be talking about some of these, hopefully, giving you some insight on what to look at,</span> <span data-start="351.15" data-end="356.34">but due to the time constraints I won't be able to dig in to all of these possible dimensions.</span> <span data-start="356.61" data-end="359.88">So I'll focus on a few of them — scope.</span> </p>
<p><span data-start="360.12" data-end="363.6">So this is essentially how much the framework is trying to do for you.</span> <span data-start="364.41" data-end="367.8">And then the render mechanism -</span> <span data-start="367.83" data-end="375.33">when you use the framework, how do you express your view structure? And how does the framework handle your code? How does it actually render stuff to the page?</span> <span data-start="376.17" data-end="385.44">And then there's the state mechanism — mutable versus immutable, dirty checking versus dependency tracking, reactivity versus simulated reactivity.</span> <span data-start="386.46" data-end="390.6">Actually, I won't have time to dig into this one, maybe this will be another talk at a later time.</span> <span data-start="390.96" data-end="397.17">So I'll go right into scope — how much a framework is trying to do for you.</span> <span data-start="399.03" data-end="409.41">So let's put it on a spectrum and you'll have one end where the framework, or the library, is doing intentionally smaller things</span> <span data-start="409.68" data-end="418.44">where on the other end, we have more monolithic things, like frameworks that try to provide as many features as possible.</span> <span data-start="418.62" data-end="419.13">Excuse me.</span> <span data-start="420.27" data-end="424.59">So some of the iconic examples, probably most people know about, right?</span> <span data-start="424.62" data-end="430.08">React kind of nicely falls onto the end of libraries, primitives.</span> <span data-start="430.35" data-end="435.21">And Angular falls on the side of frameworks providing you with a lot of abstractions, right?</span> <span data-start="435.39" data-end="443.67">So React exemplifies the philosophy where the library is focused on providing a very fundamental model for thinking about UI.</span> <span data-start="443.94" data-end="451.23">It tries to focus on providing you with these lower level good primitives on which you can build your own abstractions with.</span> <span data-start="451.92" data-end="454.17">The scope is intentionally small.</span> </p>
<p><span data-start="454.44" data-end="459.99">So that's why also why React has a very, very active ecosystem, right.</span> <span data-start="459.99" data-end="471.18">So along with the ecosystem, React is like the bazaar where the system is sort of organically built bottom up by the community around the core model that React has established.</span> <span data-start="472.2" data-end="479.97">On the other end, so Angular and alongside to some of the other frameworks like Ember, Aurelia are more like the cathedral, right.</span> <span data-start="480" data-end="490.38">They're designed top down, where most of the conceivable problems that the users will probably run into has been sort of considered during the design process -</span> <span data-start="490.41" data-end="498.69">form validation, animations — most of the common things you will encounter during the daily development, the framework tries to provide a solution for you.</span> <span data-start="499.65" data-end="504.81">And in order to do that, the framework has to be designed in a way that is very top down,</span> <span data-start="505.14" data-end="510.78">we have to think about everything how everything works together, fits together, from day one, right.</span> <span data-start="512.58" data-end="521.67">And this, this scope is intentionally big, because the goal of such a design is so that when you are trying to solve a problem,</span> <span data-start="521.67" data-end="524.76">you will be able to find the solution within the framework.</span> <span data-start="526.17" data-end="533.31">Now, we call this small scope versus big scope and it's not necessarily about good or bad.</span> <span data-start="533.37" data-end="535.23">Again, I want to emphasize that.</span> <span data-start="535.26" data-end="545.1">So some pros of the small scope is, there are fewer concepts to get started with and there's more flexibility.</span> <span data-start="545.36" data-end="552.44">So there's more userland opportunities, right, because the framework, the library is only providing with some really low level primitives.</span> <span data-start="553.16" data-end="559.04">So you have a component model, you have some props, you can pass props to it, and then you can return some virtual DOM tree.</span> <span data-start="559.42" data-end="562.6">That's pretty much it. That's pretty much it about React, right.</span> <span data-start="562.84" data-end="565.78">But on top of that, you can build arbitrary complex systems.</span> </p>
<p><span data-start="566.62" data-end="570.28">So React has a very, very active ecosystem.</span> <span data-start="570.34" data-end="576.79">People see that they have these very flexible tools and, you know, they just run wild with their creativity.</span> <span data-start="576.79" data-end="581.44">So there are a lot of great ideas coming out of the React community.</span> <span data-start="582.67" data-end="591.19">And in addition, being intentionally small in scope, also allows the team to have a smaller maintenance surface</span> <span data-start="591.22" data-end="594.85">so that they can focus on the things that they believe that matters, right.</span> <span data-start="594.85" data-end="601.63">So the team can focus on exploring new ideas, which is why react can spend such a long time working on things like</span> <span data-start="602.11" data-end="610.81">concurrent mode, suspense, React hooks, and all these interesting stuff they've been cranking out in the past few weeks or months.</span> <span data-start="611.5" data-end="614.56">Right, they've actually been working on it for a few years already so.</span> <span data-start="615.52" data-end="620.35">But this is because, you know, they have a small scope, so they can focus on these things.</span> <span data-start="621.52" data-end="625.18">So there are some cons of small scope, obviously.</span> <span data-start="625.33" data-end="631.51">So first is there's more plumbing work needed when solving inherently complex problems with simple concepts.</span> <span data-start="631.78" data-end="638.11">So there was a talk that I really liked, by Guy Steele, called "Growing a Language".</span> </p>
<p><span data-start="638.14" data-end="647.02">So during the talk, Guy set himself a rule so during that talk, he can only use single syllable words.</span> <span data-start="647.05" data-end="653.44">And if you want to use any words that has more than one syllables, he has to define it first with single syllable words.</span> <span data-start="654.07" data-end="662.32">So he is given a very limited list of primitive stuff to to be able to construct more complex ideas with.</span> <span data-start="662.62" data-end="664.96">So you can imagine how that talk went, right?</span> <span data-start="665.56" data-end="670.84">Before he speaks every sentence, he has to like, take out a few slides and define a bunch of words before he can proceed.</span> <span data-start="671.14" data-end="678.07">And that's kind of like building a really complex production grade app with very, very low level primitives -</span> <span data-start="678.25" data-end="683.56">you have to build a lot of abstract abstractions, to make yourself more efficient along the way.</span> </p>
<p><span data-start="684.67" data-end="688.9">Now, because of that, patterns naturally emerge over time, right?</span> <span data-start="690.01" data-end="692.8">When we say React is really simple to get started with,</span> <span data-start="692.95" data-end="700.09">we're kind of ignoring the fact that you sort of more or less have to learn Redux before you can consider yourself a real React developer.</span> <span data-start="700.39" data-end="706.48">And then you have to know about things like higher order components, or prod — render props,</span> <span data-start="706.48" data-end="713.17">and then now you have to learn hooks, and the many different ways of using CSS in JS, right.</span> <span data-start="713.17" data-end="718.9">So all of these patterns emerge over time, and they kind of become semi required, right?</span> </p>
<p><span data-start="718.93" data-end="723.07">If you don't know about these, you really can't call yourself a React developer.</span> <span data-start="724.12" data-end="727">And oftentimes, these things are not officially documented.</span> <span data-start="727" data-end="731.26">If you go to the React website, they're not going to tell you which CSS JS solution to use.</span> <span data-start="731.26" data-end="733.84">You have to do your own research and learn it.</span> <span data-start="734.68" data-end="742.12">So that's kind of the cons of having a really, really, you know, userland dominated system.</span> <span data-start="742.87" data-end="748.36">Now, the ecosystem can be moving too fast, and can lead to fragmentation and constant churn.</span> <span data-start="749.44" data-end="757.18">And I believe anyone who's been following along in the early days of the flux, sort of, every day there's a new flux implementation,</span> <span data-start="757.18" data-end="761.08">and then later on, everyday there's a new CSS JS implementation, right?</span> <span data-start="761.89" data-end="764.77">It's good and bad at the same time.</span> <span data-start="765.58" data-end="768.79">The good is there are always these new ideas coming out,</span> <span data-start="768.79" data-end="772.15">and we're trying to figure out what is actually the best way to do it.</span> <span data-start="772.18" data-end="776.26">The bad thing is, for people who are just trying to follow along and get something built,</span> <span data-start="777.28" data-end="782.95">you have this constant FOMO, right, you're always in fear of missing out on the next best thing.</span> </p>
<p><span data-start="783.91" data-end="791.74">So we're done with the small scope, cons, and let's talk about the pros of being large in scope.</span> <span data-start="793.51" data-end="799">The most obvious advantage is most common problems can be solved with building abstractions.</span> <span data-start="799.15" data-end="805">So if you're just trying to get something built, I just need a router, I need some animation,</span> <span data-start="805" data-end="808">I need to fetch some data with an HTTP client..</span> <span data-start="808.66" data-end="812.47">A framework like Angular provides everything you need to get that out of the door.</span> <span data-start="813.76" data-end="815.92">So you don't actually have to look elsewhere.</span> <span data-start="815.92" data-end="819.82">Just read the documentation, use the framework, and you can get things done.</span> <span data-start="820.93" data-end="825.04">Centralized design process ensures consistent and coherent ecosystem, right.</span> <span data-start="825.04" data-end="832.12">So you don't have to shop for different solutions when you're running into a specific problem.</span> <span data-start="832.48" data-end="835.66">You just look at the framework, see what the framework tells you to do, right?</span> </p>
<p><span data-start="835.66" data-end="838.06">Most likely, it has an opinion on it.</span> <span data-start="838.24" data-end="847">So you don't have to go dig into 10 different competing solutions and figure out which one fits your use case best.</span> <span data-start="848.02" data-end="852.34">Now, the cons of being large in scope is there is a higher upfront learning barrier.</span> <span data-start="853.03" data-end="859.78">In order to get the pixel onto the screen, the hoops you have to jump through to get there.</span> <span data-start="860.47" data-end="865.45">This can be a big deterrent for beginners, for people without proper, or</span> <span data-start="865.48" data-end="872.29">I wouldn't say proper — people without prior experience in dealing with back end languages.</span> <span data-start="872.32" data-end="877">Like if you've never used Java or C#, you've only learned HTML, CSS and JavaScript,</span> <span data-start="877.39" data-end="883.75">reading the Angular documentation is probably a pretty humbling experience, I would say.</span> <span data-start="885.19" data-end="886.27">It is still for me.</span> <span data-start="887.47" data-end="891.7">Now, it can be inflexible if built in solution doesn't fit the use case, right?</span> <span data-start="892" data-end="895.99">Sometimes you might just feel like, I wish I could do it the other way but</span> <span data-start="896.02" data-end="898">I don't have the option to swap it out.</span> <span data-start="899.29" data-end="907">And finally, a framework that is large in scope inherently makes introducing fundamental new ideas much more costly,</span> <span data-start="907" data-end="912.55">because there are so many associated pieces that need to work consistently together.</span> <span data-start="912.91" data-end="915.64">And when you try to change a fundamental idea,</span> <span data-start="915.73" data-end="918.28">it affects every component in your system.</span> </p>
<p><span data-start="918.52" data-end="921.76">So making changes is just a much harder thing.</span> <span data-start="921.97" data-end="926.65">Whereas if you think about in the React ecosystem,</span> <span data-start="927.17" data-end="931.64">because the core team is not really responsible for a lot of these solutions in the wild.</span> <span data-start="932.22" data-end="940.52">When you, say, introduce hooks, which made Redux more or less redundant, it's not eally a problem.</span> <span data-start="940.52" data-end="941.63">So there's that.</span> </p>
<p><span data-start="942.71" data-end="945.92">OK, so now this is where Vue kind of falls on.</span> <span data-start="945.92" data-end="953.39">But before we dig into what Vue is doing, I want to emphasize like this is not about like how Vue is better than both of these, right?</span> <span data-start="953.42" data-end="958.19">Because being in the middle doesn't necessarily indicate it's the best.</span> <span data-start="958.48" data-end="963.31">If you stretch this spectrum long enough, you zoom out long enough,</span> <span data-start="963.31" data-end="967.63">you'll see like, they are actually all kind of in the optimal zone already.</span> <span data-start="967.84" data-end="972.73">So it's just like we slightly differ on where we think the optimal point is.</span> <span data-start="972.97" data-end="978.55">So each choice also kind of fits the needs of different groups of users, right?</span> <span data-start="978.58" data-end="981.22">It's not like one thing that can fit all.</span> <span data-start="982.18" data-end="988.27">So what I call the way Vue takes on the scope problem is,</span> <span data-start="989.32" data-end="994.66">you probably know the tagline Vue is called — we call Vue the progressive framework.</span> </p>
<p><span data-start="994.81" data-end="1003.84">So being progressive in scope means framework uses a layer design that allows features to be opted in, in a progressive manner.</span> <span data-start="1004.38" data-end="1010.59">That is to say, if you don't need routing, if you don't need state management, if you don't need a built step, even,</span> <span data-start="1010.93" data-end="1013.15">you can use Vue without any of those.</span> <span data-start="1013.18" data-end="1017.65">You just pull in Vue.JS onto your page, and you can instantly start working on something.</span> <span data-start="1018.7" data-end="1023.62">The learning barrier of jumping from beginner to getting a pixel on the screen</span> <span data-start="1024.1" data-end="1031.63">is shortened by removing anything that could be in your way in your first minute of learning.</span> </p>
<p><span data-start="1032.68" data-end="1037.24">So this is — the low entry learning barrier is really important for us because</span> <span data-start="1037.78" data-end="1042.1">one of the missions of Vue is to allow more people to get into web development,</span> <span data-start="1042.13" data-end="1049.51">to allow people to learn this and to focus on building things instead of</span> <span data-start="1049.51" data-end="1055.48">learning about a lot of concepts that might not be necessary for your current use case.</span> <span data-start="1058.03" data-end="1065.5">But we still have documented solutions for these common problems, like as your use case gets more complicated,</span> <span data-start="1065.5" data-end="1067.51">as you're building something more complex,</span> <span data-start="1068.29" data-end="1070.87">you realize, okay, I do need a router.</span> <span data-start="1071.08" data-end="1075.91">So you're looking to the documentation, you see, okay, Vue actually does provide a router, which I can use.</span> <span data-start="1076.81" data-end="1082.78">But at the same time, the router is not a required piece and you can actually implement your own if you want to,</span> <span data-start="1082.78" data-end="1089.38">because you see how Vue's router is built and it is cleanly decoupled from the core implementation,</span> <span data-start="1089.38" data-end="1093.64">so you kind of realize that you can build your own solution too, if you want to.</span> </p>
<p><span data-start="1093.79" data-end="1103.78">So it's not perfect, because we being in the middle actually means we are sharing the cons of both sides.</span> <span data-start="1103.87" data-end="1111.73">So first, although we are making the adoption incremental, we are still responsible for maintaining all these things.</span> <span data-start="1112.21" data-end="1115.54">So we share the same maintenance surface problem of big scope -</span> <span data-start="1115.75" data-end="1120.46">when we want to change something fundamentally, we have to make sure the whole ecosystem moves along with it,</span> <span data-start="1120.7" data-end="1123">so this maintenance burden is almost the same with big scope.</span> </p>
<p><span data-start="1123" data-end="1130.47">And at the same time, because we do provide these pre built solutions,</span> <span data-start="1131.07" data-end="1136.98">our ecosystem probably will be not as diverse as, say, React, the small scope system,</span> <span data-start="1136.98" data-end="1141.36">because small scope is inherently like leaving the problem to the community</span> <span data-start="1141.57" data-end="1149.01">whereas in our case, a lot of users will be happy with our solutions and they probably won't spend time on trying to figure out their own solutions.</span> <span data-start="1150.03" data-end="1153.69">So that is the scope problem.</span> <span data-start="1153.69" data-end="1157.92">So hopefully, you can kind of, you now have an idea of where sort of -</span> <span data-start="1158.31" data-end="1164.25">this is what I think is the most fundamental difference between React, Vue and Angular.</span> </p>
<p><span data-start="1165.69" data-end="1170.43">This exact positioning is what defines our different user bases.</span> <span data-start="1172.14" data-end="1177.03">And I think a lot of times, we're making intentional decisions, in terms of where we stand.</span> <span data-start="1177.39" data-end="1183.93">And we, as framework designers, we know that we are attacking different sectors</span> <span data-start="1183.93" data-end="1189">and I think that's a good thing because different developers needed different solutions.</span> <span data-start="1189" data-end="1195.81">And having major frameworks covering the whole spectrum ensures everyone gets what they want.</span> <span data-start="1197.52" data-end="1202.62">Okay, so now let's talk about our rendering mechanism, i.e.,</span> <span data-start="1202.95" data-end="1208.32">how a framework allows you to express your UI structure and how it renders stuff.</span> <span data-start="1211.26" data-end="1216.42">And primarily, this is actually a pretty complex spectrum spectrum in itself.</span> <span data-start="1216.45" data-end="1218.82">It's not just a single thing.</span> <span data-start="1218.84" data-end="1229.58">So it's like a multi dimension in itself, but let's briefly simplify it and think of it as JSX versus templates,</span> <span data-start="1229.61" data-end="1237.59">that is, dynamic render functions versus static string-based compilation-based Vue expressions.</span> <span data-start="1237.92" data-end="1241.04">And then there's expressiveness versus raw performance,</span> <span data-start="1241.07" data-end="1245.24">then there's runtime scheduling versus ahead of time optimizations.</span> </p>
<p><span data-start="1247.37" data-end="1255.56">Some people have really strong opinions on this,but I personally feel that they are more alike, inherently,</span> <span data-start="1255.71" data-end="1259.04">they're just different strategies of expressing the same underlying idea.</span> <span data-start="1259.22" data-end="1261.98">So it's more about the technical trade offs, right?</span> <span data-start="1261.99" data-end="1279.39">So on the left, the spectrum, obviously JSX, React, and all the React-like libraries that use some sort of virtual DOM, like, pre-act, Stencil, Infernal, right.</span> <span data-start="1279.57" data-end="1284.49">And then on the other side, template-based solutions, so I'll talk about Vue later but</span> <span data-start="1284.72" data-end="1291.89">the more representative template-based solution, Svelte,</span> <span data-start="1293.15" data-end="1299.87">and then there's Ember, so that logo is actually Glimmer's logo — so Glimmer is the rendering engine inside Ember -</span> <span data-start="1300.32" data-end="1301.94">and then Angular as well.</span> </p>
<p><span data-start="1301.97" data-end="1309.05">So these are primarily template-based, and they compile templates into relatively lower level instructions to render stuff.</span> <span data-start="1310.25" data-end="1314.81">Now, let's talk about the pros of the JSX and virtual DOM approach.</span> <span data-start="1315.83" data-end="1324.71">The most important reason people like JSX or virtual DOM is they have the full expressiveness of JavaScript -</span> <span data-start="1325.16" data-end="1331.37">you're not confined to a arbitrary syntax, you have a language at your disposal — you can</span> <span data-start="1331.4" data-end="1334.55">it's Turing complete, you can pretty much do anything you want.</span> <span data-start="1336.86" data-end="1340.49">So you can build arbitrarily complex logic, you know, components.</span> <span data-start="1340.52" data-end="1342.95">And it's really powerful and liberating, right?</span> <span data-start="1343.25" data-end="1346.52">A lot of people like React for this particular reason.</span> <span data-start="1347.99" data-end="1352.04">And it also allows you to treat the view as data.</span> <span data-start="1352.43" data-end="1355">When you render a component, it always returns something -</span> <span data-start="1355" data-end="1359.68">it returns the tree, the virtual DOM tree that represents the current state of a component.</span> </p>
<p><span data-start="1359.95" data-end="1362.65">And this data can be used for a lot of interesting purposes.</span> <span data-start="1363.25" data-end="1368.35">It gives you userland possibility to build, say, testing solutions.</span> <span data-start="1368.38" data-end="1373.12">You can take snapshots based on the virtual DOM, you can render it to alternative targets,</span> <span data-start="1373.54" data-end="1380.8">people have been doing things like rendering it to terminals, PDF, Canvas, WebGL, anything you can think of that you can render to.</span> <span data-start="1382.69" data-end="1386.65">Because the view is data, and you can do anything with data.</span> <span data-start="1387.7" data-end="1394.39">Now, the cons of virtual DOM, is that it is actually inherently expensive, right?</span> <span data-start="1394.42" data-end="1398.83">Think about it, when React first came out, a lot of people are like, isn't this going to be slow?</span> <span data-start="1399.2" data-end="1403.55">And React's answer was, "Yes, it's slow, but it's fast enough".</span> <span data-start="1404.39" data-end="1410.72">But still, like, from a pure technical perspective, you're doing a lot of unnecessary work.</span> <span data-start="1410.99" data-end="1418.61">Think about this simple template where the amount of work needed to just update that single message binding in there,</span> <span data-start="1418.9" data-end="1425.2">we have to walk through the whole virtual DOM tree, and diff diff diff diff diff -</span> <span data-start="1425.23" data-end="1432.4">you just have to recursively keep going down until somehow you update this in this process.</span> <span data-start="1432.6" data-end="1439.65">So standard virtual DOM diffing cost is relative to the total size of your view, rather than the number of nodes that may change.</span> <span data-start="1440.89" data-end="1446.14">Even if you only have one node that may change, the virtual DOM diffing algorithm doesn't know.</span> </p>
<p><span data-start="1446.2" data-end="1452.17">The reason is the dynamic nature of render functions makes it hard to optimize for.</span> <span data-start="1453.01" data-end="1456.28">By dynamic I mean, you can write code like this,</span> <span data-start="1456.85" data-end="1463.78">you can just use a for loop to construct a children array and then give it to your parent node.</span> <span data-start="1464.17" data-end="1466.27">And God knows what other things you can do.</span> <span data-start="1467.26" data-end="1471.67">Say you can create this parent node first, then mutate its children,</span> <span data-start="1471.67" data-end="1474.16">you can push additional elements into it.</span> </p>
<p><span data-start="1474.99" data-end="1479.82">The compiler won't be able to cover all the possible edge cases you can do with JavaScript,</span> <span data-start="1479.97" data-end="1482.43">because JavaScript is simply too dynamic.</span> <span data-start="1483.57" data-end="1492.3">There are a lot of attempts in this space but inherently, it's hard to provide safe optimizations in this way,</span> <span data-start="1494.22" data-end="1497.16">because there isn't simply enough assumptions you can make.</span> <span data-start="1497.19" data-end="1501.99">The more assumptions you can make about the user intention, the easier it is to optimize the code.</span> <span data-start="1502.2" data-end="1504.93">And with JavaScript, it's just really, really hard.</span> <span data-start="1506.61" data-end="1518.37">Now, finally, React's solution to this problem is to instead of focusing on making virtual DOM itself faster, how about making perceived performance better?</span> <span data-start="1518.42" data-end="1524.33">So it introduces runtime scheduling, concurrent mode, time slicing.</span> <span data-start="1524.81" data-end="1532.55">But this, having this runtime solution, having this whole fiber, kind of like almost managing your own stack,</span> <span data-start="1534.95" data-end="1539.33">like entering and exiting, rendering, all the stuff requires a heavy runtime.</span> <span data-start="1540.2" data-end="1547.52">So this means whenever you load React, you have to load all the code that is necessary for handling all these complex runtime scheduling stuff.</span> <span data-start="1547.99" data-end="1552.67">That's like several 20, 30KB of JavaScript, right.</span> </p>
<p><span data-start="1553.39" data-end="1556.36">And that, in turn, also makes your initial loading suffer a little bit.</span> <span data-start="1559.33" data-end="1565.15">And, on the other hand, if you are compiling, rendering code from a template,</span> <span data-start="1565.72" data-end="1570.52">usually it can produce far more direct render instructions with better raw performance.</span> <span data-start="1570.7" data-end="1576.7">The reason being that the template is, by definition a very, very constrained language -</span> <span data-start="1576.82" data-end="1578.89">you can only write template a certain way.</span> </p>
<p><span data-start="1579.07" data-end="1582.61">For example, when you write code like this,</span> <span data-start="1583.12" data-end="1588.04">we can instantly tell that there's no way the order of these p can ever change,</span> <span data-start="1588.07" data-end="1590.08">there's no way this ID can ever change,</span> <span data-start="1590.08" data-end="1591.61">there's no way this class can ever change,</span> <span data-start="1591.61" data-end="1593.29">the only thing that can change is this.</span> </p>
<p><span data-start="1593.89" data-end="1602.08">So being static, and very restrictive actually allows the compiler to make more assumptions about your intention.</span> <span data-start="1602.14" data-end="1604.9">And that gives it more room to perform optimizations.</span> <span data-start="1605.29" data-end="1608.47">Think about what Svelte does when it compiles your code.</span> <span data-start="1610.6" data-end="1614.38">Everything else is static, but only name could possibly change, so</span> <span data-start="1614.72" data-end="1621.35">this P is the update function in Svelte code, and the only thing it does is change when a name has changed,</span> <span data-start="1621.35" data-end="1623.24">and then update it if it has changed.</span> </p>
<p><span data-start="1623.63" data-end="1629.42">So compare this to all the things a virtual DOM diffing algorithm tries to do.</span> <span data-start="1629.9" data-end="1632.78">The difference is just orders of magnitude faster.</span> <span data-start="1634.46" data-end="1644.84">So depending on strategy, template compilation, or in general,compilation-based approach can also result in much lighter runtime baseline size,</span> <span data-start="1644.84" data-end="1651.44">because it doesn't need all the complex runtime scheduling to trying to make things look faster,</span> <span data-start="1651.56" data-end="1653.51">because it's already fast, right?</span> <span data-start="1653.69" data-end="1664.7">So Svelte can produce extremely lightweight output without having to require heavy, heavy baseline runtime to accommodate to all the possible runtime behavior.</span> <span data-start="1665.93" data-end="1670.7">Now, the cons of template compilation is obviously, you are constrained by the template syntax -</span> <span data-start="1670.91" data-end="1673.76">you lose the expressiveness of JavaScript.</span> <span data-start="1674.21" data-end="1678.95">So when you are trying to build a really complex component, you'll feel like</span> <span data-start="1678.98" data-end="1683.21">Oh, I wish I can do this in the template, but the compiler does not support it, right,</span> <span data-start="1683.33" data-end="1687.11">you're out of luck, there's no escape hatch if you go the full compilation route,</span> <span data-start="1687.29" data-end="1696.38">because the more lower level the compiler output is, the less likely you'll be able to actually hook into it and do your custom operations there.</span> </p>
<p><span data-start="1696.9" data-end="1704.85">It's like an opa compiler that you won't be able to dig into assembly with C.</span> <span data-start="1705.3" data-end="1707.73">that's just, you know, the way it is.</span> <span data-start="1710.67" data-end="1714">It's as if you won't be able to debug your assembly code with C.</span> <span data-start="1714" data-end="1723.18">So now, lighter runtime, lighter baseline runtime may also come at the cost of more verbose output per template, because</span> <span data-start="1724.74" data-end="1734.49">when you're trying to produce code that executes as efficiently as possible, sometimes you would have to encode more information in the output directly.</span> <span data-start="1735.36" data-end="1747.78">For example, the code that Svelte produces actually imperatively creates all the elements line by line, insert them one by one, and they have a separate function for updating them.</span> <span data-start="1748.95" data-end="1755.22">In comparison, virtual DOM based results, you would have to just have one line.</span> <span data-start="1755.46" data-end="1759">And that's just a single expression that returns the virtual DOM structure.</span> <span data-start="1760.44" data-end="1762.42">So, runtime compilation.</span> <span data-start="1765.18" data-end="1768.57">There's a runtime compilation cost if you compile on the fly.</span> <span data-start="1770.34" data-end="1778.17">So most likely, for production use case, you would require users to compile beforehand so that places a hard requirement on a build step,</span> <span data-start="1778.56" data-end="1781">which is something, you know, it's just inevitable.</span> <span data-start="1781" data-end="1789.76">You either compile on the fly or pre built, which then involves all the node.js tool chains, which we are more or less used to now.</span> <span data-start="1789.76" data-end="1795.64">But still, if you can avoid it, it would be really nice when people are getting started.</span> <span data-start="1796.78" data-end="1799.81">Ok. So again, Vue kind of falls in the middle.</span> <span data-start="1800.41" data-end="1803.08">Again, I want to emphasize, this is not saying Vue is the best.</span> </p>
<p><span data-start="1805.3" data-end="1811.66">But the unique thing about Vue's rendering mechanism is we have both virtual DOM and template compilation.</span> <span data-start="1812.11" data-end="1816.19">Vue actually compile those templates into virtual DOM under the hood.</span> <span data-start="1817.33" data-end="1821.14">So we kind of get the best of both worlds.</span> <span data-start="1822.55" data-end="1827.5">We have performance — the compilation step produces specially optimized, vdom render function.</span> <span data-start="1827.5" data-end="1830.62">I'll talk about this in a bit of more details later.</span> <span data-start="1830.86" data-end="1837.31">In ver 2.x, we actually haven't fully exploited this opportunity.</span> <span data-start="1837.94" data-end="1844.84">The current Vue 2.x virtual DOM performance is probably just average virtual DOM, typical virtual DOM performance.</span> <span data-start="1845.32" data-end="1850.24">But I'll talk a bit about what we're doing in 3.0 to make this much, much faster.</span> <span data-start="1850.75" data-end="1852.25">And then there's expressiveness.</span> <span data-start="1853.17" data-end="1863.31">You can actually skip the template layer, you can drop down into render functions and directly leverage JavaScript to perform arbitrarily complex logic.</span> <span data-start="1863.4" data-end="1867.33">So this gives you an escape hatch when you feel you're constrained by templates.</span> <span data-start="1868.62" data-end="1876">Now, the downside is, right, although we can be really fast, we're not</span> <span data-start="1876.03" data-end="1886.59">we can probably never be as fast as say, Svelte because Svelte, it's the vanilla — its output is pretty much vanilla JavaScript.</span> </p>
<p><span data-start="1887.13" data-end="1896.4">Whereas in order to be compatible with handwritten render functions, Vue still has to maintain a virtual DOM, so that cost is inevitable.</span> <span data-start="1896.93" data-end="1902.06">And on the other hand, it kind of also creates a split between like, "which one should I use" problem.</span> <span data-start="1903.5" data-end="1908.18">So a lot of users, although they can actually use render function, they'll probably just never use it.</span> <span data-start="1908.6" data-end="1918.83">So now let's dig into what we're doing in v3.0 to make Vue's template compile to virtual DOM run faster than normal virtual DOM.</span> <span data-start="1919.73" data-end="1924.47">This is what we already talked about, right, this template there's only one node that would change -</span> <span data-start="1924.47" data-end="1929.69">the ideal update path is just diff this message string directly.</span> <span data-start="1930.47" data-end="1932.45">No structure is static and never changes.</span> <span data-start="1932.6" data-end="1934.13">There's only one dynamic node.</span> <span data-start="1934.16" data-end="1937.64">So if we consider this template, it's a very, very simple case.</span> <span data-start="1938.59" data-end="1943.75">It becomes a bit more complicated when you have things like v-if, which is what we call a structural directive.</span> <span data-start="1944.56" data-end="1951.61">In JSX, this is pretty much an equivalent of a ternary — based on a condition you return different branches.</span> <span data-start="1952.78" data-end="1958.99">Now, this creates a dynamic node structure, because the node may be there or may not be there.</span> <span data-start="1959.77" data-end="1968.92">So to deal with this, a naive virtual DOM diffing algorithm would have to just assume the note list has changed and try to diff the two children arrays.</span> <span data-start="1969.43" data-end="1976.03">But if we try to split it apart and see v-if separates the template into two nested blocks -</span> <span data-start="1976.3" data-end="1985.54">the outer block, if we consider the v-if itself as a node, then the outer block has a static node content, node structure.</span> </p>
<p><span data-start="1985.9" data-end="1988.48">Inside the v-if block it also is static.</span> <span data-start="1988.9" data-end="1999.37">Now we have two static blocks, where within each block, you will have no need to diff any node order changes,</span> <span data-start="1999.4" data-end="2004.83">the only thing you need is a flat array of the things that could possibly change inside this block.</span> <span data-start="2005.5" data-end="2010.24">Similarly, for v-for — every v-for iteration, we consider it a static block.</span> </p>
<p><span data-start="2011.11" data-end="2017.14">So if you have more like a v-if inside v-for you just split further into nested blocks.</span> <span data-start="2018.01" data-end="2021.28">So we end up with something I call a block tree.</span> <span data-start="2022" data-end="2031.12">This is just a play on something we know, but the block tree is a nested block — blocks, because</span> <span data-start="2032.71" data-end="2041.5">within each block, you have a completely static node structure, so there's no need for any sort of like recursively going down and trying to diff two children lists.</span> <span data-start="2042.97" data-end="2048.61">Within each block, you just have one single flat array of the nodes that could possibly change.</span> <span data-start="2048.84" data-end="2055.95">On top of this, we also have additional organization hints on, for example, if a node has only a dynamic class binding,</span> <span data-start="2055.95" data-end="2063.24">we have a fast path that you just directly set the class and you can go ahead, you don't have to diff the props if you don't want to.</span> <span data-start="2064.29" data-end="2065.37">You don't have to, right.</span> <span data-start="2066.96" data-end="2070.47">So the before and after is pretty obvious.</span> <span data-start="2071.59" data-end="2077.65">For the same template, previously, we had to do all the full algorithm for different everything.</span> <span data-start="2077.65" data-end="2086.74">And afterwards, we just do a single, flat, there will be a single array containing just this node with a dynamic text.</span> <span data-start="2086.8" data-end="2090.25">And the only thing you need to do is compare whether the text has changed.</span> <span data-start="2091.66" data-end="2108.13">So we did a brief benchmark with this is a list of 1000 v-for iterations — within each block, you have around 12 DOM nodes, that is a total of 12,000 DOM nodes.</span> <span data-start="2108.7" data-end="2116.98">Within each iteration, you have four dynamic bindings, some classes, some text, so that is 4000, dynamic bindings on the page.</span> <span data-start="2117.02" data-end="2123.65">And we update all of these bindings, and we do 100 runs, take the average.</span> <span data-start="2123.92" data-end="2136.88">Current v2.6, per update is 36 milliseconds and current v3.0 prototype with the new compilation strategy it takes only like around 5.4 milliseconds.</span> </p>
<p><span data-start="2136.88" data-end="2141.38">So that is more than six times faster in this benchmark, right.</span> <span data-start="2143.62" data-end="2144.19">Thanks.</span> <span data-start="2147.78" data-end="2157.11">So note in this benchmark alone, probably your real app probably will have a different number but you know, more or less, it's going to be a lot faster.</span> <span data-start="2157.24" data-end="2158.59">That's the baseline.</span> <span data-start="2160.6" data-end="2164.65">And then state mechanism, I probably don't have time to really dig into this.</span> <span data-start="2164.83" data-end="2167.11">So that'll be another talk.</span> <span data-start="2167.53" data-end="2175.51">But to wrap up, where is the perfect balance point here, when you're trying to design a framework?</span> <span data-start="2176.62" data-end="2183.31">The question should probably be rephrased — does a perfect balance even exist?</span> <span data-start="2184.3" data-end="2189.52">And is a single perfect balance point even optimal for JS devs as a whole, right?</span> </p>
<p><span data-start="2189.88" data-end="2196.33">Because, like, all of us are trying to optimize for different things, when you're building something specific.</span> <span data-start="2196.36" data-end="2204.82">For example, like, for Svelte, it's advantage is it can produce extremely lightweight code when you're building something small.</span> <span data-start="2205.03" data-end="2209.77">And it is also extremely fast uses very, very little memory.</span> <span data-start="2209.77" data-end="2212.59">So it can be used on like, even embedded devices.</span> <span data-start="2212.92" data-end="2219.7">But if you're targeting use cases where, you know, you probably have a more complex use case,</span> <span data-start="2220" data-end="2221.47">you have more components,</span> <span data-start="2221.47" data-end="2226.24">you want the expressiveness of JavaScript but you also want a bit more performance from the templates,</span> <span data-start="2226.24" data-end="2227.3">you can probably go with Vue.</span> <span data-start="2227.3" data-end="2234.98">And then if you don't really care that much about extreme performance but you're like "I like React's ecosystem",</span> <span data-start="2234.98" data-end="2235.85">you can go with React.</span> <span data-start="2236.6" data-end="2239.18">There's all these options you can pick.</span> <span data-start="2240.56" data-end="2248.3">So I think it's nice that the framework landscape is like a multi-dimensional space with multiple ever moving entities,</span> <span data-start="2248.3" data-end="2255.77">like think of each framework as an entity, trying to look for the balance point it believes is the best.</span> </p>
<p><span data-start="2255.8" data-end="2259.07">We're all trying to figure out, what's the best way to do things.</span> <span data-start="2259.28" data-end="2261.95">And there will be multiple of us always, right.</span> <span data-start="2262.04" data-end="2266.3">So as developers, you're like floating around in between these entities.</span> <span data-start="2267.23" data-end="2270.08">You're dragged towards one of them by their gravity.</span> <span data-start="2270.62" data-end="2276.08">And sometimes you may just, you know, switch around, you hop around and try to figure out which one is best for you.</span> <span data-start="2276.35" data-end="2278.09">I think that's a good thing, right?</span> <span data-start="2281.51" data-end="2286.31">But as a user, right, trying to navigate this multi-dimensional space can be daunting.</span> <span data-start="2287.27" data-end="2290.75">But if you want to pick up the framework properly the hard way,</span> <span data-start="2291.17" data-end="2295.28">then you have to understand some of these internal trade offs the frameworks are making.</span> </p>
<p><span data-start="2295.97" data-end="2307.37">You have to be aware of which direction this framework is heading towards and whether it aligns with what you are prioritizing in the thing you're trying to build.</span> <span data-start="2307.97" data-end="2315.89">So hopefully this talk has shed some light on that topic and could help you when you are trying to pick between frameworks in the future or</span> <span data-start="2316.25" data-end="2318.62">tell other people how they should pick a framework.</span> </p>
</section>