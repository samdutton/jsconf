<section>
<p><span data-start="9.7" data-end="13.34">Hi, I flew in from Australia the day before yesterday.</span> <span data-start="13.35" data-end="19.99">I'm not saying that I'm the most jet lagged person here, but I would appreciate it if</span> <span data-start="19.99" data-end="22.699">you could all just put in a little bit of effort to laugh at my jokes.</span> <span data-start="22.699" data-end="25.63">That would really make things easier for me!</span> <span data-start="25.63" data-end="29.65">So, the event loop.</span> <span data-start="29.65" data-end="35.14">A couple of years back, here at this very conference, a guy by the name of Phil Roberts</span> <span data-start="35.14" data-end="40.03">did a talk called "What the heck is the event loop anyway?"</span> <span data-start="40.03" data-end="43.79">If you haven't seen it, I highly recommend you check it out.</span> <span data-start="43.79" data-end="46.12">It is on the JSConf YouTube chapel.</span> <span data-start="46.12" data-end="50.37">It is pretty fucking exciting because it catches on fire!</span> <span data-start="50.37" data-end="52.71">In case you haven't seen it, though.</span> <span data-start="52.71" data-end="57.8">It is an overview of the event loop, the different components, and how they work together.</span> </p>
<p><span data-start="57.8" data-end="61.59">If you haven't seen it, we will do a quick overview of the things that are relevant for</span> <span data-start="61.59" data-end="68.049">today, and then we are going to do a deep dive into specific parts of the event loop.</span> <span data-start="68.049" data-end="75.39">So, you can think of the event loop as, like, the main function of the browser.</span> <span data-start="75.39" data-end="77.369">It's just an infinite loop.</span> </p>
<p><span data-start="77.369" data-end="82.81">It's going to grab a task off the task queue, and it's going to run that task.</span> <span data-start="82.81" data-end="86.409">Which is great, but what is a task?</span> <span data-start="86.409" data-end="91.69">So a task is how JavaScript gets run.</span> <span data-start="91.69" data-end="97.689">If we have a bit of a script like this, we can see JavaScript in there.</span> <span data-start="97.689" data-end="102.539">The browser will parse this script tag and create the task.</span> <span data-start="102.539" data-end="105.329">So the code with the dark background is going to be a task.</span> </p>
<p><span data-start="105.329" data-end="109.03">When it gets run, it's going to create a variable, it's going to do something, and it's going</span> <span data-start="109.03" data-end="116.749">to register this event listener, and, then, whenever the browser gets a keydown event,</span> <span data-start="116.749" data-end="119.529">the bit of blue is going to run as a task.</span> <span data-start="119.529" data-end="125.209">Every bit of JavaScript that runs as a task could be a script or could be a callback.</span> <span data-start="125.209" data-end="126.61">What does execute task do?</span> <span data-start="126.61" data-end="128.24">It runs the code.</span> </p>
<p><span data-start="128.24" data-end="129.89">What about the taskQueue.</span> <span data-start="129.89" data-end="136.34">That's what we are going to look at today.</span> <span data-start="136.34" data-end="142.27">We are going to look at taskQueues in the context of browsers, and look at Node, and</span> <span data-start="142.27" data-end="145.769">we are going to have a real quick look at web workers.</span> <span data-start="145.769" data-end="146.769">Constitutional.</span> <span data-start="146.769" data-end="155.12">So what is a taskQueue and what is it for?</span> <span data-start="155.12" data-end="158.12">It's where your code goes, where your JavaScript goes while it's waiting to execute.</span> <span data-start="158.12" data-end="164.61">So, like before, we could parse a script tag, we could have callback on a click event, we</span> <span data-start="164.61" data-end="168.78">could have a callback on a set time out.</span> <span data-start="168.78" data-end="173.08">They're going to go into our queue there, and they're going to get executed.</span> </p>
<p><span data-start="173.08" data-end="177.73">The important thing is that it is a queue, so things are going to get executed in the</span> <span data-start="177.73" data-end="182.76">order that they arrive — first in, first out — and the other important thing is that a</span> <span data-start="182.76" data-end="185.01">task is going to run from start to finish.</span> <span data-start="185.01" data-end="186.629">There is no interrupted JavaScript.</span> <span data-start="186.629" data-end="191.08">You don't have to worry about concurrency, locking, or any of that rubbish.</span> <span data-start="191.08" data-end="193.17">It is super easy.</span> <span data-start="193.17" data-end="194.17">Cool.</span> <span data-start="194.17" data-end="195.69">That's our event loop.</span> <span data-start="195.69" data-end="201.04">It turns out, though, it's a little bit more complicated than that.</span> <span data-start="201.04" data-end="205.34">You see, the taskQueue works in conjunction with the rendering pipeline.</span> </p>
<p><span data-start="205.34" data-end="209.95">The rendering pipeline is what it responsible for painting things in the browser window,</span> <span data-start="209.95" data-end="214.719">so you make changes to the DOM, you update your style, and then the rendering pipeline</span> <span data-start="214.719" data-end="217.769">runs and shows it on the screen.</span> <span data-start="217.769" data-end="221.2">So, the webbed pipeline can run after a task finishes.</span> <span data-start="221.2" data-end="228.03">The task finishes, the rendering pipeline can run, but browsers are pretty clever, right?</span> <span data-start="228.03" data-end="233.7">They don't like to do work that they don't have to do, and there is really no point running</span> <span data-start="233.7" data-end="238.78">the rendering pipeline unless the screen's about to refresh, so your average screen refresh</span> <span data-start="238.78" data-end="247.09">s 60 times a second, once every 16 milliseconds, so, if we run a task, the rendering pipeline</span> <span data-start="247.09" data-end="249.879">is going to wait that 16 milliseconds before it runs.</span> </p>
<p><span data-start="249.879" data-end="253.269">If it is not obvious, this is the slowed down version.</span> <span data-start="253.269" data-end="257.609">It is turns out it is hard to see, at 60 frames a second.</span> <span data-start="257.609" data-end="263.33">Sitting around doing nothing all that time is a bit of a waste, so, in reality, the browser's</span> <span data-start="263.33" data-end="267.15">going to run a where did you go of tasks, and then run the rendering pipeline.</span> <span data-start="267.15" data-end="273.1">The important thing is that the rendering pipeline can't run until the task finishes.</span> <span data-start="273.1" data-end="279.449">If you've got a task that takes a really long time, the rendering pipeline has to wait.</span> <span data-start="279.449" data-end="281.94">A couple of milliseconds here and there isn't going to matter.</span> <span data-start="281.94" data-end="288.919">If you take tasks that take a lot more than 16 milliseconds, your web page is going to</span> <span data-start="288.919" data-end="293.31">start dropping frames and start running like this.</span> <span data-start="293.31" data-end="297.59">If you do have long-running tasks, you can split them up, so you can create new tasks</span> <span data-start="297.59" data-end="299.91">using something like setTimeout.</span> <span data-start="299.91" data-end="307.919">You can use would be workers because that's what they are for.</span> <span data-start="307.919" data-end="312.05">So now, an event loop looks a bit like this.</span> <span data-start="312.05" data-end="318.43">We're going to run an infinite loop, pick a task off the task cube, and run that task,</span> <span data-start="318.43" data-end="321.57">and then, if we're ready to repaint, we will repaint.</span> </p>
<p><span data-start="321.57" data-end="324.99">That's cool, right?</span> <span data-start="324.99" data-end="334.93">It turns out, it's more complicated than that, if you have a look at the spec, which I'm</span> <span data-start="334.93" data-end="343.24">sure we do in our spare time, you will see that an event loop it have one or more taskQueues.</span> <span data-start="343.24" data-end="366.35">At this point, what I will do is I will have a look at an query .. . [Sound distorted].</span> <span data-start="366.35" data-end="376.01">So, instead, we are going to look at a theoretical browser with multiple taskQueue s.</span> <span data-start="376.01" data-end="380.629">To be clear, this is the example that is give in the spec of having multiple taskQueues,</span> <span data-start="380.629" data-end="386.919">so I didn't make it — somebody else made it up.</span> <span data-start="386.919" data-end="392.04">This browser prioritises mouse-click event.</span> <span data-start="392.04" data-end="395.46">It has got two taskQueues there.</span> <span data-start="395.46" data-end="400.8">One where our mouse click is going to go and another queue where everything else goes.</span> </p>
<p><span data-start="400.8" data-end="408.449">This is really simple, it's like the business class line at the airport.</span> <span data-start="408.449" data-end="414.349">It's going to run all of the tasks in the mouse-click queue, and then the tasks in the</span> <span data-start="414.349" data-end="415.349">other queue.</span> <span data-start="415.349" data-end="420.199">It doesn't affect the rendering pipeline which will run after each task in it wants to.</span> <span data-start="420.199" data-end="421.379">Super simple.</span> <span data-start="421.379" data-end="425.139">It doesn't have to be like that, right?</span> <span data-start="425.139" data-end="429.659">The browsers can actually execute the queues in any order they like, so we could have taken</span> <span data-start="429.659" data-end="435.62">two off the mouse click queue and three off the other queue — whatever we like.</span> <span data-start="435.62" data-end="438">The queues can be executed in any order.</span> <span data-start="438" data-end="441.92">But, the queues still do have to be queues.</span> <span data-start="441.92" data-end="445.349">So the tasks have to be executed in the order that they arrive.</span> <span data-start="445.349" data-end="451.05">First in, first out.</span> <span data-start="451.05" data-end="453.78">All of our mouse-click events have to go in that queue.</span> <span data-start="453.78" data-end="459.87">Node uses a specific queue for timeout event, so all of the timeout events have to go in</span> <span data-start="459.87" data-end="461.37">that queue.</span> <span data-start="461.37" data-end="467.53">So this is how our event loop looks now: we've got an infinite loop, we are going to pick</span> <span data-start="467.53" data-end="470.59">a queue, grab a task, and then it's time to repaint, and we will repaint.</span> </p>
<p><span data-start="470.59" data-end="472.34">This is still straightforward, right?</span> <span data-start="472.34" data-end="482.009">It turns out, it's a little bit more complicated than that, though.</span> <span data-start="482.009" data-end="486.02">We also have microtasks.</span> <span data-start="486.02" data-end="487.59">What is a microtask?</span> <span data-start="487.59" data-end="492.84">For the purposes of this 20-minute talk, a microtask is a promise.</span> <span data-start="492.84" data-end="497.849">There are other things that generate microtasks but 99.9 per cent of things that you do it's</span> <span data-start="497.849" data-end="499.919">going to be promises.</span> <span data-start="499.919" data-end="505.199">So our microtask queue is in yellow there next to the rendering pipeline, and we have</span> <span data-start="505.199" data-end="507.849">a bit of code, it's going to run.</span> <span data-start="507.849" data-end="511.729">We have a promise that resolves, it goes in the microtask queue.</span> <span data-start="511.729" data-end="515.779">Now, the microtask queue has a couple of special properties.</span> <span data-start="515.779" data-end="524.44">First of all, it runs after every task, so you finish a task, then you run the microtask</span> <span data-start="524.44" data-end="525.44">queue.</span> </p>
<p><span data-start="525.44" data-end="530.2">Even if the rendering pipeline would like it run, it has to wait until the microtask</span> <span data-start="530.2" data-end="532.43">queue finishes.</span> <span data-start="532.43" data-end="537.2">If we have multiple tasks in the microtask queue, they're all going to run.</span> <span data-start="537.2" data-end="543.35">If we add more while we are running it, those will have to be run too, so this has some</span> <span data-start="543.35" data-end="546.05">important implications for how things run.</span> <span data-start="546.05" data-end="551.89">Let's have a quick look at the difference between how tasks run and how microtasks run.</span> <span data-start="551.89" data-end="557.079">So this bit of code generates tasks.</span> <span data-start="557.079" data-end="562.42">I click the button, it's going to principle out the number of tasks that it has run, and</span> <span data-start="562.42" data-end="565.49">then it's going to generate another task, which is going to print out the number of</span> <span data-start="565.49" data-end="568.81">tasks that is run so on, and so order infinitely.</span> <span data-start="568.81" data-end="575.45">We can see it running, counting tasks, everything is great, I can select text, I can click stop.</span> <span data-start="575.45" data-end="581.7">I can't click start again, because I didn't implement that.</span> <span data-start="581.7" data-end="589.89">But, if we look at the same thing with microtasks, things are a bit different.</span> </p>
<p><span data-start="589.89" data-end="594.209">So, if I start, so this is the same code, right?</span> <span data-start="594.209" data-end="598.56">It is a coding and microtask, which is going to print out the number of microtasks that</span> <span data-start="598.56" data-end="603.01">have run, and then create another microtask, and keep looping, the same as the set setTimeout</span> <span data-start="603.01" data-end="604.42">but with promises.</span> <span data-start="604.42" data-end="613.1">If I click start promising, we can see everything has immediately gone to shit.</span> <span data-start="613.1" data-end="617.56">The button has clicked but it hasn't unclicked, right?</span> <span data-start="617.56" data-end="620.73">The cursor, which you can't see there, it's still the little hand.</span> <span data-start="620.73" data-end="623.05">I can't select text.</span> </p>
<p><span data-start="623.05" data-end="627.28">I definitely can't click stop, which wouldn't have helped because I didn't implement it</span> <span data-start="627.28" data-end="630.81">anyway, it's like I knew what was going to happen.</span> <span data-start="630.81" data-end="633.99">This page is kaput.</span> <span data-start="633.99" data-end="640.839">If we wait a little bit longer, Chrome will realise and tell us tell us but I don't have</span> <span data-start="640.839" data-end="641.839">that kind of time.</span> <span data-start="641.839" data-end="642.839">What happened there?</span> <span data-start="642.839" data-end="647.44">Exactly like we saw in the example, we are stuck, just dealing with the microtask queue.</span> <span data-start="647.44" data-end="650.74">So the rest of the event loop is blocked, we can't re-render the page, we can't do anything</span> <span data-start="650.74" data-end="654.55">else, we are stuck in the event loop — stuck in the microtask queue.</span> <span data-start="654.55" data-end="655.91">So, yes.</span> <span data-start="655.91" data-end="656.91">Cool.</span> </p>
<p><span data-start="656.91" data-end="661.74">This is how our event loop looks now.</span> <span data-start="661.74" data-end="662.8">It's an infinite loop.</span> <span data-start="662.8" data-end="668.99">We are going to pick a queue, a task off that queue, and run it.</span> <span data-start="668.99" data-end="672.18">As long as there are microtasks to round, we're going to do microtasks, and, then.</span> <span data-start="672.18" data-end="676.46">Would it be fair to say that is done, if it is time to repaint, we will repaint.</span> <span data-start="676.46" data-end="684.19">Cool, so this is starting to look a little bit complicated but it turns out it's just</span> <span data-start="684.19" data-end="687.38">a little bit more complicated than this.</span> <span data-start="687.38" data-end="693.45">We also have the animation frame callback queue which I'm going to call the animation</span> <span data-start="693.45" data-end="698.41">queue, because, if I keep saying animation frame callback queue, this talk won't get</span> <span data-start="698.41" data-end="700.649">finished in time for lunch!</span> <span data-start="700.649" data-end="706.92">So you can add things to the animation queue by calling request animation frame and passing</span> <span data-start="706.92" data-end="708.84">a callback.</span> <span data-start="708.84" data-end="709.84">Why would one do such a thing?</span> <span data-start="709.84" data-end="716.829">I'm using it here to run the animation of the browser running into the browser right-hand</span> <span data-start="716.829" data-end="718.949">window into the pipeline.</span> </p>
<p><span data-start="718.949" data-end="726.02">I have my browser window and pipeline, and I remove a class which resets the frame, and</span> <span data-start="726.02" data-end="736.62">then I add the slide class to the window which gives it a -</span> <span data-start="736.62" data-end="740.6">which makes is slide down, through the magic of transitions.</span> <span data-start="740.6" data-end="746.59">If I did it like this, as I said before, browsers are clever, and they like to be helpful.</span> <span data-start="746.59" data-end="752">If I wrote this code, the browser would look at it and say you've removed the class, and</span> <span data-start="752" data-end="754.68">then you've added the same class back again.</span> <span data-start="754.68" data-end="757.56">That's the same as doing nothing.</span> <span data-start="757.56" data-end="760.18">So, let's just do nothing.</span> </p>
<p><span data-start="760.18" data-end="766.69">Instead where I have to make sure that things occur after — so to do one, I need the browser,</span> <span data-start="766.69" data-end="769.279">the window to refresh, and then I need to do the next thing.</span> <span data-start="769.279" data-end="771.37">We have a look at how that works.</span> <span data-start="771.37" data-end="776.67">We've got our animation queue there in green beside the rendering pipeline.</span> </p>
<p><span data-start="776.67" data-end="782.85">I've got my scripts running, and I call request animation frame which adds something to the</span> <span data-start="782.85" data-end="784.03">animation queue.</span> <span data-start="784.03" data-end="789.25">You can see it's going to sit there, and nothing's going to happen until we're ready to repaint,</span> <span data-start="789.25" data-end="795.529">and then we will run the animation queue, and then we will repaint the browser.</span> <span data-start="795.529" data-end="803.29">Like the microtask queue, the animation queue has a couple of special properties.</span> <span data-start="803.29" data-end="808.35">If I have multiple things in the animation queue when it is ready to run, I'm going to</span> <span data-start="808.35" data-end="811.32">run all those things.</span> <span data-start="811.32" data-end="816.94">But, if I add more things to the animation queue while it's running, I'm not going to</span> <span data-start="816.94" data-end="818.69">run those guys.</span> <span data-start="818.69" data-end="822.449">The reason for that is that, if you're creating animations, you want to say this is what I</span> <span data-start="822.449" data-end="825.98">want to do in this frame, and then you're going to set up what is going to happen in</span> <span data-start="825.98" data-end="828.35">the next frame but you don't want run it, right?</span> <span data-start="828.35" data-end="832.88">You want to wait until the window has refreshed.</span> <span data-start="832.88" data-end="834.16">Cool.</span> <span data-start="834.16" data-end="838.279">So, this is what our event loop looks like now.</span> <span data-start="838.279" data-end="839.56">It's an infinite loop.</span> </p>
<p><span data-start="839.56" data-end="841.3">We're going to pick a queue.</span> <span data-start="841.3" data-end="845.27">We're going to grab the first task off that queue, and we're going to run the task.</span> <span data-start="845.27" data-end="848.639">Then, as long as there are microtasks, we're going to run all those.</span> <span data-start="848.639" data-end="854.19">Then, if we're ready to repaint, we're going to grab the animation tasks that are currently</span> <span data-start="854.19" data-end="859.33">in the queue, and we're going to run all of those, and then we're going to repaint.</span> <span data-start="859.33" data-end="863.44">And that is as complicated as it gets.</span> <span data-start="863.44" data-end="866.79">But, what about node?</span> <span data-start="866.79" data-end="870.69">First of all, good news.</span> <span data-start="870.69" data-end="873.089">Node is a lot simpler than a browser.</span> <span data-start="873.089" data-end="876.05">It has no script-parsing events.</span> <span data-start="876.05" data-end="881.17">You're not picking JavaScript out of HTML all over the place, you just give it a JavaScript</span> <span data-start="881.17" data-end="883.18">file and it runs it.</span> <span data-start="883.18" data-end="886.899">There is no users clicking on shit all over the place.</span> <span data-start="886.899" data-end="892.26">You don't have to worry about animation framework callbacks because there's no rendering pipeline.</span> <span data-start="892.26" data-end="899.079">There is also another — important difference with Node: the browser event loop is like</span> <span data-start="899.079" data-end="900.079">a merry-go-round.</span> </p>
<p><span data-start="900.079" data-end="903.83">It just keeps going round and round and round.</span> <span data-start="903.83" data-end="906.79">The Node event loop, it's more like a roller coaster.</span> <span data-start="906.79" data-end="912.31">It is going to run through one loop, and there's more stuff to do, it will run through another</span> <span data-start="912.31" data-end="913.73">loop.</span> <span data-start="913.73" data-end="916.42">Once it's done, that's it.</span> <span data-start="916.42" data-end="917.72">It's done.</span> <span data-start="917.72" data-end="926.61">So, the Node event loop: Node has three queues that are interesting enough to talk about</span> <span data-start="926.61" data-end="927.61">today.</span> <span data-start="927.61" data-end="934.29">It's got one queue for all of your event callbacks, so your XHR requests, your disk reads and</span> <span data-start="934.29" data-end="938.29">writes and that stuff will go in the first queue.</span> <span data-start="938.29" data-end="940.73">They're called phases in nodes.</span> <span data-start="940.73" data-end="944.579">The second phase is the check phase.</span> <span data-start="944.579" data-end="949.87">And the third phase is your timers this that's all of your timers for callback and set interval</span> <span data-start="949.87" data-end="952.43">will go into that third queue.</span> </p>
<p><span data-start="952.43" data-end="959.88">Node is going to run everything in the event callback queue; it's going to run then everything</span> <span data-start="959.88" data-end="960.899">in the check queue.</span> <span data-start="960.899" data-end="964.12">Once that is done, it's going to run everything in the timer queue.</span> <span data-start="964.12" data-end="968.41">Then, if there is more stuff, it will loop back around and run through the queues again.</span> </p>
<p><span data-start="968.41" data-end="974.37">As soon as there is no task in any queues, and there are no event waiting anywhere, it</span> <span data-start="974.37" data-end="976.23">will finish.</span> <span data-start="976.23" data-end="980.699">It will end.</span> <span data-start="980.699" data-end="985.089">So, how do you add stuff to the check phase?</span> <span data-start="985.089" data-end="990.55">You can add things to the check phase queue by calling setImmediate and parsing a callback.</span> <span data-start="990.55" data-end="996.11">setImmediate is the same as setTimeout with a time of zero, but because of the way the</span> <span data-start="996.11" data-end="1001.94">queues work, if you call setTimeout with a time of zero, and setImmediate, your setImmediate</span> <span data-start="1001.94" data-end="1005.54">is going to run first.</span> </p>
<p><span data-start="1005.54" data-end="1011.36">Node also has promises.</span> <span data-start="1011.36" data-end="1016.98">Just like the browser, and Node promises work just the same as browser promises — after</span> <span data-start="1016.98" data-end="1023.97">each task finishes, we will run the promise microtask queue.</span> <span data-start="1023.97" data-end="1029.28">Node also has another micro task queue which is the nextTick queue.</span> <span data-start="1029.28" data-end="1034.68">You can parse a callback.</span> <span data-start="1034.68" data-end="1039.32">It works just the same.</span> <span data-start="1039.32" data-end="1041.15">There's nothing really interesting there.</span> <span data-start="1041.15" data-end="1048.481">The major difference is, if you have both promises and nextTick callbacks becomes all</span> <span data-start="1048.481" data-end="1053.85">your nextTick callbacks will run before your promises, but that's pretty much it.</span> <span data-start="1053.85" data-end="1059.98">The only new things, different things in Node are setImmediate and process.next tick.</span> <span data-start="1059.98" data-end="1074.16">Pro why are they named like that?</span> </p>
<p><span data-start="1074.16" data-end="1076.18">It turns out naming things are hard.</span> <span data-start="1076.18" data-end="1079.93">You guys all know the two hard problems in computer signs, right?</span> <span data-start="1079.93" data-end="1083.98">Validation, and naming things, and off by one errors.</span> <span data-start="1083.98" data-end="1089">So this is our Node event loop.</span> <span data-start="1089" data-end="1091.51">It's only going to run while there are still task.</span> <span data-start="1091.51" data-end="1097.29">It's going to pick a queue, and then, while that queue has more tasks, it's going to grab</span> <span data-start="1097.29" data-end="1103.21">the next task in that queue, it's going to run that task, and then while the next tick</span> <span data-start="1103.21" data-end="1108.83">queue has more tasks, it's going to run all the next tick queue tasks, and then, while</span> <span data-start="1108.83" data-end="1114.56">the promise queue has more tasks, it's going to do the promises.</span> <span data-start="1114.56" data-end="1117.5">So that just leaves web workers.</span> </p>
<p><span data-start="1117.5" data-end="1125.2">Anyone who is not familiar with Australian wildlife, this is a redback spider.</span> <span data-start="1125.2" data-end="1127.3">Unlike most Australian wildlife, they're not that dangerous.</span> <span data-start="1127.3" data-end="1132.92">Nobody has died from a redback spider bite since the 1950s.</span> <span data-start="1132.92" data-end="1136.26">Probably don't get bitten by one, though.</span> <span data-start="1136.26" data-end="1147.97">So web workers: web workers turn out to be dead simple.</span> <span data-start="1147.97" data-end="1151.12">Each web worker run in its own thread.</span> <span data-start="1151.12" data-end="1158.51">It has got its own event loan, got its own stack, task queue — everything just runs</span> <span data-start="1158.51" data-end="1161.22">on its own.</span> <span data-start="1161.22" data-end="1164.94">It's even easier than Node.</span> <span data-start="1164.94" data-end="1166.27">So there are no script tags.</span> <span data-start="1166.27" data-end="1168.41">Again, you parse in a JavaScript file.</span> <span data-start="1168.41" data-end="1171.84">There are no user interactions.</span> <span data-start="1171.84" data-end="1177.37">Web workers aren't allowed to manipulate the DOM so you don't have to worry about any animation</span> <span data-start="1177.37" data-end="1181.98">frames or anything like that.</span> <span data-start="1181.98" data-end="1191.31">If we look at a demo, we can generate a task, call a setTimeout, make HSR requests, we can</span> <span data-start="1191.31" data-end="1199.17">send and receive post-message events, so, post-message is how your web worker communicates</span> <span data-start="1199.17" data-end="1202.84">with the browser window.</span> </p>
<p><span data-start="1202.84" data-end="1204.65">And we can make promises.</span> <span data-start="1204.65" data-end="1207.73">It's — that's it.</span> <span data-start="1207.73" data-end="1209.31">It's just really easy.</span> <span data-start="1209.31" data-end="1210.32">Yes.</span> <span data-start="1210.32" data-end="1216.42">So, that's a event — that's the event loop.</span> <span data-start="1216.42" data-end="1224.44">Things to remember: long-running tasks will make your page run like a wonky cat.</span> <span data-start="1224.44" data-end="1229.44">Promises and nextTick tasks can make it run like a dead cat.</span> <span data-start="1229.44" data-end="1234.59">Make sure you break your tasks up into small pieces and don't have infinitely recursive</span> <span data-start="1234.59" data-end="1237.8">promises and nextTick tasks.</span> <span data-start="1237.8" data-end="1242.07">Node is a bit different to the browser.</span> <span data-start="1242.07" data-end="1245.13">It's going to run through the event loop only as long as there are things to do.</span> </p>
<p><span data-start="1245.13" data-end="1252.75">It has got those three specific tasks, and it's got setImmediate and process.nextTick.</span> <span data-start="1252.75" data-end="1258.39">Web workers do their own thing, in their own event loop, and completely separate from anything</span> <span data-start="1258.39" data-end="1261.32">else that is going on.</span> <span data-start="1261.32" data-end="1267.81">Remember, the event loop is more exciting than you can possibly have imagined!</span> <span data-start="1267.81" data-end="1269.22">Thank you.</span> </p>
</section>