<section>
<p><span data-start="9.04" data-end="13.36">Hi everybody ! Thank you again for the introduction</span> <span data-start="13.66" data-end="18.74">I'm Shelley, a software engineer at GitHub working on open source.</span> <span data-start="18.98" data-end="24">Today, I would like to do a deep dive into the mechanics of asynchronous programming</span> <span data-start="24.009" data-end="25.939">in JavaScript.</span> <span data-start="25.939" data-end="31.61">To make sure we're all on the same page, before I get started, I will go over basic principles</span> <span data-start="31.61" data-end="37.68">of asynch, and then we will launch into the different methodologies and nuances of what</span> <span data-start="37.68" data-end="43.68">exactly differentiates them, and, finally, we will compare over the spectrum of options</span> <span data-start="43.68" data-end="48.949">to discuss which situations require which approaches.</span> </p>
<p><span data-start="48.949" data-end="53.399">Let's say you have a programme detained within a contained within a final file.</span> <span data-start="53.399" data-end="54.969">It's mate up of functions.</span> <span data-start="54.969" data-end="60.609">At any given time, only one of these is going to be executing now.</span> <span data-start="60.609" data-end="64.629">The rest will execute later at some point in the future.</span> <span data-start="64.629" data-end="68.36">That, there, is the crux of asynch.</span> <span data-start="68.36" data-end="73.77">It's the relationship between now and later, and the way in which you manage this relationship</span> <span data-start="73.77" data-end="75.52">with your code.</span> </p>
<p><span data-start="75.52" data-end="80.97">What is key here, however, and what causes some of the most difficulties for developers</span> <span data-start="80.97" data-end="86.75">when they're just starting out, is that later does not mean strictly and immediately after</span> <span data-start="86.75" data-end="88.33">now.</span> <span data-start="88.33" data-end="92.12">It could be at any point in the future, and you don't necessarily know when that will</span> <span data-start="92.12" data-end="93.12">be.</span> <span data-start="93.12" data-end="98.75">Now, let's move on to some of the technical underpinnings of how code is executed in the</span> </p>
<p><span data-start="98.75" data-end="100.97">JavaScript environment.</span> <span data-start="100.97" data-end="105">In pursuit of this understanding, it's best to start with the event loop.</span> <span data-start="105" data-end="111.36">The event loop can best be conceptualised as an endlessly running singly threaded loop</span> <span data-start="111.36" data-end="116.28">where each iteration runs a small chunk of code in the programme.</span> <span data-start="116.28" data-end="121.89">If you want to run a chunk of code at a later time, that chunk would simply be added to</span> <span data-start="121.89" data-end="124.39">the queue for the event loop.</span> <span data-start="124.39" data-end="130.34">When the time came that you desired it to execute, it would be dequeued and executed.</span> <span data-start="130.34" data-end="135.58">With ES6 came a new concept called the microtasks queue, but we will save that for a little</span> <span data-start="135.58" data-end="136.77">bit later.</span> </p>
<p><span data-start="136.77" data-end="144.33">It is also important to mention that JavaScript has what is known as run-to-completion semantics.</span> <span data-start="144.33" data-end="150.78">This means that the current task always finishes before the next task begins.</span> <span data-start="150.78" data-end="155.42">Or until it explicitly yields control back to the event loop.</span> <span data-start="155.42" data-end="161.36">As a result of this, each task has complete control over all current states, and does</span> <span data-start="161.36" data-end="167.05">not need to worry about another task modifying things at the exact same time.</span> <span data-start="167.05" data-end="172.91">Looking at the code here, running this will always print first and then second, because</span> <span data-start="172.91" data-end="180.17">the function, starting in setTimeout is added to the task queue immediately but only executed</span> <span data-start="180.17" data-end="184.74">after the current piece of code is down since it yielded control.</span> <span data-start="184.74" data-end="187.48">Now let's look at the call stack.</span> </p>
<p><span data-start="187.48" data-end="195.77">When a function foo calls a function bar, bar needs to know where inside foo to return</span> <span data-start="195.77" data-end="198.319">to after it's done.</span> <span data-start="198.319" data-end="201.9">This information is managed with the call stack.</span> <span data-start="201.9" data-end="206.91">Take a look at the set of three functions on the left-hand side of the slide.</span> <span data-start="206.91" data-end="210.97">Let's walk through how the stack will look as the programme executes.</span> <span data-start="210.97" data-end="217.16">Initially, when the programme above has started, the call stack is empty.</span> <span data-start="217.16" data-end="222.59">After foo is called, the stack has one entry: location and global scope.</span> <span data-start="222.59" data-end="227.69">As I mentioned before, foo knows where to return to when it has finished.</span> <span data-start="227.69" data-end="232.03">Next, after bar is called, the stack has two entries.</span> <span data-start="232.03" data-end="236.69">It's now stored at the location that bar needs to return to when it has finished executing</span> <span data-start="236.69" data-end="239.69">in addition to global scope.</span> </p>
<p><span data-start="239.69" data-end="245.8">The trend continues as bas is called, containing the previous return address and the previous</span> <span data-start="245.8" data-end="249.69">return addresses from previous calls.</span> <span data-start="249.69" data-end="255.21">When console.log is called in bas, the call stack is.. the console.</span> <span data-start="255.21" data-end="261">Next, each of the functions terminates, and, each time, the top entry is removed from the</span> <span data-start="261" data-end="262.4">stack.</span> <span data-start="262.4" data-end="267.849">After foo is done, we're back in global scope and the call stack is empty.</span> <span data-start="267.849" data-end="274.82">At the end, we return, and the programme is terminated.</span> <span data-start="274.82" data-end="280.43">In looking at this, you can see a handful of the things I previously mentioned.</span> <span data-start="280.43" data-end="284.56">The event loop, the task queue, and the stack.</span> <span data-start="284.56" data-end="290.81">The current task comes off of the event queue and its location is stored in memory while</span> <span data-start="290.81" data-end="294.2">irrelevant variables populate the heap.</span> <span data-start="294.2" data-end="300.62">The task queue is populated by task sources, any one of which would be a particular chunk</span> <span data-start="300.62" data-end="304.05">of code in an executing programme.</span> </p>
<p><span data-start="304.05" data-end="309.56">This snapshot would represent the moment after the all functions in the previous slide had</span> <span data-start="309.56" data-end="315.91">executed and before locations had begun to pop off of the stack.</span> <span data-start="315.91" data-end="321.6">Most of you have likely encountered callbacks, so I'm going to focus more on how they fit</span> <span data-start="321.6" data-end="324.11">into the asynch landscape as a whole.</span> <span data-start="324.11" data-end="329.47">Let's start by looking at some functions and discussing them in context.</span> <span data-start="329.47" data-end="335.08">Here, you can see I have two programmes side by side.</span> <span data-start="335.08" data-end="341.18">On the left, the function names are alphabetical from top down, and, on the right side, I've</span> <span data-start="341.18" data-end="345.87">mapped the functions to the order in which they run.</span> </p>
<p><span data-start="345.87" data-end="352.3">Most likely, your eyes have to do a significant amount of jumping around in order to discern</span> <span data-start="352.3" data-end="357.32">the order in which the functions are executing for the programme on the left.</span> <span data-start="357.32" data-end="361.73">Since they're not running in the top-down sequential order you might expect.</span> <span data-start="361.73" data-end="367.28">By following the Cardinal number of words on the right side, you probably had an easier</span> <span data-start="367.28" data-end="368.45">time.</span> <span data-start="368.45" data-end="371.04">Let's talk about why that is.</span> <span data-start="371.04" data-end="373.81">Your brain operates sequentially.</span> <span data-start="373.81" data-end="379.29">It places it at odds with the inherent functionality of callbacks.</span> <span data-start="379.29" data-end="384.419">This is a comparatively simpler example, but when callbacks start to next significantly,</span> <span data-start="384.419" data-end="390.02">you enter what is known colloquially as callback hell which becomes more difficult for your</span> <span data-start="390.02" data-end="392.75">brain to reason of through.</span> <span data-start="392.75" data-end="398.63">What is happening here in terms of the call stack, and, by extension, the event loop?</span> <span data-start="398.63" data-end="403.729">Assuming all these functions are asynch, first we will begin, and then immediately yield</span> <span data-start="403.729" data-end="406.49">control, and, then second, execute.</span> </p>
<p><span data-start="406.49" data-end="412.82">A callback was registered by first so the next available task will be that callback.</span> <span data-start="412.82" data-end="416.7">Next, third will execute, followed by fourth.</span> <span data-start="416.7" data-end="421.35">Fourth registers a callback, at then returns control, so that fifth executes.</span> <span data-start="421.35" data-end="425.34">The callback registered by fourth will come off the Q and execute, and — the queue and</span> <span data-start="425.34" data-end="429.41">execute, and finally, six will execute.</span> <span data-start="429.41" data-end="435.759">For each of these functions taking a callback, the callback itself is a black box for the</span> <span data-start="435.759" data-end="436.889">function.</span> <span data-start="436.889" data-end="443.23">The continuation of the programme is dependent on our handing that callback off to another</span> <span data-start="443.23" data-end="447.56">part of the code and then essentially just praying that it will do the correct thing</span> <span data-start="447.56" data-end="450.37">whether the callback is invoked.</span> <span data-start="450.37" data-end="458.1">This paradigm is known as inversion of control, and can create significant trust issues.</span> <span data-start="458.1" data-end="464.229">In the previous code snippet I had up, you could see that your eyes had to skip around,</span> <span data-start="464.229" data-end="469.199">even though they most likely wanted to read the code in a top-down fashion.</span> </p>
<p><span data-start="469.199" data-end="473.979">When you sometimes struggle to understand how and when each part of a piece of code</span> <span data-start="473.979" data-end="480.02">is working, it's undoubtedly hard to deal with errors in that code been within the callback</span> <span data-start="480.02" data-end="486.419">landscape, there are two ways in which errors are reported: via callbacks and via exceptions.</span> <span data-start="486.419" data-end="489.66">You need to combine both properly.</span> <span data-start="489.66" data-end="494.41">This is because the most obvious, but occasionally overlooked aspect of dealing with errors in</span> <span data-start="494.41" data-end="498.44">callbacks, is to make sure that they've actually all been handled.</span> <span data-start="498.44" data-end="503.85">However, there's a caveat to this advice, and it lies specifically in how errors are</span> <span data-start="503.85" data-end="509.65">caught: can you see how, in the snippet above, I returned and didn't throw an error.</span> <span data-start="509.65" data-end="515.63">That is intentional.</span> <span data-start="515.63" data-end="520.899">In an asynchronous environment, the exception could be thrown, and, when the lock is out</span> <span data-start="520.899" data-end="525.43">of scope, the error would be rendered meaningless.</span> <span data-start="525.43" data-end="532.82">The next big innovation in asynchronous programming promises hit JavaScript with ES6.</span> <span data-start="532.82" data-end="537.82">Before this, there was no direct notion of asynch built directly into the JavaScript</span> <span data-start="537.82" data-end="539.31">engine.</span> </p>
<p><span data-start="539.31" data-end="544.89">All it ever did was execute a single chunk of your programme at any given moment when</span> <span data-start="544.89" data-end="546.04">asked to.</span> <span data-start="546.04" data-end="552.33">You, the developer, asked it to by means of callbacks or timeouts, in order to shuffle</span> <span data-start="552.33" data-end="555.17">its place in the event loop.</span> <span data-start="555.17" data-end="560.51">With promises came a change to the JS engine which took a form of the queue that I mentioned</span> <span data-start="560.51" data-end="564.97">briefly at the beginning — the microtask queue.</span> <span data-start="564.97" data-end="570.51">Before I delve into how exactly this changes the form of the stack queue event loop diagram</span> <span data-start="570.51" data-end="576.23">I showed you a few slides ago, let's look at an example of a programme utilising promises</span> <span data-start="576.23" data-end="581.16">and then discuss what is happening and why.</span> <span data-start="581.16" data-end="584.06">Promises act as placeholders.</span> <span data-start="584.06" data-end="589.55">They allow us to reason about future values without necessarily knowing their outcomes,</span> <span data-start="589.55" data-end="592.62">making them functionally extemporaneous.</span> <span data-start="592.62" data-end="596.5">When the future value is settled, it might succeed or fail.</span> <span data-start="596.5" data-end="602.68">Then, at that point, the promise is no longer a placeholder and becomes an immutable value.</span> </p>
<p><span data-start="602.68" data-end="611.73">A few slides ago, I referenced the paradigm, the version of control.</span> <span data-start="611.73" data-end="623.18">Promises confer to us a capability to know when a given task finishes.</span> <span data-start="623.18" data-end="628.58">Promises may seem like an entirely different paradigm, but they don't get rid of callbacks</span> <span data-start="628.58" data-end="629.83">at all.</span> <span data-start="629.83" data-end="635.23">They just change with the callback has passed to, and remove the black box effect we saw</span> <span data-start="635.23" data-end="636.82">previously.</span> </p>
<p><span data-start="636.82" data-end="642.33">We get back from a function when it is completed, and then perform new passes from there, as</span> <span data-start="642.33" data-end="644.05">I said.</span> <span data-start="644.05" data-end="653.76">Promises are not just the mechanism for single-step operations that follow with this then that</span> <span data-start="653.76" data-end="661.63">flow.</span> <span data-start="661.63" data-end="677.36">[Sound distorted].</span> <span data-start="677.36" data-end="700.23">From the — calls for</span> <span data-start="700.23" data-end="707.529">the second then would create then another promise.</span> <span data-start="707.529" data-end="711.84">So, how does this look under the hood?</span> <span data-start="711.84" data-end="718.26">Promises utilise the microtask queue by allows us to say, "Here is this thing that I need</span> <span data-start="718.26" data-end="726.06">to do later but I need to ensure it happens immediately later from the — the microtask</span> <span data-start="726.06" data-end="731.87">queue can best be thought of as attached to each tech in the event loop.</span> </p>
<p><span data-start="731.87" data-end="737.05">Some asynch actions will be added to the end of the current microtask queue instead of</span> <span data-start="737.05" data-end="739.39">creating a whole new tick as a whole.</span> <span data-start="739.39" data-end="747.88">When a promise is resolved or rejected, the associated handlers will be called asynchronously</span> <span data-start="747.88" data-end="753.329">as microtasks, and then added to the queue for the current tick.</span> <span data-start="753.329" data-end="758.43">This diagram looks nearly identical to the diagram I showed you a few slides back.</span> <span data-start="758.43" data-end="761.75">One key difference from the microtask queue.</span> <span data-start="761.75" data-end="768.92">Once a promise settles or already settling, it queues a microtask.</span> <span data-start="768.92" data-end="775.02">This ensures promise callbacks are asynch even if the promise has already settled, so</span> <span data-start="775.02" data-end="781.86">calling it then would resolve a reject against the settled promise immediately queues a microtask.</span> <span data-start="781.86" data-end="787.399">Any additional microtasks queued during a given microtask are added to the end of the</span> <span data-start="787.399" data-end="789.1">queue and also processed.</span> <span data-start="789.1" data-end="795.66">So, in looking at the diagram, you see that the current task can come off the task queue</span> <span data-start="795.66" data-end="798">or the microtask queue.</span> </p>
<p><span data-start="798" data-end="801.72">All promised callbacks are queued as microtasks.</span> <span data-start="801.72" data-end="807.45">A microtask can also cause one or more microtasks to be added to the end of the same queue.</span> <span data-start="807.45" data-end="812.6">So it's theoretically possible that a microtask loop could spin indefinitely thus starving</span> <span data-start="812.6" data-end="817.55">the programme of its ability to move on to the next event loop tick.</span> <span data-start="817.55" data-end="824.29">This would conceptually be almost the same as expressing an infinite loop in your code.</span> <span data-start="824.29" data-end="826.769">What happens if something goes wrong in a promise.</span> <span data-start="826.769" data-end="828.15">How do we deal with those errors?</span> <span data-start="828.15" data-end="833.889">By default, it turns out, promises are swallowed if unhandled.</span> <span data-start="833.889" data-end="841.51">More specifically, any exception which is thrown inside a dot.then handler, or within</span> <span data-start="841.51" data-end="848.209">a function path, a new promise will be soundly disposed of unless manually handled.</span> <span data-start="848.209" data-end="853.35">The standard way to handle errors from promises is to add a catch handler at the end of your</span> <span data-start="853.35" data-end="855.44">promise chain.</span> </p>
<p><span data-start="855.44" data-end="859.58">You can also chain these handlers so that you can throw errors into progressively more</span> <span data-start="859.58" data-end="861.43">outer level scopes.</span> <span data-start="861.43" data-end="867.13">Catching and rethrowing errors in this way will tell you what led to the error more effectively</span> <span data-start="867.13" data-end="871.1">so that you can later debug the issue more efficiently.</span> <span data-start="871.1" data-end="877.99">If exceptions are thrown inside the callbacks of dot then and dot catch, it's not a method</span> <span data-start="877.99" data-end="881.56">because these two can revert them to rejections.</span> <span data-start="881.56" data-end="886.019">Let's look at an example and talk about what would work and what wouldn't in more concrete</span> <span data-start="886.019" data-end="887.8">terms.</span> <span data-start="887.8" data-end="890.2">This is a simple promise example.</span> <span data-start="890.2" data-end="896.209">From looking, you can see that from is going to reject with an error, no matter what.</span> <span data-start="896.209" data-end="900.18">So, what happens in the first example versus the second?</span> <span data-start="900.18" data-end="902.06">The first has a catch.</span> <span data-start="902.06" data-end="905.85">So it's going to print the error followed by the error message which in this case is</span> <span data-start="905.85" data-end="907.36">rejected.</span> <span data-start="907.36" data-end="911.8">You can also see the associated call stack by printing error.stack.</span> </p>
<p><span data-start="911.8" data-end="913.85">The second one doesn't have a catch.</span> <span data-start="913.85" data-end="919.07">So even though we threw an error, it will simply fail silently.</span> <span data-start="919.07" data-end="924.79">This next type of asynch approach — generators — sits a little on the edge of the overall</span> <span data-start="924.79" data-end="929.14">asynch landscape but is nevertheless important to touch on.</span> <span data-start="929.14" data-end="934.24">The first thing to observe as we talk about generators, is how they differ from normal</span> <span data-start="934.24" data-end="935.62">functions.</span> <span data-start="935.62" data-end="940.11">There are several notable differences but key to generators is their behaviour with</span> <span data-start="940.11" data-end="944.17">respect to the run to completion expectation.</span> <span data-start="944.17" data-end="948.899">With generators, we have a different kind of function which can be paused in the middle</span> <span data-start="948.899" data-end="951.99">either once or several times.</span> <span data-start="951.99" data-end="957.36">It is resumed later which allows other code to run during these pause periods between</span> <span data-start="957.36" data-end="959.26">runs.</span> </p>
<p><span data-start="959.26" data-end="963.98">The main strength of generators is that they provide a single threaded synchronous-looking</span> <span data-start="963.98" data-end="971.13">code style but allow us to hide the asynchrony away as an implementation detail.</span> <span data-start="971.13" data-end="977.08">This lets us express naturally what a programme step and statement flow is without navigating</span> <span data-start="977.08" data-end="982.07">the asynchronous gotchas and syntax at the same time.</span> <span data-start="982.07" data-end="987.11">To get an idea of how this looks in practice, let's see a function.</span> <span data-start="987.11" data-end="992.699">Here, you will see immediately that there's a little star next to the function in the</span> <span data-start="992.699" data-end="993.82">signature.</span> <span data-start="993.82" data-end="998.089">This is the syntactical indicator that you're looking at a generator function.</span> <span data-start="998.089" data-end="1002.899">The key word "yield" will send out a value whenever the function is run.</span> <span data-start="1002.899" data-end="1009.41">So, here, the yield index plus plus expression will send the index value out when pausing</span> <span data-start="1009.41" data-end="1011.75">the generator function at that point.</span> <span data-start="1011.75" data-end="1017.779">If ever the generator is restarted, whatever value it was sent in will be the result of</span> <span data-start="1017.779" data-end="1018.779">that expression.</span> <span data-start="1018.779" data-end="1023.14">It will then get added to one and assigned to the index variable.</span> <span data-start="1023.14" data-end="1026.709">When we start, index is zero.</span> <span data-start="1026.709" data-end="1030.889">So this will be yielded and then 1 will be added to the index as a result of the plus</span> <span data-start="1030.889" data-end="1032.309">plus.</span> </p>
<p><span data-start="1032.309" data-end="1038.11">This will occur each time as the value of index is passed out and then in again, and</span> <span data-start="1038.11" data-end="1041.1">so that it increments by one every time.</span> <span data-start="1041.1" data-end="1046.069">To see this a little more clearly, let's look at a diagrammatical representation.</span> <span data-start="1046.069" data-end="1049.269">On the left, you will see a traditional non-generator function.</span> <span data-start="1049.269" data-end="1054.47">It adheres to the run to completion behaviour we expect from functions with no interruptions</span> <span data-start="1054.47" data-end="1056.76">from beginning to end.</span> <span data-start="1056.76" data-end="1059.19">On the right is the generator function.</span> <span data-start="1059.19" data-end="1063.369">With multiple stops and starts between beginning and end.</span> <span data-start="1063.369" data-end="1068.47">It's important to note that there is no real official end per se in the generator function.</span> <span data-start="1068.47" data-end="1073.46">The end in this case will be the last time that that yield is called.</span> </p>
<p><span data-start="1073.46" data-end="1078.72">When the generator function is initialised, an iterator is returned, and then the generator</span> <span data-start="1078.72" data-end="1082.69">starts with the first call to next on the function.</span> <span data-start="1082.69" data-end="1087.37">This function pauses when yield is called, and then would restart with the next call</span> <span data-start="1087.37" data-end="1090.029">to next, and so on, and so forth.</span> <span data-start="1090.029" data-end="1094.69">To recap, with normal functions, you get parameters at the beginning, and a return value at the</span> <span data-start="1094.69" data-end="1100.029">end, but generator functions, you send messages out with yield, and you send messages back</span> <span data-start="1100.029" data-end="1102.5">in with each restart.</span> <span data-start="1102.5" data-end="1108.73">One of the most powerful parts of ES6 generator design is that the semantics of the code inside</span> <span data-start="1108.73" data-end="1110.979">the generator are synchronous.</span> <span data-start="1110.979" data-end="1114.129">Even if the external iteration control proceeds asynchronously.</span> <span data-start="1114.129" data-end="1118.549">That's a fancy way of saying that you can use a very simple error-handling technique</span> <span data-start="1118.549" data-end="1121.269">you're probably familiar with — the tri catch mechanism.</span> <span data-start="1121.269" data-end="1129.69">If even if the function will pause at the yield expression, the tri catch with catch</span> <span data-start="1129.69" data-end="1130.83">it.</span> </p>
<p><span data-start="1130.83" data-end="1135.739">With normal asynch capabilities like callbacks, that's almost impossible to do.</span> <span data-start="1135.739" data-end="1141.44">The generator itself has a throw function to throw an error into the generator at its</span> <span data-start="1141.44" data-end="1148.09">pause position which of course can also be caught by a try catch inside the generator.</span> <span data-start="1148.09" data-end="1151.87">Asynch await is a new way to write asynchronous code.</span> <span data-start="1151.87" data-end="1154.45">Previous options are callbacks and promises.</span> <span data-start="1154.45" data-end="1161.539">Asynch await was created to simplify the process of working with and writing chained promises.</span> <span data-start="1161.539" data-end="1165.109">And so asynch await functions themselves return promises.</span> <span data-start="1165.109" data-end="1167.179">They cannot be used with plain callbacks.</span> <span data-start="1167.179" data-end="1174.289">Asynch await is thus like promises non-blocking, and makes asynchronous code look and behave</span> <span data-start="1174.289" data-end="1176.399">more like synchronous code.</span> </p>
<p><span data-start="1176.399" data-end="1179.009">This is where all the power lies.</span> <span data-start="1179.009" data-end="1184.989">Since any asynch await function returns a promise implicitly, the resolve value of the</span> <span data-start="1184.989" data-end="1190.44">promise will be whatever you return from the function to ill straight, let's look at.</span> <span data-start="1190.44" data-end="1197.149">Here, we are returning a string that returns several components of a street address.</span> <span data-start="1197.149" data-end="1203.45">The function has the asynch key word before it and the await key word can only be used</span> <span data-start="1203.45" data-end="1206.98">in function s defined with asynch.</span> <span data-start="1206.98" data-end="1212.72">All four variables must be resolved before the function will return the desired string.</span> <span data-start="1212.72" data-end="1217.46">Also important to note here is that if we did not use the await key cord before each</span> <span data-start="1217.46" data-end="1222.09">of the address component functions, this would not necessarily fail.</span> </p>
<p><span data-start="1222.09" data-end="1226.119">It would just mean that the variables would be set to promises and from the values returned</span> <span data-start="1226.119" data-end="1227.119">from them.</span> <span data-start="1227.119" data-end="1234.399">There is it also an oft overlooked gotcha.</span> <span data-start="1234.399" data-end="1237.509">Await calls operate sequentially.</span> <span data-start="1237.509" data-end="1244.72">What this means is that the call to get.city won't kick off until we have a value for get.street</span> <span data-start="1244.72" data-end="1245.72">address.</span> <span data-start="1245.72" data-end="1253.52">In some, this depends on a call from results of a previous call.</span> <span data-start="1253.52" data-end="1259.929">Here, we want to get the address components simultaneously, so we should not be blocking</span> <span data-start="1259.929" data-end="1262.029">each on the previous one.</span> </p>
<p><span data-start="1262.029" data-end="1266.519">Instead, we should rewrite it like this.</span> <span data-start="1266.519" data-end="1272.279">Under the hood, asynch await works almost exactly the same as promises, utilising the</span> <span data-start="1272.279" data-end="1276.71">new microtask queue introduced to handle asynch operations.</span> <span data-start="1276.71" data-end="1283.489">If you're familiar with promises, you know that, if a promise is rejected, you need to</span> <span data-start="1283.489" data-end="1286.44">handle that error inside a catch.</span> <span data-start="1286.44" data-end="1291.539">If a handle be errors for synchronous and asynchronous code, you will likely have to</span> <span data-start="1291.539" data-end="1293.08">duplicate your error-handler.</span> <span data-start="1293.08" data-end="1300.19">In the above snippet, we can see there is duplicate code on lines 6 and 8.</span> <span data-start="1300.19" data-end="1305.099">The catch statement on line 7 will handle any errors that the synchronous function do</span> <span data-start="1305.099" data-end="1310.879">synchronous things may throw, but it won't handle any errors thrown by do something since</span> <span data-start="1310.879" data-end="1314.909">it's asynchronous.</span> <span data-start="1314.909" data-end="1320.509">This example may seem palatable, since all it's doing is printing the error to console,</span> <span data-start="1320.509" data-end="1326.899">but if there is any kind of complex error-handle be logic, we want to avoid duplicating it.</span> <span data-start="1326.899" data-end="1330.769">Asynch await let's us do exactly that.</span> <span data-start="1330.769" data-end="1336.46">But looking at the code snippet on the top right, you will see that we only catch once.</span> </p>
<p><span data-start="1336.46" data-end="1344.21">When we use asynch await, we can catch errors in a single handler.</span> <span data-start="1344.21" data-end="1349.76">Here, we can both minimise the total amount of code that we write and catch errors in</span> <span data-start="1349.76" data-end="1352.669">a more readable and clear way.</span> <span data-start="1352.669" data-end="1363.909">So, wrapping up: our brains plan things out in sequential blocking singly threaded semantic</span> <span data-start="1363.909" data-end="1364.909">ways.</span> <span data-start="1364.909" data-end="1372.479">But callbacks express asynchronous flow in a rather non-linear and non-sequential way.</span> <span data-start="1372.479" data-end="1377.809">Which makes reasoning properly about such code much more difficult.</span> <span data-start="1377.809" data-end="1383.019">Callbacks suffer from lack of sequentiality and lack of trustability, but they're good</span> <span data-start="1383.019" data-end="1389.359">in situations where you may just be performing a simple request that is always asynchronous.</span> <span data-start="1389.359" data-end="1394.45">They're just plain functions, so they also don't require any additional understanding</span> <span data-start="1394.45" data-end="1397.929">beyond knowing how asynchronous operations work.</span> <span data-start="1397.929" data-end="1402.629">They also at the end to be more verbose, so co-ordinating multiple asynchronous requests</span> <span data-start="1402.629" data-end="1408.34">with them concurrently can lead to callback hell if you're not actively modularising your</span> <span data-start="1408.34" data-end="1409.77">functions.</span> <span data-start="1409.77" data-end="1414.519">Dealing with errors also tends to be more confusing, since there could be many error</span> <span data-start="1414.519" data-end="1420.32">objects that all go back to a single error further down the call stack.</span> </p>
<p><span data-start="1420.32" data-end="1423.69">Promises are easier to reason of about.</span> <span data-start="1423.69" data-end="1425.2">Although they still have their downsides.</span> <span data-start="1425.2" data-end="1432.599">There are they are especially useful for co-ordinating multiple asynchronous operations, propagating</span> <span data-start="1432.599" data-end="1439.039">errors from nested asynch operations, and dynamically chaining asynchronous operation</span> <span data-start="1439.039" data-end="1444.639">s, i.e., those where you would do something asynch, examine output, and then do something</span> <span data-start="1444.639" data-end="1448.45">else asynch, based on the intermediate values.</span> <span data-start="1448.45" data-end="1455.559">Errors and error stacks in promises can also be a challenge, because they behave unintuitively</span> <span data-start="1455.559" data-end="1460.2">in the way that they print errors when those errors are thrown.</span> <span data-start="1460.2" data-end="1464.799">They brought new changes to the JavaScript engine and paved the way for later innovations</span> <span data-start="1464.799" data-end="1467.38">like asynch await.</span> <span data-start="1467.38" data-end="1473.759">This latest asynch pattern is basically syntactical sugar on promises, but it allows for more</span> <span data-start="1473.759" data-end="1476.729">intuitive reeled of asynchronous code.</span> <span data-start="1476.729" data-end="1482.259">It improves error handling compared to traditional promises and can be handled with simple try</span> <span data-start="1482.259" data-end="1483.379">catch blocks.</span> </p>
<p><span data-start="1483.379" data-end="1488.989">It is so easy to use asynch await that one of its slight dangers that you forget you're</span> <span data-start="1488.989" data-end="1492.019">writing asynchronous code at all.</span> <span data-start="1492.019" data-end="1498.379">Ultimately, the best tool to use for a job is going to be the one that is most specific</span> <span data-start="1498.379" data-end="1500.19">to the job that you're doing.</span> <span data-start="1500.19" data-end="1506.559">Now, I hope you'll have a firmer grasp on what exactly makes each of these tools a best</span> <span data-start="1506.559" data-end="1508.73">fit for certain jobs.</span> </p>
<p><span data-start="1508.73" data-end="1513.84">And be able to use them with the deeper understanding of what is going on at a granular level.</span> <span data-start="1513.84" data-end="1515.549">Thank you very much.</span> </p>
</section>