<section>
<p><span data-start="10.5" data-end="16.5">I'm Daniel Ehrenberg and I work in TC39 and I came here to tell you about bigint</span> <span data-start="16.56" data-end="17.97">Let's talk about numbers.</span> <span data-start="17.97" data-end="23.119">Math.pow(2, 53) is a function that can take a number to a particular power.</span> <span data-start="23.119" data-end="25.75">X will be to the 53rd power.</span> <span data-start="25.75" data-end="29.98">You can write two to **53.</span> <span data-start="29.98" data-end="31.66">What does that equal?</span> <span data-start="31.66" data-end="33.86">Starting with a nine and ending with a two.</span> <span data-start="33.86" data-end="37.13">What do you get if you add one to that?</span> <span data-start="37.13" data-end="39.43">Two to the 53 plus one.</span> <span data-start="39.43" data-end="40.43">The same number back.</span> <span data-start="40.43" data-end="46.02">A huge number, nine end, a two before what is going on?</span> <span data-start="46.02" data-end="53.28">In this talk, I will tell you about why numbers do this, how we can fix this using BigInt,</span> <span data-start="53.28" data-end="58.33">and how TC39 has been developing BigInt in partnership with the JavaScript community,</span> <span data-start="58.33" data-end="62.83">and how you can get involved to shape the next version of JavaScript.</span> </p>
<p><span data-start="62.83" data-end="65.689">I really want your help in all of this.</span> <span data-start="65.689" data-end="67.89">We can't do it without you.</span> <span data-start="67.89" data-end="75.24">So, first about numbers: numbers in JavaScript are 64-bit floats, floating point, binary,</span> <span data-start="75.24" data-end="76.25">numbers.</span> <span data-start="76.25" data-end="79.729">So that is basically like scientific notation.</span> <span data-start="79.729" data-end="86.479">Remember, from grade school, 30,000, you could represent as 3 times ten to the five?</span> <span data-start="86.479" data-end="88.88">Here, the component would be 5.</span> <span data-start="88.88" data-end="93.4">The sine is positive 1 and the fraction is 3.</span> <span data-start="93.4" data-end="99.481">I triple e â€” it's base two instead of base ten.</span> <span data-start="99.481" data-end="106.819">We have the sign that is one bit, and the component which is 11 bit, and the fraction,</span> <span data-start="106.819" data-end="109.389">52 bits.</span> </p>
<p><span data-start="109.389" data-end="117.299">So, our friend 2 to the 53rd power looks like this when you put it in a floating point.</span> <span data-start="117.299" data-end="120.009">Sine is zero to represent positive 1.</span> <span data-start="120.009" data-end="124.939">Component is that number starting with a 1, and the fraction is all zeros.</span> <span data-start="124.939" data-end="128.78">It has an implicit 1-point before the zeroes.</span> </p>
<p><span data-start="128.78" data-end="132.319">The next biggest number is that ending with a four.</span> <span data-start="132.319" data-end="138.83">If you look at the last digit, the last digit of this number ending a 2 is 0, and the one</span> <span data-start="138.83" data-end="140.23">being 1 is 1.</span> <span data-start="140.23" data-end="142.51">There are actually no numbers in between.</span> <span data-start="142.51" data-end="146.61">When I say "number", I mean the binary floating point numbers.</span> <span data-start="146.61" data-end="152.24">Ultimately, if we are representing something in 64 bits, there is only 2 to the 64 different</span> <span data-start="152.24" data-end="157.25">bit pattern, so we can't represent every single actual number that exists in the world, or</span> <span data-start="157.25" data-end="158.26">every single integer.</span> <span data-start="158.26" data-end="164.4">At some point, we have to round or go up to infinity or have an error.</span> <span data-start="164.4" data-end="166.9">This seems like a random case.</span> <span data-start="166.9" data-end="170.2">This never comes up in practice.</span> <span data-start="170.2" data-end="177.05">It turns out it president in Twitter's API, there's an ID field, tweets represented by</span> <span data-start="177.05" data-end="181.849">good afternoon, objects, and the idea that you get over the network looks like this,</span> <span data-start="181.849" data-end="186">this big number ending in 888.</span> <span data-start="186" data-end="192.61">When you parse that in JavaScript, it gets converted to a number.</span> <span data-start="192.61" data-end="197.57">So, the 8, 888 rounds to 900.</span> </p>
<p><span data-start="197.57" data-end="205.48">For this reason, Twitter includes a secondary field, ID string, which is a string of the</span> <span data-start="205.48" data-end="210.8">number, and that doesn't round, but people run into this as a problem all the tile.</span> <span data-start="210.8" data-end="216.36">Like it's kind of easier to use the ID rather than the ID stream, and it's hard for Twitter</span> <span data-start="216.36" data-end="218.28">to remove it because of compatibility.</span> <span data-start="218.28" data-end="223.43">Sometimes, the numbers don't overflow, like in that second line in this bug, but other</span> <span data-start="223.43" data-end="228.4">times, they do, and you just are referring to the wrong object.</span> </p>
<p><span data-start="228.4" data-end="232.909">Another case this comes up is inode numbers.</span> <span data-start="232.909" data-end="239.29">Each file is generally associated with a number, a pointer to the file.</span> <span data-start="239.29" data-end="246.079">Node.js includes an API called stat to read the inode numbers on a file.</span> <span data-start="246.079" data-end="251.099">On Linux, inode numbers are often kind of low, but on Windows, they can be high and</span> <span data-start="251.099" data-end="253.68">run into the same kind of rounding issue.</span> </p>
<p><span data-start="253.68" data-end="259.73">So this L stat sync, there's a reproducible test case where you can create a couple of</span> <span data-start="259.73" data-end="265.18">files in that folder which have inode numbers which one of them ending in 27 but then it</span> <span data-start="265.18" data-end="272.58">rounds up to  the same 28.</span> <span data-start="272.58" data-end="276.96">If you try to parse those numbers back to the system again, it is not going to work.</span> <span data-start="276.96" data-end="280.66">It is the wrong number.</span> <span data-start="280.66" data-end="291.38">To get around these kinds of problems, there are libraries created which gives you an object</span> <span data-start="291.38" data-end="298.39">API for this where you can instantiate a new big num and call methods on it to add or things</span> <span data-start="298.39" data-end="299.39">like that.</span> </p>
<p><span data-start="299.39" data-end="305.949">There are some limitations here, because it's not integrated into the system, so, if you</span> <span data-start="305.949" data-end="311.09">have something else in the standard library, or in the web platform or node, it's not obvious</span> <span data-start="311.09" data-end="312.55">how to integrate with this.</span> <span data-start="312.55" data-end="320.34">It's not optimisable so the JavaScript engine can't use knowledge of mathematics to make</span> <span data-start="320.34" data-end="321.34">it faster.</span> <span data-start="321.34" data-end="327.15">It is an extra thing to download and integrate which is difficult in some projects.</span> <span data-start="327.15" data-end="330.419">So, what if we had this in JavaScript itself?</span> <span data-start="330.419" data-end="335.75">Going back to the original example, where we add one and we get the same number back</span> <span data-start="335.75" data-end="343.45">again, what if we could indicate that we want to refer just to integers using a sufficient</span> <span data-start="343.45" data-end="344.45">if I can like n?</span> <span data-start="344.45" data-end="347.58">2n to the 53n would be the same number starting with a 9 and ending with a 2, but when you</span> <span data-start="347.58" data-end="351.43">add 1 into it, you get 3 at the end.</span> <span data-start="351.43" data-end="354.29">N here, the 2 goes to 3.</span> <span data-start="354.29" data-end="357.99">N here stands for BigInt.</span> <span data-start="357.99" data-end="359.539">Is this JavaScript?</span> <span data-start="359.539" data-end="360.949">It is.</span> </p>
<p><span data-start="360.949" data-end="361.949">Soon.</span> <span data-start="361.949" data-end="368.06">BigInt is at stage 3 in TC39, and we are adding it to the JavaScript programming language.</span> <span data-start="368.06" data-end="375.83">It is shipping in Chrome now as of a few days ago, shipping in Chrome 57, and node Master</span> <span data-start="375.83" data-end="377.74">is, BigInt is being supported.</span> <span data-start="377.74" data-end="382.58">BigInt is is being being supported in Firefox and South Africa are an as well and on the</span> <span data-start="382.58" data-end="384.46">road map for Edge.</span> <span data-start="384.46" data-end="395.71">What is TC39 do my JavaScript in ES6 gave you nice features like destructuring.</span> <span data-start="395.71" data-end="401.52">If you had two variables, X and Y, you can swap them by putting in an array on the left-hand</span> <span data-start="401.52" data-end="405.02">side and just swapping them.</span> <span data-start="405.02" data-end="411.38">And so this and other things like asynch await were added by TC39.</span> <span data-start="411.38" data-end="417.03">TC39 is a standards committee that is part of Ecma.</span> <span data-start="417.03" data-end="425.86">Ecma is this standards body based in Geneva, sort of administrative support, but then we</span> <span data-start="425.86" data-end="431.72">in the committee are JavaScript developers, implementers, people who are making JavaScript</span> <span data-start="431.72" data-end="437.06">work in web browsers, and node, and Babel.</span> </p>
<p><span data-start="437.06" data-end="453.25">Framework authors like Angular, ember, and React, and we all get together to produce</span> <span data-start="453.25" data-end="457.09">this document: the Ecma Script Language Specification.</span> <span data-start="457.09" data-end="462.84">If you were to print this out, it would be more than 1,200 pages.</span> <span data-start="462.84" data-end="465.86">I recommend just looking at the website.</span> </p>
<p><span data-start="465.86" data-end="469.71">It has these nice searching features.</span> <span data-start="469.71" data-end="471.78">We developed this document on GitHub.</span> <span data-start="471.78" data-end="478.479">It's an open-scores project like any other with issues and pull requests, and we also</span> <span data-start="478.479" data-end="483.259">develop it at meetings, so here, there's a part of an agenda for the meetings.</span> <span data-start="483.259" data-end="488.58">We always seem to run over a little bit on the agenda, but we meet every two twos more</span> <span data-start="488.58" data-end="495.14">three days, and we talk about the activity on GitHub, and we also talk about new proposals</span> <span data-start="495.14" data-end="498.44">to be extending the language.</span> <span data-start="498.44" data-end="503.169">These proposals move through stages, so, if it is a big proposal like BigInt, we don't</span> <span data-start="503.169" data-end="507.909">just have a pull request against the main spec and start with that, we instead make</span> <span data-start="507.909" data-end="509.349">a separate proposal.</span> <span data-start="509.349" data-end="512.159">It goes through these stages.</span> <span data-start="512.159" data-end="518.2">You might have heard of stage 1 is just a general idea, we're justifying a problem space</span> <span data-start="518.2" data-end="521.039">within the committee.</span> <span data-start="521.039" data-end="527.81">Stage 2 means that we have an agreed-on first draft that TC39 has decided we are going to</span> <span data-start="527.81" data-end="534.06">do something here, and it's going to look more or less like this.</span> </p>
<p><span data-start="534.06" data-end="539.9">By stage 3, all the details are worked out, and we have a complete first specification,</span> <span data-start="539.9" data-end="543.57">and it's ready to go off to implementers.</span> <span data-start="543.57" data-end="551.279">And by stage 4, we have multiple implementations, and lots of feedback from real usage, so we're</span> <span data-start="551.279" data-end="555.8">ready to make it part of the actual JavaScript standard.</span> <span data-start="555.8" data-end="560.579">So how did BigInt and through this process?</span> <span data-start="560.579" data-end="565.64">Actually, BigInt s or n64 has been in environment for longer than the stage process, longer</span> <span data-start="565.64" data-end="567.17">than Chrome and Node.</span> </p>
<p><span data-start="567.17" data-end="576.87">Back in 1999, after JavaScript was created, long and you long types were proposed, holding</span> <span data-start="576.87" data-end="579.97">unsigned 64-bit integers.</span> <span data-start="579.97" data-end="589.18">This 3, that update was expansions to the library, like regular expressions.</span> <span data-start="589.18" data-end="595.8">ES4 was this huge project that was thinking of adding these types but it got so complicated</span> <span data-start="595.8" data-end="603.47">that it just had to be abandoned be, and, in ES5 to recover and heal from that process,</span> <span data-start="603.47" data-end="608.22">the language changes were really minimal, and included things like cleaning up the object</span> <span data-start="608.22" data-end="613.69">model, and eval, and a view other library editions â€” a few other library editions.</span> <span data-start="613.69" data-end="620.11">E6 made a whole bunch of changes, such as this destructuring assignment that I mentioned.</span> </p>
<p><span data-start="620.11" data-end="624.62">As part of ES6, the committee was talking about adding value types, which would have</span> <span data-start="624.62" data-end="631.389">been user-de fined data types, so user-defined primitives.</span> <span data-start="631.389" data-end="636.61">You can already define your own objects but you can't define your own thing as a JavaScript</span> <span data-start="636.61" data-end="639.81">programmer.</span> <span data-start="639.81" data-end="645.19">We're still talking about doing value types, but they weren't added in ES6 but deferred</span> <span data-start="645.19" data-end="648.25">until later.</span> <span data-start="648.25" data-end="656.8">Long history of not jet doing larger integers, but then recently, in November 2016, Brendan</span> <span data-start="656.8" data-end="662.29">Eich proposed again to the committee that we do in 64, rather than coupling it to the</span> <span data-start="662.29" data-end="669.54">whole value-type package, in 64, and unsigned in 64 was proposed as a standalone proposal,</span> <span data-start="669.54" data-end="677.73">to add this one new primitive type.</span> <span data-start="677.73" data-end="680.08">We wanted to do it rather than BigInt rather than 64.</span> <span data-start="680.08" data-end="682.959">I will talk more about the reasons in a bit.</span> <span data-start="682.959" data-end="688.649">Then, by the July, we got to see .. process.</span> <span data-start="688.649" data-end="693.37">Now shipping in 67.</span> <span data-start="693.37" data-end="696.19">Let's go over how this happens in more detail.</span> </p>
<p><span data-start="696.19" data-end="706.43">For stage one, what you need is to have a description of the problem, and so, what we</span> <span data-start="706.43" data-end="724.62">did in TC39 is create this .. [sound distorted].</span> <span data-start="724.62" data-end="730.41">.. inviting various members participate to give opinions about various different semantic</span> <span data-start="730.41" data-end="731.47">points.</span> <span data-start="731.47" data-end="738.37">So, a couple of big discussions that we went through were big â€” I mentioned in the history</span> <span data-start="738.37" data-end="743.649">that much of the time we've been discussing adding 64-bit integers to the language rather</span> <span data-start="743.649" data-end="747.35">than adding other tree size integers.</span> <span data-start="747.35" data-end="753.16">Some of the reasons for that were some people felt like it would be a more minimal addition,</span> <span data-start="753.16" data-end="759.04">so, if you have a 64-bit integer, it would overflow or throw an exception when you get</span> <span data-start="759.04" data-end="764.38">out of bounds.</span> <span data-start="764.38" data-end="765.38">That could work.</span> <span data-start="765.38" data-end="767.48">For a lot of the applications, it works.</span> <span data-start="767.48" data-end="770.08">The whole point of the proposal is to avoid the overflow.</span> </p>
<p><span data-start="770.08" data-end="773.66">Sometimes, 64 bits is enough.</span> <span data-start="773.66" data-end="779.529">People thought this would be maybe easier to convince browsers to implement, or it might</span> <span data-start="779.529" data-end="786.899">execute faster, but, when we talked more with the browsers, actually benefit from the V8</span> <span data-start="786.899" data-end="791.79">team, sort of led this effort to re consider arbitrary sized integers.</span> <span data-start="791.79" data-end="796.209">This way, you never have to worry about overflow, and it actually turns out that the way that</span> <span data-start="796.209" data-end="802.99">modern JavaScript engines work, they have machinery for doing this sort of optimisation</span> <span data-start="802.99" data-end="809.25">for working with numbers in particular ranges, to convert them to integers.</span> <span data-start="809.25" data-end="817.55">And, at the same time, n64 wouldn't be that fast without all sorts of optimisations, because</span> <span data-start="817.55" data-end="822.839">it has to be allocated in the heap, you have to do all sorts of type-checking, and to get</span> <span data-start="822.839" data-end="829.38">it to the point where it's allocated in registers or on the stack, there is already a lot of</span> <span data-start="829.38" data-end="830.72">magic going on.</span> <span data-start="830.72" data-end="833.24">When that same magic is apply, it would work for BigInt.</span> </p>
<p><span data-start="833.24" data-end="838.23">We decided to bite the bullet, solve the whole problem better go and go with BigInt rather</span> <span data-start="838.23" data-end="840.93">than n64.</span> <span data-start="840.93" data-end="846.94">The other big semantic point we discussed is what to do with mixed types.</span> <span data-start="846.94" data-end="853.82">So, in a language like Python, you can just add a â€” you can just add a large integer and</span> <span data-start="853.82" data-end="858.67">a float, and you get a float back, and what we decided for JavaScript is we don't want</span> <span data-start="858.67" data-end="859.99">to do that.</span> <span data-start="859.99" data-end="865.73">What we're doing instead, I mean, the whole point of BigInt is to be this new data type</span> <span data-start="865.73" data-end="868.05">that provides this mathematical accuracy.</span> <span data-start="868.05" data-end="871.86">You don't have to think about all the complexity of IEE74.</span> <span data-start="871.86" data-end="882.37">You can just think about integers, but what integer would you get when you add a very</span> <span data-start="882.37" data-end="887.13">large integer, 2 to the 53 plus 1.5?</span> <span data-start="887.13" data-end="892.45">The answer isn't actually contained in this set of integers or in the set of representable</span> <span data-start="892.45" data-end="894.519">float-point values.</span> <span data-start="894.519" data-end="897.76">What we decided is, rather than come up with the wrong answer, when the whole point of</span> <span data-start="897.76" data-end="902.759">the feature is to come to the right answer, we would throw a type error in this case.</span> <span data-start="902.759" data-end="906.42">We would say we're not going to come to an answer.</span> </p>
<p><span data-start="906.42" data-end="915.05">Actually, you can't mix BigInts and numbers in general in mathematical operations.</span> <span data-start="915.05" data-end="918.92">This leads to a best practice that I recommend.</span> <span data-start="918.92" data-end="925.02">BigInt are good when you have a value that ranges that might be larger than what can</span> <span data-start="925.02" data-end="931.47">be represented in numbers, but if numbers are working for you, stick with them.</span> <span data-start="931.47" data-end="936.861">Numbers still worked just fine for small integers, and in general, because we have to make make</span> <span data-start="936.861" data-end="940.279">this decision up front, it is because of that.</span> <span data-start="940.279" data-end="947.47">That issue I just described, you know, numbers in use for what they're in use for right now,</span> <span data-start="947.47" data-end="950.38">still works very well.</span> <span data-start="950.38" data-end="963.389">So to get to stage 2 from there, the committee wrote this draft specification document, and</span> <span data-start="963.389" data-end="969.49">this is like the main document for the whole specification except that it is only the segment</span> <span data-start="969.49" data-end="976.25">that relates to this new feature, so it includes some insertions, deletions, and some new sections,</span> <span data-start="976.25" data-end="979.91">but you can ultimately read it in the same HTML file.</span> <span data-start="979.91" data-end="989.73">That's generated from this specification form â€” format, in let's you use a combination of</span> <span data-start="989.73" data-end="999.339">markdown and grammar syntax easily to generate these specification drafts.</span> <span data-start="999.339" data-end="1005.959">My co-work er Robyn Templeton implemented BigInt in SpiderMonkey, which is currently</span> <span data-start="1005.959" data-end="1009.92">starting to land.</span> </p>
<p><span data-start="1009.92" data-end="1015.199">So, even though stage 3 is when something is really, really ready for implementation,</span> <span data-start="1015.199" data-end="1019.449">and really stable, it's never too early to get started prototyping, and this process</span> <span data-start="1019.449" data-end="1023.63">leads to â€” helps the development of the feature.</span> <span data-start="1023.63" data-end="1028.16">To get to stage 3, we needed sign-off on this specification.</span> <span data-start="1028.16" data-end="1032.44">In particular, a couple of committee members, or more than a couple of committee members,</span> <span data-start="1032.44" data-end="1038.27">volunteer to read the whole specification in a lot of detail, as well as the editors,</span> <span data-start="1038.27" data-end="1040.449">and see whether it's ready this.</span> <span data-start="1040.449" data-end="1047">Leads to a lot of typos being fixed and cases being looked at closely, and, once we got</span> <span data-start="1047" data-end="1051.16">to this level of stability where the committee has signed off and the committee is really</span> <span data-start="1051.16" data-end="1056.35">saying, "Yes, we want to to this feature," stage 2 is, "We want to do this feature,"</span> <span data-start="1056.35" data-end="1062.25">and stage 3 is, "We want to do it this way, and we need implementation feedback."</span> <span data-start="1062.25" data-end="1066.88">This level of stability led the V8 team to implement BigInt.</span> <span data-start="1066.88" data-end="1075.11">Following that, the â€” so, you know, thank you Jacob for great work leading the BigInt</span> <span data-start="1075.11" data-end="1084.09">implementation, and Kyle Lima worked on BigInt in KLC which is in progress.</span> </p>
<p><span data-start="1084.09" data-end="1088.67">Even once we got to a stage 3, even once we said that we have this level of stability,</span> <span data-start="1088.67" data-end="1093.9">there were still some Edge cases that people came across, which, because the feature hasn't</span> <span data-start="1093.9" data-end="1100.21">shipped to the web yet, we were opening to revisiting.</span> <span data-start="1100.21" data-end="1104.65">So there were tons of different edge cases like this that we spent committee time on</span> <span data-start="1104.65" data-end="1110.38">before getting to stage 3, and, even after stage 3, we looked at this one.</span> <span data-start="1110.38" data-end="1116.25">You know double equals and less than, in JavaScript, you can use them to compare a number and a</span> <span data-start="1116.25" data-end="1121.5">string, and, when you do that, it converts the string to a number, and it compares them</span> <span data-start="1121.5" data-end="1124.27">as numeric values.</span> <span data-start="1124.27" data-end="1131.02">So, you know, this is part of JavaScript being maybe weekly typed, and having all these casts</span> <span data-start="1131.02" data-end="1138.4">everywhere, and so, to make sure that BigInt is consistent with â€” to make sure that BigInt</span> <span data-start="1138.4" data-end="1139.75">is consistent with numbers.</span> <span data-start="1139.75" data-end="1144.02">We did that same behaviour in BigInt.</span> <span data-start="1144.02" data-end="1151.4">In this second case, accidentally we were converting BigInt to a number, and it wouldn't</span> <span data-start="1151.4" data-end="1157.01">compare as less than when it is actually the same value, because that number would be rounding</span> <span data-start="1157.01" data-end="1159">down.</span> </p>
<p><span data-start="1159" data-end="1164.181">To get to stage 4, what we are going to need is full tests, there's a performance test</span> <span data-start="1164.181" data-end="1174.21">suite that verifies that implementations are working right, so we have those conformance</span> <span data-start="1174.21" data-end="1175.21">tests.</span> <span data-start="1175.21" data-end="1182.59">A full request, there's still more refactor to go do for that, and two implementations</span> <span data-start="1182.59" data-end="1187.73">where we have one full implementation, but the next two are still in progress.</span> <span data-start="1187.73" data-end="1194.9">So maybe we will get this by ES2019, or ES2020 â€” I hope so.</span> </p>
<p><span data-start="1194.9" data-end="1201.32">So, to let you know how to get involved, there's just a lot of different ways to get involved</span> <span data-start="1201.32" data-end="1202.82">here.</span> <span data-start="1202.82" data-end="1204.39">Feedback on GitHub issues is really great.</span> <span data-start="1204.39" data-end="1208.92">I love to hear about whether feature proposal works for you.</span> <span data-start="1208.92" data-end="1213.46">If there are pieces missing or if a case should be handled differently, and this was really</span> <span data-start="1213.46" data-end="1218.62">useful for working through tons of issues with BigInt.</span> <span data-start="1218.62" data-end="1225.91">Test 262 tests, there's a project to implement tests for the JavaScript language itself.</span> <span data-start="1225.91" data-end="1229.43">And it's an open-source project that's happy to have new contributions.</span> <span data-start="1229.43" data-end="1235.88">What we find is that, when something is missing from the test suite, actually, different browsers</span> <span data-start="1235.88" data-end="1242.09">or different JavaScript implementations have different behaviour, because different people</span> <span data-start="1242.09" data-end="1246.94">end up reading the same specification differently by accident, and so it's really important</span> <span data-start="1246.94" data-end="1248.74">to have a full test suite.</span> </p>
<p><span data-start="1248.74" data-end="1251.04">There are other parts.</span> <span data-start="1251.04" data-end="1258.01">Other have tests like web platform tests, and so, for example, here's a pull request</span> <span data-start="1258.01" data-end="1265.19">to add tests that check that adding a number in a BigInt throws a type error.</span> <span data-start="1265.19" data-end="1272.76">For the BigInt project, it helps make implementations right the first time and say correct.</span> <span data-start="1272.76" data-end="1278.16">Sometimes, a joke was made to me, sometimes, implementations make so many optimisations</span> <span data-start="1278.16" data-end="1283.03">that they optimise away the specification itself.</span> <span data-start="1283.03" data-end="1285.13">This will prevent that.</span> <span data-start="1285.13" data-end="1289.92">As you're maintaining the project, you have these complete correctness tests.</span> <span data-start="1289.92" data-end="1295.68">But, it went even further than that, because the people working on these tests took a really</span> <span data-start="1295.68" data-end="1300.44">close look at all the Edge cases, and helped work through a lot of design decisions.</span> <span data-start="1300.44" data-end="1307.05">More than six test engineers collaborated, especially from Boku and Egalia.</span> <span data-start="1307.05" data-end="1310.76">We are happy to have help, documentation and education.</span> </p>
<p><span data-start="1310.76" data-end="1314.66">With this readme file, a number of people contributed.</span> <span data-start="1314.66" data-end="1317.91">It's important to understand the different mental models that JavaScript programmers</span> <span data-start="1317.91" data-end="1324.05">have.</span> <span data-start="1324.05" data-end="1327.43">People aren't programming thinking through the entire specification, and different people</span> <span data-start="1327.43" data-end="1331.22">have different mental models, so this is especially useful.</span> <span data-start="1331.22" data-end="1335.26">We tried to compare a bunch of different ways of thinking through code when designing language</span> <span data-start="1335.26" data-end="1336.72">features.</span> <span data-start="1336.72" data-end="1342.23">For example, in the BigInt design process, Ashley Williams pointed out that, when learning</span> <span data-start="1342.23" data-end="1347.8">programming, a lot of programmers have an intuition that variables should have particular</span> <span data-start="1347.8" data-end="1349.25">types.</span> <span data-start="1349.25" data-end="1355.75">So, this made us feel not quite as bad about not permitting mixed operations between BigInt</span> <span data-start="1355.75" data-end="1362.35">and number because this is an intuitive thing for people to learn, that a value has a particular</span> <span data-start="1362.35" data-end="1365.3">type.</span> <span data-start="1365.3" data-end="1373.54">It's also welcome to implement things, so you can contribute to lots of implementations</span> <span data-start="1373.54" data-end="1379.15">in JavaScript, so, through implementations, it's not just about getting JavaScript to</span> <span data-start="1379.15" data-end="1384.27">developers, all these three implementations of BigInt that are in progress have contributed</span> <span data-start="1384.27" data-end="1388.51">to the design of the feature.</span> </p>
<p><span data-start="1388.51" data-end="1393.27">It's also possible, if you're not able to do this development yourself, companies like</span> <span data-start="1393.27" data-end="1402.14">Bloomberg and Google sponsor work to push these things forward, and of course, in these</span> <span data-start="1402.14" data-end="1406.46">meetings, we are open to new members, so, let me know if you want to get involved as</span> <span data-start="1406.46" data-end="1409.38">a TC39 delegate.</span> <span data-start="1409.38" data-end="1411.64">It's an organisational membership.</span> </p>
<p><span data-start="1411.64" data-end="1417.9">Something like your employer would join, or there are also non-profit memberships.</span> <span data-start="1417.9" data-end="1426.45">So, as a takeaway, please, if you're interested in building the future of JavaScript, get</span> <span data-start="1426.45" data-end="1427.99">involved in TC39.</span> <span data-start="1427.99" data-end="1434.3">You can go to our website, and you know, now you have BigInts, and cruise them for iterators</span> <span data-start="1434.3" data-end="1438.93">which may be big, and use numbers for numbers that are smaller.</span> </p>
<p><span data-start="1438.93" data-end="1441.89">So, I'm Little Dan, and thank you!</span> </p>
</section>