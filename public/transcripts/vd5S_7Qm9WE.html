<section>
<p><span data-start="0.16" data-end="1.36">"Everything as a Stream!": How We're Embracing React Programming to Build</span> <span data-start="1.36" data-end="2.36">a Large SPA — Anton Abilov</span> <span data-start="2.36" data-end="3.36"Audience member: Hey, everybody!</span> <span data-start="3.36" data-end="4.36">OK, so for our next speaker, fun fact: He's never lost a dance of limbo.</span> <span data-start="4.36" data-end="5.36">Is limbo a dance?</span> <span data-start="5.36" data-end="6.36">He's never lost limbo, just know that.</span> <span data-start="6.36" data-end="7.36">So for our next talk it's called everything as a stream.</span> <span data-start="7.36" data-end="8.36">Let's welcome Anton Abilov.</span> <span data-start="8.36" data-end="9.36">[applause]</span> <span data-start="9.36" data-end="12.849">I won't be doing limbo on stage, but if you want to challenge me in limbo later, I'm all</span> <span data-start="12.849" data-end="14.209">for it.</span> <span data-start="14.209" data-end="16.75">So I'm very excited to be here.</span> <span data-start="16.75" data-end="19.32">I came all the way from Norway for this conference.</span> <span data-start="19.32" data-end="20.949">It's been awesome so far.</span> <span data-start="20.949" data-end="25.99">Thanks to all of you, the organizers, and the speakers of course.</span> </p>
<p><span data-start="25.99" data-end="30.95">Now we're going to talk a little bit more about streams, and how we've embraced Functional</span> <span data-start="30.95" data-end="39.531">Reactive Programming to build a large single-page application at Ardoq, owe at Ardoq we try</span> <span data-start="39.531" data-end="51.53">to help  —  we do this by model emthem as a graph so we map out applications, business</span> <span data-start="51.53" data-end="55.949">capabilities, their infrastructure and how it all ties together.</span> <span data-start="55.949" data-end="62.899">It's a fairly client-side-heavy app with dynamic generated visualizations, real-time collaboration</span> <span data-start="62.899" data-end="69.75">and also an interesting mix of technologies that we're going to go a bit in.</span> <span data-start="69.75" data-end="74.94">So for this talk we're going to define some concepts to give you an intro to streams and</span> <span data-start="74.94" data-end="76.37">Functional Reactive Programming.</span> <span data-start="76.37" data-end="81.18">Then we're going to hopefully give you some motivation for why you should care, and then</span> <span data-start="81.18" data-end="86.59">we're going to present some building blocks for building an app with RX JS and also talk</span> <span data-start="86.59" data-end="91.06">about some roadblocks that we've hit along the way.</span> <span data-start="91.06" data-end="96.38">So Functional Reactive Programming, how many of you have used it before.</span> <span data-start="96.38" data-end="98.56">Please raise a hand.</span> <span data-start="98.56" data-end="100.95">That's a few, not that many.</span> </p>
<p><span data-start="100.95" data-end="106.74">I think I can't see because of the lights, but Functional Reactive Programming is programming</span> <span data-start="106.74" data-end="111.57">with data streams.</span> <span data-start="111.57" data-end="118.48">If you look at the languages a lot of us use, a lot of them involve the principles of reactive</span> <span data-start="118.48" data-end="119.48">programming.</span> <span data-start="119.48" data-end="130.72">For Redux, for example, you have the store, so that is essentially a stream, right?</span> <span data-start="130.72" data-end="135.23">What we do in reactive programming, though, is we elevate streams and we treat them as</span> <span data-start="135.23" data-end="141.2">first-class citizens and the functional part comes from the part that we compose them functionally,</span> <span data-start="141.2" data-end="144.59">so we map them, filter, and reduce.</span> </p>
<p><span data-start="144.59" data-end="148.59">There are many libraries in JavaScript for working with streams, and in this talk we're</span> <span data-start="148.59" data-end="152.42">going to focus on RxJS which is probably the most popular one.</span> <span data-start="152.42" data-end="157.5">I think it surpassed a million downloads had this year and it's the only dependency of</span> <span data-start="157.5" data-end="159.92">Angular.</span> <span data-start="159.92" data-end="166.29">So RxJS is a library for transforming, composing and querying streams of data, it implements</span> <span data-start="166.29" data-end="171.84">the observable type in JavaScript.</span> <span data-start="171.84" data-end="174.6">And many people call it LoDash for streams.</span> <span data-start="174.6" data-end="180.12">I think it's quite powerful and I like this definition, and I hope you can see that, as</span> <span data-start="180.12" data-end="181.12">well.</span> </p>
<p><span data-start="181.12" data-end="192.03">So the observable is comes from reactive tensions, Rx and it allowed us to work with async code</span> <span data-start="192.03" data-end="196.88">more easily and when interesting the observable, I like to compare it with promises because</span> <span data-start="196.88" data-end="203.5">I think most of us have worked with promises, so whereas a promise emits a single value,</span> <span data-start="203.5" data-end="207.73">observables emit multiple values over a period of time.</span> <span data-start="207.73" data-end="218.11">A promise is not lazy, it begins promising on crease, so whereas an observable is lazy,</span> <span data-start="218.11" data-end="222.9">so you can declare an observable that should fetch data from an API, but it won't actually</span> <span data-start="222.9" data-end="228.22">start fetching until you subscribe to it.</span> </p>
<p><span data-start="228.22" data-end="233.65">Whereas a promise can't be canceled, observables can be canceled seamlessly and this can be</span> <span data-start="233.65" data-end="238.961">quite powerful in some web applications, a lot of the core contributors at RxJS work</span> <span data-start="238.961" data-end="245.17">at Netflix and their canonical example is when a user starts buffering a video and then</span> <span data-start="245.17" data-end="253.03">goes back, with promises this can be quite complex, while with observables, it's seamless</span> <span data-start="253.03" data-end="258.32">and kind of reflecting on these properties, I think the more complex our single-page applications</span> <span data-start="258.32" data-end="263.71">become, the more things kind of emit over time and the observable pattern fits much</span> <span data-start="263.71" data-end="267.35">better for dealing with this than promises.</span> <span data-start="267.35" data-end="271.79">Another reason for why you should care is that the observable is a Stage 1 proposal</span> <span data-start="271.79" data-end="273.48">in JavaScript.</span> </p>
<p><span data-start="273.48" data-end="275.72">So it might actually become a part of our language.</span> <span data-start="275.72" data-end="283.25">And RxJS have also done a lot of work in mirroring that proposal.</span> <span data-start="283.25" data-end="285.6">So how did we come across RxJS.</span> <span data-start="285.6" data-end="293.33">We went with Redux, then we needed a way to handle async and for simple applications you</span> <span data-start="293.33" data-end="294.741">might be fine with Redux thunk.</span> <span data-start="294.741" data-end="303.86">But if you have more complex, you might want to look into reDutch .. we tried Redux observable</span> <span data-start="303.86" data-end="309.96">and that was the gateway drug to streams.</span> <span data-start="309.96" data-end="316.74">So on the left side here you have a typical Redux application or a flux-architecture where</span> <span data-start="316.74" data-end="322.75">you have views that trigger actions, these actions are reduced in the store and then</span> <span data-start="322.75" data-end="325.82">the views are described in this store to read the application state.</span> <span data-start="325.82" data-end="332.33">What Redux observable does is it also adds epochs into the mix.</span> </p>
<p><span data-start="332.33" data-end="339.62">Epochs take our actions and can also read the store and they emit new actions, and the</span> <span data-start="339.62" data-end="345.24">store and actions are represented as RxJS streams, so you can apply several operators</span> <span data-start="345.24" data-end="351.91">to them, and write fairly complex async code seamlessly.</span> <span data-start="351.91" data-end="357.05">And for us streams really made sense, so for the actions in store, I mean they emit over</span> <span data-start="357.05" data-end="362.13">time, so representing them as a stream makes sense, but then if you think of your web applications</span> <span data-start="362.13" data-end="370.139">you also have click events, DOM events, user reaction.</span> <span data-start="370.139" data-end="377.85">And thinking of these as streams kind of liberates you, it makes it much easier to model complex</span> <span data-start="377.85" data-end="380.24">data flow.</span> <span data-start="380.24" data-end="383.88">And you might even think of everything as a stream eventually.</span> <span data-start="383.88" data-end="390.6">At least for us that kind of became the case and this is our mantra when building applications.</span> <span data-start="390.6" data-end="408.25">And while we were super-zen, like this dog meditating, that's when reality kicked in.</span> </p>
<p><span data-start="408.25" data-end="411.92">It was in a quite dire state, with vast amounts of technical debt.</span> <span data-start="411.92" data-end="417.9">So as I said, Ardoq is a startup and for the first four years we were trying to find product</span> <span data-start="417.9" data-end="422.979">market fit and what that meant is that we needed to add a lot of new features without</span> <span data-start="422.979" data-end="426.699">thinking much about technical debt or dealing with that.</span> <span data-start="426.699" data-end="431.18">And kind of in the JavaScript world, that also meant that we took a lot of shortcuts,</span> <span data-start="431.18" data-end="436.85">introduced a lot of new libraries, and it led to a mix of paradigms that don't mix well</span> <span data-start="436.85" data-end="437.85">together.</span> <span data-start="437.85" data-end="443.419">We had a new colleague join two years ago, and he said that our app basically showcased</span> <span data-start="443.419" data-end="445.68">the history of web development.</span> <span data-start="445.68" data-end="447.09">[laughter]</span> <span data-start="447.09" data-end="453.8">It had a mix of JQuery, handlebars, React, Redux, all the good stuff for the bad stuff.</span> <span data-start="453.8" data-end="459.8">So it was really hard to reason about what's going on.</span> <span data-start="459.8" data-end="465.259">If you tried to fix something over here, this other thing broke and also state was all over</span> <span data-start="465.259" data-end="471.24">the place, and it was really hard to reason what was going on, and I think that's where</span> </p>
<p><span data-start="471.24" data-end="478.69">Redux saved us is it allowed us to think easily about our state.</span> <span data-start="478.69" data-end="487.71">The so the plans, first we to rearchitecture mid flight.</span> <span data-start="487.71" data-end="489.979">We need to start decoupling or app.</span> <span data-start="489.979" data-end="494.509">Then we need to be able to reason about our state and also need good interop with legacy</span> <span data-start="494.509" data-end="496.16">state and views.</span> <span data-start="496.16" data-end="504.71">So new views need to interrupt with old state and old views and RxJS and Redux was introduced,</span> <span data-start="504.71" data-end="508.49">but then we started thinking, do we really need Redux?</span> <span data-start="508.49" data-end="512.949">And it was great for starting from scratch, but it was not really obvious how we introduced</span> <span data-start="512.949" data-end="517.56">it in a legacy app, especially since we had a lot of state all over the place, simply</span> <span data-start="517.56" data-end="522.05">adding a Redux store would mean we had another state manager and so it became an even bigger</span> <span data-start="522.05" data-end="528.579">mess and if you read the Redux documentation, they mention RxJS and they say it works together</span> <span data-start="528.579" data-end="533.94">with Redux, but I'm going to highlight this one paragraph and that's where they ask: Do</span> <span data-start="533.94" data-end="536.999">you really need Redux if you already use RX?</span> <span data-start="536.999" data-end="537.999">Maybe not.</span> <span data-start="537.999" data-end="543.579">It's not hard to reimplement Redux in RX.</span> <span data-start="543.579" data-end="546.12">And that's essentially what we did.</span> </p>
<p><span data-start="546.12" data-end="553.81">So we defined these building blocks, which are very similar to a Redux architecture.</span> <span data-start="553.81" data-end="555.839">It's a flux-like architecture.</span> <span data-start="555.839" data-end="559.329">We have the action stream which ties everything together.</span> <span data-start="559.329" data-end="563.79">That is subscribed by the state stream which calculates the application state based on</span> <span data-start="563.79" data-end="564.79">actions.</span> <span data-start="564.79" data-end="568.869">Then we have view streams which is a layer in between the states and our views, which</span> <span data-start="568.869" data-end="574.8">prepares the state for the views so that the views can be as simple as possible, essentially</span> <span data-start="574.8" data-end="577.87">pure functions of view streams.</span> <span data-start="577.87" data-end="582.47">Finally we have routines and that's where we contain our side effects, so similar to</span> <span data-start="582.47" data-end="587.49">epochs and Redux observable and they also allow us to kind of decouple our application,</span> <span data-start="587.49" data-end="590.86">so I'm going to jump into each one of these.</span> </p>
<p><span data-start="590.86" data-end="596.379">Owe the action stream allows any part of the action to communicate.</span> <span data-start="596.379" data-end="601.47">We define it as a subject so a subject is a type of an observable.</span> <span data-start="601.47" data-end="607.88">Whereas an observable emits data over time, you can also push data to a subject, using</span> <span data-start="607.88" data-end="611.139">the .next method.</span> <span data-start="611.139" data-end="617.839">And with these two lines of code we can dispatch our first action and launch a rocket at JSConf.</span> <span data-start="617.839" data-end="621.629">However, nothing is happening yet.</span> <span data-start="621.629" data-end="623.56">So with that reintroduced routines.</span> <span data-start="623.56" data-end="627.36">Rye teens handle actions and produce side effects.</span> <span data-start="627.36" data-end="629.759">So here's an example of a routine.</span> <span data-start="629.759" data-end="642.6">It pipes the action step.</span> <span data-start="642.6" data-end="649.389">So we filter on the launch rocket action then we mapped that to fetching of coordinates</span> <span data-start="649.389" data-end="655.73">which could be an API call to get the coordinates and finally if that touches successfully,</span> <span data-start="655.73" data-end="658.66">we dispatch an action to proceed.</span> <span data-start="658.66" data-end="662.279">And these are three different RxJS operators.</span> <span data-start="662.279" data-end="668.72">Of type was custom and in the middle we have switchMap and I purposely chose switchMap</span> <span data-start="668.72" data-end="672.839">instead of flat map to show cancellation.</span> </p>
<p><span data-start="672.839" data-end="679.189">Essentially what switchMap does is if it starts fetching coordinates and that takes a long</span> <span data-start="679.189" data-end="684.269">time and then another action is dispatched to launch another rocket, the first one would</span> <span data-start="684.269" data-end="685.79">be canceled.</span> <span data-start="685.79" data-end="690.999">So that's how cancellation can easily be built into streams.</span> <span data-start="690.999" data-end="698.85">So routines allow us to decouple our application, because modules can simply define what they</span> <span data-start="698.85" data-end="705.459">should react to, and our views and other modules can dispatch action, so it allows us to decouple</span> <span data-start="705.459" data-end="706.459">them.</span> </p>
<p><span data-start="706.459" data-end="710.069">For us that helped a lot, because we had basically a spaghetti monster.</span> <span data-start="710.069" data-end="716.36">If one service needed to use another, it basically imported it and if that needs to use the other</span> <span data-start="716.36" data-end="720.189">one, then you have circular dependencies and once everything goes over the action stream</span> <span data-start="720.189" data-end="725.67">it's much easier to build a modular application.</span> <span data-start="725.67" data-end="729.819">And then we hit our first roadblock, and that was dead streams.</span> <span data-start="729.819" data-end="733.529">So what is streamed may die.</span> <span data-start="733.529" data-end="736.49">Essentially you need to catch your errors with RxJS.</span> <span data-start="736.49" data-end="742.31">So in this example if we fetch coordinates and that API call fails, then it wouldn't</span> <span data-start="742.31" data-end="745.35">proceed, and that makes sense.</span> <span data-start="745.35" data-end="755.899">As you would expect.</span> <span data-start="755.899" data-end="760.749">With RxJS you need to catch errors in order to keep your streams alive and that is actually</span> <span data-start="760.749" data-end="766.209">a pretty good feature, I think because it forces you to catch errors and define how</span> <span data-start="766.209" data-end="768.309">your application should handle them.</span> <span data-start="768.309" data-end="772.899">Of course, for production-ready code you might want to make it more robust by centralizing</span> <span data-start="772.899" data-end="778.66">stream creation.</span> <span data-start="778.66" data-end="786.72">Next we have state streams, so so far we have actions and routines.</span> </p>
<p><span data-start="786.72" data-end="792.99">State streams emit the state of our application and here's an example of our state stream.</span> <span data-start="792.99" data-end="798.66">So the rocket stream pipes the action stream and accumulates state over time.</span> <span data-start="798.66" data-end="808.85">So if this batch action to launch a rocket, it will decrement the fuel of a rocket.</span> <span data-start="808.85" data-end="814.48">It's basically a reducer, except it's now modeled as a stream.</span> <span data-start="814.48" data-end="818.839">Now that it's modeled as a stream, we can also do a lot of different things with them</span> <span data-start="818.839" data-end="820.859">that we're going to go into.</span> <span data-start="820.859" data-end="826.369">So one thing is that we can have derived state, so oftentimes in your applications you have</span> <span data-start="826.369" data-end="831.1">state which depends on base state.</span> </p>
<p><span data-start="831.1" data-end="835.98">For example, we could have refueling cost, which should be calculated using the fuel</span> <span data-start="835.98" data-end="843.339">price, for example, so here we pluck the fuel from the rocket stream and then we apply distinct</span> <span data-start="843.339" data-end="844.999">until changed.</span> <span data-start="844.999" data-end="851.239">That adds memorization, so essentially it won't emit until the fuel changes and then</span> <span data-start="851.239" data-end="856.749">we define it with a fuel price stream.</span> <span data-start="856.749" data-end="862.81">So when something subscribes to this, it would also do an API call to get the latest fuel</span> <span data-start="862.81" data-end="868.619">price and finally we mapped that to the refueling cost.</span> </p>
<p><span data-start="868.619" data-end="880.649">And normally, if you would have minimization in a Redux, you would have to add ..</span> <span data-start="880.649" data-end="886.339">Next we have proxy state, so going back to our requirements, we have a lot of legacy</span> <span data-start="886.339" data-end="894.459">state, and we need to interrupt with that, we can create our own stream creators and</span> <span data-start="894.459" data-end="896.989">essentially stream our legacy state.</span> </p>
<p><span data-start="896.989" data-end="902.8">So here we create an observable from a backbone model.</span> <span data-start="902.8" data-end="908.389">Whenever a backbone model syncs with a server it also pushes that to an observable.</span> <span data-start="908.389" data-end="916.179">So we can simply subscribe to these streams and they won't really know about backbone</span> <span data-start="916.179" data-end="922.029">being under the hood so we can later swap out backbone easily.</span> <span data-start="922.029" data-end="926.489">So the benefits of state streams is that they're quite expressive and powerful, yet easy to</span> <span data-start="926.489" data-end="927.559">reason about.</span> <span data-start="927.559" data-end="937.959">So going back to this slide, we have minimization built in and once you get used to the paradigm</span> <span data-start="937.959" data-end="942.089">it's quite easy to read.</span> <span data-start="942.089" data-end="951.54">Then it has good interop with legacy state.</span> <span data-start="951.54" data-end="955.589">You could add debouncing, you have minimization with distinct until changed.</span> <span data-start="955.589" data-end="961.069">You could add a buffer and there are many other options, as well.</span> <span data-start="961.069" data-end="965.41">Then we hit our next roadblock and that's cold versus hot?</span> </p>
<p><span data-start="965.41" data-end="970.279">So I think anyone who starts using RxJS hits this roadblock eventually.</span> <span data-start="970.279" data-end="975.829">For those of you who are not familiar with cold versus hot, it might also be a bit ambiguous</span> <span data-start="975.829" data-end="976.829">terms.</span> <span data-start="976.829" data-end="979.36">They didn't make much sense to me the first time I heard them.</span> <span data-start="979.36" data-end="987.22">What it means is observables are cold by default and then they can be made hot.</span> <span data-start="987.22" data-end="995.089">Cold observables work in the way that every new subscriber gets its own producer.</span> </p>
<p><span data-start="995.089" data-end="1001.989">So imagine that there's an observable which models the Fibonacci sequence, the first subscriber</span> <span data-start="1001.989" data-end="1007.069">would get the whole sequence and the second subscriber would also get the whole sequence.</span> <span data-start="1007.069" data-end="1015.35">And that makes sense in some cases, with API calls, for example, you would expect that</span> <span data-start="1015.35" data-end="1019.009">every new subscriber would do a new API call.</span> <span data-start="1019.009" data-end="1024.03">However, for some cases such as state streams, that's not really efficient, because every</span> <span data-start="1024.03" data-end="1031.63">new subscriber to a state stream would provide a new producer, so it would recalculate the</span> <span data-start="1031.63" data-end="1035.4">state every time.</span> <span data-start="1035.4" data-end="1039.53">So what we can do for state streams is we have hot observables.</span> <span data-start="1039.53" data-end="1046.9">So essentially it shares the producer among all subscribers.</span> </p>
<p><span data-start="1046.9" data-end="1051.76">Basically cold versus hot is a very important property of streams that has implications</span> <span data-start="1051.76" data-end="1055.63">and you need to think about this when you define your streams.</span> <span data-start="1055.63" data-end="1061.1">And for streams, it's easy, we just make them hot.</span> <span data-start="1061.1" data-end="1067.27">laugh so next we have views and views is a function</span> <span data-start="1067.27" data-end="1075.31">of streams and I hope host of you agree that the views should be dead simple, pure functional</span> <span data-start="1075.31" data-end="1076.49">components.</span> <span data-start="1076.49" data-end="1081.19">It makes them decouple from our business logic and easy to change them later.</span> <span data-start="1081.19" data-end="1089.83">So we have view streams that pipe state streams and prepare them for the view so the views</span> <span data-start="1089.83" data-end="1091.87">can be as simple as possible.</span> <span data-start="1091.87" data-end="1096.2">And we've created a connect utility function.</span> <span data-start="1096.2" data-end="1104.33">Essentially what it does is it subscribes to a stream when the view is mounted and then</span> <span data-start="1104.33" data-end="1111.92">unsubscribes when it's unmounted, so the view would update whenever the view stream updates.</span> <span data-start="1111.92" data-end="1115.29">Next we can also have view streams that fetch data.</span> <span data-start="1115.29" data-end="1120.99">So you could define a view stream as an AJAX call, so you could essentially fetch data</span> <span data-start="1120.99" data-end="1126.85">from the API when the view mounts and map that to props for the view.</span> </p>
<p><span data-start="1126.85" data-end="1131.43">Using another operator, we could also add initial loading props so that the view could</span> <span data-start="1131.43" data-end="1137.29">load something before the API call resolves, and we could also catch errors, so with just</span> <span data-start="1137.29" data-end="1144.12">fivish lines of code and maybe a couple of utility functions we have a view that's coupled</span> <span data-start="1144.12" data-end="1152.05">to an API call without having that API logic in our view.</span> <span data-start="1152.05" data-end="1158.05">So that is essentially our building blocks for building an application with RxJS and</span> <span data-start="1158.05" data-end="1162.93">now I want to reflect a little bit on the higher level pitfalls and benefits of that.</span> <span data-start="1162.93" data-end="1170.17">So one thing is that RxJS is extremely flexible and you need to invest some time in kind of</span> <span data-start="1170.17" data-end="1172.03">dealing with this flexibility.</span> <span data-start="1172.03" data-end="1177.22">Because you can really shoot yourself in the foot when dealing with it.</span> <span data-start="1177.22" data-end="1181.57">Another thing is that you might end up with streams all over the place.</span> <span data-start="1181.57" data-end="1189.8">I heard a podcast with Ben Lesch, the core maintainer of RxJS, and he warns about basically</span> <span data-start="1189.8" data-end="1194.69">creating streams all over the place and that's what many people do, and I like Dan, that's</span> <span data-start="1194.69" data-end="1197.6">the title of my talk.</span> <span data-start="1197.6" data-end="1206.4">However, I think you can circumvent that probably being explicit about your streams.</span> <span data-start="1206.4" data-end="1211.39">So kind of the building blocks I presented, it's not meant to be a framework or a silver</span> <span data-start="1211.39" data-end="1217.37">bullet or everyone it's kind of an architecture that you can build to suit your needs and</span> </p>
<p><span data-start="1217.37" data-end="1220.99">I think RxJS is a great tool for that.</span> <span data-start="1220.99" data-end="1226.71">The next is that debugging can be a bit challenging in RxJS.</span> <span data-start="1226.71" data-end="1233.33">Call stacks are a I will little bit long and hide some important details, however, we have</span> <span data-start="1233.33" data-end="1234.89">tools to also deal with that.</span> <span data-start="1234.89" data-end="1240.94">So you can use RxJS spy to tag your streams and essentially you can replay your streams,</span> <span data-start="1240.94" data-end="1245.79">you can stop them, similar with how you would do with Redux DevTools and the creator is</span> <span data-start="1245.79" data-end="1251.58">also working on a Chrome extension so then we'll have a similar experience and the benefits</span> <span data-start="1251.58" data-end="1256.92">of RxJS and streams is that it is extremely flexible so you can do a lot of things with</span> <span data-start="1256.92" data-end="1263.64">the operators that RxJS provides, and I think also one thing is the kind of the expressiveness</span> <span data-start="1263.64" data-end="1265.26">of reactive programming.</span> </p>
<p><span data-start="1265.26" data-end="1272.7">You can write ten lines of code with a few operators and that defines a fairly complicated</span> <span data-start="1272.7" data-end="1279.35">async logic, and then it's still very easy to reason about.</span> <span data-start="1279.35" data-end="1284.88">And perhaps the most important point is that with streams, there is very little overhead</span> <span data-start="1284.88" data-end="1290.61">to dealing with asynchronous code because once you kind of embrace streams, then everything</span> <span data-start="1290.61" data-end="1296.27">can react to anything at any point in time so you don't really care whether it's async</span> <span data-start="1296.27" data-end="1297.57">or synchronous.</span> <span data-start="1297.57" data-end="1313.66">So I think a think I hear about JavaScript is that we treat asyncnus if you.</span> <span data-start="1313.66" data-end="1319.28">If you find that async code makes things complex in your application, or perhaps if you're</span> <span data-start="1319.28" data-end="1322.88">working on a large single page application and it's difficult to reason about what's</span> <span data-start="1322.88" data-end="1323.88">going on.</span> </p>
<p><span data-start="1323.88" data-end="1325.79">That was the case for us.</span> <span data-start="1325.79" data-end="1330.46">Obviously adding reactive programming to the mix won't solve your problems, but I really</span> <span data-start="1330.46" data-end="1336.76">think it will help you.</span> <span data-start="1336.76" data-end="1341.61">And the next is if you're using Angular or Redux observable.</span> <span data-start="1341.61" data-end="1346.91">So our Angular has a single dependency, and I think that's RxJS, but I think people who</span> <span data-start="1346.91" data-end="1355.26">haven't embraced it: And perhaps also if you use Redux, you should really check out Redux</span> <span data-start="1355.26" data-end="1358.2">observable.</span> </p>
<p><span data-start="1358.2" data-end="1362.96">So I hope this talk was interesting and that you might also start thinking about everything</span> <span data-start="1362.96" data-end="1371.11">as a stream.</span> </p>
</section>