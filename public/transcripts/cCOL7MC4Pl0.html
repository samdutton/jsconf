<section>
<p><span data-start="13.599" data-end="15.599">Hello everyone</span> <span data-start="16.029" data-end="19.019">Why can't the slide show come out?</span> <span data-start="20.859" data-end="23.399">This is my first time in Singapore</span> <span data-start="24.76" data-end="26.76">Feel good</span> <span data-start="29.65" data-end="33">It would be better if you applaud now</span> <span data-start="34.12" data-end="39.54">I came to this meeting as soon as I got off the plane, so I did n’t have time to stroll</span> <span data-start="39.54" data-end="42.959">But I will stay a few more days later, I will look around</span> <span data-start="43.41" data-end="45.41">I brought my partner</span> <span data-start="45.55" data-end="49.349">I must say it was a huge mistake</span> <span data-start="49.75" data-end="53.879">Because she was really looking forward to the trip, especially the first few weeks</span> <span data-start="53.879" data-end="58.858">She ’s been saying that she has two weeks to go to Singapore, one week, five days</span> <span data-start="58.859" data-end="64.889">Could you please stop mentioning it</span> <span data-start="65.56" data-end="71.1">What I thought was that there were only five days to prepare my speech</span> <span data-start="71.1" data-end="77.009">This worst project manager has been mocking me for being poorly prepared</span> <span data-start="77.53" data-end="81.239">But one thing she is very good is that she can tolerate me</span> </p>
<p><span data-start="81.64" data-end="88.259">I am easily anxious. I will worry about it</span> <span data-start="88.96" data-end="90.82">I feel anxious about things that have nothing to do with me</span> <span data-start="90.82" data-end="94.079">Someone posted this on Twitter</span> <span data-start="95.77" data-end="98.79">He held the MacBook with two fingers</span> <span data-start="100.659" data-end="106.019">And it's on the concrete floor, I never fell asleep after watching this photo</span> <span data-start="108.28" data-end="114.96">This code also annoys me because there is no semicolon. Roar if you remember to always add a semicolon</span> <span data-start="116.229" data-end="119.489">Good, the rest are a bunch of monsters</span> <span data-start="120.7" data-end="124.9">But this is not the thing I worry about the most</span> <span data-start="125.98" data-end="132.34">But add something to the DOM and hide it, maybe wait until there is a click event and then show it</span> <span data-start="133.22" data-end="139.32">I would worry if the user would see something flash before the element was hidden</span> <span data-start="140.28" data-end="142.76">And I can't reproduce it so far</span> <span data-start="142.76" data-end="147.95">I have n’t met before, but it ’s hard to say under race conditions</span> <span data-start="148.47" data-end="151.82">So I usually reorder these codes, just to sleep</span> <span data-start="153" data-end="155.69">But in fact there is no race condition here</span> </p>
<p><span data-start="156.36" data-end="158.36">Because the code runs and renders</span> <span data-start="159" data-end="161.57">Their timing is tightly defined</span> <span data-start="162.6" data-end="164.37">And most of the cases are ok</span> <span data-start="164.37" data-end="169.819">This is thanks to the event loop, the next 30 minutes, if I do n’t mess up</span> <span data-start="169.86" data-end="177.17">You will know why the code works like this. I'm not sure if I can make it clear, I don't make a promise</span> <span data-start="177.84" data-end="182.52">There is something in the web page, usually we become the main thread</span> <span data-start="183.78" data-end="185.7">This is the main thread</span> <span data-start="185.7" data-end="193.24">The main thread is called because many things run on it, including JavaScript and rendering, and is where the DOM exists.</span> <span data-start="193.94" data-end="198.76">This means that most things on the webpage have a certain order</span> <span data-start="198.77" data-end="203.119">No code will execute at the same time, such as editing the same DOM at the same time</span> </p>
<p><span data-start="203.79" data-end="206.689">Then leads to terrible race conditions</span> <span data-start="207.27" data-end="213.35">But it also means that if the main thread has code running for a long time</span> <span data-start="213.35" data-end="214.85">200 milliseconds</span> <span data-start="214.85" data-end="216.85">Long time for user interaction</span> <span data-start="216.96" data-end="223.279">In this case, it is perceived because it blocks many other things, such as rendering or user interaction.</span> <span data-start="224.25" data-end="227.96">And I think it ’s hard to imagine this as a human</span> <span data-start="228.72" data-end="230.55">Because human</span> <span data-start="230.55" data-end="233.719">Very good at multi-threaded operation</span> <span data-start="233.72" data-end="238.52">For example, I can stand on one foot while waving</span> <span data-start="238.52" data-end="242.27">I'm talking, breathing, processing sound and visual information</span> </p>
<p><span data-start="243.12" data-end="248.75">Humans don't have a main thread and we are not blocked by irrelevant things</span> <span data-start="249.57" data-end="252.26">Except one thing</span> <span data-start="252.9" data-end="254.9">That is sneezing</span> <span data-start="256.5" data-end="263.989">Because other things stop when you sneeze. Such as not speaking when sneezing</span> <span data-start="264.72" data-end="266.72">Then the face becomes silly X</span> <span data-start="267.23" data-end="271.759">If you were driving, you would hope that no one would die as a result.</span> <span data-start="272.73" data-end="278.329">At least we become single-threaded when we sneeze</span> <span data-start="279.06" data-end="283.339">Loss of hearing, vision or thinking</span> </p>
<p><span data-start="284.19" data-end="288.499">Unless sneezing forces you to do so. You have actually lost control</span> <span data-start="288.96" data-end="291.74">Then the sneeze will end and the body will recover</span> <span data-start="291.84" data-end="297.88">You will know if there are fewer arms and legs</span> <span data-start="297.889" data-end="304.219">Are there missing passengers? Obviously we don't want to write the same code as sneezing</span> <span data-start="305.01" data-end="310.339">So although we have the main thread, we still want to start some other scenes</span> <span data-start="310.62" data-end="312.03">For network or codec</span> <span data-start="312.03" data-end="314.03">Or listen to the input device</span> <span data-start="314.31" data-end="317.419">But once these threads have done something the page cares about</span> <span data-start="317.7" data-end="322.009">They need to transfer information back to the main thread</span> </p>
<p><span data-start="322.41" data-end="324.919">The event loop is actually directing it all</span> <span data-start="325.44" data-end="330.679">For example, setTimeout, isn't this naming good? indeed. Is the order of the parameters wrong?</span> <span data-start="331.26" data-end="335.089">I think so. But have you ever wondered how it works</span> <span data-start="336" data-end="340.549">Okay, let's write a web standard for him, I'll do it these days</span> <span data-start="341.37" data-end="348.289">We start with setTimeout. When it is called, we need to perform these steps: wait for x ms and execute the callback.</span> <span data-start="349.68" data-end="351.68">But this doesn't work</span> <span data-start="352.32" data-end="358.549">Because it means that it will execute on the same thread as the method that called it</span> <span data-start="358.65" data-end="362.359">This is also JavaScript, so it will be executed in the main thread</span> <span data-start="363.24" data-end="369.59">For example, waiting for 5000ms, we wait on the main thread, which will block many other things</span> </p>
<p><span data-start="370.169" data-end="372.139">So this specification is not working yet</span> <span data-start="372.139" data-end="377.689">So change it. This way we perform these steps in parallel</span> <span data-start="378.45" data-end="383.509">That is to detach from the main thread and run at the same time as other things</span> <span data-start="384.75" data-end="391.279">This has new problems, because we are now executing callbacks from a non-main thread</span> <span data-start="392.31" data-end="394.339">Does not work at all</span> <span data-start="394.34" data-end="398.209">Finally, there may be a lot of JS code editing the same DOM at the same time</span> <span data-start="398.21" data-end="400.19">There will be many race conditions</span> <span data-start="400.19" data-end="405.559">So we put the task in the queue and then return to the main thread for execution</span> <span data-start="405.96" data-end="410.359">Now we are calling JS in the JS thread</span> <span data-start="410.61" data-end="412.819">This is how the browser works at its core</span> <span data-start="412.819" data-end="418.878">If you click the mouse, how is it handed over from the operating system to JS? It submits tasks in the queue</span> <span data-start="419.009" data-end="422.209">If it is a fetch request, how does it hand the response to JS?</span> <span data-start="422.46" data-end="428.12">It is still submitting a task. You send a message to the worker from the page and still submit a task</span> <span data-start="428.819" data-end="434.569">So regarding the event loop, I want to talk about the task queue first.</span> <span data-start="436.379" data-end="443.479">I find visual animation easier to understand than the specification</span> </p>
<p><span data-start="444.9" data-end="449.269">This is it, I hope I have made the problem clear</span> <span data-start="450.18" data-end="454.789">I really hope the question is clear, because my whole speech is based on this diagram</span> <span data-start="454.919" data-end="459.978">If there is nothing to do, the event loop will always idle in a CPU economical way,</span> <span data-start="460.169" data-end="463.698">This animation runs at 100% of real time</span> <span data-start="463.699" data-end="468.079">It ’s still too fast. To see clearly, let ’s slow down a bit.</span> <span data-start="469.169" data-end="475.008">After we submitted a task, the event loop went around in a circle. This is where the mission takes place</span> <span data-start="476.339" data-end="478.999">Here the browser says about the event loop</span> <span data-start="479.4" data-end="482.449">There is something for you</span> <span data-start="482.759" data-end="487.639">The event loop is great. Then add it to the to-do list. Will deal with it later</span> <span data-start="489.15" data-end="492.349">What if we submit two callbacks with setTimeout</span> <span data-start="492.839" data-end="499.279">We want to run in 1 second. According to the specification, we made clear that the two algorithms will be parallel</span> <span data-start="499.279" data-end="502.549">1000ms each wait</span> <span data-start="502.55" data-end="506.719">Then add tasks to the queue and return to the main thread</span> <span data-start="507.27" data-end="512.87">The browser said to the event loop, I have something here</span> <span data-start="512.87" data-end="520.279">But actually there are two things please, so each thing is added to the queue as a todo item.</span> <span data-start="520.279" data-end="525.439">The event loop indicates no problem, so it runs the first callback first</span> </p>
<p><span data-start="525.959" data-end="527.959">Then run the second</span> <span data-start="528.66" data-end="530.66">This is the task</span> <span data-start="531.05" data-end="533.56">If that's all simple</span> <span data-start="534.41" data-end="539.98">It becomes complicated if you add rendering.</span> </p>
<p><span data-start="539.98" data-end="541.98">The browser will use the rendering to update the screen content</span> <span data-start="543.02" data-end="549.36">The rendering step takes another circle, which contains style calculations. Which is to view all CSS</span> <span data-start="549.36" data-end="551.88">Calculate styles applied to all elements</span> <span data-start="553.46" data-end="557.74">It generates a render tree</span> <span data-start="558.62" data-end="560.62">Will calculate the position of the element</span> <span data-start="560.69" data-end="564.549">Then generate corresponding pixels</span> <span data-start="565.1" data-end="569.08">So at some point, the browser will tell the event loop</span> <span data-start="569.1" data-end="574.06">Need to update screen content. The event loop says I'll do it the next time I go to the event loop</span> <span data-start="575.2" data-end="577.98">I don't understand you but i</span> <span data-start="578.66" data-end="581.74">I consider myself an expert at writing bad code</span> <span data-start="581.74" data-end="586.479">I can make an endless loop with just a bit of code</span> <span data-start="586.48" data-end="591.25">Let's see what happens if that is the case</span> <span data-start="591.83" data-end="597.069">This page has a gif and text, a big button that runs an endless loop</span> <span data-start="597.68" data-end="599.68">If i click</span> <span data-start="599.69" data-end="605.679">Everything stopped, there was no way to select the text, and the entire tab was dead</span> </p>
<p><span data-start="606.47" data-end="610">The code is simple</span> <span data-start="612.44" data-end="616.15">How to visualize this process? After the user clicks the button</span> <span data-start="616.25" data-end="620.14">The browser tells the event loop that I have a task for you. Event loop says no problem, let me do it</span> <span data-start="620.81" data-end="624.549">But this task can never be completed</span> <span data-start="625.339" data-end="626.93">Always running JS</span> <span data-start="626.93" data-end="629.62">After a few milliseconds, the browser tells the event loop</span> <span data-start="629.99" data-end="633.64">We are going to update the gif</span> <span data-start="634.25" data-end="639.25">Remember to render the next time you are convenient. The event loop says: Uh ..</span> <span data-start="639.25" data-end="645.099">I'll talk about things when I'm busy</span> <span data-start="646.16" data-end="649.87">Then the user wants to select some text, it will contain click test</span> <span data-start="650" data-end="653.65">Look at the DOM and more. So the browser will say</span> <span data-start="653.65" data-end="654.7">I still have some to-do things for you</span> </p>
<p><span data-start="655.66" data-end="661.06">The event loop will say, do you know how long it takes to execute an infinite loop</span> <span data-start="662.12" data-end="664.989">Takes a long time as the name suggests</span> <span data-start="665.689" data-end="671.229">This is why the while loop blocks rendering and other interactions, but it is a good thing</span> <span data-start="671.23" data-end="676.3">Let's take a look at the previous concerns. I worry that something will pass by.</span> <span data-start="676.3" data-end="676.85">But it doesn't actually happen</span> <span data-start="676.85" data-end="679.659">Because this code is part of a task</span> <span data-start="679.73" data-end="683.889">So it must be fully executed before rendering</span> <span data-start="684.46" data-end="688.68">The event loop will ensure that the task is completed before rendering</span> <span data-start="689.42" data-end="692.88">However, I still have pressure, and I will still interact with each other when I see such code.</span> <span data-start="693.86" data-end="696.76">Well, while loops block rendering, what about this?</span> <span data-start="697.36" data-end="703.68">This is a loop, but every time we insert tasks into the queue through setTimeout</span> <span data-start="704.32" data-end="708.3">Let's see what happens</span> </p>
<p><span data-start="709.78" data-end="715.32">I clicked the button, as if the page was still working, as if nothing had changed, but behind the scenes, these things happened</span> <span data-start="716.269" data-end="717.829">Add tasks to the queue</span> <span data-start="717.829" data-end="719.269">Check the event loop</span> <span data-start="719.269" data-end="725.558">Extract the task, then submit another task, and repeat it forever</span> <span data-start="725.959" data-end="727.959">But we have seen before</span> </p>
<p><span data-start="728.18" data-end="730.599">Can only perform one task at a time</span> <span data-start="730.67" data-end="735.219">So when one task is completed, you must make a full circle to execute the next one.</span> <span data-start="736.639" data-end="743.019">So the browser can update the gif display at some point</span> <span data-start="743.019" data-end="747.878">This is why the setTimeout loop does not block rendering</span> <span data-start="749.389" data-end="753.128">But if the code you want to execute is related to rendering</span> <span data-start="753.74" data-end="759.399">Then it ’s not suitable for tasks, as far as the event loop is concerned</span> <span data-start="759.399" data-end="761.059">Task execution and rendering are not on the same side</span> <span data-start="761.059" data-end="765.939">We want to execute the code in the rendering step</span> <span data-start="766.819" data-end="770.558">The browser provides us with the requestAnimationFrame function to implement</span> <span data-start="771.41" data-end="775.269">I think this function name sucks too</span> <span data-start="778.459" data-end="783.998">RAF callbacks are executed as part of the rendering step and I will explain the benefits of doing so</span> <span data-start="783.999" data-end="785.999">I will make a box animation</span> <span data-start="786.529" data-end="791.888">I want to move the box one pixel at a time by using requestAnimationFrame</span> <span data-start="793.1" data-end="795.409">To create a loop</span> </p>
<p><span data-start="796.829" data-end="802.159">That's it if we replace requestAnimationFrame with setTimeout?</span> <span data-start="807.329" data-end="809.009">Looks like this</span> <span data-start="809.009" data-end="811.639">The box is moving faster now</span> <span data-start="811.639" data-end="817.878">About 3.5 times, which means that callbacks are executed more frequently. This is definitely not good</span> <span data-start="817.879" data-end="819.879">By no means good</span> <span data-start="820.35" data-end="824.24">Earlier we saw that rendering can be inserted between tasks and executed</span> <span data-start="824.85" data-end="830.779">But what can happen does not necessarily mean it will happen. We extract a task</span> <span data-start="830.779" data-end="834.828">Can it be rendered now, no? Can we make another round? Can we render now?</span> <span data-start="835.499" data-end="839.149">Still can't do many tasks can keep coming in</span> <span data-start="839.879" data-end="841.49">Until the browser can finally say</span> <span data-start="841.49" data-end="844.849">Next time I want to update the display</span> <span data-start="845.22" data-end="848.66">The browser can decide when to render, and its goal is to be as efficient as possible</span> <span data-start="848.91" data-end="854.059">Only render when necessary, if there is no interface change, it will not render</span> </p>
<p><span data-start="855.689" data-end="861.079">For example, when the tab is blocked and invisible, it will not be rendered because it is meaningless.</span> <span data-start="861.99" data-end="865.639">And most screens have a fixed refresh rate</span> <span data-start="865.639" data-end="867.799">Almost 60 refreshes per second</span> <span data-start="867.8" data-end="869.49">Fast or slow</span> <span data-start="869.49" data-end="874.459">But 60 Hz is the most common. If we change the style a thousand times a second</span> <span data-start="874.459" data-end="877.068">Will not render a thousand times per second</span> <span data-start="877.379" data-end="882.199">It will match the display refresh frequency and display performance.</span> <span data-start="882.689" data-end="889.339">Usually 60 times per second, faster rendering is meaningless and invisible to the user</span> <span data-start="890.189" data-end="892.189">But that's what setTimeout does</span> </p>
<p><span data-start="892.649" data-end="899.058">It moves faster because some movements are invisible to the user</span> <span data-start="899.639" data-end="901.639">Beyond display capabilities</span> <span data-start="902.99" data-end="904.99">Currently we have been using setTimeout as a shortcut to submit tasks</span> <span data-start="905.22" data-end="910.73">It's actually not convenient. Although we set the delay time to 0</span> <span data-start="910.73" data-end="912.439">Browsers usually use 4.7 as the default</span> <span data-start="912.439" data-end="916.729">By convention, browsers can use any value as the default</span> <span data-start="917.399" data-end="920.178">But we actually measured it is almost 4.7</span> <span data-start="921.029" data-end="923.448">There is no one special way to submit a task</span> <span data-start="923.459" data-end="929.448">We can use message channel to simulate me to test</span> <span data-start="930.479" data-end="935.749">If you can't stand the picture flashing all the time, I suggest you don't</span> </p>
<p><span data-start="936.569" data-end="942.168">At the same time, there are many tasks being performed. It seems that the position of the box is random.</span> <span data-start="942.239" data-end="945.709">Tasks come in every 200 milliseconds</span> <span data-start="946.229" data-end="953.629">Although rendering can occur between tasks, this interval can run thousands of tasks</span> <span data-start="954.809" data-end="956.809">Okay, finally stopped flashing</span> <span data-start="957.119" data-end="962.839">We imagine these to be presented to the user as frames</span> <span data-start="962.839" data-end="968.808">So rendering takes place at the beginning of each frame, including style calculations, layout and drawing</span> <span data-start="968.969" data-end="972.079">Not all of them are included every time, it depends on what needs to be updated</span> <span data-start="972.079" data-end="977.058">I like it very clean and tidy</span> <span data-start="978.18" data-end="979.859">And task</span> </p>
<p><span data-start="979.86" data-end="986.54">No bird at all these random event loops will guarantee</span> <span data-start="987.06" data-end="989.749">Execute in order of submission</span> <span data-start="989.749" data-end="994.788">But in a certain frame, there is no similar sequence.</span> <span data-start="996.329" data-end="998.329">We have seen this before in setTimeout</span> <span data-start="998.789" data-end="1002.559">We got three to four tasks per frame</span> <span data-start="1002.899" data-end="1009.069">From a rendering perspective, three quarters of the effort is wasted. Some old animation libraries</span> <span data-start="1009.829" data-end="1013.868">Like to use milliseconds to simulate the callback execution frequency of about 60 times per second</span> <span data-start="1016.219" data-end="1018.159">They make a lot of assumptions about the screen</span> <span data-start="1018.159" data-end="1024.008">Assume a refresh rate of 60 Hz. Generally okay, and it does eliminate some duplication of effort</span> <span data-start="1025.429" data-end="1028.898">Unfortunately this is a serious hack, because setTimeout is not used for animation</span> <span data-start="1028.899" data-end="1032.138">Due to its inaccuracy, it will cause drift phenomenon</span> <span data-start="1032.149" data-end="1036.039">Causes nothing in one frame, but the next frame</span> </p>
<p><span data-start="1036.039" data-end="1041.109">But doing twice as much, the visual effect is poor for the user</span> <span data-start="1041.869" data-end="1048.039">In addition, if the task execution time is long, it is possible that the rendering steps will be shifted because they are all on one thread</span> <span data-start="1048.039" data-end="1050.919">This lovely rhythm was disrupted originally</span> <span data-start="1051.889" data-end="1053.889">If using requestAnimationFrame</span> <span data-start="1054.019" data-end="1057.368">Looks like this</span> <span data-start="1057.369" data-end="1061.869">Everything is clean and organized</span> <span data-start="1062.57" data-end="1064.57">Even this long mission</span> <span data-start="1064.7" data-end="1070.99">The performance trajectory I observed also pleased me</span> <span data-start="1072.519" data-end="1074.519">Of course, we cannot completely avoid the task</span> <span data-start="1074.69" data-end="1080.169">Such as click events, they will be submitted as tasks, and they need to respond as soon as possible</span> <span data-start="1080.169" data-end="1084.489">If you have something like timer or something from the network</span> <span data-start="1084.73" data-end="1086.72">I really recommend using requestAnimationFrame</span> <span data-start="1086.72" data-end="1092.079">To process tasks in batches, especially when you already have animations running, because it can save a lot of repetitive work</span> <span data-start="1092.09" data-end="1097.299">I treat tasks like people who drink sparkling water</span> </p>
<p><span data-start="1097.82" data-end="1099.82">I know their existence</span> <span data-start="1100.19" data-end="1104.83">But I try to minimize contact because I don't trust them</span> <span data-start="1104.83" data-end="1111.669">I think I have empathy, but I think that soda is disgusting</span> <span data-start="1112.309" data-end="1117.819">I never thought anyone would drink sparkling water</span> <span data-start="1128.179" data-end="1132.038">I have a list on Twitter full of people drinking sparkling water</span> <span data-start="1134.72" data-end="1140.199">Not weird behavior, I just need to know what they are doing</span> <span data-start="1183.98" data-end="1186.789">Just said, right, requestAnimationFrame</span> <span data-start="1187.669" data-end="1192.819">One more detail I want to mention</span> <span data-start="1193.55" data-end="1198.609">requestAnimationFrame is executed before processing CSS and drawing</span> <span data-start="1199.55" data-end="1206.109">So code like this looks expensive, but it's not</span> <span data-start="1206.69" data-end="1209.619">Because before rendering, JS will always be executed from beginning to end</span> <span data-start="1209.62" data-end="1214.78">So when you do this, the browser sits still and lets you play for yourself</span> <span data-start="1214.88" data-end="1219.34">CSS is not considered at all</span> <span data-start="1219.86" data-end="1223.09">Until the last render</span> </p>
<p><span data-start="1223.52" data-end="1227.499">It just looks at what changed in the end? Only this last line is useful</span> <span data-start="1229.31" data-end="1232.33">This also explains some of the issues that have bothered me before</span> <span data-start="1232.33" data-end="1237.309">I have an object and I want to make an animation</span> <span data-start="1238.04" data-end="1240.04">Location from 100</span> <span data-start="1240.41" data-end="1241.85">Up to 500</span> <span data-start="1241.85" data-end="1248.05">It's simple. So I have a listner, X is set to 1000</span> <span data-start="1248.05" data-end="1252.099">Then tell it to fade to 500</span> <span data-start="1253.49" data-end="1259.06">But the animation is from 0 to 500</span> <span data-start="1260.42" data-end="1262">Browser, this is not what I told you</span> <span data-start="1262" data-end="1268.81">I made it clear that the transition from 1000 to 500, I was wondering if it should be</span> <span data-start="1269.21" data-end="1271.21">Set all values ​​at once</span> <span data-start="1271.28" data-end="1277.57">I guess the reason is the same as before, the browser only considers the style at the end</span> <span data-start="1278.12" data-end="1280.57">It ignores the first deformation value</span> <span data-start="1281.18" data-end="1287.409">I want to put the second part in requestAnimationFrame</span> <span data-start="1288.32" data-end="1292.84">It ’s still from 0 to 500. What happened?</span> </p>
<p><span data-start="1293.51" data-end="1297.969">Let me tell you what happened. User clicks on button</span> <span data-start="1298.52" data-end="1305.41">A task is formed, so we come here, we set the initial value of the deformation here</span> <span data-start="1305.93" data-end="1313.93">We add an animation frame to the queue, and then make a circle, we set the target value here</span> <span data-start="1314.72" data-end="1318.97">But browsers didn't consider CSS until this point, just this purple part</span> <span data-start="1318.97" data-end="1322.33">Only here is CSS calculated</span> <span data-start="1322.58" data-end="1328.179">It completely ignores the initial value because the browser doesn't care about the style during the style change</span> <span data-start="1329.3" data-end="1330.88">Here's how to fix</span> <span data-start="1330.88" data-end="1336.64">You need to use two animation frames, now it will change from 1000 to 500</span> <span data-start="1338.33" data-end="1343.99">Here is a hack, you can use getComputedStyle and read one of the properties</span> <span data-start="1343.99" data-end="1348.49">It forces the browser to do style calculations a lot in advance</span> <span data-start="1349.28" data-end="1353.859">It will notice all values ​​set before this point</span> <span data-start="1354.8" data-end="1358.029">x-axis from 500 to 1000</span> </p>
<p><span data-start="1358.97" data-end="1363.79">But be careful this way, because you might make your browser do a lot of things you do n’t want to do.</span> <span data-start="1363.86" data-end="1366.67">It originally wanted to do it only once in a frame</span> <span data-start="1367.79" data-end="1370.209">In reality, the best way is</span> <span data-start="1370.4" data-end="1375.969">Use the animation API because you can specify animation parameters directly</span> <span data-start="1375.97" data-end="1381.67">But currently only Chrome supports it, so it's too early to talk about it</span> <span data-start="1386.81" data-end="1392.229">If requestAnimationFrame is new to you</span> <span data-start="1392.93" data-end="1398.229">That ’s not to blame you, maybe you are misled by some specific implementation</span> <span data-start="1398.23" data-end="1400.719">Edge and Safari are wrong, they put requestAnimationFrame here</span> <span data-start="1401.45" data-end="1403.45">The most obvious is that they are placed after drawing</span> <span data-start="1404.21" data-end="1409.84">This is annoying. Because it means that if the user clicked here</span> <span data-start="1409.84" data-end="1411.84">You want batch processing, so use requestAnimationFrame</span> <span data-start="1412.04" data-end="1417.55">Edge and Safari will render before calling your callback</span> <span data-start="1418.34" data-end="1424">So the user may not see the change until the next frame</span> <span data-start="1424.1" data-end="1426.579">This adds a lot of delay to what's on the screen</span> </p>
<p><span data-start="1427.1" data-end="1431.5">It ’s also difficult to batch jobs, I hope they fix it soon</span> <span data-start="1431.54" data-end="1436.869">This is what the web standard says, and Chrome and firefox have already done so</span> <span data-start="1439.67" data-end="1443.56">That's it for requestAnimationFrame, and I want to talk about microtasks</span> <span data-start="1444.23" data-end="1447.13">I dare say this should be the least known in the event loop</span> <span data-start="1448.28" data-end="1450.08">I will associate micro tasks with promises</span> <span data-start="1450.08" data-end="1457.96">This was not the case in the 1990s, when browsers wanted to provide developers with an interface to monitor DOM changes</span> <span data-start="1458.51" data-end="1464.979">w3c agreed and gave us some mutation events</span> <span data-start="1464.98" data-end="1469.839">When a node joins the body, I hope there is a way to know</span> </p>
<p><span data-start="1469.84" data-end="1471.84">Okay, so there is another series of events</span> <span data-start="1473.06" data-end="1478.749">There are many problems in reality. Looking at this code, I added 100 spans to the body</span> <span data-start="1481.34" data-end="1488.199">How many events do you think you will receive in this case? One?</span> <span data-start="1489.14" data-end="1490.91">wrong</span> <span data-start="1490.91" data-end="1493.599">100? One event per span, right</span> <span data-start="1494.12" data-end="1496.07">I will receive another 100</span> <span data-start="1496.07" data-end="1497.75">Because of this sentence</span> <span data-start="1497.75" data-end="1504.04">When the text is placed in the span, these events are passed up</span> <span data-start="1504.04" data-end="1506.04">This sentence will give you 200 events</span> <span data-start="1506.84" data-end="1509.829">Because of this simple DOM modification</span> <span data-start="1510.02" data-end="1516.009">Thousands of events are triggered. If you have very little logic in the callback</span> <span data-start="1516.08" data-end="1518.56">Will quickly become a burden. This will be a disaster in performance.</span> </p>
<p><span data-start="1519.11" data-end="1522.49">What we want is to listen to these jobs in batches</span> <span data-start="1522.49" data-end="1525.819">It's kind of like the browser behavior mentioned earlier, just sit back and watch</span> <span data-start="1526.13" data-end="1529.81">Then tell us together when convenient</span> <span data-start="1530.24" data-end="1535.12">Something to represent all changes</span> <span data-start="1536.24" data-end="1542.53">I only want to receive one notification instead of 200, so they create a new queue called a micro task</span> <span data-start="1543.32" data-end="1550.63">I have read a lot of documents about microtasks, and they all say that every event loop will process microtasks</span> </p>
<p><span data-start="1550.91" data-end="1555.16">After the task is processed, it is a micro task or something. It sounds like it is right.</span> <span data-start="1555.77" data-end="1560.77">In the event loop, there is only one place where microtasks can occur, but not where you usually encounter</span> <span data-start="1561.44" data-end="1566.5">And it happens every time JS execution is completed</span> <span data-start="1566.5" data-end="1572.319">When the execution stack is cleared</span> <span data-start="1572.69" data-end="1574.22">The micro task will run</span> <span data-start="1574.22" data-end="1576.37">So halfway through the mission</span> <span data-start="1576.71" data-end="1582.55">It is also possible to run microtasks, and it is also possible to run microtasks during rendering</span> </p>
<p><span data-start="1582.55" data-end="1584.55">Basically where you can run JS</span> <span data-start="1585.44" data-end="1587.44">So this means that JS will execute until completion</span> <span data-start="1587.9" data-end="1593.53">Add 100 spans, and we receive a callback after completion</span> <span data-start="1594.77" data-end="1600.579">Promise also takes advantage of this. We submit a microtask here and print yo</span> <span data-start="1601.429" data-end="1603.429">Then the execution is completed and a log is printed</span> </p>
<p><span data-start="1603.5" data-end="1605.829">We used micro-tasks, print hey</span> <span data-start="1606.62" data-end="1611.919">So this means that when the promise callback is executed, the browser will guarantee that no other JS will execute only halfway.</span> <span data-start="1612.14" data-end="1617.559">Promise callbacks will be at the bottom of the stack. This is why Promises use microtasks.</span> <span data-start="1618.71" data-end="1622.63">What if we write a loop with microtasks</span> <span data-start="1624.26" data-end="1626.26">The same demo as before</span> <span data-start="1628.34" data-end="1633.819">Click the button to block rendering and block tabs, just like before</span> <span data-start="1636.799" data-end="1643.509">Promise callbacks are asynchronous, yes. But what does asynchronous mean? It means</span> <span data-start="1644.33" data-end="1648.819">They will be executed after the synchronization code, all printed before Hey</span> <span data-start="1649.46" data-end="1655.36">But asynchronous doesn't mean that it will make way for rendering or any other event loop.</span> <span data-start="1656.69" data-end="1660.13">So far we have looked at three different queues</span> </p>
<p><span data-start="1660.83" data-end="1665.949">Task queue, animation callback queue, and micro task queue</span> <span data-start="1666.32" data-end="1668.32">Just to make your life less bitter</span> <span data-start="1668.929" data-end="1671.739">They handle it slightly differently</span> <span data-start="1671.96" data-end="1677.29">For example, the task queue only processes one at a time</span> <span data-start="1677.29" data-end="1679.29">If another event comes in, put it at the end of the line</span> <span data-start="1680.419" data-end="1683.649">The animation callback will be executed at once</span> <span data-start="1684.74" data-end="1690.309">Unless a new one is submitted in the process. They will be delayed until the next frame</span> <span data-start="1691.13" data-end="1693.969">The micro task will be executed to completion</span> </p>
<p><span data-start="1694.7" data-end="1695.57">Including inserted</span> <span data-start="1695.57" data-end="1702.16">So if your submission is as fast as processing, you will always be processing microtasks</span> <span data-start="1702.74" data-end="1708.819">If the queue is not empty, the event loop is blocked, which is why rendering is blocked</span> <span data-start="1709.58" data-end="1714.22">Sorry, I ’m excited when I talk about this, I hope you are the same</span> <span data-start="1715.19" data-end="1718.03">Thank you for being alone</span> <span data-start="1719.12" data-end="1722.53">I used to have a job</span> <span data-start="1723.559" data-end="1728.629">These are just my hobbies</span> <span data-start="1729.33" data-end="1733.279">Later, my hobby became a job, so I stopped.</span> <span data-start="1733.68" data-end="1739.07">I became bored</span> <span data-start="1797.61" data-end="1803.42">I do quizzes from time to time</span> <span data-start="1803.42" data-end="1809.599">This is one of my favorite questions. There is a button, an onclick event, and a promise is resolved</span> <span data-start="1810.15" data-end="1812.15">Then print some logs</span> </p>
<p><span data-start="1812.31" data-end="1816.889">But I have two event listeners on one element</span> <span data-start="1817.89" data-end="1819.89">If the user clicks the button</span> <span data-start="1820.23" data-end="1823.099">What happens and what is the order of log output</span> <span data-start="1827.34" data-end="1829.04">First the first listener is executed</span> <span data-start="1829.04" data-end="1830.58">Ok, it will enter the JS stack</span> <span data-start="1830.58" data-end="1835.369">Raise a micro task to the queue, reach the next line, print Listener1, this is the first answer</span> <span data-start="1836.79" data-end="1841.67">Most people agree with this, but what happens next, I started a poll on Twiter</span> <span data-start="1841.67" data-end="1843.67">I also talked to some people</span> <span data-start="1843.87" data-end="1850.94">Most people say that the next log should be Listener 2. 63% of people choose this</span> <span data-start="1851.31" data-end="1856.399">But this is not the correct answer.</span> </p>
<p><span data-start="1859.62" data-end="1866.969">Do n’t worry if you choose Listener2, many people are like you</span> <span data-start="1867.97" data-end="1873.659">The listener has finished executing, so the stack is cleared</span> <span data-start="1874.299" data-end="1876.389">So it's the micro task</span> <span data-start="1876.52" data-end="1881.159">This will run the promise and print Micortask 1</span> <span data-start="1881.74" data-end="1887.4">Then it ’s the second listener, so the order is Listener 1 Microtask 1 Listen 2 Microtask2</span> <span data-start="1888.97" data-end="1896.13">This is the case when the user clicks the button. What if we click the button by code? The situation is different</span> <span data-start="1897.549" data-end="1902.908">First our script will be on the stack and click</span> </p>
<p><span data-start="1903.669" data-end="1906.778">It dispatches events synchronously, so it starts executing the first listener</span> <span data-start="1907.299" data-end="1911.519">Submit the microtask, print listener 1, is the next step to execute the microtask? no</span> <span data-start="1911.52" data-end="1914.459">Can't complete a micro task</span> <span data-start="1914.46" data-end="1919.5">This is the difference. At this time, the stack has not been cleared, and the button's click method has not been executed</span> <span data-start="1920.38" data-end="1927.029">So execute Listener 2 and submit another microtask, now print Listener2</span> </p>
<p><span data-start="1928.12" data-end="1931.049">The listener has finished executing</span> <span data-start="1931.12" data-end="1935.819">The button click event is completed, the stack is cleared, and micro tasks can now be performed</span> <span data-start="1935.82" data-end="1941.07">They are executed in order, pay attention to this in actual coding</span> <span data-start="1941.98" data-end="1946.289">Pay attention when writing automation</span> <span data-start="1947.289" data-end="1949.349">Because automation may use code to perform clicks</span> </p>
</section>