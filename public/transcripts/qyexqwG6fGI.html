<section>
<p><span data-start="18.93" data-end="25.31">Hello everybody, my name is Iliyan, I am working as a software engineer for an L.A. based company</span> <span data-start="25.31" data-end="33.36">called Liferay, and today, I will talk about HTTP 2.0 and QUIC protocols (of the very new</span> <span data-start="33.36" data-end="41.42">future), which will replace the protocol which is currently used by Worldwide Web — HTTP</span> <span data-start="41.42" data-end="43.26">1.1.</span> <span data-start="43.26" data-end="49.73">So, first is that question — why do we need a the new version of HTTP protocol?</span> <span data-start="49.73" data-end="52.329">What is wrong with the [current version of the] protocol?</span> <span data-start="52.329" data-end="57.73">After all it's used by worldwide web since 1990, right?</span> <span data-start="57.73" data-end="65.899">It works pretty well, it's very simple, actually browser sends request the server, server responds</span> <span data-start="65.899" data-end="67.33">and this is it.</span> <span data-start="67.33" data-end="74.5">Very simple, but if you check this chart which is just for four years, you'll see that there</span> <span data-start="74.5" data-end="80.49">is not only one request, and one response, but there are actually multiple requests and</span> <span data-start="80.49" data-end="87.17">responses — about 80‑90 for the top 100 sites according to HTTP Archive.</span> </p>
<p><span data-start="87.17" data-end="92.4">So, this comes to tell us that the Web has changed drastically, it's a web platform,</span> <span data-start="92.4" data-end="99.2">it's no more platform for reading different cross‑linked documents.</span> <span data-start="99.2" data-end="107.46">And because of that, we have to admit that HTTP 1.1 has issues.</span> <span data-start="107.46" data-end="114.85">Those issues are so big that unfortunately we need a new version of the protocol and</span> <span data-start="114.85" data-end="119.75">those issues are so many that I will mention only three of them.</span> <span data-start="119.75" data-end="123.159">The first one is that it's very latency sensitive.</span> <span data-start="123.159" data-end="131.06">Right, imagine we have a server in L.A. and our client is right here in Berlin, all those</span> <span data-start="131.06" data-end="135.59">requests should go from Berlin to L.A. and then get back.</span> <span data-start="135.59" data-end="144">This is very expensive, and, latency and protocol is very latency sensitive, right.</span> <span data-start="144" data-end="146.45">Apart from that, the specification is huge.</span> <span data-start="146.45" data-end="151.68">The original specification has been replaced by ability ten different RFCs for message</span> <span data-start="151.68" data-end="156.75">syntax for semantics and content and so on.</span> <span data-start="156.75" data-end="163.44">There are optional parts, like HTTP pipelining, which are sometimes implemented, sometimes</span> <span data-start="163.44" data-end="166.489">they are not.</span> </p>
<p><span data-start="166.489" data-end="173.59">And more — like buggy proxy servers, so this is the key — latency kills and bandwidth is</span> <span data-start="173.59" data-end="179.94">not everything, if you check this chart from, I guess, most of you are very well aware of</span> <span data-start="179.94" data-end="186.59">it already, from some point how fast is your network is your Internet at home for daily</span> <span data-start="186.59" data-end="191.62">browsing it doesn't matter, if you have about five megabits, it's pretty much enough.</span> <span data-start="191.62" data-end="198.59">I'm not talking about streaming or downloading huge video files, but for daily browsing.</span> <span data-start="198.59" data-end="203.12">What matters is the round trip time.</span> <span data-start="203.12" data-end="210.16">For every 20 milliseconds, as you see, the page loading time increases.</span> </p>
<p><span data-start="210.16" data-end="217.05">So, we are stuck by latency, so what could be the solution?</span> <span data-start="217.05" data-end="222.799">It's obvious that sending one request and returning responses is not enough, so what</span> <span data-start="222.799" data-end="224.67">could be the solution?</span> <span data-start="224.67" data-end="228.28">One possible solution could be HTTP pipelining, right?</span> <span data-start="228.28" data-end="233.65">Since that's exactly it's purpose, instead to send one request to the server and waiting</span> <span data-start="233.65" data-end="240.519">for the response, browser sends three or more requests and waiting for three or more responses.</span> </p>
<p><span data-start="240.519" data-end="249.73">Sounds very good in theory, but unfortunately, it's not like this, that's not the solution.</span> <span data-start="249.73" data-end="251.859">So why not?</span> <span data-start="251.859" data-end="257.699">It's not because by the specification the server must sends it's responses in the same</span> <span data-start="257.699" data-end="261.8">order that requests were received.</span> <span data-start="261.8" data-end="262.8">So this is it.</span> <span data-start="262.8" data-end="268.68">In fact, the entire connection remains first in and first out, and head of line blocking</span> <span data-start="268.68" data-end="270.729">can occur.</span> </p>
<p><span data-start="270.729" data-end="272.12">What exactly this means?</span> <span data-start="272.12" data-end="278.56">Imagine we have three questions and the first of them requires some heavy database request</span> <span data-start="278.56" data-end="279.56">on the server, right.</span> <span data-start="279.56" data-end="288.36">The rest, the rest of those could be just one JavaScript and one CSS file and they will</span> <span data-start="288.36" data-end="289.36">be blocked.</span> <span data-start="289.36" data-end="297.24">There are more buggy proxy servers which are not properly implementing HTTP pipelining.</span> <span data-start="297.24" data-end="306.46">And as a result, in most browsers, HTTP pipelining is disabled or not implemented at all.</span> <span data-start="306.46" data-end="310.3">So keeping that in mind, what could be\h‑‑ what could browsers do?</span> <span data-start="310.3" data-end="314.669">What can they do in order to improve the performance?</span> <span data-start="314.669" data-end="321.46">There is no other way except to achieve multiplexing by opening multiple connections to the servers</span> <span data-start="321.46" data-end="324.9">and that's exactly what they do.</span> </p>
<p><span data-start="324.9" data-end="326.939">So this is the one side of the question.</span> <span data-start="326.939" data-end="335.12">The second side or the next side is that developers, as very creative people, they implemented</span> <span data-start="335.12" data-end="339.21">a lot of workarounds, so‑called optimizations.</span> <span data-start="339.21" data-end="344.419">Most of you will be very well aware of them, they are creating images sprites, sharding,</span> <span data-start="344.419" data-end="352.719">resolution sharding, resource inlining, concatenating file, combo services, preloading service when</span> <span data-start="352.719" data-end="359.21">the user is idle, reducing cookie size or even using cookie‑free domains exactly for</span> <span data-start="359.21" data-end="364.969">that purpose, using link instead @import, to pack components into multipart documents</span> <span data-start="364.969" data-end="366.06">and so on.</span> <span data-start="366.06" data-end="373.69">In fact, a whole industry has been created to deal with those issues, sites have been</span> <span data-start="373.69" data-end="380.939">created, performance groups in the big companies like Google and Yahoo have been created, but</span> <span data-start="380.939" data-end="388.83">if you're a regular developer, and as soon as you read all those guidelines, you start</span> <span data-start="388.83" data-end="392.199">looking like this ..</span> <span data-start="392.199" data-end="393.419">Why should I do all that?</span> <span data-start="393.419" data-end="395.44">Why is that needed?</span> <span data-start="395.44" data-end="405.09">And, if you also got tired of all that, then, say welcome to HTTP 2.0 and QUIC protocols.</span> </p>
<p><span data-start="405.09" data-end="412.96">HTTP 2.0 which will replace 1.1 is currently on draft 14.</span> <span data-start="412.96" data-end="418.939">It's being actively developed and not yet finalized, it will be probably this year or</span> <span data-start="418.939" data-end="421.719">maybe the next one.</span> <span data-start="421.719" data-end="430.71">And, it's purpose or it's objective is very simple: To fix the issues in version 1.1,</span> <span data-start="430.71" data-end="434.08">but without breaking the web.</span> <span data-start="434.08" data-end="441.52">Sounds very ambitious and this protocol is actually based on SPDY which has been developed</span> <span data-start="441.52" data-end="445.479">by Google in 2009.</span> <span data-start="445.479" data-end="455.54">The very first draft of HTTP 2.0 version 0 was based on the latest specification of SPDY.</span> <span data-start="455.54" data-end="460.499">So, going inside to the protocol, how browsers switches to that protocol?</span> <span data-start="460.499" data-end="471.15">There is HTTP and HTTPS, and if we switch from HTTP we use the upgrade mechanism, however</span> <span data-start="471.15" data-end="473.37">this means a round trip.</span> </p>
<p><span data-start="473.37" data-end="477.509">That's why it's better to look for another solution.</span> <span data-start="477.509" data-end="486.75">And if we switch from HTTPS to HTTP 2.0, an Application Layer Protocol Negotiation Extension</span> <span data-start="486.75" data-end="492.62">has been used, which avoids this draw back.</span> <span data-start="492.62" data-end="501.259">The protocol has many exciting features, and I will note some of them.</span> <span data-start="501.259" data-end="506.24">The main difference with version 1.1 is that it's binary protocol.</span> <span data-start="506.24" data-end="508.05">It's not text one.</span> <span data-start="508.05" data-end="513.75">So, for browsers, it makes huge difference for us, it makes that if you use telnet to</span> <span data-start="513.75" data-end="519.789">look to some server, to log in to some server that won't be possible anymore, but because</span> <span data-start="519.789" data-end="525.61">it's binary protocol it's much easier a parser to be created and if you are NodeJS developer,</span> <span data-start="525.61" data-end="533.24">and you want to create your own server it will be much easier for you to create a parser</span> <span data-start="533.24" data-end="536.74">based on this binary protocol.</span> <span data-start="536.74" data-end="542.69">There won't be a need to deal with string limited, with strings at all.</span> <span data-start="542.69" data-end="551.19">On the very low level browser and server exchange frames and each frame belongs to a stream.</span> <span data-start="551.19" data-end="556.899">If there is a frame, which doesn't belong to a stream, that's protocol error.</span> </p>
<p><span data-start="556.899" data-end="561.66">What is really important is that those streams are multiplexed.</span> <span data-start="561.66" data-end="567.8">We have one single connection, but multiple streams, they are multiplexed and they also</span> <span data-start="567.8" data-end="569.85">have priorities.</span> <span data-start="569.85" data-end="574.709">This is really important — as you know, every page there are some resources which are critical</span> <span data-start="574.709" data-end="577.769">for rendering the page and there are others which are not.</span> <span data-start="577.769" data-end="585.16">CSS [files] are critical, JavaScript could be critical if the page requires JavaScript,</span> <span data-start="585.16" data-end="586.94">but the images usually are not.</span> <span data-start="586.94" data-end="594.199">So, now, we can balance with those different streams.</span> <span data-start="594.199" data-end="600.8">Something which we were doing for years was called resource inlining, now it's on the</span> <span data-start="600.8" data-end="603.62">protocol level and it's called server push.</span> <span data-start="603.62" data-end="613.029">Again, if I have a NodeJS server, I can check if the browser allows server push and to push</span> <span data-start="613.029" data-end="621.66">my critical resources when the page is being loaded, right, instead to put everything on</span> <span data-start="621.66" data-end="627.24">the page, and to deal with caches and something like this.</span> <span data-start="627.24" data-end="632.79">This is what we have to emphasize: One connection to the server that should be enough, and not</span> <span data-start="632.79" data-end="636.93">six connection per domain as most browsers do now.</span> </p>
<p><span data-start="636.93" data-end="641.5">Some of them actually open more than six connections.</span> <span data-start="641.5" data-end="649.35">But, in general, this is not good for no one, neither for the browser nor for the server.</span> <span data-start="649.35" data-end="657.25">The browser has to deal with memory, to balance those connections and that's not good.</span> <span data-start="657.25" data-end="663.68">Now, just one connection, we go back as to the point, as it should be.</span> <span data-start="663.68" data-end="670.18">As I said, frames — that's on the very low level.</span> <span data-start="670.18" data-end="673.399">And this is how a frame looks like:</span> <span data-start="673.399" data-end="676.839">We want to take a look on all of this one by one.</span> </p>
<p><span data-start="676.839" data-end="684.13">I will mention just two of those, the type of the frame, and stream identifier.</span> <span data-start="684.13" data-end="688.899">Every page has stream identifier, so as I said [if there is no stream identifier] this</span> <span data-start="688.899" data-end="691.61">would be protocol error.</span> <span data-start="691.61" data-end="698.24">There are about ten different frame types currently in the latest draft.</span> <span data-start="698.24" data-end="703.96">Like data frame, which conveys arbitrary data associated with a stream there are frames</span> <span data-start="703.96" data-end="711.87">which deal with headers, some of those are related to stream priority, some of them are</span> <span data-start="711.87" data-end="717.3">related to promises, to push promises, this is related server push.</span> <span data-start="717.3" data-end="724.3">For some of them the purpose is to reset a stream — just abort the stream, I don't want</span> <span data-start="724.3" data-end="728.22">the see it anymore.</span> <span data-start="728.22" data-end="736.38">And those frames are grouped in streams, so streams, by definition is logical bidirectional</span> <span data-start="736.38" data-end="743.5">sequence of frames, frames which are being exchanged between the browser and the server.</span> <span data-start="743.5" data-end="753.18">So, one single connection can has multiple open streams, like in this example, you may\h‑‑</span> <span data-start="753.18" data-end="756.56">you may see that we currently have three streams.</span> <span data-start="756.56" data-end="759.269">Stream one, stream two, and stream four.</span> <span data-start="759.269" data-end="765.42">So, there are\h‑‑ they all contain some frames, and they are multiplexed.</span> <span data-start="765.42" data-end="772.49">One stream may represent an HTML page, another stream may represent a JavaScript file or</span> <span data-start="772.49" data-end="779.199">a third one some style, but they're multiplexed and prioritized by the browser.</span> </p>
<p><span data-start="779.199" data-end="783.639">So, going to priorities:</span> <span data-start="783.639" data-end="791.73">Each stream has priority, that priority is specified by the browser and what is important</span> <span data-start="791.73" data-end="795.66">is that priority can be changed on runtime.</span> <span data-start="795.66" data-end="801.51">So, the exact order in which frames are delivered can be further optimized.</span> <span data-start="801.51" data-end="809.3">The priorities are optional, 31 birth value, and stream with priority 0 has the highest</span> <span data-start="809.3" data-end="811.31">priority.</span> </p>
<p><span data-start="811.31" data-end="813.33">Right ..</span> <span data-start="813.33" data-end="820.94">streams also have dependencies, and like in this example we have two streams B and C which</span> <span data-start="820.94" data-end="828.17">depend on A, so if we have another stream called D, and it just has priority, it will</span> <span data-start="828.17" data-end="837.62">have the same value as B and C, however, if we say that D depends on A, then B and C will</span> <span data-start="837.62" data-end="844.16">start depending on the D too.</span> <span data-start="844.16" data-end="851.459">Another key part of the protocol is related to headers, as I said, we cannot break the</span> <span data-start="851.459" data-end="853.36">web, right, this is the deal.</span> <span data-start="853.36" data-end="857.29">So, HTTP 2.0 is stateless protocol too.</span> </p>
<p><span data-start="857.29" data-end="864.8">Nothing has change changed here, the client still has to send data to to the server, however,</span> <span data-start="864.8" data-end="866.67">there is a big difference:</span> <span data-start="866.67" data-end="872.19">The headers in version 2.0 are now compressed.</span> <span data-start="872.19" data-end="876.97">This is the big difference.</span> <span data-start="876.97" data-end="881.61">Just a few words about the compression, it's stateful, it's not stateless, which means</span> <span data-start="881.61" data-end="889.139">that a single compression context for the entire connection is used, and the algorithm</span> <span data-start="889.139" data-end="900.75">is especially designed for the protocol, it's called HPAC because of some evil guys who</span> <span data-start="900.75" data-end="908.61">applied attacks like CRIME and BREACH, so we have a specially designed compression algorithm</span> <span data-start="908.61" data-end="911.74">for the protocol.</span> </p>
<p><span data-start="911.74" data-end="917.269">Going back to what we know very well, server push, we did that for years, nothing new here,</span> <span data-start="917.269" data-end="924.82">I guess all of you applied or embedded some resources to the page — CSS or JavaScript</span> <span data-start="924.82" data-end="927.839">or SVG impage or what ever.</span> <span data-start="927.839" data-end="934.85">So here, this is the difference — server pre‑emptively sends resources to a client in association</span> <span data-start="934.85" data-end="938.129">with the previous client‑initiated request.</span> </p>
<p><span data-start="938.129" data-end="944.7">So, I'm requesting indexed HTML on the server side, me as JavaScript developer who works</span> <span data-start="944.7" data-end="950.569">on NodeJS server, I can push the critical resources which are needed for the page to</span> <span data-start="950.569" data-end="953.319">be rendered, right?</span> <span data-start="953.319" data-end="960.209">Of there is, this is a trick here — the client explicitly must allow it.</span> <span data-start="960.209" data-end="965.32">So, on the server side when we implement our servers, we have to check if that is allowed</span> <span data-start="965.32" data-end="971.139">otherwise that could [lead] to a reset stream or something like this.</span> <span data-start="971.139" data-end="981.54">A client cannot push, which means the browser cannot push resources to the server — only</span> <span data-start="981.54" data-end="986.089">the server is allowed to do that .</span> </p>
<p><span data-start="986.089" data-end="988.99">So — very briefly, this is it.</span> <span data-start="988.99" data-end="991.41">HTTP 2 Rulez, right?</span> <span data-start="991.41" data-end="999.56">Because now as developers we have full power to apply different kind of optimizations,</span> <span data-start="999.56" data-end="1006.209">different than those which we are currently doing, or we can apply more — we can get heuristics</span> <span data-start="1006.209" data-end="1013.19">from how the user behaves with the page [in order] to push resources, to optimize our</span> <span data-start="1013.19" data-end="1017.54">pages in different way.</span> </p>
<p><span data-start="1017.54" data-end="1022.97">This is not the end because now we have\h‑‑ because the research continues.</span> <span data-start="1022.97" data-end="1028.94">We have another protocol, also started by Google, research by Google, it's called QUIC.</span> <span data-start="1028.94" data-end="1043.17">QUIC is a natural extension of SPDY and HTTP 2.0 research, this is also multiplexing transport</span> <span data-start="1043.17" data-end="1049.9">protocol but there is a big difference — this protocol runs on top of UDP, it doesn't run</span> <span data-start="1049.9" data-end="1056.76">on top of TCP as SPDY and HTTP 2.0 do.</span> <span data-start="1056.76" data-end="1061.13">This protocol runs on top of UDP.</span> <span data-start="1061.13" data-end="1068.5">Because it runs on top of UDP, the browsers cannot use those out of the box features which</span> <span data-start="1068.5" data-end="1071.39">are available in TCP, right?</span> <span data-start="1071.39" data-end="1075.9">So those should be implemented on application level.</span> </p>
<p><span data-start="1075.9" data-end="1077.1">So why should do we that?</span> <span data-start="1077.1" data-end="1080.66">Because it's very hard to update TCP.</span> <span data-start="1080.66" data-end="1087.38">It's everywhere, it's on servers, routers, it needs years until it's being updated.</span> <span data-start="1087.38" data-end="1095.64">But now we can apply the results of the research, how to improve the web on QUIC, Google applied</span> <span data-start="1095.64" data-end="1101.44">to their servers, applied to Chrome and now everything is clear.</span> <span data-start="1101.44" data-end="1107.95">You can see how QUIC works right now in your browser, there is a flag, you can enable it</span> <span data-start="1107.95" data-end="1108.95">if you want.</span> </p>
<p><span data-start="1108.95" data-end="1114.1">I actually do it to see how it's going.</span> <span data-start="1114.1" data-end="1123.3">So, that's not the first time when people are trying to fix the issues of using UDP,</span> <span data-start="1123.3" data-end="1130.41">people haven't slept those years, and there were already existing solutions, like, SCTP</span> <span data-start="1130.41" data-end="1136.72">over DTLS, that's one possible solution, those are two different protocols.</span> <span data-start="1136.72" data-end="1143.28">After all SCTP provides, among other thing, stream multiplexing, right?</span> <span data-start="1143.28" data-end="1149.26">DTLS provides SSL quality encryption and authentication over UDP stream.</span> <span data-start="1149.26" data-end="1154.32">So why not use those protocols?</span> <span data-start="1154.32" data-end="1162.56">The answer is very simple, because roughly four round trips are needed to SCTP over DTLS</span> <span data-start="1162.56" data-end="1163.56">connection.</span> <span data-start="1163.56" data-end="1170.34">You can imagine how expensive, again with the expensive of Berlin client and L.A. server,</span> <span data-start="1170.34" data-end="1171.53">that's too expensive.</span> <span data-start="1171.53" data-end="1178.28">In contrast, the goal of QUIC is to perform a connection establishment with zero round</span> <span data-start="1178.28" data-end="1179.79">trip time overhead.</span> <span data-start="1179.79" data-end="1183.56">This is the goal.</span> <span data-start="1183.56" data-end="1191.81">QUIC has all the benefits of SPDY and HTTP 2.0, but, there there is a big difference,</span> <span data-start="1191.81" data-end="1197.71">there is no head‑of‑line blocking in QUIC!</span> </p>
<p><span data-start="1197.71" data-end="1204.5">As you can imagine, delaying of only one packet causes the entire set of SPDY streams to pause,</span> <span data-start="1204.5" data-end="1211.7">HTTP/2 streams to pause because TCP only provides a single serialized stream interface, but</span> <span data-start="1211.7" data-end="1218.32">in QUIC when a single packet is lost, only one stream is being delayed.</span> <span data-start="1218.32" data-end="1224.25">We can illustrate that with an image, and here is how does it look like.</span> <span data-start="1224.25" data-end="1231.85">Here we have three streams, with red, green, and blue color, and if a packet in the stream</span> <span data-start="1231.85" data-end="1241.9">marked with red color is being lost, the rest two streams are not being affected.</span> <span data-start="1241.9" data-end="1248.1">Here we can compare how QUIC behaves versus TCP + TLS.</span> <span data-start="1248.1" data-end="1255.42">For repeat connection, it's zero milliseconds round trip time, right, for TCP plus TLS it's</span> <span data-start="1255.42" data-end="1256.62">200 ms.</span> <span data-start="1256.62" data-end="1263.12">For new connectio with QUIC it's 100ms, for TCP + TLS it is 300 milliseconds, that's too</span> <span data-start="1263.12" data-end="1264.12">much.</span> <span data-start="1264.12" data-end="1271.54">As I sad this protocol rests on top of UDP, so many of the out of the box features in</span> <span data-start="1271.54" data-end="1280">TCP are now not available so they have to be implemented on the application level.</span> <span data-start="1280" data-end="1286.2">QUIC also provides encryption, which is compatible to TLS, but with more efficient handshake.</span> <span data-start="1286.2" data-end="1293.29">It has replay attack and IP spoofing protection, and it also has something very important — in</span> <span data-start="1293.29" data-end="1300.26">order to minimize all those round trips, which really decreases the performance, there is</span> <span data-start="1300.26" data-end="1304.97">forward error correction, which means on the price of an additional packet (for example),</span> <span data-start="1304.97" data-end="1313.04">we can restore a packet which has been lost, so the server won't have to send this packet</span> <span data-start="1313.04" data-end="1314.55">again.</span> </p>
<p><span data-start="1314.55" data-end="1321.6">A really cool feature for us, like especially for us who use mobile phones, if we\h‑‑</span> <span data-start="1321.6" data-end="1329.62">that the communication channels are not defined by IP plus port, but by an ID, so, in this\h‑‑</span> <span data-start="1329.62" data-end="1338.26">in this room there is WiFi and if you leave the WiFi and go outside of this building for</span> <span data-start="1338.26" data-end="1346.73">using mobile Internet, that one\h‑‑ that won't be so bad because the connection continues.</span> <span data-start="1346.73" data-end="1347.73">So ..</span> <span data-start="1347.73" data-end="1355.02">all this sounds very cool, very exciting, and I wanted to see what is the current status</span> <span data-start="1355.02" data-end="1361.96">of those two protocols where we are going\h‑‑ how are we going, especially for this presentation,</span> <span data-start="1361.96" data-end="1370.89">I created the small site, which is\h‑‑ which has really cool name HTTPRulez.com,</span> <span data-start="1370.89" data-end="1377.05">it consists on the two pages, on the first page we have\h‑‑ on the first page we</span> <span data-start="1377.05" data-end="1386.49">have. it represents an online shop with CSS JavaScript and images and the second page</span> <span data-start="1386.49" data-end="1391.11">I have a few web components, they are supposed to be the future of web development, so I</span> <span data-start="1391.11" data-end="1399.32">wanted to see if we serve the content via different protocols it will make some difference.</span> </p>
<p><span data-start="1399.32" data-end="1400.61">So ..</span> <span data-start="1400.61" data-end="1406.9">from my point of view that site is like Open Source platform for testing different optimizations</span> <span data-start="1406.9" data-end="1414.24">strategies for HTTP 2.0, there is\h‑‑ this is the idea, same content, but, served</span> <span data-start="1414.24" data-end="1423.04">via different end points, via HTTP, HTTPS, SPDY and HTTP 2, that's really cool, isn't</span> <span data-start="1423.04" data-end="1424.04">it?</span> <span data-start="1424.04" data-end="1428.001">I don't have QUIC end point yet, because there is no production ready server, not this there</span> <span data-start="1428.001" data-end="1435.53">is HTTP 2.0 production server — I implemented this on NodeJS, so I had to build version</span> <span data-start="1435.53" data-end="1440.77">of Node with ALPN support, but it currently works.</span> <span data-start="1440.77" data-end="1452.91">On each page we can see the load time so we can compare, and because we have great tools</span> <span data-start="1452.91" data-end="1459.23">like Webpage, now we can check what is the difference\h‑‑ I intentionally did not</span> <span data-start="1459.23" data-end="1464.01">apply any of those dark workarounds we were doing for years.</span> <span data-start="1464.01" data-end="1468.88">I did not create any sprite for images, there are about 30 images, I did not create any</span> <span data-start="1468.88" data-end="1479.36">sprite, I wanted to start with something simple and see how it behaves if we avoid all of</span> <span data-start="1479.36" data-end="1480.36">that.</span> </p>
<p><span data-start="1480.36" data-end="1483.11">On top we can implement further optimizations.</span> <span data-start="1483.11" data-end="1492.041">So, this is what HTT\h‑‑ what webpagepast shows as waterfall when we use HTTPS, this</span> <span data-start="1492.041" data-end="1500.26">is the waterfall, you can see how it looks like, you can also see that the browser Chrome</span> <span data-start="1500.26" data-end="1506.96">opened six connections for this domain and now for each connection we have initializing,</span> <span data-start="1506.96" data-end="1517.68">we have SSL negotiation, which is expensive, TCP needs three round trips, right, so this</span> <span data-start="1517.68" data-end="1519.37">is not so good.</span> <span data-start="1519.37" data-end="1523.65">Six connections, you can imagine how much time we are losing for [establishing] all</span> <span data-start="1523.65" data-end="1526">those connections.</span> <span data-start="1526" data-end="1535.77">And here I have a waterfall, again with webpagetest, which represents HTTP/2 waterfall without</span> <span data-start="1535.77" data-end="1537.24">server push.</span> <span data-start="1537.24" data-end="1542.82">On the server, I haven't pushed any of those resources, I just relied on the browser to</span> <span data-start="1542.82" data-end="1544.24">do its best.</span> </p>
<p><span data-start="1544.24" data-end="1546.54">Currently this only works on Canary.</span> <span data-start="1546.54" data-end="1551.59">It doesn't work on Chrome, I hope in a few months that it will be available in Chrome</span> <span data-start="1551.59" data-end="1559.48">too, but for now we have to use Canary and apply a special flag — if you go to chrome://flags/</span> <span data-start="1559.48" data-end="1568.34">you is to enable SPDY/4 which is the internal name of HTTP/2 for Canary.</span> <span data-start="1568.34" data-end="1574.57">But, now it works, it supports draft 14, which is the latest one so that is really cool.</span> <span data-start="1574.57" data-end="1582.9">Here you can see that the browser created only one connection to the server, not six,</span> <span data-start="1582.9" data-end="1583.9">this is the big deal.</span> <span data-start="1583.9" data-end="1590.14">All those resources were multiplexed and sent to the browser via just one connection.</span> <span data-start="1590.14" data-end="1593.09">This is huge improvement.</span> <span data-start="1593.09" data-end="1598.67">But I wanted to see how it behaves if I push some resources so here is the waterfall, what</span> <span data-start="1598.67" data-end="1605.86">currently webpagetest shows, probably that will change because if you open Canary Dev</span> <span data-start="1605.86" data-end="1612.581">tools you can see all these resources, but in webpagetest it looks like if the browser</span> <span data-start="1612.581" data-end="1619.01">made only one request to the server which is index HTML or slash (/), but not — actually</span> </p>
<p><span data-start="1619.01" data-end="1626.77">I intentionally pushed all CSS, JavaScript and images files when the browser requests</span> <span data-start="1626.77" data-end="1630.53">index HTML page.</span> <span data-start="1630.53" data-end="1631.59">So ..</span> <span data-start="1631.59" data-end="1632.59">again ..</span> <span data-start="1632.59" data-end="1644.78">we have connection view, it shows only one connection, not six.</span> </p>
<p><span data-start="1644.78" data-end="1650.08">If we have to draw the line, I would like to say the following:</span> <span data-start="1650.08" data-end="1656.97">If you remember the workarounds, which we did to speed up our sites for years, all those</span> <span data-start="1656.97" data-end="1666.25">workarounds.. ask yourself how HTTP 2.0 will affect the way you develop and optimize web</span> <span data-start="1666.25" data-end="1670.28">applications for you or for your company.</span> </p>
</section>