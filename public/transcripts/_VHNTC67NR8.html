<section>
<p><span data-start="6.79" data-end="7.79"Audience member: Okay.</span> <span data-start="7.79" data-end="8.79">Hi, everyone.</span> <span data-start="8.79" data-end="15.74">My name is Maxim Koretskyi, but I'm also known as the Wizard because I like to talk and write</span> <span data-start="15.74" data-end="23.36">about complicated stuff, topics that sometimes are seen as mysterious, and hence the name</span> <span data-start="23.36" data-end="24.36">The Wizard.</span> <span data-start="24.36" data-end="34.36">I'm going to be talking about why Angular and React, the top web frameworks we have</span> <span data-start="34.36" data-end="36.43">today, are so fast.</span> <span data-start="36.43" data-end="44.19">I will present a few JavaScript opened myself techniques that these frameworks use to make</span> <span data-start="44.19" data-end="45.82">JavaScript run fast.</span> <span data-start="45.82" data-end="48.25">Now, I work at AG Grid.</span> <span data-start="48.25" data-end="54.3">This is where we develop the best data grid in the world, so, if you need the data grid,</span> <span data-start="54.3" data-end="59.93">we have a free community version with a lot of features, so definitely give it a try if</span> <span data-start="59.93" data-end="61.25">you need data grid.</span> </p>
<p><span data-start="61.25" data-end="67.81">I'm also the founder of Angular and dev community where we write and publish articles about</span> <span data-start="67.81" data-end="72">advanced topics of Angular.</span> <span data-start="72" data-end="81.39">So, we will be talking about three things today: monomorphism, bitfils, and filters.</span> <span data-start="81.39" data-end="87.4">How many know about monomorphism, watch talks?</span> <span data-start="87.4" data-end="88.84">Something?</span> <span data-start="88.84" data-end="90.29">Okay.</span> <span data-start="90.29" data-end="94.95">I watched a talk by Benedict last year, gave a talk about monomorphism.</span> <span data-start="94.95" data-end="99.6">I will give you an overview of what it is.</span> <span data-start="99.6" data-end="109.06">I will talk about bitfils and how Angular uses structure known as bloom filters.</span> <span data-start="109.06" data-end="111.08">Let's start with monomorphism.</span> <span data-start="111.08" data-end="112.59">I do a lot of reverse engineering.</span> <span data-start="112.59" data-end="117.869">I sit at the computer with debugger and go through the sores of the frameworks.</span> <span data-start="117.869" data-end="124.59">These are the comments that I found inside Angular and React sources.</span> <span data-start="124.59" data-end="130.28">So these are the comments by technical leads of the frameworks, and they talk about hidden</span> <span data-start="130.28" data-end="132.31">class.</span> </p>
<p><span data-start="132.31" data-end="137.029">And internal data structures called fibre and view nodes.</span> <span data-start="137.029" data-end="144.359">They want to ensure that these internal data structures share the same hidden class, and</span> <span data-start="144.359" data-end="148.209">that is to make property access monomorphic.</span> <span data-start="148.209" data-end="152.87">So a bunch of words when I first encountered that, I didn't really know what they were</span> <span data-start="152.87" data-end="154.62">talking about.</span> <span data-start="154.62" data-end="157.809">We need to clarify today what is hidden class?</span> <span data-start="157.809" data-end="159.739">What is monomorphic property access?</span> <span data-start="159.739" data-end="166.609">Why is it important in what are these data structures, like fibre and view nodes?</span> <span data-start="166.609" data-end="170.15">Let's start with data structures.</span> <span data-start="170.15" data-end="180.12">Fibre nodes and view nodes in Angular are used internally to represent a template, basically.</span> <span data-start="180.12" data-end="188.329">When you define a component, this is the declaration of a component in Angular.</span> <span data-start="188.329" data-end="196.29">Angular uses view nodes, data structures, that it creates to represent a template.</span> <span data-start="196.29" data-end="204.359">They define the metadata needed to render the DOM, and it also specifies which part</span> <span data-start="204.359" data-end="207.67">of the DOM needs to be up dated.</span> <span data-start="207.67" data-end="209.349">Something called bindings.</span> </p>
<p><span data-start="209.349" data-end="214.859">How many of you work with Angular?</span> <span data-start="214.859" data-end="217.969">The same thing in React.</span> <span data-start="217.969" data-end="225.719">We also define components, we define a template, and React uses fibre node.</span> <span data-start="225.719" data-end="228.68">This is new React fibre 16 architecture.</span> <span data-start="228.68" data-end="233.159">It uses fibre node to represent the DOM.</span> <span data-start="233.159" data-end="235.549">How many use React?</span> <span data-start="235.549" data-end="241.939">About 40 per cent.</span> <span data-start="241.939" data-end="245.779">Fibre nodes and view nodes are used by these frameworks to represent a template.</span> <span data-start="245.779" data-end="252.45">This is something in between the declaration of a component template and the DOM.</span> <span data-start="252.45" data-end="260.42">What is common between these data structures is that they are used a lot when these frameworks</span> <span data-start="260.42" data-end="264.05">process changes.</span> </p>
<p><span data-start="264.05" data-end="269.21">Imagine there's a function called update node, an example of a function, there are a bunch</span> <span data-start="269.21" data-end="274.39">of functions similar to this one in both frameworks.</span> <span data-start="274.39" data-end="280.82">This function takes in a data structure, fibre or view node as the first parameter and then</span> <span data-start="280.82" data-end="285.16">it reads some property.</span> <span data-start="285.16" data-end="293.84">What is interesting that these kind of functions and the property access to easily exceed 10,000</span> <span data-start="293.84" data-end="295.67">times.</span> </p>
<p><span data-start="295.67" data-end="307.25">So it reads the data structure 10,000 times, every single times, changes are being processed.</span> <span data-start="307.25" data-end="311.37">So it can happen a few times per second.</span> <span data-start="311.37" data-end="316.51">You can imagine how many times the framework in JavaScript needs to have access to the</span> <span data-start="316.51" data-end="317.87">property.</span> <span data-start="317.87" data-end="326.93">The problem is virtual machines bike V8, it's a complicated process to figure out where</span> <span data-start="326.93" data-end="333.58">exactly in memory for the value of the property is stored.</span> <span data-start="333.58" data-end="340.92">Hence the virtual machine has optimisation techniques they use to make the process faster.</span> <span data-start="340.92" data-end="345.92">First, let me explain to you: when I was trying to figure out all that stuff, the question</span> <span data-start="345.92" data-end="348.5">I had is why is it complicated?</span> <span data-start="348.5" data-end="352.2">Why is it complicated to figure out where the value is, right?</span> <span data-start="352.2" data-end="356.37">And the answer is because of something called shapes or hidden classes.</span> </p>
<p><span data-start="356.37" data-end="363.36">That is exactly the hidden class that Sebastian talked in his comment.</span> <span data-start="363.36" data-end="369.27">So every single JavaScript object that you write in your everyday code is represented</span> <span data-start="369.27" data-end="377.81">by the JavaScript object, the object internally, inside the VM, and this also is the corresponding</span> <span data-start="377.81" data-end="379.29">shape object.</span> <span data-start="379.29" data-end="386.95">So shape defines or describes the layout, which properties the object has, and some</span> <span data-start="386.95" data-end="393.16">metadata, for example, the offset, where to find the value in memory.</span> <span data-start="393.16" data-end="396.42">You might think why do we need this shape, right?</span> <span data-start="396.42" data-end="401.1">Why not put all description of the properties on the object itself?</span> </p>
<p><span data-start="401.1" data-end="404.57">And the reason is memory save.</span> <span data-start="404.57" data-end="412.09">So, if we have two objects, on 1,000 objects, right, there's no need to describe the layout</span> <span data-start="412.09" data-end="413.8">every single time.</span> <span data-start="413.8" data-end="421.03">We can describe the layout only once, and then link this object to the shape that describes</span> <span data-start="421.03" data-end="422.03">the layout, right?</span> <span data-start="422.03" data-end="427.09">In this way, we only describe the layout once, even though we have, I don't know, potentially</span> <span data-start="427.09" data-end="431.21">millions of objects in memory.</span> <span data-start="431.21" data-end="434.78">But then, it creates a problem.</span> <span data-start="434.78" data-end="440.22">What if we want to add an extra property?</span> <span data-start="440.22" data-end="446.41">Now we want to extend the object A. We want to introduce the new property "W".</span> <span data-start="446.41" data-end="451.27">Well, we need to introduce a new shape.</span> <span data-start="451.27" data-end="456.74">We cannot add the W property to the original shape.</span> <span data-start="456.74" data-end="461.06">Because it would mean that the other object, the object B that points to the same shape</span> <span data-start="461.06" data-end="464.139">has this property, which is not true.</span> </p>
<p><span data-start="464.139" data-end="468.35">We need to introduce the new property and then the new shape.</span> <span data-start="468.35" data-end="470.2">Then we update links.</span> <span data-start="470.2" data-end="475.139">The object now, the object points to the new shape.</span> <span data-start="475.139" data-end="481.73">The same thing happens if we introduce another property we create one more shape.</span> <span data-start="481.73" data-end="487.3">And so, in fact, we end up with something called Transition Chains.</span> <span data-start="487.3" data-end="491.61">And it means that, when you try to access the property, for example, X, the original</span> <span data-start="491.61" data-end="500.9">property on the A object which points to the button on the chain.</span> </p>
<p><span data-start="500.9" data-end="506.46">It needs to go through every single property upwards and will until it finds the shape</span> <span data-start="506.46" data-end="510.919">that describes the property.</span> <span data-start="510.919" data-end="512.76">Okay?</span> <span data-start="512.76" data-end="517.25">You can imagine that, if you add a lot of properties in different places and modify</span> <span data-start="517.25" data-end="523.18">object shape, you will have a transition shape potentially with hundreds of transitions.</span> <span data-start="523.18" data-end="527.459">And so, every single time when you access a property, the virtual machine has to go</span> <span data-start="527.459" data-end="533.379">through all that process to figure out the shape that describes the layout and memory</span> <span data-start="533.379" data-end="537.199">of that and retrieve that information.</span> <span data-start="537.199" data-end="546.779">So a technique that V8 uses is to make that process faster.</span> <span data-start="546.779" data-end="552.589">The idea is simple: the .. is the main word here.</span> <span data-start="552.589" data-end="559.47">Every single JavaScript function is represented internally by the object called closure.</span> <span data-start="559.47" data-end="566.129">This is where the virtual machine caches some information about the function, which objects</span> <span data-start="566.129" data-end="572.26">are used to add parameters to this function, and the other information.</span> <span data-start="572.26" data-end="575.18">And feed the vector, and this is the cache.</span> <span data-start="575.18" data-end="578.67">This is where the virtual machine will cache some information.</span> <span data-start="578.67" data-end="581.639">So let me give you an example of how it works.</span> </p>
<p><span data-start="581.639" data-end="587.589">Suppose we are calling the function Get X and passing in an object with the X property.</span> <span data-start="587.589" data-end="595.269">The virtual machine figures out the shape for this object, right, and then what it can</span> <span data-start="595.269" data-end="605.639">do is that it can cache the shape of the object, and then the property, right, because we are</span> <span data-start="605.639" data-end="613.779">getting access to the X property, and it can couch the offset, right?</span> <span data-start="613.779" data-end="621.519">So the next time when we execute this function and pass in an object that has the same shape,</span> <span data-start="621.519" data-end="627.3">the virtual machine can only compare the shapes, and, if they match, there's no longer need</span> <span data-start="627.3" data-end="629.05">to figure out the shape.</span> </p>
<p><span data-start="629.05" data-end="635.209">You can just take the cache value from the offset and use it to resolve the value in</span> <span data-start="635.209" data-end="636.88">the memory.</span> <span data-start="636.88" data-end="642.97">And what it also does is it defines the state of the function, and the state there can be</span> <span data-start="642.97" data-end="652.17">three types of states: monomorphic state, monomorphic property access, and polymorphic.</span> <span data-start="652.17" data-end="658.11">In this case, it's monomorphism because it — it's monomorphic because it has been called</span> <span data-start="658.11" data-end="663.41">with one type of shape.</span> <span data-start="663.41" data-end="670.019">Polymorphic is when a function has seen four types of shapes up to four times, and megamorphic</span> <span data-start="670.019" data-end="676.49">is when you've been passing objects of different shapes, more than four types of shapes.</span> <span data-start="676.49" data-end="686.92">It's important that you pass objects of the state to one function so the state remains</span> <span data-start="686.92" data-end="688.769">monomorphic.</span> <span data-start="688.769" data-end="702.24">I read the comment that monomorphic property access can be up to 100 times faster than</span> <span data-start="702.24" data-end="703.24">megamorphic.</span> </p>
<p><span data-start="703.24" data-end="710.91">If you take into account this 10,000 times of access during each change detection cycle</span> <span data-start="710.91" data-end="716.689">that can happen several hundred times a second, you can imagine the kind of impact monomorphic</span> <span data-start="716.689" data-end="721.22">property access can have on the speed.</span> <span data-start="721.22" data-end="729.949">So frameworks use this to create — actually, what they do is they want to enforce this</span> <span data-start="729.949" data-end="736.619">function that takes these nodes, it uses the same shape, same hidden class for fibre and</span> <span data-start="736.619" data-end="741.7">view nodes, and that makes property access monomorphic.</span> <span data-start="741.7" data-end="752.819">You can have HTML elements, child opponents, and if you follow object-orientated programming</span> <span data-start="752.819" data-end="758.49">principles, you would create different classes for different elements.</span> <span data-start="758.49" data-end="765.399">These frameworks actually merge everything into one data structure, one class, with all</span> <span data-start="765.399" data-end="773.1">set of fields and they use one tag filled to distinguish between types of node.</span> <span data-start="773.1" data-end="775.399">This is the code from the React framework.</span> <span data-start="775.399" data-end="780.99">This is a function that is executed for every single DOM element, so potentially thousands</span> <span data-start="780.99" data-end="788.529">of times during each cycle, and you can see here that they try to distinguish by tag,</span> <span data-start="788.529" data-end="791.67">and then run the corresponding logic.</span> </p>
<p><span data-start="791.67" data-end="794.86">Okay, so that is monomorphism.</span> <span data-start="794.86" data-end="796.66">Now, let's talk about bitfils.</span> <span data-start="796.66" data-end="800.25">This is the other things that both frameworks happily used.</span> <span data-start="800.25" data-end="803.67">Bitfils is a low-level concept.</span> <span data-start="803.67" data-end="809.93">Those who have programmed with C++, for example, know this data structure, and bitfils is just</span> <span data-start="809.93" data-end="815.019">basically an array of bits — zeros and ones.</span> <span data-start="815.019" data-end="823.12">You can define a bitfil today in JavaScript, type OB prefix in console and you'll get the</span> <span data-start="823.12" data-end="826.36">binary fill.</span> <span data-start="826.36" data-end="831.939">Now React uses bitfils to en code side effects.</span> <span data-start="831.939" data-end="838.31">Side effects in React are basically just operations that the framework needs to do on DOM elements,</span> <span data-start="838.31" data-end="844.579">maybe place an element in the DOM, update tags, remove element, and, instead of having</span> <span data-start="844.579" data-end="852.329">an array of strings, for example, that define operations, they just assign places, and say</span> <span data-start="852.329" data-end="856.389">that, "Okay, the third bit is the update operation."</span> </p>
<p><span data-start="856.389" data-end="860.499">So, if the bit is one, I know that I need to update task.</span> <span data-start="860.499" data-end="865.529">If the bit is zero, it means that there is nothing to do here.</span> <span data-start="865.529" data-end="870.05">And I found that when I was debugging React, I'm sitting with a debugger, and I'm following</span> <span data-start="870.05" data-end="877.739">the spun element, and I've just updated the tag on the spun element, so I'm trying to</span> <span data-start="877.739" data-end="881.6">figure out what changes it will have.</span> <span data-start="881.6" data-end="888.619">So the effect tag is this effects filled, and it's a bitfil, so right after the render</span> <span data-start="888.619" data-end="896.759">face when it has process changes, the number, the value, is four, and, because it's a bitfil,</span> <span data-start="896.759" data-end="907.3">it's binary, so I converted it into like — here, it is actually the decimal, but I know it's</span> <span data-start="907.3" data-end="911.82">binary, so I converted it to binary and I got 100.</span> <span data-start="911.82" data-end="919.5">If you explore the fill, you can see it's a third bit, and that's exactly what I expected.</span> <span data-start="919.5" data-end="928.429">React encoded the update operation, so later — for example, here, when the function update</span> <span data-start="928.429" data-end="935.249">hosts the facts, it's executed, so, React will check every single bit and see what kind</span> <span data-start="935.249" data-end="936.8">of operations it needs to perform.</span> </p>
<p><span data-start="936.8" data-end="941.559">For example, update will up date the tags.</span> <span data-start="941.559" data-end="948.37">Now, you might be looking at that and think to yourself, "Well, why bother?"</span> <span data-start="948.37" data-end="954.869">This is okay, but it's still too low level, but there are a number of benefits, and advantages</span> <span data-start="954.869" data-end="959.63">that bitfils have over other types of data structures.</span> <span data-start="959.63" data-end="965.98">For example, with bitfils, there is no need to allocate memory for JavaScript objects</span> <span data-start="965.98" data-end="973.149">and shapes, so the virtual machine can save a lot of space, and because there is no shapes</span> <span data-start="973.149" data-end="980.66">and JavaScript objects, there are no references, it means that the garbage collection is a</span> <span data-start="980.66" data-end="982.299">lot simpler.</span> <span data-start="982.299" data-end="988.029">You know, you figure out the dependency graph and know which objects are safe to remove.</span> <span data-start="988.029" data-end="994.949">With the bitfils, it's one instruction to the processor to clear the contingent memory,</span> <span data-start="994.949" data-end="997.759">and that's it.</span> </p>
<p><span data-start="997.759" data-end="1006.579">With the bitfil, it's a smaller contiguous memory usage and allows for fast access for</span> <span data-start="1006.579" data-end="1007.6">a single bit.</span> <span data-start="1007.6" data-end="1014.17">It's one twice operator, and that's it.</span> <span data-start="1014.17" data-end="1015.449">So that is bitfils.</span> <span data-start="1015.449" data-end="1019.209">They're used by both Angular and React.</span> <span data-start="1019.209" data-end="1022.899">The last date structure is bloom filters.</span> <span data-start="1022.899" data-end="1027.2">It's an interesting data structure.</span> <span data-start="1027.2" data-end="1033.67">This data structure is designed to answer one simple question: is it element in the</span> <span data-start="1033.67" data-end="1036.15">set or not?</span> <span data-start="1036.15" data-end="1043.42">Well, you can use an array, of course, and just go over each element, make a comparison</span> <span data-start="1043.42" data-end="1046.12">and figure out whether there is an element in the set or not.</span> </p>
<p><span data-start="1046.12" data-end="1047.12">It's quite long.</span> <span data-start="1047.12" data-end="1052.49">You can imagine you have one million objects, you need to go through every single one, and</span> <span data-start="1052.49" data-end="1053.49">it's pretty long.</span> <span data-start="1053.49" data-end="1057.6">Well, bloom filters allows you to do that with just one operation.</span> <span data-start="1057.6" data-end="1062.34">I show you how to do that.</span> <span data-start="1062.34" data-end="1069.9">What is good about bloom filters is you can get two types of answers — yes or no — and,</span> <span data-start="1069.9" data-end="1075.31">when you get the answer no, it means the element is definitely not in the set.</span> <span data-start="1075.31" data-end="1080.01">But when you get the answer yes, it's not actually yes, it's maybe.</span> <span data-start="1080.01" data-end="1084.11">The probability varies.</span> <span data-start="1084.11" data-end="1087.62">Because of that, this data structure is called probabilistic, right?</span> </p>
<p><span data-start="1087.62" data-end="1091.33">There is probability here.</span> <span data-start="1091.33" data-end="1094.78">You might be looking at that and thinking to yourself, "Who needs a data structure that</span> <span data-start="1094.78" data-end="1098.67">doesn't give you correct answer s?"</span> <span data-start="1098.67" data-end="1107.26">This data structure is used most often when you expect the answer no most of the time.</span> <span data-start="1107.26" data-end="1109.72">And this is exactly the case that I will present to you now.</span> <span data-start="1109.72" data-end="1116.35">But first, I will show you how this data structure works, so each element in the set is encoded</span> <span data-start="1116.35" data-end="1123.04">in a bitfil — one bitfils, or a few bitfils — you will have a hashing function that will</span> <span data-start="1123.04" data-end="1126.57">take a value and produce some number.</span> <span data-start="1126.57" data-end="1132.85">For example, for John, if we run the function and we get the number 2, for example, we use</span> <span data-start="1132.85" data-end="1139.72">the first letter and the code, for the letter, we will just use a binary or operator to set</span> <span data-start="1139.72" data-end="1142.17">the second bit.</span> </p>
<p><span data-start="1142.17" data-end="1149.43">And later, we will use the same function to get the number for John, but now we will use</span> <span data-start="1149.43" data-end="1156.7">the B twice or operator to check if the John is here.</span> <span data-start="1156.7" data-end="1161.5">You can imagine if the bit is not set, if it is zero, it means that John is not here.</span> <span data-start="1161.5" data-end="1167.77">Now, where the problem is why, yes, it's not guaranteed.</span> <span data-start="1167.77" data-end="1170.89">The problem is collisions.</span> <span data-start="1170.89" data-end="1176.75">If we use the same hashing function and we use, for example, the only first letter to</span> <span data-start="1176.75" data-end="1184.69">figure out the number, we're passing John and Jane, they have the same first letter.</span> <span data-start="1184.69" data-end="1186.49">Here we have a collision, right?</span> <span data-start="1186.49" data-end="1193.29">We end up with the John being in the set and Jane not being in the set, but the hash function</span> <span data-start="1193.29" data-end="1201.16">would produce the same value and we get a wrong result.</span> </p>
<p><span data-start="1201.16" data-end="1203.02">So where does Angular use this?</span> <span data-start="1203.02" data-end="1207.04">It uses in a dependency injection system.</span> <span data-start="1207.04" data-end="1210.74">So the cornerstone of the dependency injection system is an injector.</span> <span data-start="1210.74" data-end="1217.03">It's a service, a container, where you can con figure the dependencies between services,</span> <span data-start="1217.03" data-end="1222.42">and then the injectors responsible for instantiating them.</span> <span data-start="1222.42" data-end="1229.76">Whereas most systems have only single injector called Global Injector, Angular has a hierarchical</span> <span data-start="1229.76" data-end="1238.13">dependency injection, so, for the hierarchy of components, it creates an injector.</span> <span data-start="1238.13" data-end="1244.32">For each component, you get an extra injector, so you end up with a hierarchy of injectors,</span> <span data-start="1244.32" data-end="1251.81">and let's say the widget manager is provided in the top-most injector, or the bottom-most</span> <span data-start="1251.81" data-end="1256.14">one requires on the widget.</span> </p>
<p><span data-start="1256.14" data-end="1262.9">Angular would have to go through every single injector to figure out where exactly is this</span> <span data-start="1262.9" data-end="1270.46">service, and only when it reaches the bottom-most injector it will be able to resolve the component.</span> <span data-start="1270.46" data-end="1276.69">You can imagine it could take quite a while, for example, if every single injector has</span> <span data-start="1276.69" data-end="1282.3">ten dependencies, ten services, it would need to go through every single one of them and</span> <span data-start="1282.3" data-end="1285.53">do comparison which is a long time.</span> </p>
<p><span data-start="1285.53" data-end="1291.93">So what Angular does, it introduces a bloom filter for every single injector, and with</span> <span data-start="1291.93" data-end="1298.54">bloom filter, as I showed you, it's one operation to know whether the service is in the set</span> <span data-start="1298.54" data-end="1301.45">or not.</span> <span data-start="1301.45" data-end="1314.3">As I told you, the answer is most likely to go to be no, to so here, no here, and the</span> <span data-start="1314.3" data-end="1317.63">last, the top-most, the answer is maybe.</span> <span data-start="1317.63" data-end="1325.46">If we get the answer maybe, then we can do our actual comparison and find the service</span> <span data-start="1325.46" data-end="1327.86">if it is there.</span> </p>
<p><span data-start="1327.86" data-end="1331.03">So that is bloom filter for you.</span> <span data-start="1331.03" data-end="1336.81">Okay, so here's a bunch of protocols that, if you're interested in that kind of flow-level</span> <span data-start="1336.81" data-end="1345.54">details, I've written about reverse engineering, because I've reverse engineered webpack, other</span> <span data-start="1345.54" data-end="1352.21">tools, change detection in Angular, and reconciliation in React.</span> <span data-start="1352.21" data-end="1354.4">So here are the articles for you to check out.</span> <span data-start="1354.4" data-end="1359.61">Also, if you want to learn more about this kind of topics, you can follow me on Twitter.</span> <span data-start="1359.61" data-end="1366.07">I regularly write about some findings that I pick in these frameworks, and I've written</span> <span data-start="1366.07" data-end="1371.4">about my journey, the article you can also read.</span> </p>
<p><span data-start="1371.4" data-end="1376.37">So I hope that the knowledge that I've told you today that is awakened your curiosity</span> <span data-start="1376.37" data-end="1381.961">to learn more about this kind of stuff, and I want you never to stop learning, and, by</span> <span data-start="1381.961" data-end="1385.9">doing so, you will be able to reach new heights every day.</span> <span data-start="1385.9" data-end="1388.65">Because I want you all guys to be extraordinary engineers.</span> <span data-start="1388.65" data-end="1390.76">Thank you for your attention, and good luck.</span> </p>
</section>