<section>
<p><span data-start="3.139" data-end="23.08">Franziska Hinkelmann — JavaScript engines how do they even?</span> </p>
</section>

<section>
<p><span data-start="42.35" data-end="45.66"><span class="speaker">Franziska</span>: Good morning, are you pumped about low-level JavaScript stuff. That's what we</span> <span data-start="45.66" data-end="50.27">are going to do now. I'm Franziska Hinkelmann on the V8 team, in Munich, not that far away.</span> <span data-start="50.27" data-end="58.039">V8 is being developed in Germany for the most part. V8 is the JavaScript engine, and my</span> <span data-start="58.039" data-end="65.449">work focuses a lot on performance optimisations for ES6 and ES6 next features and I talk to</span> <span data-start="65.449" data-end="73.86">you about JavaScript engines now. Engines: why would you care about engines at all? Well,</span> <span data-start="73.86" data-end="78.729">if you have any JavaScript source code and you run it, it's always the engine that runs</span> <span data-start="78.729" data-end="88.1">it for you. It doesn't matter if you run it in the browser, or node node.js or an IoT</span> <span data-start="88.1" data-end="93.57">device, to go from something you write to executing that, that's what the engines are</span> <span data-start="93.57" data-end="101.079">doing. JavaScript engines are the heart of everything that we do. JavaScript engines</span> <span data-start="101.079" data-end="106.96">have been evolved a lot in the last 22 years. We can run massive complex frameworks and</span> <span data-start="106.96" data-end="112.409">enterprise node.js service and there is a lot of cool technology in JavaScript engines.</span> <span data-start="112.409" data-end="119.11">I hope in the next 20 minutes to give you a bit of an idea what's happening inside those</span> <span data-start="119.11" data-end="124.74">engines, what is making your code run so fast? I will be talking a little bit about performance,</span> <span data-start="124.74" data-end="131.2">and I just want to point out when I talk about performance, I mean specifically only JavaScript</span> <span data-start="131.2" data-end="135.881">performance, like computing and running actual JavaScript. I'm not talking about all the</span> <span data-start="135.881" data-end="140.5">other things that are super important for performance like DOM and rendering and network</span> <span data-start="140.5" data-end="150.099">latency. When I say performance, I mean computing and running JavaScript. There are several</span> </p>
<p><span data-start="150.099" data-end="156.159">JavaScript engines, all the major browsers have their own JavaScript engine, and it is</span> <span data-start="156.159" data-end="161.87">really good there are several engines because more engines mean competition. Competition</span> <span data-start="161.87" data-end="171.86">really means better performance and better adherence to the standard. In the major browsers,</span> <span data-start="171.86" data-end="182.54">just to drop a few names, up there, JavaScript -</span> <span data-start="182.54" data-end="190.33">Spidermonkey is in Firefox by Mozilla and V8 is in Chrome. If you run node.js, you know</span> <span data-start="190.33" data-end="195.849">you need an engine. By default, node.js comes with V8 but there is a Chakra core build of</span> <span data-start="195.849" data-end="201.65">node.js and there you get node.js with a Microsoft Chakra engine, and there is a SpiderNode project</span> <span data-start="201.65" data-end="213.879">using Spidermonkey. Again, if you're working on IoT, if you work on small devices, you</span> <span data-start="213.879" data-end="220.08">might want to trade in performance for memory size. The performance on the browsers are</span> <span data-start="220.08" data-end="227.58">fast, they take up a lot of memory. On IoT devices, you can take smaller engines somewhat</span> <span data-start="227.58" data-end="244.22">slower but they fit, like Duktape or Jerryscript. The ECMAScript is designed by the TC39 committee.</span> </p>
<p><span data-start="244.22" data-end="249.76">They discuss additions and changes to the language and formalise it as a standard, and</span> <span data-start="249.76" data-end="255.689">then we engine implementers implement those standards to give you JavaScript. That's really</span> <span data-start="255.689" data-end="262.941">cool before we have a TC39 panel here this afternoon, so some committee members are here</span> <span data-start="262.941" data-end="267.72">to answer your questions, and they still take questions, so you can Tweet some questions</span> <span data-start="267.72" data-end="271.72">for the panel this afternoon. If you want to know what is happening in the language,</span> <span data-start="271.72" data-end="281.57">what is the take on a few changes, like that. All right, so JavaScript is a standard. We</span> <span data-start="281.57" data-end="287.45">implement that. And the engine is the thing responsible for using the rules on the standard</span> <span data-start="287.45" data-end="294.89">and then to run your JavaScript. What is a really cool thing about JavaScript, besides</span> <span data-start="294.89" data-end="301.45">the awesome community and JSConf? One thing that I think is really cool is that if you</span> <span data-start="301.45" data-end="308.28">write JavaScript code, and you have variables, you can just say var x equals something. You</span> <span data-start="308.28" data-end="319.08">don't have to worry about what that x actually is. You can use var or const but you don't</span> <span data-start="319.08" data-end="326.11">have to distinguish upfront if you have a number, a string, or an array. If you have</span> <span data-start="326.11" data-end="331.68">ever written C++, the rules are really, really strict, and you first have to figure out and</span> <span data-start="331.68" data-end="339.29">read up a lot about integers just to get your first "hello world" program running. If you</span> <span data-start="339.29" data-end="346.79">write C++ and want to define a variable that values 17, you have to specify and know what</span> <span data-start="346.79" data-end="354.37">you want to specify. In this case, I'm specifying aspect and integer which can be a whole number,</span> <span data-start="354.37" data-end="361">positive or negative. They can only be — within a certain range, so, if your number gets too</span> <span data-start="361" data-end="367.77">big, it doesn't fit into an integer any more. If you write JavaScript, don't care about</span> <span data-start="367.77" data-end="372.75">any of that. That makes it really simple for us. We don't have to worry about this. It</span> <span data-start="372.75" data-end="378.94">makes it easy to get started, it makes it easier to explain it, it makes prototyping</span> <span data-start="378.94" data-end="386.29">usually faster, so that's a really cool thing for a language. And we call this the language</span> <span data-start="386.29" data-end="392.61">is dynamically typed, so a language like C++ where you have to define this is considered</span> <span data-start="392.61" data-end="401.7">statically typed. It is not only about the basic types, strings where you think you can</span> <span data-start="401.7" data-end="408.88">figure out where they are and say not not much more work. This is for more complex objects.</span> </p>
<p><span data-start="408.88" data-end="414.65">When you have any objects in JavaScript, you can add and delete properties as you wish,</span> <span data-start="414.65" data-end="419.88">as you need, you don't have to make that clear beforehand. So this object here as the properties</span> <span data-start="419.88" data-end="427.08">x and y but if needed, it can delete a property, it can add a property. I have access to all</span> <span data-start="427.08" data-end="433.28">the properties on the prototype change which I can also change. So, that's something that</span> <span data-start="433.28" data-end="440.47">makes it easy to work with objects, and sometimes, it would be even impossible to specify beforehand</span> <span data-start="440.47" data-end="445.62">what exactly your object is like. If you get a bunk of Jason over the net and turn it into</span> <span data-start="445.62" data-end="452.41">an object, sometimes, you don't know actually what the properties will be. For us as developers,</span> <span data-start="452.41" data-end="457.83">that's super useful. It makes it a little bit easier. If you're a compiler, though,</span> <span data-start="457.83" data-end="463.72">this is not good, because you give so little information to the compiler, the compilers</span> <span data-start="463.72" data-end="468.49">have a hard time generating machine code which is fast if they have no information. That's</span> <span data-start="468.49" data-end="474.28">why the point in C++ you specify all that because the compiler needs this information</span> <span data-start="474.28" data-end="483.38">upfront so it can compile your code into an executable. C++ is statically typed not to</span> <span data-start="483.38" data-end="488.721">make it hard for developers because that allows you to generate fast machine code when you</span> <span data-start="488.721" data-end="501.62">compile C++. But know know JavaScript is pretty fast, right? We have huge libraries, huge</span> <span data-start="501.62" data-end="508.33">frameworks, we run all these JavaScript tools to transpile our code. JavaScript is really</span> <span data-start="508.33" data-end="513.709">fast, even though it is dynamically typed, and we have all this freedom when we are using</span> <span data-start="513.709" data-end="520.27">objects and types. And the trick that all modern JavaScript engines use is so-called</span> <span data-start="520.27" data-end="530.031">just In Time compilation, abbreviated as JIT compilation which means "just in time. What</span> <span data-start="530.031" data-end="537.83">that means is we're not first compiling ahead of tame, finished a compilation and then run</span> <span data-start="537.83" data-end="543.49">the code, we are mixing these two steps together and we're using information from running the</span> <span data-start="543.49" data-end="550.45">code to recompiling the code. So we are compiling the source code just in time as we need it,</span> <span data-start="550.45" data-end="555.81">we collect some information when we run it, and then we recompile this source code. If</span> <span data-start="555.81" data-end="562.47">you think about C++ again which is compiled ahead of time, it is two separate steps. You</span> <span data-start="562.47" data-end="567.59">first compile it, you get an executable, and then you run that executable. In JavaScript,</span> <span data-start="567.59" data-end="576.07">that is one step. If you start a node — note process, you say note server just — it is</span> <span data-start="576.07" data-end="582.46">all together because compilation and execution goes at the same time and there is feedback</span> <span data-start="582.46" data-end="592.2">going back and forth to speed up the execution. What modern engines have is they don't have</span> <span data-start="592.2" data-end="597.85">one compiler, they have at least two compilers where one of them is an optimising compiler.</span> </p>
<p><span data-start="597.85" data-end="605.44">The main concept I want you to take away here is we have an optimising compiler that is</span> <span data-start="605.44" data-end="609.52">recompiling hot functions, so a function that you're using a lot that is worth speeding</span> <span data-start="609.52" data-end="615.61">up is considered hot, that is recompiled by the optimising compiler which means we compile</span> <span data-start="615.61" data-end="620.87">the code, we run it a few times, we collect information about the types and then we say,</span> <span data-start="620.87" data-end="625.76">"Oh, this function is not, let's make it faster by using the information that we have got</span> <span data-start="625.76" data-end="633.59">at so far." So when we're recompiling, when we're optimising, we're recompiling assuming</span> <span data-start="633.59" data-end="638.94">that we will see similar types as before, so we bake in this information in the optimised</span> <span data-start="638.94" data-end="646.12">machine code. Now since JavaScript does dynamically type, no-one is forcing you to keep that same</span> <span data-start="646.12" data-end="651.24">type, and you can change the kind of inputs you give to your functions, so it might happen</span> <span data-start="651.24" data-end="656.56">that, at some point, you run this optimised function on different kind of objects and</span> <span data-start="656.56" data-end="661.68">then you have to de-optimise, you can use this optimised code for that, and you fall</span> <span data-start="661.68" data-end="669.78">back to the baseline compiler. So, compile, run a few times, optimise, assuming certain</span> <span data-start="669.78" data-end="676.17">conditions, run the optimised code, if the conditions fail, go back to the basic code.</span> </p>
<p><span data-start="676.17" data-end="682.51">Now, so you start with JavaScript source code, then the parser generates an abstract syntax</span> <span data-start="682.51" data-end="690.691">tree. I will not talk about the parser because my co-worker Marja will tell you how we parse</span> <span data-start="690.691" data-end="696.48">JavaScript and how you can write it to make it a little faster. The source code is consumed</span> <span data-start="696.48" data-end="702.79">by the parser and then we generate an abstract syntax stream. Then a compiler is using that</span> <span data-start="702.79" data-end="710.8">abstract syntax stream to make the machine code. We collect the information and pass</span> <span data-start="710.8" data-end="717.09">it on to the optimising compiler to generate faster machine code. Every once in a while,</span> <span data-start="717.09" data-end="723.63">we have to bail out de-optimised, do an OSI exit to go back to the slower baseline machine</span> <span data-start="723.63" data-end="733.87">code. In the V8 engine, the baseline compiler is an interpreter called Ignition, and the</span> <span data-start="733.87" data-end="743.09">optimising compiler is called TurboFan. If you hear about them not in relation to cars,</span> <span data-start="743.09" data-end="753.24">it is about the compiler pipeline in V8! It used to be crank shaft, we fixed it out, ignition,</span> <span data-start="753.24" data-end="764.02">make Chrome and node fast. In Spidermonkey the optimising compiler is Ironmonkey, and</span> <span data-start="764.02" data-end="776.14">there are a few more around where Safari, they don't have one optimising compilers but</span> <span data-start="776.14" data-end="784.75">two, so a low-level interpreter and a DFG optimising compiler and B3, and Chakra also</span> <span data-start="784.75" data-end="796.36">has an optimising compiler. The optimising compiler uses previously seen type information.</span> </p>
<p><span data-start="796.36" data-end="802.25">If you change your objects all the time, then we cannot generate good optimised code or</span> <span data-start="802.25" data-end="807.93">if you've generated, you have to de-optimise a lot. De-optimisation always means a small</span> <span data-start="807.93" data-end="816.05">performance hit. From the high-level concept, and now I want you show you on a really concrete</span> <span data-start="816.05" data-end="823.79">example. I'm going to show you the optimised machine code for this on an Intel processor.</span> <span data-start="823.79" data-end="828.7">I'm using a very simple example. It is a load function that takes the parameter and all</span> <span data-start="828.7" data-end="836.35">it does is is it returns object at x. The property examine is, you do it all — property</span> <span data-start="836.35" data-end="843.31">axis in JavaScript is fairly complicated for the compiler because if you have an object</span> <span data-start="843.31" data-end="848.2">that a compiler doesn't know anything about it and you want x, you don't know where is</span> <span data-start="848.2" data-end="853.68">this x? Does this object have an x? Is it may be under prototype chain? How are the</span> <span data-start="853.68" data-end="858.13">properties stored for the object? Where in the memory is the value for x? In implement,</span> <span data-start="858.13" data-end="867.54">this does quite a lot of work to do something like "object that x". So, one small thing</span> </p>
<p><span data-start="867.54" data-end="872.071">I have to explain before we get started is how objects are represented internally. We</span> <span data-start="872.071" data-end="881.861">represent object types incrementally by transitioning for every property to a new type. So, if you</span> <span data-start="881.861" data-end="889.36">have an empty object literal, it is represented by just object, basically. If you have a literal</span> <span data-start="889.36" data-end="894.69">with a property x, then we transition from the empty literal type to the next type that's</span> <span data-start="894.69" data-end="899.85">a literal with an x property. And then if you have more properties, we transition over</span> <span data-start="899.85" data-end="905.55">to more types of objects, so that's an internal representation since you don't have to specify</span> <span data-start="905.55" data-end="911.36">a class or anything in JavaScript, you can just modify object types as you want. Internally,</span> <span data-start="911.36" data-end="917.44">we keep track of a type of objects. And because of these transitions, it is actually making</span> <span data-start="917.44" data-end="923.67">a difference if your object has x defined first or y defined first, so just because</span> <span data-start="923.67" data-end="929.991">two objects have the same properties, they're not the same type internally. All right, so</span> <span data-start="929.991" data-end="936.87">I'm running the load function a few times, and I'm always running them with these objects</span> <span data-start="936.87" data-end="942.21">here. They look similar, but it is not the same objects. The X and Y values are obviously</span> <span data-start="942.21" data-end="947.51">different. But all these objects have the same shape. Internally, they all correspond</span> <span data-start="947.51" data-end="953.13">to this kind of object. So, if I'm running the function a lot, eventually, the compiler</span> <span data-start="953.13" data-end="958.23">says, "Hey, this is a hot function, let's optimise it" and this is what it is being</span> <span data-start="958.23" data-end="965.88">optimised to. So this is assembly code. But I will explain to you what is happening here.</span> </p>
<p><span data-start="965.88" data-end="970.69">So, at the top, I left out a little bit of stuff, this is where we said up the stack</span> <span data-start="970.69" data-end="977.75">- set up the stack when we enter the function. The important thing is here: this address</span> <span data-start="977.75" data-end="983.74">corresponds to the type of the object that we fed the function with. So, internally,</span> <span data-start="983.74" data-end="992.55">this address represents an object that has an x and a y. So this is optimised code that</span> <span data-start="992.55" data-end="998.61">was generated after we have run the function a few times. And it has memorised this type,</span> <span data-start="998.61" data-end="1005.149">and now when we run this function again in assembly code low-level, register level, we</span> <span data-start="1005.149" data-end="1013.18">load this type, and then we do a comparison. We are comparing our parameter where it has</span> <span data-start="1013.18" data-end="1020.649">the same type as what we saved before. We run it and say does the new parameter look</span> <span data-start="1020.649" data-end="1028.89">like the things we've seen in the past? If the comparison is true, we move over here</span> <span data-start="1028.89" data-end="1035.819">where we just — where we now are getting the value of x. So this is the address of the</span> <span data-start="1035.819" data-end="1042.61">object plus 17, which means take a memory offset off the object because we know at this</span> <span data-start="1042.61" data-end="1049.15">position, it is the x value. So this short cut corresponds to the value for x. And we</span> <span data-start="1049.15" data-end="1054.679">can just take that from memory and be done with it. That is getting object of x. We don't</span> <span data-start="1054.679" data-end="1058.391">have to look in the prototype chain or see if there are side effects or anything. Just</span> <span data-start="1058.391" data-end="1066.12">say if this kind of object comes, then the value is here in memory. Now, if we are calling</span> <span data-start="1066.12" data-end="1071.69">the optimised code with an object that looks different than this kind of object, then the</span> <span data-start="1071.69" data-end="1078.92">comparison of the object types is going to fail, and we have to do a jump down to 5a</span> <span data-start="1078.92" data-end="1085.2">and 5a is a de-optimisation bail-out. On that schematic, de-optimisation bail-out is the</span> <span data-start="1085.2" data-end="1092.92">point from where we go from the fast optimised code back to the slow baseline code because</span> <span data-start="1092.92" data-end="1099.62">we don't have optimised code to handle the code if we run it with different kind of objects,</span> <span data-start="1099.62" data-end="1105.49">because if we say, "For any kind of objects, the x value is over here in memory", that</span> <span data-start="1105.49" data-end="1114.28">would be wrong. When you write JavaScript code, it is actually compiled to machine code</span> <span data-start="1114.28" data-end="1119.29">like this, that looks different depending on your system's architecture, that this is</span> <span data-start="1119.29" data-end="1127.3">what is happening at the very basis when you're running JavaScript code. When I ran this function</span> <span data-start="1127.3" data-end="1132.9">with objects that have a different type — like these objects here have different properties</span> <span data-start="1132.9" data-end="1138.61">so we don't consider them the same type, one has an a, one doesn't, it has a b property</span> <span data-start="1138.61" data-end="1146.61">instead — to optimise the machine code looks very similar to what we've just seen, instead</span> <span data-start="1146.61" data-end="1153.88">of one type, we have four types now, one that corresponds to every input that we have recorded</span> <span data-start="1153.88" data-end="1160.13">before. So we do four comparisons, if we match either one of those with the new object we've</span> <span data-start="1160.13" data-end="1167.651">put in, we say short cut, take the value of a memory from here, we are done with it. If</span> <span data-start="1167.651" data-end="1176.92">none of them matches, then we jump, and, again, we are jumping to a de-optimisation. So, depending</span> <span data-start="1176.92" data-end="1183.79">on the input values that we've observed, the optimised code looks different — like the</span> <span data-start="1183.79" data-end="1189.74">first one had one comparison, this had four comparisons. Now, you're saying, okay, so</span> <span data-start="1189.74" data-end="1195.059">you're just adding comparisons for every single input type, but you can see this doesn't sail</span> <span data-start="1195.059" data-end="1200.05">because then you have these if compares, if compares, it would take forever and really</span> <span data-start="1200.05" data-end="1207.87">blow up memory. What we do is, if you have more than four types, we actually don't compare</span> <span data-start="1207.87" data-end="1215.28">to all the types any more, this address here does not correspond to a specific type. This</span> <span data-start="1215.28" data-end="1222.89">one just points to string x because we wanted the property x, and we have to call into function</span> <span data-start="1222.89" data-end="1229.44">which is now looking up property x in a big pool of 3,000 entries. You can imagine in</span> <span data-start="1229.44" data-end="1234.49">machine code, it looks short, but this is an expensive call here. It is much more expensive</span> <span data-start="1234.49" data-end="1243.12">than just saying, "Move this from memory over here." As a performance tip at this really,</span> <span data-start="1243.12" data-end="1250.36">really low level of engine-level performance things, one thing that helps de-optimising</span> <span data-start="1250.36" data-end="1255.7">compilers or the JavaScript engines in general is if you are always using the same type of</span> <span data-start="1255.7" data-end="1263.1">objects. So, if your objects represent the same thing anyways, and if it is possible</span> <span data-start="1263.1" data-end="1268.93">in not making your code terribly unreadable, try to make them the same type for the engine.</span> </p>
<p><span data-start="1268.93" data-end="1276.66">So, for example, in this case, this is exactly the same information as to slides before,</span> <span data-start="1276.66" data-end="1282.75">except that I'm always adding b, c. D, as  to all the objects. Now, for the</span> <span data-start="1282.75" data-end="1288.12">compiler, this is considered one object type, and the optimised code is nice and short,</span> <span data-start="1288.12" data-end="1294.23">there is exactly one type of object that corresponds to this bigger object with all the parameters,</span> <span data-start="1294.23" data-end="1305.03">and then there is one comparison saying is this the same? Use the value done. This is</span> <span data-start="1305.03" data-end="1312.1">the general idea. Store information or collect information by running, recompile, assuming</span> <span data-start="1312.1" data-end="1317.61">we get the exact same type of inputs — like different values but similar types — and then</span> <span data-start="1317.61" data-end="1323.76">the resulting code is really fast as long as you don't change types. We recently implemented</span> <span data-start="1323.76" data-end="1331.22">this speed-up for an ES6 feature. In ES6, you have the option to define object literals</span> <span data-start="1331.22" data-end="1337.299">with computer property names. In ES5 when you had a variable as a key, you first had</span> <span data-start="1337.299" data-end="1344.44">to create the object and then you could set that property. So, if x is a variable and</span> <span data-start="1344.44" data-end="1353.231">you want o of x, you have to create the literal. In ES6, you can do this in one step. Just</span> <span data-start="1353.231" data-end="1361.35">use the brackets inside the object notation. We saw in benchmarks that this right-hand</span> <span data-start="1361.35" data-end="1368.2">side is a lot slower than the ES5 equivalent. You saw in the last talk the list of benchmarks,</span> <span data-start="1368.2" data-end="1373.05">the yellow and green thing. This one was red because it was so much slower than the ES5</span> <span data-start="1373.05" data-end="1379.77">counterpart. But we applied the same principle. A lot of times in this kind of code, the x</span> <span data-start="1379.77" data-end="1385.88">is a symbol, and every function runs is the same symbol, so we applied this principle</span> <span data-start="1385.88" data-end="1391.98">here. We run the code a few times, we memorise what x is and optimise to a fast pass saying</span> <span data-start="1391.98" data-end="1398.02">if it is the same symbol we've seen all the time, then this is the kind of object we are</span> <span data-start="1398.02" data-end="1404.35">creating instead of to make the these expensive object transitions when we are creating this</span> <span data-start="1404.35" data-end="1411.429">every time. So by applying these optimisation principles, we've got a ten-times speed-up</span> <span data-start="1411.429" data-end="1421.179">on that benchmark, and the yellow-green benchmark list is on par with the ES5 equivalent. You</span> <span data-start="1421.179" data-end="1426.02">can use this ES6 feature without having to worry that it would slow down your performance</span> <span data-start="1426.02" data-end="1434.72">if that is really critical to you. So far, the high-level overview, you can't put too</span> <span data-start="1434.72" data-end="1440.09">much into 25 minutes. I hope I was able to give you some idea of what is going on. If</span> <span data-start="1440.09" data-end="1444.41">you want to dig deeper into that, of course you can try it out yourself and make your</span> <span data-start="1444.41" data-end="1451.68">own experiments and see what is going on. All the engines are open source, or all the</span> <span data-start="1451.68" data-end="1457.32">engines I mentioned are open source. You can get the source code, look at that, of course.</span> </p>
<p><span data-start="1457.32" data-end="1464.35">But you can play around with it. You probably have Node installed anyways, so use Note or</span> <span data-start="1464.35" data-end="1473.35">Chrome and palace in a few — if you pass in print opt code you will see the optimised</span> <span data-start="1473.35" data-end="1487.231">code that I have just shown you. So, because of how JavaScript is dynamically typed, we</span> <span data-start="1487.231" data-end="1493.64">have to use JIT compilation to get any kind of speed speed. Because of how the optimising</span> <span data-start="1493.64" data-end="1501.97">compilers under JIT work, your JavaScript code, if it's statically typed, then that's</span> <span data-start="1501.97" data-end="1504.01">the best thing you can do for the compilers. Thank you. [Cheering].</span> <span data-start="1504.01" data-end="1505.01"Audience member: Thank you very much to Franziska for the excellent introduction to how the engine works</span> <span data-start="1505.01" data-end="1506.01">in JavaScript — very interesting topic. I think when we work practically with JavaScript,</span> <span data-start="1506.01" data-end="1507.01">we don't know what is going on on the system level, we don't know how our code is being</span> <span data-start="1507.01" data-end="1508.01">compiled. We're going to start again in just a couple of minutes with our next talk, and,</span> <span data-start="1508.01" data-end="1509.01">if anyone is here what is curious going on in the other track, we have Ben Vinegar talking</span> <span data-start="1509.01" data-end="1510.01">about source maps. Graph QL has put fliers out on the table. They have a discount code.</span> <span data-start="1510.01" data-end="1511.01">It is another conference that's going to be taking place just across the river on 21st</span> </p>
</section>