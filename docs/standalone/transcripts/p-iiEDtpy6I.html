<!DOCTYPE html>

<!--
Copyright 2019 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="author" content="//google.com">
  <meta name="description" content="JSConf transcript">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>p-iiEDtpy6I</title>
  <link rel="stylesheet" href="../css/main.css">
</head>

<body>

<iframe id="youtube" src="https://www.youtube.com/embed/p-iiEDtpy6I?enablejsapi=1"></iframe>

<div id="container">

<div id="options">
  <div id="google-translate"></div>
  <div>
    <input type="checkbox" id="videoSticky" checked>
    <label for="videoSticky">Video position sticky</label>
  </div>
  <div>
    <input type="checkbox" id="captionScroll" checked>
    <label for="captionScroll">Keep current caption visible</label>
  </div>
</div>

<section>
<p><span data-start="3.139" data-end="23.08">Franziska Hinkelmann — JavaScript engines how do they even?</span> </p>
</section>

<section>
<p><span data-start="42.35" data-end="45.66"><span class="speaker">Franziska</span>: Good morning, are you pumped about low-level JavaScript stuff. That's what we</span> <span data-start="45.66" data-end="50.27">are going to do now. I'm Franziska Hinkelmann on the V8 team, in Munich, not that far away.</span> <span data-start="50.27" data-end="58.039">V8 is being developed in Germany for the most part. V8 is the JavaScript engine, and my</span> <span data-start="58.039" data-end="65.449">work focuses a lot on performance optimisations for ES6 and ES6 next features and I talk to</span> <span data-start="65.449" data-end="73.86">you about JavaScript engines now. Engines: why would you care about engines at all? Well,</span> <span data-start="73.86" data-end="78.729">if you have any JavaScript source code and you run it, it's always the engine that runs</span> <span data-start="78.729" data-end="88.1">it for you. It doesn't matter if you run it in the browser, or node node.js or an IoT</span> <span data-start="88.1" data-end="93.57">device, to go from something you write to executing that, that's what the engines are</span> <span data-start="93.57" data-end="101.079">doing. JavaScript engines are the heart of everything that we do. JavaScript engines</span> <span data-start="101.079" data-end="106.96">have been evolved a lot in the last 22 years. We can run massive complex frameworks and</span> <span data-start="106.96" data-end="112.409">enterprise node.js service and there is a lot of cool technology in JavaScript engines.</span> <span data-start="112.409" data-end="119.11">I hope in the next 20 minutes to give you a bit of an idea what's happening inside those</span> <span data-start="119.11" data-end="124.74">engines, what is making your code run so fast? I will be talking a little bit about performance,</span> <span data-start="124.74" data-end="131.2">and I just want to point out when I talk about performance, I mean specifically only JavaScript</span> <span data-start="131.2" data-end="135.881">performance, like computing and running actual JavaScript. I'm not talking about all the</span> <span data-start="135.881" data-end="140.5">other things that are super important for performance like DOM and rendering and network</span> <span data-start="140.5" data-end="150.099">latency. When I say performance, I mean computing and running JavaScript. There are several</span> </p>
<p><span data-start="150.099" data-end="156.159">JavaScript engines, all the major browsers have their own JavaScript engine, and it is</span> <span data-start="156.159" data-end="161.87">really good there are several engines because more engines mean competition. Competition</span> <span data-start="161.87" data-end="171.86">really means better performance and better adherence to the standard. In the major browsers,</span> <span data-start="171.86" data-end="182.54">just to drop a few names, up there, JavaScript -</span> <span data-start="182.54" data-end="190.33">Spidermonkey is in Firefox by Mozilla and V8 is in Chrome. If you run node.js, you know</span> <span data-start="190.33" data-end="195.849">you need an engine. By default, node.js comes with V8 but there is a Chakra core build of</span> <span data-start="195.849" data-end="201.65">node.js and there you get node.js with a Microsoft Chakra engine, and there is a SpiderNode project</span> <span data-start="201.65" data-end="213.879">using Spidermonkey. Again, if you're working on IoT, if you work on small devices, you</span> <span data-start="213.879" data-end="220.08">might want to trade in performance for memory size. The performance on the browsers are</span> <span data-start="220.08" data-end="227.58">fast, they take up a lot of memory. On IoT devices, you can take smaller engines somewhat</span> <span data-start="227.58" data-end="244.22">slower but they fit, like Duktape or Jerryscript. The ECMAScript is designed by the TC39 committee.</span> </p>
<p><span data-start="244.22" data-end="249.76">They discuss additions and changes to the language and formalise it as a standard, and</span> <span data-start="249.76" data-end="255.689">then we engine implementers implement those standards to give you JavaScript. That's really</span> <span data-start="255.689" data-end="262.941">cool before we have a TC39 panel here this afternoon, so some committee members are here</span> <span data-start="262.941" data-end="267.72">to answer your questions, and they still take questions, so you can Tweet some questions</span> <span data-start="267.72" data-end="271.72">for the panel this afternoon. If you want to know what is happening in the language,</span> <span data-start="271.72" data-end="281.57">what is the take on a few changes, like that. All right, so JavaScript is a standard. We</span> <span data-start="281.57" data-end="287.45">implement that. And the engine is the thing responsible for using the rules on the standard</span> <span data-start="287.45" data-end="294.89">and then to run your JavaScript. What is a really cool thing about JavaScript, besides</span> <span data-start="294.89" data-end="301.45">the awesome community and JSConf? One thing that I think is really cool is that if you</span> <span data-start="301.45" data-end="308.28">write JavaScript code, and you have variables, you can just say var x equals something. You</span> <span data-start="308.28" data-end="319.08">don't have to worry about what that x actually is. You can use var or const but you don't</span> <span data-start="319.08" data-end="326.11">have to distinguish upfront if you have a number, a string, or an array. If you have</span> <span data-start="326.11" data-end="331.68">ever written C++, the rules are really, really strict, and you first have to figure out and</span> <span data-start="331.68" data-end="339.29">read up a lot about integers just to get your first "hello world" program running. If you</span> <span data-start="339.29" data-end="346.79">write C++ and want to define a variable that values 17, you have to specify and know what</span> <span data-start="346.79" data-end="354.37">you want to specify. In this case, I'm specifying aspect and integer which can be a whole number,</span> <span data-start="354.37" data-end="361">positive or negative. They can only be — within a certain range, so, if your number gets too</span> <span data-start="361" data-end="367.77">big, it doesn't fit into an integer any more. If you write JavaScript, don't care about</span> <span data-start="367.77" data-end="372.75">any of that. That makes it really simple for us. We don't have to worry about this. It</span> <span data-start="372.75" data-end="378.94">makes it easy to get started, it makes it easier to explain it, it makes prototyping</span> <span data-start="378.94" data-end="386.29">usually faster, so that's a really cool thing for a language. And we call this the language</span> <span data-start="386.29" data-end="392.61">is dynamically typed, so a language like C++ where you have to define this is considered</span> <span data-start="392.61" data-end="401.7">statically typed. It is not only about the basic types, strings where you think you can</span> <span data-start="401.7" data-end="408.88">figure out where they are and say not not much more work. This is for more complex objects.</span> </p>
<p><span data-start="408.88" data-end="414.65">When you have any objects in JavaScript, you can add and delete properties as you wish,</span> <span data-start="414.65" data-end="419.88">as you need, you don't have to make that clear beforehand. So this object here as the properties</span> <span data-start="419.88" data-end="427.08">x and y but if needed, it can delete a property, it can add a property. I have access to all</span> <span data-start="427.08" data-end="433.28">the properties on the prototype change which I can also change. So, that's something that</span> <span data-start="433.28" data-end="440.47">makes it easy to work with objects, and sometimes, it would be even impossible to specify beforehand</span> <span data-start="440.47" data-end="445.62">what exactly your object is like. If you get a bunk of Jason over the net and turn it into</span> <span data-start="445.62" data-end="452.41">an object, sometimes, you don't know actually what the properties will be. For us as developers,</span> <span data-start="452.41" data-end="457.83">that's super useful. It makes it a little bit easier. If you're a compiler, though,</span> <span data-start="457.83" data-end="463.72">this is not good, because you give so little information to the compiler, the compilers</span> <span data-start="463.72" data-end="468.49">have a hard time generating machine code which is fast if they have no information. That's</span> <span data-start="468.49" data-end="474.28">why the point in C++ you specify all that because the compiler needs this information</span> <span data-start="474.28" data-end="483.38">upfront so it can compile your code into an executable. C++ is statically typed not to</span> <span data-start="483.38" data-end="488.721">make it hard for developers because that allows you to generate fast machine code when you</span> <span data-start="488.721" data-end="501.62">compile C++. But know know JavaScript is pretty fast, right? We have huge libraries, huge</span> <span data-start="501.62" data-end="508.33">frameworks, we run all these JavaScript tools to transpile our code. JavaScript is really</span> <span data-start="508.33" data-end="513.709">fast, even though it is dynamically typed, and we have all this freedom when we are using</span> <span data-start="513.709" data-end="520.27">objects and types. And the trick that all modern JavaScript engines use is so-called</span> <span data-start="520.27" data-end="530.031">just In Time compilation, abbreviated as JIT compilation which means "just in time. What</span> <span data-start="530.031" data-end="537.83">that means is we're not first compiling ahead of tame, finished a compilation and then run</span> <span data-start="537.83" data-end="543.49">the code, we are mixing these two steps together and we're using information from running the</span> <span data-start="543.49" data-end="550.45">code to recompiling the code. So we are compiling the source code just in time as we need it,</span> <span data-start="550.45" data-end="555.81">we collect some information when we run it, and then we recompile this source code. If</span> <span data-start="555.81" data-end="562.47">you think about C++ again which is compiled ahead of time, it is two separate steps. You</span> <span data-start="562.47" data-end="567.59">first compile it, you get an executable, and then you run that executable. In JavaScript,</span> <span data-start="567.59" data-end="576.07">that is one step. If you start a node — note process, you say note server just — it is</span> <span data-start="576.07" data-end="582.46">all together because compilation and execution goes at the same time and there is feedback</span> <span data-start="582.46" data-end="592.2">going back and forth to speed up the execution. What modern engines have is they don't have</span> <span data-start="592.2" data-end="597.85">one compiler, they have at least two compilers where one of them is an optimising compiler.</span> </p>
<p><span data-start="597.85" data-end="605.44">The main concept I want you to take away here is we have an optimising compiler that is</span> <span data-start="605.44" data-end="609.52">recompiling hot functions, so a function that you're using a lot that is worth speeding</span> <span data-start="609.52" data-end="615.61">up is considered hot, that is recompiled by the optimising compiler which means we compile</span> <span data-start="615.61" data-end="620.87">the code, we run it a few times, we collect information about the types and then we say,</span> <span data-start="620.87" data-end="625.76">"Oh, this function is not, let's make it faster by using the information that we have got</span> <span data-start="625.76" data-end="633.59">at so far." So when we're recompiling, when we're optimising, we're recompiling assuming</span> <span data-start="633.59" data-end="638.94">that we will see similar types as before, so we bake in this information in the optimised</span> <span data-start="638.94" data-end="646.12">machine code. Now since JavaScript does dynamically type, no-one is forcing you to keep that same</span> <span data-start="646.12" data-end="651.24">type, and you can change the kind of inputs you give to your functions, so it might happen</span> <span data-start="651.24" data-end="656.56">that, at some point, you run this optimised function on different kind of objects and</span> <span data-start="656.56" data-end="661.68">then you have to de-optimise, you can use this optimised code for that, and you fall</span> <span data-start="661.68" data-end="669.78">back to the baseline compiler. So, compile, run a few times, optimise, assuming certain</span> <span data-start="669.78" data-end="676.17">conditions, run the optimised code, if the conditions fail, go back to the basic code.</span> </p>
<p><span data-start="676.17" data-end="682.51">Now, so you start with JavaScript source code, then the parser generates an abstract syntax</span> <span data-start="682.51" data-end="690.691">tree. I will not talk about the parser because my co-worker Marja will tell you how we parse</span> <span data-start="690.691" data-end="696.48">JavaScript and how you can write it to make it a little faster. The source code is consumed</span> <span data-start="696.48" data-end="702.79">by the parser and then we generate an abstract syntax stream. Then a compiler is using that</span> <span data-start="702.79" data-end="710.8">abstract syntax stream to make the machine code. We collect the information and pass</span> <span data-start="710.8" data-end="717.09">it on to the optimising compiler to generate faster machine code. Every once in a while,</span> <span data-start="717.09" data-end="723.63">we have to bail out de-optimised, do an OSI exit to go back to the slower baseline machine</span> <span data-start="723.63" data-end="733.87">code. In the V8 engine, the baseline compiler is an interpreter called Ignition, and the</span> <span data-start="733.87" data-end="743.09">optimising compiler is called TurboFan. If you hear about them not in relation to cars,</span> <span data-start="743.09" data-end="753.24">it is about the compiler pipeline in V8! It used to be crank shaft, we fixed it out, ignition,</span> <span data-start="753.24" data-end="764.02">make Chrome and node fast. In Spidermonkey the optimising compiler is Ironmonkey, and</span> <span data-start="764.02" data-end="776.14">there are a few more around where Safari, they don't have one optimising compilers but</span> <span data-start="776.14" data-end="784.75">two, so a low-level interpreter and a DFG optimising compiler and B3, and Chakra also</span> <span data-start="784.75" data-end="796.36">has an optimising compiler. The optimising compiler uses previously seen type information.</span> </p>
<p><span data-start="796.36" data-end="802.25">If you change your objects all the time, then we cannot generate good optimised code or</span> <span data-start="802.25" data-end="807.93">if you've generated, you have to de-optimise a lot. De-optimisation always means a small</span> <span data-start="807.93" data-end="816.05">performance hit. From the high-level concept, and now I want you show you on a really concrete</span> <span data-start="816.05" data-end="823.79">example. I'm going to show you the optimised machine code for this on an Intel processor.</span> <span data-start="823.79" data-end="828.7">I'm using a very simple example. It is a load function that takes the parameter and all</span> <span data-start="828.7" data-end="836.35">it does is is it returns object at x. The property examine is, you do it all — property</span> <span data-start="836.35" data-end="843.31">axis in JavaScript is fairly complicated for the compiler because if you have an object</span> <span data-start="843.31" data-end="848.2">that a compiler doesn't know anything about it and you want x, you don't know where is</span> <span data-start="848.2" data-end="853.68">this x? Does this object have an x? Is it may be under prototype chain? How are the</span> <span data-start="853.68" data-end="858.13">properties stored for the object? Where in the memory is the value for x? In implement,</span> <span data-start="858.13" data-end="867.54">this does quite a lot of work to do something like "object that x". So, one small thing</span> </p>
<p><span data-start="867.54" data-end="872.071">I have to explain before we get started is how objects are represented internally. We</span> <span data-start="872.071" data-end="881.861">represent object types incrementally by transitioning for every property to a new type. So, if you</span> <span data-start="881.861" data-end="889.36">have an empty object literal, it is represented by just object, basically. If you have a literal</span> <span data-start="889.36" data-end="894.69">with a property x, then we transition from the empty literal type to the next type that's</span> <span data-start="894.69" data-end="899.85">a literal with an x property. And then if you have more properties, we transition over</span> <span data-start="899.85" data-end="905.55">to more types of objects, so that's an internal representation since you don't have to specify</span> <span data-start="905.55" data-end="911.36">a class or anything in JavaScript, you can just modify object types as you want. Internally,</span> <span data-start="911.36" data-end="917.44">we keep track of a type of objects. And because of these transitions, it is actually making</span> <span data-start="917.44" data-end="923.67">a difference if your object has x defined first or y defined first, so just because</span> <span data-start="923.67" data-end="929.991">two objects have the same properties, they're not the same type internally. All right, so</span> <span data-start="929.991" data-end="936.87">I'm running the load function a few times, and I'm always running them with these objects</span> <span data-start="936.87" data-end="942.21">here. They look similar, but it is not the same objects. The X and Y values are obviously</span> <span data-start="942.21" data-end="947.51">different. But all these objects have the same shape. Internally, they all correspond</span> <span data-start="947.51" data-end="953.13">to this kind of object. So, if I'm running the function a lot, eventually, the compiler</span> <span data-start="953.13" data-end="958.23">says, "Hey, this is a hot function, let's optimise it" and this is what it is being</span> <span data-start="958.23" data-end="965.88">optimised to. So this is assembly code. But I will explain to you what is happening here.</span> </p>
<p><span data-start="965.88" data-end="970.69">So, at the top, I left out a little bit of stuff, this is where we said up the stack</span> <span data-start="970.69" data-end="977.75">- set up the stack when we enter the function. The important thing is here: this address</span> <span data-start="977.75" data-end="983.74">corresponds to the type of the object that we fed the function with. So, internally,</span> <span data-start="983.74" data-end="992.55">this address represents an object that has an x and a y. So this is optimised code that</span> <span data-start="992.55" data-end="998.61">was generated after we have run the function a few times. And it has memorised this type,</span> <span data-start="998.61" data-end="1005.149">and now when we run this function again in assembly code low-level, register level, we</span> <span data-start="1005.149" data-end="1013.18">load this type, and then we do a comparison. We are comparing our parameter where it has</span> <span data-start="1013.18" data-end="1020.649">the same type as what we saved before. We run it and say does the new parameter look</span> <span data-start="1020.649" data-end="1028.89">like the things we've seen in the past? If the comparison is true, we move over here</span> <span data-start="1028.89" data-end="1035.819">where we just — where we now are getting the value of x. So this is the address of the</span> <span data-start="1035.819" data-end="1042.61">object plus 17, which means take a memory offset off the object because we know at this</span> <span data-start="1042.61" data-end="1049.15">position, it is the x value. So this short cut corresponds to the value for x. And we</span> <span data-start="1049.15" data-end="1054.679">can just take that from memory and be done with it. That is getting object of x. We don't</span> <span data-start="1054.679" data-end="1058.391">have to look in the prototype chain or see if there are side effects or anything. Just</span> <span data-start="1058.391" data-end="1066.12">say if this kind of object comes, then the value is here in memory. Now, if we are calling</span> <span data-start="1066.12" data-end="1071.69">the optimised code with an object that looks different than this kind of object, then the</span> <span data-start="1071.69" data-end="1078.92">comparison of the object types is going to fail, and we have to do a jump down to 5a</span> <span data-start="1078.92" data-end="1085.2">and 5a is a de-optimisation bail-out. On that schematic, de-optimisation bail-out is the</span> <span data-start="1085.2" data-end="1092.92">point from where we go from the fast optimised code back to the slow baseline code because</span> <span data-start="1092.92" data-end="1099.62">we don't have optimised code to handle the code if we run it with different kind of objects,</span> <span data-start="1099.62" data-end="1105.49">because if we say, "For any kind of objects, the x value is over here in memory", that</span> <span data-start="1105.49" data-end="1114.28">would be wrong. When you write JavaScript code, it is actually compiled to machine code</span> <span data-start="1114.28" data-end="1119.29">like this, that looks different depending on your system's architecture, that this is</span> <span data-start="1119.29" data-end="1127.3">what is happening at the very basis when you're running JavaScript code. When I ran this function</span> <span data-start="1127.3" data-end="1132.9">with objects that have a different type — like these objects here have different properties</span> <span data-start="1132.9" data-end="1138.61">so we don't consider them the same type, one has an a, one doesn't, it has a b property</span> <span data-start="1138.61" data-end="1146.61">instead — to optimise the machine code looks very similar to what we've just seen, instead</span> <span data-start="1146.61" data-end="1153.88">of one type, we have four types now, one that corresponds to every input that we have recorded</span> <span data-start="1153.88" data-end="1160.13">before. So we do four comparisons, if we match either one of those with the new object we've</span> <span data-start="1160.13" data-end="1167.651">put in, we say short cut, take the value of a memory from here, we are done with it. If</span> <span data-start="1167.651" data-end="1176.92">none of them matches, then we jump, and, again, we are jumping to a de-optimisation. So, depending</span> <span data-start="1176.92" data-end="1183.79">on the input values that we've observed, the optimised code looks different — like the</span> <span data-start="1183.79" data-end="1189.74">first one had one comparison, this had four comparisons. Now, you're saying, okay, so</span> <span data-start="1189.74" data-end="1195.059">you're just adding comparisons for every single input type, but you can see this doesn't sail</span> <span data-start="1195.059" data-end="1200.05">because then you have these if compares, if compares, it would take forever and really</span> <span data-start="1200.05" data-end="1207.87">blow up memory. What we do is, if you have more than four types, we actually don't compare</span> <span data-start="1207.87" data-end="1215.28">to all the types any more, this address here does not correspond to a specific type. This</span> <span data-start="1215.28" data-end="1222.89">one just points to string x because we wanted the property x, and we have to call into function</span> <span data-start="1222.89" data-end="1229.44">which is now looking up property x in a big pool of 3,000 entries. You can imagine in</span> <span data-start="1229.44" data-end="1234.49">machine code, it looks short, but this is an expensive call here. It is much more expensive</span> <span data-start="1234.49" data-end="1243.12">than just saying, "Move this from memory over here." As a performance tip at this really,</span> <span data-start="1243.12" data-end="1250.36">really low level of engine-level performance things, one thing that helps de-optimising</span> <span data-start="1250.36" data-end="1255.7">compilers or the JavaScript engines in general is if you are always using the same type of</span> <span data-start="1255.7" data-end="1263.1">objects. So, if your objects represent the same thing anyways, and if it is possible</span> <span data-start="1263.1" data-end="1268.93">in not making your code terribly unreadable, try to make them the same type for the engine.</span> </p>
<p><span data-start="1268.93" data-end="1276.66">So, for example, in this case, this is exactly the same information as to slides before,</span> <span data-start="1276.66" data-end="1282.75">except that I'm always adding b, c. D, as  to all the objects. Now, for the</span> <span data-start="1282.75" data-end="1288.12">compiler, this is considered one object type, and the optimised code is nice and short,</span> <span data-start="1288.12" data-end="1294.23">there is exactly one type of object that corresponds to this bigger object with all the parameters,</span> <span data-start="1294.23" data-end="1305.03">and then there is one comparison saying is this the same? Use the value done. This is</span> <span data-start="1305.03" data-end="1312.1">the general idea. Store information or collect information by running, recompile, assuming</span> <span data-start="1312.1" data-end="1317.61">we get the exact same type of inputs — like different values but similar types — and then</span> <span data-start="1317.61" data-end="1323.76">the resulting code is really fast as long as you don't change types. We recently implemented</span> <span data-start="1323.76" data-end="1331.22">this speed-up for an ES6 feature. In ES6, you have the option to define object literals</span> <span data-start="1331.22" data-end="1337.299">with computer property names. In ES5 when you had a variable as a key, you first had</span> <span data-start="1337.299" data-end="1344.44">to create the object and then you could set that property. So, if x is a variable and</span> <span data-start="1344.44" data-end="1353.231">you want o of x, you have to create the literal. In ES6, you can do this in one step. Just</span> <span data-start="1353.231" data-end="1361.35">use the brackets inside the object notation. We saw in benchmarks that this right-hand</span> <span data-start="1361.35" data-end="1368.2">side is a lot slower than the ES5 equivalent. You saw in the last talk the list of benchmarks,</span> <span data-start="1368.2" data-end="1373.05">the yellow and green thing. This one was red because it was so much slower than the ES5</span> <span data-start="1373.05" data-end="1379.77">counterpart. But we applied the same principle. A lot of times in this kind of code, the x</span> <span data-start="1379.77" data-end="1385.88">is a symbol, and every function runs is the same symbol, so we applied this principle</span> <span data-start="1385.88" data-end="1391.98">here. We run the code a few times, we memorise what x is and optimise to a fast pass saying</span> <span data-start="1391.98" data-end="1398.02">if it is the same symbol we've seen all the time, then this is the kind of object we are</span> <span data-start="1398.02" data-end="1404.35">creating instead of to make the these expensive object transitions when we are creating this</span> <span data-start="1404.35" data-end="1411.429">every time. So by applying these optimisation principles, we've got a ten-times speed-up</span> <span data-start="1411.429" data-end="1421.179">on that benchmark, and the yellow-green benchmark list is on par with the ES5 equivalent. You</span> <span data-start="1421.179" data-end="1426.02">can use this ES6 feature without having to worry that it would slow down your performance</span> <span data-start="1426.02" data-end="1434.72">if that is really critical to you. So far, the high-level overview, you can't put too</span> <span data-start="1434.72" data-end="1440.09">much into 25 minutes. I hope I was able to give you some idea of what is going on. If</span> <span data-start="1440.09" data-end="1444.41">you want to dig deeper into that, of course you can try it out yourself and make your</span> <span data-start="1444.41" data-end="1451.68">own experiments and see what is going on. All the engines are open source, or all the</span> <span data-start="1451.68" data-end="1457.32">engines I mentioned are open source. You can get the source code, look at that, of course.</span> </p>
<p><span data-start="1457.32" data-end="1464.35">But you can play around with it. You probably have Node installed anyways, so use Note or</span> <span data-start="1464.35" data-end="1473.35">Chrome and palace in a few — if you pass in print opt code you will see the optimised</span> <span data-start="1473.35" data-end="1487.231">code that I have just shown you. So, because of how JavaScript is dynamically typed, we</span> <span data-start="1487.231" data-end="1493.64">have to use JIT compilation to get any kind of speed speed. Because of how the optimising</span> <span data-start="1493.64" data-end="1501.97">compilers under JIT work, your JavaScript code, if it's statically typed, then that's</span> <span data-start="1501.97" data-end="1504.01">the best thing you can do for the compilers. Thank you. [Cheering].</span> <span data-start="1504.01" data-end="1505.01"Audience member: Thank you very much to Franziska for the excellent introduction to how the engine works</span> <span data-start="1505.01" data-end="1506.01">in JavaScript — very interesting topic. I think when we work practically with JavaScript,</span> <span data-start="1506.01" data-end="1507.01">we don't know what is going on on the system level, we don't know how our code is being</span> <span data-start="1507.01" data-end="1508.01">compiled. We're going to start again in just a couple of minutes with our next talk, and,</span> <span data-start="1508.01" data-end="1509.01">if anyone is here what is curious going on in the other track, we have Ben Vinegar talking</span> <span data-start="1509.01" data-end="1510.01">about source maps. Graph QL has put fliers out on the table. They have a discount code.</span> <span data-start="1510.01" data-end="1511.01">It is another conference that's going to be taking place just across the river on 21st</span> </p>
</section>

<!-- div#container ends -->
</div>

<img alt="The End" id="fin" src="../images/fin.jpg">

<script>
/*eslint-disable */
function googleTranslateElementInit() {
  new google.translate.TranslateElement({pageLanguage: 'en',
    layout: google.translate.TranslateElement.InlineLayout.SIMPLE
    }, 'google-translate');
}
/* eslint-enable */
</script>

<script src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>

<script src="../js/main.js"></script>

</body>

</html>
